{"0": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  ulong uVar1;\n  code *pcVar2;\n  [TYPE5] [VAR5] ;\n  TYPE47 [VAR4] ;\n  [TYPE6] [VAR6] ;\n  \n  uVar1 = ([VAR3] >> 1) * 8;\n  if (([VAR1] ->field_0x3c & 2) == 0) {\n    [FUNC7] ([VAR2] ,uVar1 & 0xffffffff,[VAR1] + 1);\n    *(code **)([VAR1] [3].oiv + 0xc) = [FUNC2] ;\n  }\n  else {\n    [FUNC5] ([VAR2] ,uVar1 & 0xffffffff,[VAR1] + 1);\n    *(code **)([VAR1] [3].oiv + 0xc) = [FUNC3] ;\n  }\n  [FUNC5] ([VAR2] + ([VAR3] >> 1),uVar1 & 0xffffffff,&[VAR1] [2].cts_mode);\n  *(code **)([VAR1] [3].buf + 4) = [FUNC3] ;\n  *(TYPE11 *)&[VAR1] [3].num = [VAR1] + 1;\n  *(uint **)([VAR1] [3].oiv + 4) = &[VAR1] [2].cts_mode;\n  if (([VAR1] ->field_0x3c & 2) == 0) {\n    pcVar2 = [FUNC6] ;\n  }\n  else {\n    pcVar2 = [FUNC4] ;\n  }\n  *(code **)([VAR1] [3].buf + 0xc) = pcVar2;\n  return 1;\n}", "answer": {"VAR1": "ctx", "VAR2": "key", "VAR3": "keylen", "VAR4": "xctx", "VAR5": "bytes", "VAR6": "bits", "FUNC2": "aesni_decrypt", "FUNC3": "aesni_encrypt", "FUNC1": "cipher_hw_aesni_xts_initkey", "FUNC6": "aesni_xts_decrypt", "TYPE3": "size_t", "FUNC7": "aesni_set_decrypt_key", "TYPE2": "uchar *", "FUNC4": "aesni_xts_encrypt", "TYPE5": "size_t", "FUNC5": "aesni_set_encrypt_key", "TYPE4": "PROV_AES_XTS_CTX *", "TYPE6": "size_t", "TYPE1": "PROV_CIPHER_CTX *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV RBP,RSI\nSHR RDX,0x1\nMOV R12,RDX\nLEA R14,[RDX*0x8]\nTEST byte ptr [RDI + 0x3c],0x2\nJZ 0x000d2292\nLEA RDX,[RDI + 0xc0]\nMOV ESI,R14D\nMOV RDI,RBP\nCALL 0x0011d3b0\nLEA RAX,[0x119600]\nMOV qword ptr [RBX + 0x2c0],RAX\nLEA R13,[RBX + 0x1b8]\nLEA RDI,[RBP + R12*0x1]\nMOV RDX,R13\nMOV ESI,R14D\nCALL 0x0011d3b0\nLEA RAX,[0x119600]\nMOV qword ptr [RBX + 0x2c8],RAX\nLEA RAX,[RBX + 0xc0]\nMOV qword ptr [RBX + 0x2b0],RAX\nMOV qword ptr [RBX + 0x2b8],R13\nTEST byte ptr [RBX + 0x3c],0x2\nJNZ 0x000d22b4\nLEA RAX,[0x11b5c0]\nMOV qword ptr [RBX + 0x2d0],RAX\nMOV EAX,0x1\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nLEA RDX,[RDI + 0xc0]\nMOV ESI,R14D\nMOV RDI,RBP\nCALL 0x0011d340\nLEA RAX,[0x119650]\nMOV qword ptr [RBX + 0x2c0],RAX\nJMP 0x000d2236\nLEA RAX,[0x11ae50]\nJMP 0x000d227d\n"}, "1": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] )\n{\n  char *pcVar1;\n  \n  pcVar1 = \"ECDH\";\n  if (([VAR1] != 0xb) && (pcVar1 = \"ECDSA\", [VAR1] != 0xc)) {\n    pcVar1 = (char *)0x0;\n  }\n  return pcVar1;\n}", "answer": {"VAR1": "operation_id", "FUNC1": "ec_query_operation_name", "TYPE1": "int"}, "assembly": "LEA RAX,[0x2c8553]\nCMP EDI,0xb\nJZ 0x001a92e8\nCMP EDI,0xc\nLEA RAX,[0x2c8528]\nMOV EDX,0x0\nCMOVNZ RAX,RDX\nRET\n"}, "2": {"funcbody": "void [FUNC2] (uint *param_1,long param_2,uint *param_3,long param_4,int param_5)\n{\n  uint *puVar1;\n  \n  do {\n    *param_1 = (*param_3 | *param_1) - ((*param_3 ^ *param_1) >> 1 & 0xff7f7f7f);\n    param_1[1] = (param_3[1] | param_1[1]) - ((param_3[1] ^ param_1[1]) >> 1 & 0xff7f7f7f);\n    param_1[2] = (param_3[2] | param_1[2]) - ((param_3[2] ^ param_1[2]) >> 1 & 0xff7f7f7f);\n    param_1[3] = (param_3[3] | param_1[3]) - ((param_3[3] ^ param_1[3]) >> 1 & 0xff7f7f7f);\n    param_1[4] = (param_3[4] | param_1[4]) - ((param_3[4] ^ param_1[4]) >> 1 & 0xff7f7f7f);\n    param_1[5] = (param_3[5] | param_1[5]) - ((param_3[5] ^ param_1[5]) >> 1 & 0xff7f7f7f);\n    param_1[6] = (param_3[6] | param_1[6]) - ((param_3[6] ^ param_1[6]) >> 1 & 0xff7f7f7f);\n    puVar1 = param_3 + 7;\n    param_3 = (uint *)((long)param_3 + param_4);\n    param_1[7] = (*puVar1 | param_1[7]) - ((*puVar1 ^ param_1[7]) >> 1 & 0xff7f7f7f);\n    param_1 = (uint *)((long)param_1 + param_2);\n    param_5 = param_5 + -1;\n  } while (param_5 != 0);\n  return;\n}", "answer": {"FUNC2": "FUNC1", "FUNC1": "FUN_00b37bc0"}, "assembly": "MOV EAX,dword ptr [RDX]\nMOV R10D,dword ptr [RDI]\nMOV R9D,EAX\nXOR EAX,R10D\nSHR RAX,0x1\nOR R9D,R10D\nMOV R10D,dword ptr [RDI + 0x4]\nAND EAX,0xff7f7f7f\nSUB R9D,EAX\nMOV dword ptr [RDI],R9D\nMOV EAX,dword ptr [RDX + 0x4]\nMOV R9D,EAX\nXOR EAX,R10D\nSHR RAX,0x1\nOR R9D,R10D\nMOV R10D,dword ptr [RDI + 0x8]\nAND EAX,0xff7f7f7f\nSUB R9D,EAX\nMOV dword ptr [RDI + 0x4],R9D\nMOV EAX,dword ptr [RDX + 0x8]\nMOV R9D,EAX\nXOR EAX,R10D\nSHR RAX,0x1\nOR R9D,R10D\nMOV R10D,dword ptr [RDI + 0xc]\nAND EAX,0xff7f7f7f\nSUB R9D,EAX\nMOV dword ptr [RDI + 0x8],R9D\nMOV EAX,dword ptr [RDX + 0xc]\nMOV R9D,EAX\nXOR EAX,R10D\nSHR RAX,0x1\nOR R9D,R10D\nMOV R10D,dword ptr [RDI + 0x10]\nAND EAX,0xff7f7f7f\nSUB R9D,EAX\nMOV dword ptr [RDI + 0xc],R9D\nMOV EAX,dword ptr [RDX + 0x10]\nMOV R9D,EAX\nXOR EAX,R10D\nSHR RAX,0x1\nOR R9D,R10D\nMOV R10D,dword ptr [RDI + 0x14]\nAND EAX,0xff7f7f7f\nSUB R9D,EAX\nMOV dword ptr [RDI + 0x10],R9D\nMOV EAX,dword ptr [RDX + 0x14]\nMOV R9D,EAX\nXOR EAX,R10D\nSHR RAX,0x1\nOR R9D,R10D\nMOV R10D,dword ptr [RDI + 0x18]\nAND EAX,0xff7f7f7f\nSUB R9D,EAX\nMOV dword ptr [RDI + 0x14],R9D\nMOV EAX,dword ptr [RDX + 0x18]\nMOV R9D,EAX\nXOR EAX,R10D\nOR R9D,R10D\nSHR RAX,0x1\nMOV R10D,dword ptr [RDI + 0x1c]\nAND EAX,0xff7f7f7f\nSUB R9D,EAX\nMOV dword ptr [RDI + 0x18],R9D\nMOV EAX,dword ptr [RDX + 0x1c]\nADD RDX,RCX\nMOV R9D,EAX\nXOR EAX,R10D\nSHR RAX,0x1\nOR R9D,R10D\nAND EAX,0xff7f7f7f\nSUB R9D,EAX\nMOV dword ptr [RDI + 0x1c],R9D\nADD RDI,RSI\nSUB R8D,0x1\nJNZ 0x00b37bc0\nRET\n"}, "3": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  char cVar1;\n  long lVar2;\n  [TYPE3] [VAR3] ;\n  char *pcVar3;\n  \n  lVar2 = -1;\n  pcVar3 = [VAR1] ->name;\n  do {\n    if (lVar2 == 0) break;\n    lVar2 = lVar2 + -1;\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar3 + 1;\n  } while (cVar1 != '\\0');\n  if ([VAR2] != (TYPE20x0) {\n    [FUNC2] ((char *)[VAR2] ,[VAR1] ->name);\n  }\n  return ~(uint)lVar2;\n}", "answer": {"VAR1": "f", "VAR2": "data", "VAR3": "len", "FUNC2": "strcpy", "FUNC1": "fontspec_serialise", "TYPE3": "int", "TYPE2": "void *", "TYPE1": "FontSpec *"}, "assembly": "PUSH RBX\nMOV RDX,qword ptr [RDI]\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,RDX\nSCASB.REPNE RDI\nMOV RAX,RCX\nNOT RAX\nLEA RBX,[RAX + -0x1]\nTEST RSI,RSI\nJZ 0x000326ad\nMOV RDI,RSI\nMOV RSI,RDX\nCALL 0x00007500\nLEA EAX,[RBX + 0x1]\nPOP RBX\nRET\n"}, "4": {"funcbody": "uint [FUNC1] (TYPE11 [VAR1] )\n{\n  TYPE48 [VAR4] ;\n  uint uVar1;\n  TYPE29 [VAR2] ;\n  uint *puVar2;\n  byte *pbVar3;\n  TYPE39 [VAR3] ;\n  \n  puVar2 = [VAR1] ->mem32;\n  pbVar3 = (byte *)((ulong)[VAR1] ->memsize + (long)puVar2);\n  if ([VAR1] ->large_len == 0) {\n    [VAR4] = [VAR1] ->v3 + 0x165667b1;\n  }\n  else {\n    [VAR4] = ([VAR1] ->v1 << 1 | (uint)((int)[VAR1] ->v1 < 0)) + ([VAR1] ->v2 << 7 | [VAR1] ->v2 >> 0x19) +\n           ([VAR1] ->v3 << 0xc | [VAR1] ->v3 >> 0x14) + ([VAR1] ->v4 >> 0xe | [VAR1] ->v4 << 0x12);\n  }\n  [VAR4] = [VAR4] + [VAR1] ->total_len_32;\n  if ([VAR1] ->mem32 + 1 <= pbVar3) {\n    do {\n      uVar1 = *puVar2 * -0x3d4d51c3 + [VAR4] ;\n      [VAR4] = (uVar1 >> 0xf | uVar1 * 0x20000) * 0x27d4eb2f;\n      puVar2 = puVar2 + 1;\n    } while (puVar2 != (uint *)((long)[VAR1] ->mem32 +\n                               ((ulong)(pbVar3 + (-0x1c - (long)[VAR1] )) & 0xfffffffffffffffc) + 4));\n    puVar2 = (uint *)((long)([VAR1] ->mem32 + 1) +\n                     ((ulong)(pbVar3 + (-0x1c - (long)[VAR1] )) & 0xfffffffffffffffc));\n  }\n  if (puVar2 < pbVar3) {\n    do {\n      uVar1 = (uint)*(byte *)puVar2 * 0x165667b1 + [VAR4] ;\n      [VAR4] = (uVar1 * 0x800 | uVar1 >> 0x15) * -0x61c8864f;\n      puVar2 = (uint *)((long)puVar2 + 1);\n    } while ((uint *)pbVar3 != puVar2);\n  }\n  uVar1 = ([VAR4] >> 0xf ^ [VAR4] ) * -0x7a143589;\n  uVar1 = (uVar1 ^ uVar1 >> 0xd) * -0x3d4d51c3;\n  return uVar1 ^ uVar1 >> 0x10;\n}", "answer": {"VAR1": "state_in", "VAR2": "p", "VAR3": "bEnd", "VAR4": "h32", "FUNC1": "XXH32_digest", "TYPE3": "BYTE *", "TYPE2": "BYTE *", "TYPE4": "U32", "TYPE1": "XXH32_state_t *"}, "assembly": "LEA RSI,[RDI + 0x18]\nMOV R8D,dword ptr [RDI + 0x28]\nADD R8,RSI\nCMP dword ptr [RDI + 0x4],0x0\nJZ 0x0005bc40\nMOV EAX,dword ptr [RDI + 0x8]\nROL EAX,0x1\nMOV EDX,dword ptr [RDI + 0xc]\nROL EDX,0x7\nADD EAX,EDX\nMOV EDX,dword ptr [RDI + 0x10]\nROL EDX,0xc\nADD EAX,EDX\nMOV EDX,dword ptr [RDI + 0x14]\nROR EDX,0xe\nADD EAX,EDX\nADD EAX,dword ptr [RDI]\nMOV EDX,EAX\nLEA R10,[RDI + 0x1c]\nCMP R8,R10\nJC 0x0005bbfc\nMOV RCX,RSI\nMOV RAX,R8\nSUB RAX,RDI\nLEA R9,[RAX + -0x1c]\nMOV RAX,R9\nAND RAX,-0x4\nLEA RDI,[RSI + RAX*0x1 + 0x4]\nIMUL EAX,dword ptr [RCX],-0x3d4d51c3\nADD EAX,EDX\nROR EAX,0xf\nIMUL EDX,EAX,0x27d4eb2f\nADD RCX,0x4\nCMP RCX,RDI\nJNZ 0x0005bbda\nAND R9,-0x4\nLEA RSI,[R10 + R9*0x1]\nCMP R8,RSI\nJBE 0x0005bc1e\nMOVZX EAX,byte ptr [RSI]\nIMUL EAX,EAX,0x165667b1\nADD EAX,EDX\nROL EAX,0xb\nIMUL EDX,EAX,-0x61c8864f\nADD RSI,0x1\nCMP R8,RSI\nJNZ 0x0005bc01\nMOV EAX,EDX\nSHR EAX,0xf\nXOR EAX,EDX\nIMUL EAX,EAX,-0x7a143589\nMOV EDX,EAX\nSHR EDX,0xd\nXOR EAX,EDX\nIMUL EAX,EAX,-0x3d4d51c3\nMOV EDX,EAX\nSHR EDX,0x10\nXOR EAX,EDX\nRET\nMOV EAX,dword ptr [RDI + 0x10]\nADD EAX,0x165667b1\nJMP 0x0005bbb4\n"}, "5": {"funcbody": "grub_err_t [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  grub_err_t gVar1;\n  grub_size_t len;\n  \n  len = [VAR1] ->mft_size * 0x200;\n  gVar1 = [FUNC2] (&([VAR1] ->mmft).attr,[VAR2] ,len * [VAR3] ,len,0,(grub_disk_read_hook_t)0x0,(void *)0x0);\n  if (gVar1 == GRUB_ERR_NONE) {\n    gVar1 = [FUNC3] ([VAR2] ,[VAR1] ->mft_size,\"FILE\");\n  }\n  else {\n    gVar1 = [FUNC4] (GRUB_ERR_BAD_FS,\"read MFT 0x%llx fails\",[VAR3] );\n  }\n  return gVar1;\n}", "answer": {"VAR1": "data", "VAR2": "buf", "VAR3": "mftno", "FUNC2": "read_attr", "FUNC3": "fixup", "FUNC1": "read_mft", "TYPE3": "grub_uint64_t", "TYPE2": "grub_uint8_t *", "FUNC4": "grub_error", "TYPE1": "grub_ntfs_data *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV RBP,RSI\nMOV R12,RDX\nMOV RCX,qword ptr [RDI + 0xf8]\nSHL RCX,0x9\nMOV RDX,RCX\nIMUL RDX,R12\nLEA RDI,[RDI + 0xa8]\nSUB RSP,0x8\nPUSH 0x0\nMOV R9D,0x0\nMOV R8D,0x0\nCALL 0x0002fa37\nADD RSP,0x10\nTEST EAX,EAX\nJNZ 0x0002fba4\nMOV RSI,qword ptr [RBX + 0xf8]\nLEA RDX,[0x87db6]\nMOV RDI,RBP\nCALL 0x0002f0f4\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDX,R12\nLEA RSI,[0x8a8a6]\nMOV EDI,0x9\nMOV EAX,0x0\nCALL 0x000697d3\nJMP 0x0002fb9f\n"}, "6": {"funcbody": "long [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  long lVar1;\n  long lVar2;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR5] ;\n  \n  if ([VAR1] == ([TYPE1] )0x0) {\n    lVar2 = -2;\n  }\n  else {\n    [VAR5] = [VAR3] ;\n    if ((([VAR1] ->callback == (_func_603 *)0x0) || (*(long *)([VAR1] ->callback + 0x58) == 0)) ||\n       ([VAR2] != 0xe)) {\n      [FUNC5] ();\n      [FUNC2] (\"crypto/bio/bio_lib.c\",0x255,\"BIO_callback_ctrl\");\n      [FUNC4] (0x20,0x79,(char *)0x0);\n      lVar2 = -2;\n    }\n    else if (((([VAR1] ->cb_arg == (char *)0x0) &&\n              (lVar2._0_4_ = [VAR1] ->init, lVar2._4_4_ = [VAR1] ->shutdown, lVar2 == 0)) ||\n             (lVar2 = [FUNC3] ((BIO *)[VAR1] ,6,(char *)&[VAR5] ,0,0xe,0,1,(size_t *)0x0), 0 < lVar2)) &&\n            ((lVar2 = (**(code **)([VAR1] ->callback + 0x58))([VAR1] ,0xe,[VAR5] ),\n             [VAR1] ->cb_arg != (char *)0x0 ||\n             (lVar1._0_4_ = [VAR1] ->init, lVar1._4_4_ = [VAR1] ->shutdown, lVar1 != 0)))) {\n      lVar2 = [FUNC3] ((BIO *)[VAR1] ,0x86,(char *)&[VAR5] ,0,0xe,0,lVar2,(size_t *)0x0);\n    }\n  }\n  return lVar2;\n}", "answer": {"VAR1": "b", "VAR2": "cmd", "VAR3": "fp", "VAR4": "ret", "VAR5": "local_20", "FUNC2": "ERR_set_debug", "FUNC3": "bio_call_callback", "FUNC1": "BIO_callback_ctrl", "TYPE3": "fp *", "TYPE2": "int", "FUNC4": "ERR_set_error", "TYPE5": "undefined8", "FUNC5": "ERR_new", "TYPE4": "long", "TYPE1": "BIO *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV qword ptr [RSP + 0x8],RDX\nTEST RDI,RDI\nJZ 0x00075882\nMOV EBP,ESI\nMOV RBX,RDI\nMOV RAX,qword ptr [RDI + 0x8]\nTEST RAX,RAX\nJZ 0x00075826\nCMP qword ptr [RAX + 0x58],0x0\nJZ 0x00075826\nCMP ESI,0xe\nJNZ 0x00075826\nCMP qword ptr [RDI + 0x10],0x0\nJZ 0x00075865\nLEA RDX,[RSP + 0x8]\nPUSH 0x0\nPUSH 0x1\nMOV R9D,0x0\nMOV R8D,EBP\nMOV ECX,0x0\nMOV ESI,0x6\nMOV RDI,RBX\nCALL 0x00074647\nADD RSP,0x10\nTEST RAX,RAX\nJLE 0x0007581f\nMOV RAX,qword ptr [RBX + 0x8]\nMOV RDX,qword ptr [RSP + 0x8]\nMOV ESI,EBP\nMOV RDI,RBX\nCALL qword ptr [RAX + 0x58]\nCMP qword ptr [RBX + 0x10],0x0\nJZ 0x00075875\nLEA RDX,[RSP + 0x8]\nPUSH 0x0\nPUSH RAX\nMOV R9D,0x0\nMOV R8D,EBP\nMOV ECX,0x0\nMOV ESI,0x86\nMOV RDI,RBX\nCALL 0x00074647\nADD RSP,0x10\nADD RSP,0x18\nPOP RBX\nPOP RBP\nRET\nCALL 0x0008372e\nLEA RDX,[0x261b50]\nMOV ESI,0x255\nLEA RDI,[0x261af0]\nCALL 0x0008383b\nMOV EDX,0x0\nMOV ESI,0x79\nMOV EDI,0x20\nMOV EAX,0x0\nCALL 0x00083b52\nMOV RAX,-0x2\nJMP 0x0007581f\nCMP qword ptr [RDI + 0x18],0x0\nJNZ 0x000757b3\nJMP 0x000757e0\nCMP qword ptr [RBX + 0x18],0x0\nJNZ 0x000757f8\nJMP 0x0007581f\nMOV RAX,-0x2\nJMP 0x0007581f\n"}, "7": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  int iVar2;\n  [TYPE3] [VAR3] ;\n  int iVar3;\n  [TYPE4] [VAR4] ;\n  int iVar4;\n  \n  if ([VAR1] == ([TYPE1] )0x0) {\n    iVar1 = -3;\n  }\n  else if ([VAR1] ->cmp == (wget_vector_compare_fn *)0x0) {\n    iVar1 = -3;\n  }\n  else {\n    iVar2 = [VAR1] ->cur;\n    if (iVar2 == 1) {\n      iVar1 = (*[VAR1] ->cmp)([VAR2] ,*[VAR1] ->entry);\n      iVar1 = -(uint)(iVar1 != 0);\n    }\n    else if (([VAR1] ->field_0x20 & 1) == 0) {\n      iVar1 = 0;\n      if (iVar2 < 1) {\n        iVar1 = -1;\n      }\n      else {\n        do {\n          iVar2 = (*[VAR1] ->cmp)([VAR2] ,[VAR1] ->entry[iVar1]);\n          if (iVar2 == 0) {\n            return iVar1;\n          }\n          iVar1 = iVar1 + 1;\n        } while (iVar1 < [VAR1] ->cur);\n        iVar1 = -1;\n      }\n    }\n    else {\n      iVar1 = -1;\n      iVar2 = iVar2 + -1;\n      if (-1 < iVar2) {\n        iVar1 = 0;\n        do {\n          iVar4 = (iVar1 + iVar2) / 2;\n          iVar3 = (*[VAR1] ->cmp)([VAR2] ,[VAR1] ->entry[iVar4]);\n          if (iVar3 < 1) {\n            if (-1 < iVar3) {\n              return iVar4;\n            }\n            iVar2 = iVar4 + -1;\n          }\n          else {\n            iVar1 = iVar4 + 1;\n          }\n        } while (iVar1 <= iVar2);\n        iVar1 = -1;\n      }\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "v", "VAR2": "elem", "VAR3": "res", "VAR4": "m", "FUNC1": "wget_vector_find", "TYPE3": "int", "TYPE2": "void *", "TYPE4": "int", "TYPE1": "wget_vector *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nTEST RDI,RDI\nJZ 0x00027cdc\nMOV RAX,qword ptr [RDI]\nTEST RAX,RAX\nJZ 0x00027ce7\nMOV R12,RSI\nMOV RBX,RDI\nMOV R13D,dword ptr [RDI + 0x1c]\nCMP R13D,0x1\nJNZ 0x00027c48\nMOV RDX,qword ptr [RDI + 0x10]\nMOV RSI,qword ptr [RDX]\nMOV RDI,R12\nCALL RAX\nTEST EAX,EAX\nSETNZ R15B\nMOVZX R15D,R15B\nNEG R15D\nMOV EAX,R15D\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nTEST byte ptr [RDI + 0x20],0x1\nJNZ 0x00027c87\nMOV R15D,0x0\nTEST R13D,R13D\nJLE 0x00027c7f\nMOVSXD RAX,R15D\nMOV RDX,qword ptr [RBX + 0x10]\nMOV RSI,qword ptr [RDX + RAX*0x8]\nMOV RDI,R12\nCALL qword ptr [RBX]\nTEST EAX,EAX\nJZ 0x00027c36\nADD R15D,0x1\nCMP dword ptr [RBX + 0x1c],R15D\nJG 0x00027c59\nMOV R15D,0xffffffff\nJMP 0x00027c36\nMOV R15D,0xffffffff\nJMP 0x00027c36\nMOV R15D,0xffffffff\nADD R13D,R15D\nJS 0x00027c36\nMOV R14D,0x0\nJMP 0x00027ca7\nTEST EAX,EAX\nJNS 0x00027c36\nLEA R13D,[RBP + -0x1]\nCMP R14D,R13D\nJG 0x00027cd1\nLEA EAX,[R14 + R13*0x1]\nMOV EBP,EAX\nSHR EBP,0x1f\nADD EBP,EAX\nSAR EBP,0x1\nMOV R15D,EBP\nMOVSXD RDX,EBP\nMOV RAX,qword ptr [RBX + 0x10]\nMOV RSI,qword ptr [RAX + RDX*0x8]\nMOV RDI,R12\nCALL qword ptr [RBX]\nTEST EAX,EAX\nJLE 0x00027c9a\nLEA R14D,[RBP + 0x1]\nJMP 0x00027ca2\nMOV R15D,0xffffffff\nJMP 0x00027c36\nMOV R15D,0xfffffffd\nJMP 0x00027c36\nMOV R15D,0xfffffffd\nJMP 0x00027c36\n"}, "8": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  int iVar1;\n  ASN1_TIME *t;\n  [TYPE7] [VAR7] ;\n  ASN1_TIME *t_00;\n  [TYPE8] [VAR8] ;\n  char *pcVar2;\n  char *pcVar3;\n  int iVar4;\n  [TYPE9] [VAR9] ;\n  \n  t = [FUNC2] ((ASN1_TIME *)0x0,[VAR5] );\n  t_00 = [FUNC2] ((ASN1_TIME *)0x0,[VAR6] );\n  if ((t != (ASN1_TIME *)0x0) && (t_00 != (ASN1_TIME *)0x0)) {\n    iVar1 = [FUNC6] (t,t_00);\n    iVar4 = 1;\n    if (-1 < iVar1) goto LAB_00008bff;\n  }\n  pcVar2 = [FUNC4] ((ASN1_TIME *)t_00);\n  pcVar3 = [FUNC4] ((ASN1_TIME *)t);\n  [FUNC3] ((char *)0x0,[VAR1] ,[VAR2] ,\"time_t\",[VAR3] ,[VAR4] ,\">=\",\"[%s] compared to [%s]\",pcVar3,pcVar2);\n  iVar4 = 0;\nLAB_00008bff:\n  [FUNC5] (t);\n  [FUNC5] (t_00);\n  return iVar4;\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "s1", "VAR4": "s2", "VAR5": "t1", "VAR6": "t2", "FUNC2": "ASN1_TIME_set", "FUNC3": "test_fail_message", "FUNC1": "test_time_t_ge", "FUNC6": "ASN1_TIME_compare", "TYPE3": "char *", "TYPE2": "int", "FUNC4": "print_time", "TYPE5": "time_t", "FUNC5": "ASN1_STRING_free", "TYPE4": "char *", "TYPE7": "ASN1_TIME *", "TYPE6": "time_t", "TYPE9": "undefined8", "TYPE8": "ASN1_TIME *", "VAR7": "at1", "VAR8": "at2", "VAR9": "local_40", "TYPE1": "char *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV qword ptr [RSP + 0x8],RDI\nMOV R13D,ESI\nMOV R14,RDX\nMOV R15,RCX\nMOV RBP,R9\nMOV RSI,R8\nMOV EDI,0x0\nCALL 0x000023e0\nMOV RBX,RAX\nMOV RSI,RBP\nMOV EDI,0x0\nCALL 0x000023e0\nMOV RBP,RAX\nTEST RBX,RBX\nJZ 0x00008bab\nTEST RAX,RAX\nJZ 0x00008bab\nMOV RSI,RAX\nMOV RDI,RBX\nCALL 0x00002390\nMOV R12D,0x1\nTEST EAX,EAX\nJNS 0x00008bff\nMOV RDI,RBP\nCALL 0x00006129\nMOV R12,RAX\nMOV RDI,RBX\nCALL 0x00006129\nPUSH R12\nPUSH RAX\nLEA RAX,[0xb73f]\nPUSH RAX\nLEA RAX,[0xb61a]\nPUSH RAX\nMOV R9,R15\nMOV R8,R14\nLEA RCX,[0xb738]\nMOV EDX,R13D\nMOV RSI,qword ptr [RSP + 0x28]\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x0000625e\nADD RSP,0x20\nMOV R12D,0x0\nMOV RDI,RBX\nCALL 0x000026a0\nMOV RDI,RBP\nCALL 0x000026a0\nMOV EAX,R12D\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "9": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE21 [VAR2] ,[TYPE3] [VAR3] )\n{\n  long *plVar1;\n  int iVar2;\n  [TYPE4] [VAR4] ;\n  \n  if ([VAR3] == 1) {\n    plVar1 = (long *)((long)[VAR1] ->iostream + 0x20);\n    *plVar1 = *plVar1 + [VAR2] ;\n    iVar2 = 0;\n  }\n  else {\n    iVar2 = -1;\n    if ([VAR3] != 2) {\n      if ([VAR3] != 0) {\n        return 0;\n      }\n      *(TYPE21 *)((long)[VAR1] ->iostream + 0x20) = [VAR2] ;\n      return 0;\n    }\n  }\n  return iVar2;\n}", "answer": {"VAR1": "abfd", "VAR2": "offset", "VAR3": "whence", "VAR4": "vec", "FUNC1": "opncls_bseek", "TYPE3": "int", "TYPE2": "file_ptr", "TYPE4": "opncls *", "TYPE1": "bfd *"}, "assembly": "MOV RCX,qword ptr [RDI + 0x10]\nCMP EDX,0x1\nJZ 0x00096558\nMOV EAX,0xffffffff\nCMP EDX,0x2\nJZ 0x00096561\nTEST EDX,EDX\nJZ 0x00096551\nMOV EAX,0x0\nRET\nMOV qword ptr [RCX + 0x20],RSI\nMOV EAX,EDX\nRET\nADD qword ptr [RCX + 0x20],RSI\nMOV EAX,0x0\nRET\n"}, "10": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,TYPE27 [VAR2] )\n{\n  bfd_section *pbVar1;\n  void *pvVar2;\n  [TYPE3] [VAR3] ;\n  [TYPE4] [VAR4] ;\n  \n  if ([VAR2] ->symstrtab != (elf_strtab_hash *)0x0) {\n    [FUNC2] ([VAR2] ->symstrtab);\n  }\n  [FUNC3] ([VAR2] ->contents);\n  [FUNC3] ([VAR2] ->external_relocs);\n  [FUNC3] ([VAR2] ->internal_relocs);\n  [FUNC3] ([VAR2] ->external_syms);\n  [FUNC3] ([VAR2] ->locsym_shndx);\n  [FUNC3] ([VAR2] ->internal_syms);\n  [FUNC3] ([VAR2] ->indices);\n  [FUNC3] ([VAR2] ->sections);\n  if ([VAR2] ->symshndxbuf != (Elf_External_Sym_Shndx *)0xffffffffffffffff) {\n    [FUNC3] ([VAR2] ->symshndxbuf);\n  }\n  for (pbVar1 = [VAR1] ->sections; pbVar1 != (bfd_section *)0x0; pbVar1 = pbVar1->next) {\n    pvVar2 = pbVar1->used_by_bfd;\n    [FUNC3] (*(void **)((long)pvVar2 + 0x68));\n    [FUNC3] (*(void **)((long)pvVar2 + 0x80));\n  }\n  return;\n}", "answer": {"VAR1": "obfd", "VAR2": "flinfo", "VAR3": "o", "VAR4": "esdo", "FUNC2": "_bfd_elf_strtab_free", "FUNC3": "free", "FUNC1": "elf_final_link_free", "TYPE3": "asection *", "TYPE2": "elf_final_link_info *", "TYPE4": "bfd_elf_section_data *", "TYPE1": "bfd *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV RBX,RSI\nMOV RDI,qword ptr [RSI + 0x10]\nTEST RDI,RDI\nJZ 0x00065ae4\nCALL 0x0007add8\nMOV RDI,qword ptr [RBX + 0x28]\nCALL 0x0002bee0\nMOV RDI,qword ptr [RBX + 0x30]\nCALL 0x0002bee0\nMOV RDI,qword ptr [RBX + 0x38]\nCALL 0x0002bee0\nMOV RDI,qword ptr [RBX + 0x40]\nCALL 0x0002bee0\nMOV RDI,qword ptr [RBX + 0x48]\nCALL 0x0002bee0\nMOV RDI,qword ptr [RBX + 0x50]\nCALL 0x0002bee0\nMOV RDI,qword ptr [RBX + 0x58]\nCALL 0x0002bee0\nMOV RDI,qword ptr [RBX + 0x60]\nCALL 0x0002bee0\nMOV RDI,qword ptr [RBX + 0x68]\nCMP RDI,-0x1\nJZ 0x00065b3b\nCALL 0x0002bee0\nMOV RBX,qword ptr [RBP + 0x90]\nTEST RBX,RBX\nJZ 0x00065b6c\nMOV RBP,qword ptr [RBX + 0xd0]\nMOV RDI,qword ptr [RBP + 0x68]\nCALL 0x0002bee0\nMOV RDI,qword ptr [RBP + 0x80]\nCALL 0x0002bee0\nMOV RBX,qword ptr [RBX + 0x8]\nTEST RBX,RBX\nJNZ 0x00065b47\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "11": {"funcbody": "gint [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  [TYPE5] [VAR5] ;\n  int iVar1;\n  gint gVar2;\n  undefined8 uVar3;\n  [TYPE6] [VAR6] ;\n  int *piVar4;\n  [TYPE4] [VAR4] ;\n  ColumnsChild *pCVar5;\n  [TYPE3] [VAR3] ;\n  GList *pGVar6;\n  int iVar7;\n  gint *pgVar8;\n  gint gVar9;\n  [TYPE7] [VAR7] ;\n  \n  pGVar6 = [VAR1] ->children;\n  if (pGVar6 == (GList *)0x0) {\n    iVar7 = 0;\n  }\n  else {\n    pCVar5 = (ColumnsChild *)pGVar6->data;\n    if (pCVar5 == (ColumnsChild *)0x0) {\n      iVar7 = 0;\n    }\n    else {\n      pgVar8 = columns_compute_width::onecol;\n      iVar7 = 0;\n      gVar9 = 1;\n      do {\n        if (pCVar5->widget == (GtkWidget *)0x0) {\n          gVar9 = pCVar5->ncols;\n          pgVar8 = pCVar5->percentages;\n        }\n        else {\n          iVar1 = [FUNC5] ();\n          if (iVar1 != 0) {\n            gVar2 = (*[VAR2] )(pCVar5);\n            [VAR6] = pCVar5->colspan;\n            if ([VAR6] == 0) {\n              [VAR6] = gVar9 - pCVar5->colstart;\n            }\n            if ([VAR6] < 1) {\n              iVar1 = 0;\n            }\n            else {\n              piVar4 = pgVar8 + pCVar5->colstart;\n              iVar1 = 0;\n              do {\n                iVar1 = iVar1 + *piVar4;\n                piVar4 = piVar4 + 1;\n              } while (piVar4 != pgVar8 + (ulong)([VAR6] - 1) + (long)pCVar5->colstart + 1);\n            }\n            iVar1 = (iVar1 + -1 + (gVar2 + [VAR1] ->spacing) * 100) / iVar1 - [VAR1] ->spacing;\n            if (iVar7 < iVar1) {\n              iVar7 = iVar1;\n            }\n          }\n        }\n        pGVar6 = pGVar6->next;\n      } while ((pGVar6 != (GList *)0x0) &&\n              (pCVar5 = (ColumnsChild *)pGVar6->data, pCVar5 != (ColumnsChild *)0x0));\n    }\n  }\n  uVar3 = [FUNC2] ();\n  uVar3 = [FUNC4] ([VAR1] ,uVar3);\n  iVar1 = [FUNC3] (uVar3);\n  return iVar7 + iVar1 * 2;\n}", "answer": {"VAR1": "cols", "VAR2": "get_width", "VAR3": "children", "VAR4": "child", "VAR5": "childwidth", "VAR6": "colspan", "FUNC2": "gtk_container_get_type", "FUNC3": "gtk_container_get_border_width", "FUNC1": "columns_compute_width", "TYPE3": "GList *", "TYPE2": "widget_dim_fn_t", "FUNC4": "g_type_check_instance_cast", "TYPE5": "gint", "FUNC5": "gtk_widget_get_visible", "TYPE4": "ColumnsChild *", "TYPE7": "undefined8", "TYPE6": "gint", "VAR7": "local_40", "TYPE1": "Columns *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV R14,RDI\nMOV qword ptr [RSP + 0x8],RSI\nMOV RBP,qword ptr [RDI + 0x28]\nTEST RBP,RBP\nJZ 0x0003a091\nMOV RBX,qword ptr [RBP]\nTEST RBX,RBX\nJZ 0x0003a0c2\nLEA R13,[0x80330]\nMOV R12D,0x0\nMOV R15D,0x1\nJMP 0x0003a060\nMOV R15D,dword ptr [RBX + 0x20]\nMOV R13,qword ptr [RBX + 0x28]\nJMP 0x0003a04e\nTEST ECX,ECX\nJLE 0x0003a08a\nMOVSXD RSI,dword ptr [RBX + 0x8]\nLEA RDX,[R13 + RSI*0x4]\nLEA ECX,[RCX + -0x1]\nADD RCX,RSI\nLEA RSI,[R13 + RCX*0x4 + 0x4]\nMOV ECX,0x0\nADD ECX,dword ptr [RDX]\nADD RDX,0x4\nCMP RDX,RSI\nJNZ 0x0003a02a\nMOV ESI,dword ptr [R14 + 0x38]\nADD EAX,ESI\nIMUL EAX,EAX,0x64\nLEA EAX,[RCX + RAX*0x1 + -0x1]\nCDQ\nIDIV ECX\nSUB EAX,ESI\nCMP R12D,EAX\nCMOVL R12D,EAX\nMOV RBP,qword ptr [RBP + 0x8]\nTEST RBP,RBP\nJZ 0x0003a097\nMOV RBX,qword ptr [RBP]\nTEST RBX,RBX\nJZ 0x0003a097\nMOV RDI,qword ptr [RBX]\nTEST RDI,RDI\nJZ 0x0003a003\nCALL 0x00010de0\nTEST EAX,EAX\nJZ 0x0003a04e\nMOV RDI,RBX\nMOV RAX,qword ptr [RSP + 0x8]\nCALL RAX\nMOV ECX,dword ptr [RBX + 0xc]\nTEST ECX,ECX\nJNZ 0x0003a00d\nMOV ECX,R15D\nSUB ECX,dword ptr [RBX + 0x8]\nJMP 0x0003a00d\nMOV ECX,0x0\nJMP 0x0003a035\nMOV R12D,0x0\nCALL 0x00010a50\nMOV RSI,RAX\nMOV RDI,R14\nCALL 0x00010550\nMOV RDI,RAX\nCALL 0x00010f10\nLEA EAX,[R12 + RAX*0x2]\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV R12D,0x0\nJMP 0x0003a097\n"}, "12": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,[TYPE2] [VAR2] )\n{\n  long lVar1;\n  int iVar2;\n  TYPE35 [VAR3] ;\n  long in_FS_OFFSET;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  TYPE78 [VAR7] ;\n  TYPE65 [VAR6] ;\n  TYPE58 [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR7] .seed = (ASN1_BIT_STRING *)0x0;\n  [VAR7] .counter = (BIGNUM *)0x0;\n  [VAR8] = 0;\n  [FUNC8] (&[VAR1] ->params,&[VAR5] .p,&[VAR5] .q,&[VAR5] .g);\n  [VAR5] .j = ([VAR1] ->params).j;\n  [FUNC5] (&[VAR1] ->params,&[VAR6] .data,&[VAR8] ,&[VAR9] );\n  [VAR6] .length = (int)[VAR8] ;\n  if ((([VAR9] == -1) || ([VAR6] .data == (uchar *)0x0)) || ([VAR6] .length < 1)) {\n    [VAR5] .vparams = (int_dhvparams *)0x0;\nLAB_00174f96:\n    iVar2 = [FUNC6] (&[VAR5] ,[VAR2] );\n  }\n  else {\n    [VAR6] .flags = 8;\n    [VAR7] .seed = &[VAR6] ;\n    [VAR7] .counter = (BIGNUM *)[FUNC3] ();\n    iVar2 = 0;\n    if ([VAR7] .counter == (BIGNUM *)0x0) goto LAB_00174faf;\n    iVar2 = [FUNC7] ((BIGNUM *)[VAR7] .counter,(long)[VAR9] );\n    if (iVar2 != 0) {\n      [VAR5] .vparams = &[VAR7] ;\n      goto LAB_00174f96;\n    }\n  }\n  [FUNC4] ((BIGNUM *)[VAR7] .counter);\nLAB_00174faf:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "dh", "VAR2": "pp", "VAR3": "params", "VAR4": "local_20", "VAR5": "dhx", "VAR6": "seed", "FUNC2": "__stack_chk_fail", "FUNC3": "BN_new", "FUNC1": "i2d_DHxparams", "FUNC6": "i2d_int_dhx", "TYPE3": "FFC_PARAMS *", "FUNC7": "BN_set_word", "TYPE2": "uchar * *", "FUNC4": "BN_free", "TYPE5": "int_dhx942_dh", "FUNC5": "ossl_ffc_params_get_validate_params", "TYPE4": "undefined8", "TYPE7": "int_dhvparams", "TYPE6": "ASN1_BIT_STRING", "FUNC8": "ossl_ffc_params_get0_pqg", "TYPE9": "int", "TYPE8": "size_t", "VAR7": "dhv", "VAR8": "seedlen", "VAR9": "counter", "TYPE1": "DH *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x70\nMOV RBP,RDI\nMOV R12,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x68],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP + 0x10],0x0\nMOV qword ptr [RSP + 0x18],0x0\nMOV qword ptr [RSP + 0x8],0x0\nLEA RBX,[RDI + 0x8]\nLEA RSI,[RSP + 0x40]\nLEA RCX,[RSI + 0x10]\nLEA RDX,[RSI + 0x8]\nMOV RDI,RBX\nCALL 0x001c688b\nMOV RAX,qword ptr [RBP + 0x20]\nMOV qword ptr [RSP + 0x58],RAX\nLEA RCX,[RSP + 0x4]\nLEA RDX,[RSP + 0x8]\nLEA RSI,[RSP + 0x28]\nMOV RDI,RBX\nCALL 0x001c69b7\nMOV RAX,qword ptr [RSP + 0x8]\nMOV dword ptr [RSP + 0x20],EAX\nCMP dword ptr [RSP + 0x4],-0x1\nJZ 0x00174f8d\nCMP qword ptr [RSP + 0x28],0x0\nJZ 0x00174f8d\nTEST EAX,EAX\nJG 0x00174fca\nMOV qword ptr [RSP + 0x60],0x0\nLEA RDI,[RSP + 0x40]\nMOV RSI,R12\nCALL 0x00174dca\nMOV EBX,EAX\nMOV RDI,qword ptr [RSP + 0x18]\nCALL 0x0007db60\nMOV EAX,EBX\nMOV RBX,qword ptr [RSP + 0x68]\nXOR RBX,qword ptr FS:[0x28]\nJNZ 0x00175010\nADD RSP,0x70\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV qword ptr [RSP + 0x30],0x8\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nCALL 0x0007d348\nMOV qword ptr [RSP + 0x18],RAX\nMOV EBX,0x0\nTEST RAX,RAX\nJZ 0x00174faf\nMOVSXD RSI,dword ptr [RSP + 0x4]\nMOV RDI,RAX\nCALL 0x0007dd1d\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x00174fa5\nLEA RAX,[RSP + 0x10]\nMOV qword ptr [RSP + 0x60],RAX\nJMP 0x00174f96\nCALL 0x00065670\n"}, "13": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  ListDelF p_Var1;\n  void *pvVar2;\n  [TYPE2] [VAR2] ;\n  \n  pvVar2 = [FUNC2] ([VAR1] );\n  [VAR2] ._0_4_ = 0;\n  if (pvVar2 != (void *)0x0) {\n    p_Var1 = [VAR1] ->list->fDel;\n    if (p_Var1 == (ListDelF)0x0) {\n      [VAR2] ._0_4_ = 1;\n    }\n    else {\n      (*p_Var1)(pvVar2);\n      [VAR2] ._0_4_ = 1;\n    }\n  }\n  return (int)[VAR2] ;\n}", "answer": {"VAR1": "i", "VAR2": "v", "FUNC2": "list_remove", "FUNC1": "list_delete", "TYPE2": "void *", "TYPE1": "ListIterator"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCALL 0x0001af50\nMOV RDI,RAX\nMOV EAX,0x0\nTEST RDI,RDI\nJZ 0x0001af9d\nMOV RAX,qword ptr [RBX]\nMOV RAX,qword ptr [RAX + 0x18]\nTEST RAX,RAX\nJZ 0x0001af9f\nCALL RAX\nMOV EAX,0x1\nPOP RBX\nRET\nMOV EAX,0x1\nJMP 0x0001af9d\n"}, "14": {"funcbody": "int [FUNC1] (TYPE12 [VAR1] ,TYPE22 [VAR2] ,TYPE31 [VAR3] )\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = [FUNC3] ((EVP_PKEY *)[VAR3] ->p2);\n  iVar2 = 0;\n  if (iVar1 == 6) {\n    iVar2 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,4);\n  }\n  return iVar2;\n}", "answer": {"VAR1": "state", "VAR2": "translation", "VAR3": "ctx", "FUNC2": "get_rsa_payload_exponent", "FUNC3": "EVP_PKEY_get_base_id", "FUNC1": "get_rsa_payload_e5", "TYPE3": "translation_ctx_st *", "TYPE2": "translation_st *", "TYPE1": "state"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV EBP,EDI\nMOV R12,RSI\nMOV RBX,RDX\nMOV RDI,qword ptr [RDX + 0x20]\nCALL 0x0008cdc5\nMOV EDX,0x0\nCMP EAX,0x6\nJZ 0x00184b84\nMOV EAX,EDX\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV ECX,0x4\nMOV RDX,RBX\nMOV RSI,R12\nMOV EDI,EBP\nCALL 0x00184968\nMOV EDX,EAX\nJMP 0x00184b7d\n"}, "15": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  [TYPE2] pcVar1;\n  char cVar2;\n  size_t sVar3;\n  \n  if ([VAR3] != 0) {\n    pcVar1 = [VAR2] + [VAR3] ;\n    do {\n      cVar2 = *[VAR2] ;\n      if ([VAR1] ->len == 0xff) {\n        [VAR1] ->buf[0xff] = '\\0';\n        (*[VAR1] ->callback)([VAR1] ->buf,0xff,[VAR1] ->opaque);\n        [VAR1] ->len = 0;\n        [VAR1] ->flush_count = [VAR1] ->flush_count + 1;\n      }\n      sVar3 = [VAR1] ->len;\n      [VAR1] ->len = sVar3 + 1;\n      [VAR1] ->buf[sVar3] = cVar2;\n      [VAR1] ->last_char = cVar2;\n      [VAR2] = [VAR2] + 1;\n    } while ([VAR2] != pcVar1);\n    return;\n  }\n  return;\n}", "answer": {"VAR1": "dpi", "VAR2": "s", "VAR3": "l", "FUNC1": "d_append_buffer", "TYPE3": "size_t", "TYPE2": "char *", "TYPE1": "d_print_info *"}, "assembly": "TEST RDX,RDX\nJZ 0x000d4cd8\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RSI\nLEA R13,[RSI + RDX*0x1]\nJMP 0x000d4c8a\nMOV RAX,qword ptr [RBX + 0x100]\nLEA RDX,[RAX + 0x1]\nMOV qword ptr [RBX + 0x100],RDX\nMOV byte ptr [RBX + RAX*0x1],R12B\nMOV byte ptr [RBX + 0x108],R12B\nADD RBP,0x1\nCMP RBP,R13\nJZ 0x000d4ccd\nMOVZX R12D,byte ptr [RBP]\nCMP qword ptr [RBX + 0x100],0xff\nJNZ 0x000d4c64\nMOV byte ptr [RBX + 0xff],0x0\nMOV RDX,qword ptr [RBX + 0x118]\nMOV ESI,0xff\nMOV RDI,RBX\nCALL qword ptr [RBX + 0x110]\nMOV qword ptr [RBX + 0x100],0x0\nADD qword ptr [RBX + 0x140],0x1\nJMP 0x000d4c64\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nRET\n"}, "16": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  \n  iVar1 = -1;\n  if ([VAR1] != ([TYPE1] )0x0) {\n    iVar1 = [VAR1] ->_maxy + 1;\n  }\n  iVar1 = [FUNC2] ([VAR1] ,0,iVar1,1);\n  return iVar1;\n}", "answer": {"VAR1": "z", "FUNC2": "wtouchln", "FUNC1": "touchwin", "TYPE1": "WINDOW *"}, "assembly": "SUB RSP,0x8\nMOV EDX,0xffffffff\nTEST RDI,RDI\nJZ 0x0000bd48\nMOVSX EDX,word ptr [RDI + 0x4]\nADD EDX,0x1\nMOV ECX,0x1\nMOV ESI,0x0\nCALL 0x0001286b\nADD RSP,0x8\nRET\n"}, "17": {"funcbody": "wchar_t [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n             [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] )\n{\n  byte bVar1;\n  wchar_t wVar2;\n  int iVar3;\n  \n  if ((byte)([VAR3] + 0xbfU) < 0x1a) {\n    bVar1 = [VAR1] [4] & 0xdf;\n  }\n  else {\n    bVar1 = [VAR1] [4];\n  }\n  wVar2 = L'\\0';\n  if ((bVar1 == [VAR3] ) && (wVar2 = L'\\x01', [VAR3] != '\\0')) {\n    if ((byte)([VAR4] + 0xbfU) < 0x1a) {\n      bVar1 = [VAR1] [5] & 0xdf;\n    }\n    else {\n      bVar1 = [VAR1] [5];\n    }\n    wVar2 = L'\\0';\n    if ((bVar1 == [VAR4] ) && (wVar2 = L'\\x01', [VAR4] != '\\0')) {\n      if ((byte)([VAR5] + 0xbfU) < 0x1a) {\n        bVar1 = [VAR1] [6] & 0xdf;\n      }\n      else {\n        bVar1 = [VAR1] [6];\n      }\n      wVar2 = L'\\0';\n      if ((bVar1 == [VAR5] ) && (wVar2 = L'\\x01', [VAR5] != '\\0')) {\n        if ((byte)([VAR6] + 0xbfU) < 0x1a) {\n          bVar1 = [VAR1] [7] & 0xdf;\n        }\n        else {\n          bVar1 = [VAR1] [7];\n        }\n        wVar2 = L'\\0';\n        if ((bVar1 == [VAR6] ) && (wVar2 = L'\\x01', [VAR6] != '\\0')) {\n          if ((byte)([VAR7] + 0xbfU) < 0x1a) {\n            bVar1 = [VAR1] [8] & 0xdf;\n          }\n          else {\n            bVar1 = [VAR1] [8];\n          }\n          wVar2 = L'\\0';\n          if ((bVar1 == [VAR7] ) && (wVar2 = L'\\x01', [VAR7] != '\\0')) {\n            iVar3 = [FUNC2] ([VAR1] + 9,[VAR2] + 9);\n            wVar2 = (wchar_t)(iVar3 == 0);\n          }\n        }\n      }\n    }\n  }\n  return wVar2;\n}", "answer": {"VAR1": "s1", "VAR2": "s2", "VAR3": "s24", "VAR4": "s25", "VAR5": "s26", "VAR6": "s27", "FUNC2": "c_strcasecmp", "FUNC1": "strcaseeq4", "TYPE3": "char", "TYPE2": "char *", "TYPE5": "char", "TYPE4": "char", "TYPE7": "char", "TYPE6": "char", "VAR7": "s28", "TYPE1": "char *"}, "assembly": "SUB RSP,0x8\nMOV R11D,dword ptr [RSP + 0x10]\nLEA EAX,[RDX + -0x41]\nCMP AL,0x19\nJA 0x000075b9\nMOVZX EAX,byte ptr [RDI + 0x4]\nAND EAX,0xffffffdf\nCMP AL,DL\nSETZ R10B\nMOV EAX,0x0\nTEST R10B,R10B\nJZ 0x000075b4\nMOV EAX,0x1\nTEST DL,DL\nJZ 0x000075b4\nLEA EAX,[RCX + -0x41]\nCMP AL,0x19\nJA 0x000075c5\nMOVZX EAX,byte ptr [RDI + 0x5]\nAND EAX,0xffffffdf\nCMP AL,CL\nSETZ DL\nMOV EAX,0x0\nTEST DL,DL\nJZ 0x000075b4\nMOV EAX,0x1\nTEST CL,CL\nJZ 0x000075b4\nLEA EAX,[R8 + -0x41]\nCMP AL,0x19\nJA 0x000075d0\nMOVZX EAX,byte ptr [RDI + 0x6]\nAND EAX,0xffffffdf\nCMP AL,R8B\nSETZ DL\nMOV EAX,0x0\nTEST DL,DL\nJZ 0x000075b4\nMOV EAX,0x1\nTEST R8B,R8B\nJZ 0x000075b4\nLEA EAX,[R9 + -0x41]\nCMP AL,0x19\nJA 0x000075dc\nMOVZX EAX,byte ptr [RDI + 0x7]\nAND EAX,0xffffffdf\nCMP AL,R9B\nSETZ DL\nMOV EAX,0x0\nTEST DL,DL\nJZ 0x000075b4\nMOV EAX,0x1\nTEST R9B,R9B\nJZ 0x000075b4\nLEA EAX,[R11 + -0x41]\nCMP AL,0x19\nJA 0x000075e8\nMOVZX EAX,byte ptr [RDI + 0x8]\nAND EAX,0xffffffdf\nCMP AL,R11B\nSETZ DL\nMOV EAX,0x0\nTEST DL,DL\nJZ 0x000075b4\nMOV EAX,0x1\nTEST R11B,R11B\nJZ 0x000075b4\nADD RSI,0x9\nADD RDI,0x9\nCALL 0x0000a04b\nTEST EAX,EAX\nSETZ AL\nMOVZX EAX,AL\nADD RSP,0x8\nRET\nCMP byte ptr [RDI + 0x4],DL\nSETZ R10B\nJMP 0x000074d3\nCMP byte ptr [RDI + 0x5],CL\nSETZ DL\nJMP 0x00007505\nCMP byte ptr [RDI + 0x6],R8B\nSETZ DL\nJMP 0x00007538\nCMP byte ptr [RDI + 0x7],R9B\nSETZ DL\nJMP 0x00007564\nCMP byte ptr [RDI + 0x8],R11B\nSETZ DL\nJMP 0x0000758c\n"}, "18": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  uint uVar1;\n  int iVar2;\n  OSSL_PARAM *pOVar3;\n  [TYPE4] [VAR4] ;\n  TYPE34 [VAR3] ;\n  long in_FS_OFFSET;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  long [VAR5] ;\n  \n  [VAR5] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR7] = (TYPE70x0;\n  [VAR6] = 0;\n  uVar1 = 1;\n  if ([VAR2] != ([TYPE2] )0x0) {\n    pOVar3 = [FUNC7] ([VAR2] ,\"strength\");\n    if (pOVar3 != (OSSL_PARAM *)0x0) {\n      uVar1 = [FUNC3] (pOVar3,(uint *)((long)[VAR1] + 0xc));\n      if (uVar1 == 0) goto LAB_000fdbbf;\n    }\n    pOVar3 = [FUNC7] ([VAR2] ,\"test_entropy\");\n    if (pOVar3 != (OSSL_PARAM *)0x0) {\n      uVar1 = [FUNC6] (pOVar3,&[VAR7] ,0,&[VAR6] );\n      if (uVar1 == 0) goto LAB_000fdbbf;\n      [FUNC5] (*(void **)((long)[VAR1] + 0x18));\n      *([TYPE7] *)((long)[VAR1] + 0x18) = [VAR7] ;\n      *([TYPE6] *)((long)[VAR1] + 0x28) = [VAR6] ;\n      *(undefined8 *)((long)[VAR1] + 0x30) = 0;\n      [VAR7] = (TYPE70x0;\n    }\n    pOVar3 = [FUNC7] ([VAR2] ,\"test_nonce\");\n    if (pOVar3 != (OSSL_PARAM *)0x0) {\n      uVar1 = [FUNC6] (pOVar3,&[VAR7] ,0,&[VAR6] );\n      if (uVar1 == 0) goto LAB_000fdbbf;\n      [FUNC5] (*(void **)((long)[VAR1] + 0x20));\n      *([TYPE7] *)((long)[VAR1] + 0x20) = [VAR7] ;\n      *([TYPE6] *)((long)[VAR1] + 0x38) = [VAR6] ;\n    }\n    pOVar3 = [FUNC7] ([VAR2] ,\"max_request\");\n    uVar1 = 1;\n    if (pOVar3 != (OSSL_PARAM *)0x0) {\n      iVar2 = [FUNC4] (pOVar3,(size_t *)((long)[VAR1] + 0x10));\n      uVar1 = (uint)(iVar2 != 0);\n    }\n  }\nLAB_000fdbbf:\n  if ([VAR5] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar1;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "vtest", "VAR2": "params", "VAR3": "t", "VAR4": "p", "VAR5": "local_20", "VAR6": "size", "FUNC2": "__stack_chk_fail", "FUNC3": "OSSL_PARAM_get_uint", "FUNC1": "test_rng_set_ctx_params", "FUNC6": "OSSL_PARAM_get_octet_string", "TYPE3": "PROV_TEST_RNG *", "FUNC7": "OSSL_PARAM_locate_const", "TYPE2": "OSSL_PARAM *", "FUNC4": "OSSL_PARAM_get_size_t", "TYPE5": "undefined8", "FUNC5": "FUNC1", "TYPE4": "OSSL_PARAM *", "TYPE7": "void *", "TYPE6": "size_t", "VAR7": "ptr", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP + 0x8],0x0\nMOV qword ptr [RSP + 0x10],0x0\nMOV EAX,0x1\nTEST RSI,RSI\nJZ 0x000fdbbf\nMOV RBP,RDI\nMOV RBX,RSI\nLEA RSI,[0x297cbf]\nMOV RDI,RBX\nCALL 0x0009c58e\nTEST RAX,RAX\nJZ 0x000fdb90\nLEA RSI,[RBP + 0xc]\nMOV RDI,RAX\nCALL 0x0009ca8a\nTEST EAX,EAX\nJZ 0x000fdbbf\nLEA RSI,[0x27858e]\nMOV RDI,RBX\nCALL 0x0009c58e\nTEST RAX,RAX\nJZ 0x000fdc12\nLEA RCX,[RSP + 0x10]\nLEA RSI,[RSP + 0x8]\nMOV EDX,0x0\nMOV RDI,RAX\nCALL 0x0009d7ef\nTEST EAX,EAX\nJNZ 0x000fdbda\nMOV RDX,qword ptr [RSP + 0x18]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x000fdca2\nADD RSP,0x28\nPOP RBX\nPOP RBP\nRET\nMOV RDI,qword ptr [RBP + 0x18]\nMOV EDX,0xbd\nLEA RSI,[0x2785a8]\nCALL 0x0009a1a8\nMOV RAX,qword ptr [RSP + 0x8]\nMOV qword ptr [RBP + 0x18],RAX\nMOV RAX,qword ptr [RSP + 0x10]\nMOV qword ptr [RBP + 0x28],RAX\nMOV qword ptr [RBP + 0x30],0x0\nMOV qword ptr [RSP + 0x8],0x0\nLEA RSI,[0x27859b]\nMOV RDI,RBX\nCALL 0x0009c58e\nTEST RAX,RAX\nJZ 0x000fdc6c\nLEA RCX,[RSP + 0x10]\nLEA RSI,[RSP + 0x8]\nMOV EDX,0x0\nMOV RDI,RAX\nCALL 0x0009d7ef\nTEST EAX,EAX\nJZ 0x000fdbbf\nMOV RDI,qword ptr [RBP + 0x20]\nMOV EDX,0xc8\nLEA RSI,[0x2785a8]\nCALL 0x0009a1a8\nMOV RAX,qword ptr [RSP + 0x8]\nMOV qword ptr [RBP + 0x20],RAX\nMOV RAX,qword ptr [RSP + 0x10]\nMOV qword ptr [RBP + 0x38],RAX\nLEA RSI,[0x27830e]\nMOV RDI,RBX\nCALL 0x0009c58e\nMOV RDI,RAX\nMOV EAX,0x1\nTEST RDI,RDI\nJZ 0x000fdbbf\nLEA RSI,[RBP + 0x10]\nCALL 0x0009d287\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x000fdbbf\nCALL 0x00062890\n"}, "19": {"funcbody": "void [FUNC1] (void)\n{\n  [FUNC2] (&mu_auth_modules);\n  mu_auth_modules = selected_auth_modules;\n  selected_auth_modules = (mu_list_t)0x0;\n  [FUNC2] (&mu_getpw_modules);\n  mu_getpw_modules = selected_getpw_modules;\n  selected_getpw_modules = (mu_list_t)0x0;\n  [FUNC3] ();\n  return;\n}", "answer": {"FUNC2": "mu_list_destroy", "FUNC3": "mu_auth_begin_setup", "FUNC1": "mu_auth_finish_setup"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nLEA RDI,[0x2df018]\nCALL 0x00025040\nMOV RAX,qword ptr [0x002df020]\nMOV qword ptr [0x002df018],RAX\nMOV qword ptr [0x002df020],0x0\nLEA RDI,[0x2df008]\nCALL 0x00025040\nMOV RAX,qword ptr [0x002df010]\nMOV qword ptr [0x002df008],RAX\nMOV qword ptr [0x002df010],0x0\nCALL 0x000233e0\nNOP\nPOP RBP\nRET\n"}, "20": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE27 [VAR2] )\n{\n  int iVar1;\n  DH_NAMED_GROUP *group;\n  TYPE39 [VAR3] ;\n  char *pcVar2;\n  [TYPE4] [VAR4] ;\n  \n  if ([VAR2] ->nid == 0) {\n    [VAR4] ._0_4_ = [FUNC6] ([VAR1] ,\"P:   \",[VAR2] ->p);\n    if ((((uint)[VAR4] != 0) &&\n        (((([VAR2] ->q == (BIGNUM *)0x0 || ([VAR4] ._0_4_ = [FUNC6] ([VAR1] ,\"Q:   \",[VAR2] ->q), (uint)[VAR4] != 0))\n          && ([VAR4] ._0_4_ = [FUNC6] ([VAR1] ,\"G:   \",[VAR2] ->g), (uint)[VAR4] != 0)) &&\n         (([VAR2] ->j == (BIGNUM *)0x0 || ([VAR4] ._0_4_ = [FUNC6] ([VAR1] ,\"J:   \",[VAR2] ->j), (uint)[VAR4] != 0)))\n         ))) && (([VAR2] ->seed == (uchar *)0x0 ||\n                 ([VAR4] ._0_4_ = [FUNC3] ([VAR1] ,\"SEED:\",[VAR2] ->seed,[VAR2] ->seedlen), (uint)[VAR4] != 0)))) {\n      if (([VAR2] ->gindex != -1) && (iVar1 = [FUNC2] ((BIO *)[VAR1] ,\"gindex: %d\\n\"), iVar1 < 1)) {\n        return 0;\n      }\n      if (([VAR2] ->pcounter != -1) && (iVar1 = [FUNC2] ((BIO *)[VAR1] ,\"pcounter: %d\\n\"), iVar1 < 1)) {\n        return 0;\n      }\n      [VAR4] ._0_4_ = 1;\n      if ([VAR2] ->h != 0) {\n        iVar1 = [FUNC2] ((BIO *)[VAR1] ,\"h: %d\\n\");\n        [VAR4] ._0_4_ = (uint)(0 < iVar1);\n      }\n    }\n  }\n  else {\n    group = [FUNC4] ([VAR2] ->nid);\n    pcVar2 = [FUNC5] (group);\n    [VAR4] ._0_4_ = 0;\n    if (pcVar2 != (char *)0x0) {\n      iVar1 = [FUNC2] ((BIO *)[VAR1] ,\"GROUP: %s\\n\");\n      [VAR4] ._0_4_ = (uint)(0 < iVar1);\n    }\n  }\n  return (uint)[VAR4] ;\n}", "answer": {"VAR1": "out", "VAR2": "ffc", "VAR3": "group", "VAR4": "name", "FUNC2": "BIO_printf", "FUNC3": "print_labeled_buf", "FUNC1": "ffc_params_to_text", "FUNC6": "print_labeled_bignum", "TYPE3": "DH_NAMED_GROUP *", "TYPE2": "FFC_PARAMS *", "FUNC4": "ossl_ffc_uid_to_dh_named_group", "FUNC5": "ossl_ffc_named_group_get_name", "TYPE4": "char *", "TYPE1": "BIO *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV EDI,dword ptr [RSI + 0x34]\nTEST EDI,EDI\nJZ 0x0019b7b6\nCALL 0x00127648\nMOV RDI,RAX\nCALL 0x0012772b\nMOV RDX,RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x0019b7af\nLEA RSI,[0x2f8914]\nMOV RDI,RBP\nCALL 0x000d688d\nTEST EAX,EAX\nSETG AL\nMOVZX EAX,AL\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RBX,RSI\nMOV RDX,qword ptr [RSI]\nLEA RSI,[0x2f891f]\nMOV RDI,RBP\nCALL 0x0019b4ae\nTEST EAX,EAX\nJZ 0x0019b7af\nMOV RDX,qword ptr [RBX + 0x8]\nTEST RDX,RDX\nJZ 0x0019b7eb\nLEA RSI,[0x2f8925]\nMOV RDI,RBP\nCALL 0x0019b4ae\nTEST EAX,EAX\nJZ 0x0019b7af\nMOV RDX,qword ptr [RBX + 0x10]\nLEA RSI,[0x2f892b]\nMOV RDI,RBP\nCALL 0x0019b4ae\nTEST EAX,EAX\nJZ 0x0019b7af\nMOV RDX,qword ptr [RBX + 0x18]\nTEST RDX,RDX\nJZ 0x0019b81e\nLEA RSI,[0x2f8931]\nMOV RDI,RBP\nCALL 0x0019b4ae\nTEST EAX,EAX\nJZ 0x0019b7af\nMOV RDX,qword ptr [RBX + 0x20]\nTEST RDX,RDX\nJZ 0x0019b842\nMOV RCX,qword ptr [RBX + 0x28]\nLEA RSI,[0x2f8937]\nMOV RDI,RBP\nCALL 0x0019b0f1\nTEST EAX,EAX\nJZ 0x0019b7af\nMOV EDX,dword ptr [RBX + 0x38]\nCMP EDX,-0x1\nJNZ 0x0019b883\nMOV EDX,dword ptr [RBX + 0x30]\nCMP EDX,-0x1\nJNZ 0x0019b8a7\nMOV EDX,dword ptr [RBX + 0x3c]\nMOV EAX,0x1\nTEST EDX,EDX\nJZ 0x0019b7af\nLEA RSI,[0x2f8957]\nMOV RDI,RBP\nMOV EAX,0x0\nCALL 0x000d688d\nTEST EAX,EAX\nSETG AL\nMOVZX EAX,AL\nJMP 0x0019b7af\nLEA RSI,[0x2f893d]\nMOV RDI,RBP\nMOV EAX,0x0\nCALL 0x000d688d\nMOV EDX,EAX\nMOV EAX,0x0\nTEST EDX,EDX\nJG 0x0019b84a\nJMP 0x0019b7af\nLEA RSI,[0x2f8949]\nMOV RDI,RBP\nMOV EAX,0x0\nCALL 0x000d688d\nMOV EDX,EAX\nMOV EAX,0x0\nTEST EDX,EDX\nJG 0x0019b852\nJMP 0x0019b7af\n"}, "21": {"funcbody": "int [FUNC1] (TYPE18 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  uint64_t uVar1;\n  \n  if ([VAR3] == 0x10) {\n    uVar1 = ([VAR1] ->tag).word[1];\n    *(uint64_t *)[VAR2] = ([VAR1] ->tag).word[0];\n    *(uint64_t *)([VAR2] + 8) = uVar1;\n  }\n  return (uint)([VAR3] == 0x10);\n}", "answer": {"VAR1": "ctx", "VAR2": "tag", "VAR3": "len", "FUNC1": "ossl_siv128_get_tag", "TYPE3": "size_t", "TYPE2": "uchar *", "TYPE1": "SIV128_CONTEXT *"}, "assembly": "MOV EAX,0x0\nCMP RDX,0x10\nJZ 0x001b6457\nRET\nMOV RAX,qword ptr [RDI + 0x10]\nMOV RDX,qword ptr [RDI + 0x18]\nMOV qword ptr [RSI],RAX\nMOV qword ptr [RSI + 0x8],RDX\nMOV EAX,0x1\nJMP 0x001b6455\n"}, "22": {"funcbody": "int [FUNC1] (TYPE14 [VAR1] ,TYPE20 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC2] ((EVP_MD_CTX *)[VAR1] ,(EVP_PKEY_CTX **)[VAR2] ,(EVP_MD *)[VAR3] ,(char *)0x0,\n                (OSSL_LIB_CTX *)0x0,(char *)0x0,(ENGINE *)[VAR4] ,(EVP_PKEY *)[VAR5] ,0,(OSSL_PARAM *)0x0)\n  ;\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "pctx", "VAR3": "type", "VAR4": "e", "VAR5": "pkey", "FUNC2": "do_sigver_init", "FUNC1": "EVP_DigestSignInit", "TYPE3": "EVP_MD *", "TYPE2": "EVP_PKEY_CTX * *", "TYPE5": "EVP_PKEY *", "TYPE4": "ENGINE *", "TYPE1": "EVP_MD_CTX *"}, "assembly": "SUB RSP,0x8\nPUSH 0x0\nPUSH 0x0\nPUSH R8\nPUSH RCX\nMOV R9D,0x0\nMOV R8D,0x0\nMOV ECX,0x0\nCALL 0x0008b4ec\nADD RSP,0x28\nRET\n"}, "23": {"funcbody": "sgj_opaque_p [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  char cVar1;\n  [TYPE5] [VAR5] ;\n  char *out;\n  [TYPE4] [VAR4] ;\n  json_value *pjVar2;\n  long lVar3;\n  int iVar4;\n  [TYPE3] pcVar5;\n  \n  if ([VAR1] == (TYPE10x0) {\n    return (sgj_opaque_p)0x0;\n  }\n  if (([VAR1] ->pr_as_json == false) || ([VAR3] == (TYPE30x0)) {\n    pjVar2 = (json_value *)0x0;\n  }\n  else {\n    lVar3 = -1;\n    pcVar5 = [VAR3] ;\n    do {\n      if (lVar3 == 0) break;\n      lVar3 = lVar3 + -1;\n      cVar1 = *pcVar5;\n      pcVar5 = pcVar5 + 1;\n    } while (cVar1 != '\\0');\n    iVar4 = ~(uint)lVar3 + 7;\n    out = (char *)[FUNC4] ((long)iVar4);\n    iVar4 = [FUNC2] ([VAR3] ,out,iVar4);\n    if (iVar4 < 1) {\n      pjVar2 = (json_value *)0x0;\n    }\n    else {\n      pjVar2 = [FUNC5] (0);\n      if ([VAR2] == ([TYPE2] )0x0) {\n        [VAR2] = [VAR1] ->basep;\n      }\n      pjVar2 = [FUNC3] ((json_value *)[VAR2] ,out,pjVar2);\n    }\n  }\n  return pjVar2;\n}", "answer": {"VAR1": "jsp", "VAR2": "jop", "VAR3": "conv2sname", "VAR4": "sname", "VAR5": "nlen", "FUNC2": "sgj_name_to_snake", "FUNC3": "json_object_push", "FUNC1": "sgj_snake_named_subobject_r", "TYPE3": "char *", "TYPE2": "sgj_opaque_p", "FUNC4": "malloc", "TYPE5": "int", "FUNC5": "json_object_new", "TYPE4": "char *", "TYPE1": "sgj_state *"}, "assembly": "TEST RDI,RDI\nJZ 0x0001c22f\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R12,RDI\nMOV R13,RSI\nMOV RBP,RDX\nCMP byte ptr [RDI],0x0\nJZ 0x0001c235\nTEST RDX,RDX\nJZ 0x0001c235\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,RDX\nSCASB.REPNE RDI\nMOV RBX,RCX\nNOT RBX\nLEA EBX,[RBX + 0x7]\nMOVSXD RDI,EBX\nCALL 0x00011b10\nMOV R14,RAX\nMOV EDX,EBX\nMOV RSI,RAX\nMOV RDI,RBP\nCALL 0x0001ba31\nTEST EAX,EAX\nJLE 0x0001c23c\nMOV EDI,0x0\nCALL 0x00011f30\nTEST R13,R13\nJZ 0x0001c228\nMOV RDX,RAX\nMOV RSI,R14\nMOV RDI,R13\nCALL 0x00011e30\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV R13,qword ptr [R12 + 0x20]\nJMP 0x0001c211\nMOV EAX,0x0\nRET\nMOV EAX,0x0\nJMP 0x0001c21f\nMOV EAX,0x0\nJMP 0x0001c21f\n"}, "24": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC2] (stdscr,[VAR1] ,[VAR2] );\n  if (iVar1 != -1) {\n    iVar1 = [FUNC3] (stdscr,[VAR3] ,-1);\n  }\n  return iVar1;\n}", "answer": {"VAR1": "a1", "VAR2": "a2", "VAR3": "z", "FUNC2": "wmove", "FUNC3": "winnstr", "FUNC1": "mvinstr", "TYPE3": "char *", "TYPE2": "int", "TYPE1": "int"}, "assembly": "PUSH RBX\nMOV RBX,RDX\nMOV EDX,ESI\nMOV ESI,EDI\nMOV RDI,qword ptr [0x0023c950]\nCALL 0x0000eb53\nCMP EAX,-0x1\nJZ 0x0000bc43\nMOV EDX,0xffffffff\nMOV RSI,RBX\nMOV RDI,qword ptr [0x0023c950]\nCALL 0x0000da3e\nPOP RBX\nRET\n"}, "25": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  [TYPE3] [VAR3] ;\n  \n  if ([VAR1] != ([TYPE1] )0x0) {\n    if ([VAR2] ->final_rename_temp == (char *)0x0) {\n      iVar1 = [FUNC2] ((FILE *)[VAR1] );\n    }\n    else {\n      iVar1 = [FUNC4] ([VAR1] );\n    }\n    iVar1 = [FUNC3] (iVar1,[VAR2] );\n    return iVar1;\n  }\n  return -1;\n}", "answer": {"VAR1": "stream", "VAR2": "action", "VAR3": "ret", "FUNC2": "fclose", "FUNC3": "after_close_actions", "FUNC1": "fclose_supersede", "TYPE3": "int", "TYPE2": "supersede_final_action *", "FUNC4": "fclose_temp", "TYPE1": "FILE *"}, "assembly": "TEST RDI,RDI\nJZ 0x00025b14\nPUSH RBX\nMOV RBX,RSI\nCMP qword ptr [RSI],0x0\nJZ 0x00025b0b\nCALL 0x0000a830\nMOV EDI,EAX\nMOV RSI,RBX\nCALL 0x0002551d\nPOP RBX\nRET\nCALL 0x0000bc10\nMOV EDI,EAX\nJMP 0x00025b01\nMOV EAX,0xffffffff\nRET\n"}, "26": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  unique_sections *puVar2;\n  char *pcVar3;\n  [TYPE2] [VAR2] ;\n  \n  puVar2 = unique_section_list;\n  if (unique_section_list != (unique_sections *)0x0) {\n    do {\n      iVar1 = [FUNC2] (puVar2->name,[VAR1] );\n      if (iVar1 == 0) {\n        return;\n      }\n      puVar2 = puVar2->next;\n    } while (puVar2 != (unique_sections *)0x0);\n  }\n  puVar2 = (unique_sections *)[FUNC4] (0x10);\n  pcVar3 = [FUNC3] ([VAR1] );\n  puVar2->name = pcVar3;\n  puVar2->next = unique_section_list;\n  unique_section_list = puVar2;\n  return;\n}", "answer": {"VAR1": "name", "VAR2": "ent", "FUNC2": "strcmp", "FUNC3": "xstrdup", "FUNC1": "lang_add_unique", "TYPE2": "unique_sections *", "FUNC4": "xmalloc", "TYPE1": "char *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV RBX,qword ptr [0x00448728]\nTEST RBX,RBX\nJZ 0x00048f47\nMOV RDI,qword ptr [RBX + 0x8]\nMOV RSI,RBP\nCALL 0x000336f0\nTEST EAX,EAX\nJZ 0x00048f71\nMOV RBX,qword ptr [RBX]\nTEST RBX,RBX\nJNZ 0x00048f2f\nMOV EDI,0x10\nCALL 0x0012ebe6\nMOV RBX,RAX\nMOV RDI,RBP\nCALL 0x0012ecda\nMOV qword ptr [RBX + 0x8],RAX\nMOV RAX,qword ptr [0x00448728]\nMOV qword ptr [RBX],RAX\nMOV qword ptr [0x00448728],RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "27": {"funcbody": "int [FUNC1] (TYPE14 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  BIO_METHOD *type;\n  BIO *out;\n  [TYPE4] [VAR4] ;\n  long lVar2;\n  long in_FS_OFFSET;\n  [TYPE6] [VAR6] ;\n  long [VAR5] ;\n  \n  [VAR5] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR6] = ([TYPE6] )0x0;\n  if ([VAR3] == ([TYPE3] )0x0) {\n    [FUNC8] ();\n    [FUNC6] (\"crypto/encode_decode/encoder_lib.c\",99,\"OSSL_ENCODER_to_data\");\n    [FUNC5] (0x3b,0xc0102,(char *)0x0);\n    iVar1 = 0;\n    goto LAB_00099eba;\n  }\n  type = [FUNC4] ();\n  out = (BIO *)[FUNC10] (type);\n  iVar1 = 0;\n  if (out != (BIO *)0x0) {\n    iVar1 = [FUNC2] ([VAR1] ,out);\n    if (iVar1 != 0) {\n      lVar2 = [FUNC3] ((BIO *)out,0x73,0,&[VAR6] );\n      iVar1 = 0;\n      if (0 < lVar2) {\n        if ([VAR2] == ([TYPE2] )0x0) {\n          *[VAR3] = [VAR6] ->length;\n          iVar1 = 1;\n        }\n        else {\n          if (*[VAR2] == (uchar *)0x0) {\n            *[VAR3] = [VAR6] ->length;\n          }\n          else {\n            if (*[VAR3] < [VAR6] ->length) goto LAB_00099eb2;\n            *[VAR3] = *[VAR3] - [VAR6] ->length;\n          }\n          if (*[VAR2] == (uchar *)0x0) {\n            *[VAR2] = (uchar *)[VAR6] ->data;\n            [VAR6] ->data = (char *)0x0;\n            iVar1 = 1;\n          }\n          else {\n            [FUNC9] (*[VAR2] ,[VAR6] ->data,[VAR6] ->length);\n            *[VAR2] = *[VAR2] + [VAR6] ->length;\n            iVar1 = 1;\n          }\n        }\n      }\n    }\n  }\nLAB_00099eb2:\n  [FUNC11] ((BIO *)out);\nLAB_00099eba:\n  if ([VAR5] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n  [FUNC7] ();\n}", "answer": {"FUNC11": "BIO_free", "VAR1": "ctx", "VAR2": "pdata", "VAR3": "pdata_len", "VAR4": "out", "FUNC10": "BIO_new", "VAR5": "local_30", "VAR6": "buf", "FUNC2": "OSSL_ENCODER_to_bio", "FUNC3": "BIO_ctrl", "FUNC1": "OSSL_ENCODER_to_data", "FUNC6": "ERR_set_debug", "TYPE3": "size_t *", "FUNC7": "__stack_chk_fail", "TYPE2": "uchar * *", "FUNC4": "BIO_s_mem", "TYPE5": "undefined8", "FUNC5": "ERR_set_error", "TYPE4": "BIO *", "TYPE6": "BUF_MEM *", "FUNC8": "ERR_new", "FUNC9": "memcpy", "TYPE1": "OSSL_ENCODER_CTX *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x10\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],0x0\nTEST RDX,RDX\nJZ 0x00099edd\nMOV R13,RDI\nMOV R14,RSI\nMOV R12,RDX\nCALL 0x0007b09a\nMOV RDI,RAX\nCALL 0x00075b54\nMOV RBP,RAX\nMOV EBX,0x0\nTEST RAX,RAX\nJZ 0x00099eb2\nMOV RSI,RAX\nMOV RDI,R13\nCALL 0x00099cf5\nMOV EBX,EAX\nTEST EAX,EAX\nJNZ 0x00099f1a\nMOV RDI,RBP\nCALL 0x00075b6a\nMOV EAX,EBX\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00099fce\nADD RSP,0x10\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nCALL 0x0009edef\nLEA RDX,[0x26cf50]\nMOV ESI,0x63\nLEA RDI,[0x26cc48]\nCALL 0x0009eefc\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0x3b\nMOV EAX,0x0\nCALL 0x0009f213\nMOV EBX,0x0\nJMP 0x00099eba\nMOV RCX,RSP\nMOV EDX,0x0\nMOV ESI,0x73\nMOV RDI,RBP\nCALL 0x00076232\nMOV EBX,0x0\nTEST RAX,RAX\nJLE 0x00099eb2\nTEST R14,R14\nJZ 0x00099fac\nCMP qword ptr [R14],0x0\nJZ 0x00099fc1\nMOV RAX,qword ptr [R12]\nMOV RDX,qword ptr [RSP]\nMOV RDX,qword ptr [RDX]\nCMP RAX,RDX\nJC 0x00099eb2\nSUB RAX,RDX\nMOV qword ptr [R12],RAX\nMOV RDI,qword ptr [R14]\nTEST RDI,RDI\nJZ 0x00099f8f\nMOV RAX,qword ptr [RSP]\nMOV RSI,qword ptr [RAX + 0x8]\nMOV RDX,qword ptr [RAX]\nCALL 0x00062930\nMOV RAX,qword ptr [RSP]\nMOV RAX,qword ptr [RAX]\nADD qword ptr [R14],RAX\nMOV EBX,0x1\nJMP 0x00099eb2\nMOV RAX,qword ptr [RSP]\nMOV RDX,qword ptr [RAX + 0x8]\nMOV qword ptr [R14],RDX\nMOV qword ptr [RAX + 0x8],0x0\nMOV EBX,0x1\nJMP 0x00099eb2\nMOV RAX,qword ptr [RSP]\nMOV RAX,qword ptr [RAX]\nMOV qword ptr [R12],RAX\nMOV EBX,0x1\nJMP 0x00099eb2\nMOV RAX,qword ptr [RSP]\nMOV RAX,qword ptr [RAX]\nMOV qword ptr [R12],RAX\nJMP 0x00099f63\nCALL 0x00062730\n"}, "28": {"funcbody": "/* Local variable drbg:PROV_DRBG *[RDI:8] conflicts with parameter, skipped. */\nint [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  \n  if (([VAR1] != ([TYPE1] )0x0) && (*[VAR1] != (CRYPTO_RWLOCK *)0x0)) {\n    iVar1 = [FUNC2] (*[VAR1] );\n    return iVar1;\n  }\n  return 1;\n}", "answer": {"VAR1": "vctx", "FUNC2": "CRYPTO_THREAD_write_lock", "FUNC1": "ossl_drbg_lock", "TYPE1": "void *"}, "assembly": "MOV EAX,0x1\nTEST RDI,RDI\nJZ 0x00209db4\nMOV RDI,qword ptr [RDI]\nTEST RDI,RDI\nJZ 0x00209db4\nSUB RSP,0x8\nCALL 0x000a3e99\nADD RSP,0x8\nRET\nRET\n"}, "29": {"funcbody": "SWI_CONTROL_SCRIPT * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  SWI_CONTROL_SCRIPT *pSVar1;\n  int iVar2;\n  [TYPE3] [VAR3] ;\n  SWI_CONTROL_SCRIPT **ppSVar3;\n  \n  ppSVar3 = [VAR1] ->swi_scM->swi_coM;\n  pSVar1 = *ppSVar3;\n  if ((pSVar1 != (SWI_CONTROL_SCRIPT *)0x0) && ([VAR2] != pSVar1->sidM)) {\n    iVar2 = 0;\n    do {\n      iVar2 = iVar2 + 1;\n      ppSVar3 = ppSVar3 + 1;\n      pSVar1 = *ppSVar3;\n      if ((9 < iVar2) || (pSVar1 == (SWI_CONTROL_SCRIPT *)0x0)) {\n        return (SWI_CONTROL_SCRIPT *)0x0;\n      }\n    } while (pSVar1->sidM != [VAR2] );\n  }\n  return pSVar1;\n}", "answer": {"VAR1": "xfile", "VAR2": "id", "VAR3": "scripts", "FUNC1": "swi_xfile_get_control_script_by_id", "TYPE3": "SWI_CONTROL_SCRIPT * *", "TYPE2": "int", "TYPE1": "SWI_XFILE *"}, "assembly": "MOV RDX,qword ptr [RDI + 0x70]\nMOV RAX,qword ptr [RDX]\nTEST RAX,RAX\nJZ 0x0003d9bc\nCMP ESI,dword ptr [RAX + 0x48]\nJZ 0x0003d9bc\nMOV ECX,0x0\nADD ECX,0x1\nADD RDX,0x8\nMOV RAX,qword ptr [RDX]\nCMP ECX,0x9\nJG 0x0003d9b7\nTEST RAX,RAX\nJZ 0x0003d9b7\nCMP dword ptr [RAX + 0x48],ESI\nJNZ 0x0003d99c\nJMP 0x0003d9bc\nMOV EAX,0x0\nRET\n"}, "30": {"funcbody": "int [FUNC1] (TYPE18 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  uint uVar1;\n  int iVar2;\n  \n  uVar1 = [FUNC4] ([VAR1] ,[VAR2] );\n  if (uVar1 != 0) {\n    uVar1 = [FUNC2] ([VAR1] ,-1,\"\\x06\\x03+eq\",5);\n    if (uVar1 != 0) {\n      iVar2 = [FUNC3] ([VAR1] ,[VAR2] );\n      uVar1 = (uint)(iVar2 != 0);\n    }\n  }\n  return uVar1;\n}", "answer": {"VAR1": "pkt", "VAR2": "cont", "VAR3": "ec", "FUNC2": "ossl_DER_w_precompiled", "FUNC3": "ossl_DER_w_end_sequence", "FUNC1": "ossl_DER_w_algorithmIdentifier_ED448", "TYPE3": "ECX_KEY *", "TYPE2": "int", "FUNC4": "ossl_DER_w_begin_sequence", "TYPE1": "WPACKET *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV EBP,ESI\nCALL 0x001a594b\nTEST EAX,EAX\nJNZ 0x00105a01\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV ECX,0x5\nLEA RDX,[0x29cad9]\nMOV ESI,0xffffffff\nMOV RDI,RBX\nCALL 0x001a56a0\nTEST EAX,EAX\nJZ 0x001059fa\nMOV ESI,EBP\nMOV RDI,RBX\nCALL 0x001a596c\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x001059fa\n"}, "31": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  if ([VAR1] != ([TYPE1] )0x0) {\n    [FUNC3] ([VAR1] ->begin);\n    [VAR1] ->begin = (char *)0x0;\n    [VAR1] ->end = (char *)0x0;\n    [VAR1] ->sz = 0;\n    [FUNC3] ([VAR1] ->ptrs);\n    [VAR1] ->ptrs = (char **)0x0;\n    [VAR1] ->nptrs = 0;\n    [FUNC3] ([VAR1] ->encoded);\n    [VAR1] ->encoded = (char *)0x0;\n    [VAR1] ->encoded_sz = 0;\n    return;\n  }\n  [FUNC2] (\"buf\",\"lib/buffer.c\",0x17,\"ul_buffer_free_data\");\n}", "answer": {"VAR1": "buf", "FUNC2": "__assert_fail", "FUNC3": "free", "FUNC1": "ul_buffer_free_data", "TYPE1": "ul_buffer *"}, "assembly": "PUSH RBX\nTEST RDI,RDI\nJZ 0x00018e50\nMOV RBX,RDI\nMOV RDI,qword ptr [RDI]\nCALL 0x00004e70\nMOV qword ptr [RBX],0x0\nMOV qword ptr [RBX + 0x8],0x0\nMOV qword ptr [RBX + 0x10],0x0\nMOV RDI,qword ptr [RBX + 0x30]\nCALL 0x00004e70\nMOV qword ptr [RBX + 0x30],0x0\nMOV qword ptr [RBX + 0x38],0x0\nMOV RDI,qword ptr [RBX + 0x20]\nCALL 0x00004e70\nMOV qword ptr [RBX + 0x20],0x0\nMOV qword ptr [RBX + 0x28],0x0\nPOP RBX\nRET\nLEA RCX,[0x1dc90]\nMOV EDX,0x17\nLEA RSI,[0x1dc59]\nLEA RDI,[0x1dc66]\nCALL 0x000051d0\n"}, "32": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  long lVar1;\n  int iVar2;\n  [TYPE5] [VAR5] ;\n  long in_FS_OFFSET;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR8] = 0;\n  if ([VAR1] == (TYPE10x0) {\n    [FUNC3] (\"out != NULL\",\"src/pk/dh/dh_export.c\",0x1c);\n  }\n  if ([VAR2] == (TYPE20x0) {\n    [FUNC3] (\"outlen != NULL\",\"src/pk/dh/dh_export.c\",0x1d);\n  }\n  if ([VAR4] == ([TYPE4] )0x0) {\n    [FUNC3] (\"key != NULL\",\"src/pk/dh/dh_export.c\",0x1e);\n  }\n  if ([VAR3] == 1) {\n    [VAR7] [0] = '\\x01';\n    iVar2 = [FUNC4] ([VAR1] ,[VAR2] ,3,1,&[VAR8] ,4,1,[VAR7] ,2,1,[VAR4] ->prime,2,1,[VAR4] ->base,2,1,[VAR4] ->x,0,0,0);\n  }\n  else {\n    [VAR7] [0] = '\\0';\n    iVar2 = [FUNC4] ([VAR1] ,[VAR2] ,3,1,&[VAR8] ,4,1,[VAR7] ,2,1,[VAR4] ->prime,2,1,[VAR4] ->base,2,1,[VAR4] ->y,0,0,0);\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "out", "VAR2": "outlen", "VAR3": "type", "VAR4": "key", "VAR5": "err", "VAR6": "local_10", "FUNC2": "__stack_chk_fail", "FUNC3": "crypt_argchk", "FUNC1": "dh_export", "TYPE3": "int", "TYPE2": "ulong *", "FUNC4": "der_encode_sequence_multi", "TYPE5": "int", "TYPE4": "dh_key *", "TYPE7": "uchar[1]", "TYPE6": "undefined8", "TYPE8": "ulong", "VAR7": "flags", "VAR8": "version", "TYPE1": "uchar *"}, "assembly": "SUB RSP,0x28\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP + 0x8],0x0\nTEST RDI,RDI\nJZ 0x00079e11\nTEST RSI,RSI\nJZ 0x00079e29\nTEST RCX,RCX\nJZ 0x00079e41\nCMP EDX,0x1\nJZ 0x00079e59\nMOV byte ptr [RSP + 0x17],0x0\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nPUSH qword ptr [RCX + 0x10]\nPUSH 0x1\nPUSH 0x2\nPUSH qword ptr [RCX + 0x18]\nPUSH 0x1\nPUSH 0x2\nPUSH qword ptr [RCX + 0x20]\nPUSH 0x1\nPUSH 0x2\nLEA RAX,[RSP + 0x77]\nPUSH RAX\nPUSH 0x1\nMOV R9D,0x4\nLEA R8,[RSP + 0x78]\nMOV ECX,0x1\nMOV EDX,0x3\nMOV EAX,0x0\nCALL 0x00014930\nADD RSP,0x70\nMOV RDX,qword ptr [RSP + 0x18]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x00079ea9\nADD RSP,0x28\nRET\nMOV EDX,0x1c\nLEA RSI,[0xc8e7d]\nLEA RDI,[0xab721]\nCALL 0x00014260\nMOV EDX,0x1d\nLEA RSI,[0xc8e7d]\nLEA RDI,[0xb1724]\nCALL 0x00014260\nMOV EDX,0x1e\nLEA RSI,[0xc8e7d]\nLEA RDI,[0xc8f9d]\nCALL 0x00014260\nMOV byte ptr [RSP + 0x17],0x1\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nPUSH qword ptr [RCX + 0x8]\nPUSH 0x1\nPUSH 0x2\nPUSH qword ptr [RCX + 0x18]\nPUSH 0x1\nPUSH 0x2\nPUSH qword ptr [RCX + 0x20]\nPUSH 0x1\nPUSH 0x2\nLEA RDX,[RSP + 0x77]\nPUSH RDX\nPUSH 0x1\nMOV R9D,0x4\nLEA R8,[RSP + 0x78]\nMOV ECX,0x1\nMOV EDX,0x3\nMOV EAX,0x0\nCALL 0x00014930\nADD RSP,0x70\nJMP 0x00079df8\nCALL 0x00013870\n"}, "33": {"funcbody": "/* DWARF original prototype: void ~Form_(Form_ * this, int __in_chrg) */\nvoid __thiscall Form::Form_::[FUNC1] (Form_ *this,[TYPE1] [VAR1] )\n{\n  pointer pcVar1;\n  \n  (this->super_ElementAttributes_).super_Element_._vptr_Element_ =\n       (_func_int_varargs **)&PTR_[FUNC1] _002400d0;\n  pcVar1 = (this->method)._M_dataplus._M_p;\n  if ((anon_union_16_2_edb7204a_for_basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_3\n       *)pcVar1 != &(this->method).field_2) {\n    [FUNC2] (pcVar1);\n  }\n  pcVar1 = (this->action)._M_dataplus._M_p;\n  if ((anon_union_16_2_edb7204a_for_basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_3\n       *)pcVar1 != &(this->action).field_2) {\n    [FUNC2] (pcVar1);\n  }\n  (this->super_ElementAttributes_).super_Element_._vptr_Element_ =\n       (_func_int_varargs **)&DAT_00240688;\n  pcVar1 = (this->super_ElementAttributes_).attr._M_dataplus._M_p;\n  if ((anon_union_16_2_edb7204a_for_basic_string<char,_std::char_traits<char>,_std::allocator<char>_>_3\n       *)pcVar1 != &(this->super_ElementAttributes_).attr.field_2) {\n    [FUNC2] (pcVar1);\n  }\n  (this->super_ElementAttributes_).super_Element_._vptr_Element_ =\n       (_func_int_varargs **)&DAT_002408b8;\n  std::__cxx11::_List_base<Element::Element_*,_std::allocator<Element::Element_*>_>::[FUNC3] \n            (&(this->super_ElementAttributes_).super_Element_.elements.\n              super__List_base<Element::Element_*,_std::allocator<Element::Element_*>_>);\n  return;\n}", "answer": {"VAR1": "__in_chrg", "FUNC2": "operator.delete", "FUNC3": "_M_clear", "FUNC1": "~Form_", "TYPE1": "int"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nLEA RAX,[0x2400d0]\nMOV qword ptr [RDI],RAX\nMOV RDI,qword ptr [RDI + 0x60]\nLEA RAX,[RBX + 0x70]\nCMP RDI,RAX\nJZ 0x00011ea0\nCALL 0x00005180\nMOV RDI,qword ptr [RBX + 0x40]\nLEA RAX,[RBX + 0x50]\nCMP RDI,RAX\nJZ 0x00011eb2\nCALL 0x00005180\nLEA RAX,[0x240688]\nMOV qword ptr [RBX],RAX\nMOV RDI,qword ptr [RBX + 0x20]\nLEA RAX,[RBX + 0x30]\nCMP RDI,RAX\nJZ 0x00011ece\nCALL 0x00005180\nLEA RAX,[0x2408b8]\nMOV qword ptr [RBX],RAX\nLEA RDI,[RBX + 0x8]\nCALL 0x0000e55a\nPOP RBX\nRET\n"}, "34": {"funcbody": "int [FUNC1] (TYPE15 [VAR1] ,[TYPE2] [VAR2] )\n{\n  if ([VAR2] != (TYPE20x0) {\n    *([TYPE2] *)[VAR1] = [VAR2] ;\n    return 1;\n  }\n  [FUNC4] ();\n  [FUNC2] (\"crypto/engine/eng_lib.c\",0xc5,\"ENGINE_set_id\");\n  [FUNC3] (0x26,0xc0102,(char *)0x0);\n  return 0;\n}", "answer": {"VAR1": "e", "VAR2": "id", "FUNC2": "ERR_set_debug", "FUNC3": "ERR_set_error", "FUNC1": "ENGINE_set_id", "TYPE2": "char *", "FUNC4": "ERR_new", "TYPE1": "ENGINE *"}, "assembly": "TEST RSI,RSI\nJZ 0x00095206\nMOV qword ptr [RDI],RSI\nMOV EAX,0x1\nRET\nSUB RSP,0x8\nCALL 0x0009809b\nLEA RDX,[0x2679a0]\nMOV ESI,0xc5\nLEA RDI,[0x267977]\nCALL 0x000981a8\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0x26\nMOV EAX,0x0\nCALL 0x000984bf\nMOV EAX,0x0\nADD RSP,0x8\nRET\n"}, "35": {"funcbody": "mu_message_t [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  long [VAR2] ;\n  \n  [VAR2] = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = [FUNC5] ([VAR1] ,&[VAR3] );\n  [FUNC7] ([VAR1] );\n  if (iVar1 != 0) {\n    uVar2 = [FUNC4] (iVar1);\n    uVar3 = [FUNC3] (\"mailutils\",\"cannot open draft message stream: %s\");\n    [FUNC2] (uVar3,uVar2);\n    [VAR3] = (mu_message_t)0x0;\n  }\n  if ([VAR2] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return [VAR3] ;\n  }\n  [FUNC6] ();\n}", "answer": {"VAR1": "instream", "VAR2": "local_20", "VAR3": "msg", "VAR4": "rc", "VAR5": "instream-local", "FUNC2": "mu_error", "FUNC3": "dgettext", "FUNC1": "mh_stream_to_message", "FUNC6": "__stack_chk_fail", "TYPE3": "mu_message_t", "FUNC7": "mu_stream_unref", "TYPE2": "undefined8", "FUNC4": "mu_strerror", "TYPE5": "mu_stream_t", "FUNC5": "mu_stream_to_message", "TYPE4": "int", "TYPE1": "mu_stream_t"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nPUSH RBX\nSUB RSP,0x38\nMOV qword ptr [RBP + -0x38],RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RBP + -0x18],RAX\nXOR EAX,EAX\nLEA RDX,[RBP + -0x20]\nMOV RAX,qword ptr [RBP + -0x38]\nMOV RSI,RDX\nMOV RDI,RAX\nCALL 0x000070a0\nMOV dword ptr [RBP + -0x24],EAX\nMOV RAX,qword ptr [RBP + -0x38]\nMOV RDI,RAX\nCALL 0x00007d10\nCMP dword ptr [RBP + -0x24],0x0\nJZ 0x00012061\nMOV EAX,dword ptr [RBP + -0x24]\nMOV EDI,EAX\nCALL 0x00007c20\nMOV RBX,RAX\nLEA RSI,[0x20d90]\nLEA RDI,[0x20db5]\nCALL 0x00006f60\nMOV RSI,RBX\nMOV RDI,RAX\nMOV EAX,0x0\nCALL 0x00007170\nMOV EAX,0x0\nJMP 0x00012065\nMOV RAX,qword ptr [RBP + -0x20]\nMOV RCX,qword ptr [RBP + -0x18]\nXOR RCX,qword ptr FS:[0x28]\nJZ 0x00012079\nCALL 0x00007a10\nADD RSP,0x38\nPOP RBX\nPOP RBP\nRET\n"}, "36": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  char *__s2;\n  char *pcVar2;\n  modes *pmVar3;\n  \n  if ([VAR1] < 2) {\n    [FUNC4] (1,\"Using %s mode to transfer files.\\n\",mode);\n  }\n  else {\n    if ([VAR1] == 2) {\n      if (modes[0].m_name != (char *)0x0) {\n        pcVar2 = [VAR2] [1];\n        pmVar3 = modes;\n        __s2 = modes[0].m_name;\n        do {\n          iVar1 = [FUNC5] (pcVar2,__s2);\n          if (iVar1 == 0) {\n            if (__s2 != (char *)0x0) {\n              [FUNC3] (pmVar3->m_mode);\n              return;\n            }\n            break;\n          }\n          pmVar3 = pmVar3 + 1;\n          __s2 = pmVar3->m_name;\n        } while (__s2 != (char *)0x0);\n      }\n      [FUNC4] (1,\"%s: unknown mode\\n\",[VAR2] [1]);\n    }\n    [FUNC4] (1,\"usage: %s [\",*[VAR2] );\n    if (modes[0].m_name != (char *)0x0) {\n      pcVar2 = \" \";\n      pmVar3 = modes;\n      do {\n        [FUNC4] (1,&DAT_0000af20,pcVar2);\n        if (*pcVar2 == ' ') {\n          pcVar2 = \" | \";\n        }\n        pmVar3 = pmVar3 + 1;\n      } while (pmVar3->m_name != (char *)0x0);\n    }\n    [FUNC2] (\" ]\");\n  }\n  return;\n}", "answer": {"VAR1": "argc", "VAR2": "argv", "FUNC2": "puts", "FUNC3": "settftpmode", "FUNC1": "modecmd", "TYPE2": "char * *", "FUNC4": "__printf_chk", "FUNC5": "strcmp", "TYPE1": "int"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nCMP EDI,0x1\nJLE 0x000030d9\nMOV R13,RSI\nCMP EDI,0x2\nJNZ 0x0000305a\nMOV RBX,qword ptr [0x0020e280]\nTEST RBX,RBX\nJZ 0x00003040\nMOV R12,qword ptr [RSI + 0x8]\nLEA RBP,[0x20e280]\nMOV RSI,RBX\nMOV RDI,R12\nCALL 0x000025d0\nTEST EAX,EAX\nJZ 0x000030f8\nADD RBP,0x10\nMOV RBX,qword ptr [RBP]\nTEST RBX,RBX\nJNZ 0x00003020\nMOV RDX,qword ptr [R13 + 0x8]\nLEA RSI,[0xaf02]\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x000026e0\nMOV RDX,qword ptr [R13]\nLEA RSI,[0xaf14]\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x000026e0\nMOV RCX,qword ptr [0x0020e280]\nTEST RCX,RCX\nJZ 0x000030c2\nLEA RBX,[0xb0f5]\nLEA RBP,[0x20e280]\nLEA R12,[0xaefe]\nMOV RDX,RBX\nLEA RSI,[0xaf20]\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x000026e0\nCMP byte ptr [RBX],0x20\nCMOVZ RBX,R12\nADD RBP,0x10\nMOV RCX,qword ptr [RBP]\nTEST RCX,RCX\nJNZ 0x00003095\nLEA RDI,[0xaf25]\nCALL 0x000023f0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nLEA RDX,[0x20eb60]\nLEA RSI,[0xb358]\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x000026e0\nJMP 0x000030ce\nTEST RBX,RBX\nJZ 0x00003040\nMOV RDI,qword ptr [RBP + 0x8]\nCALL 0x00002aac\nJMP 0x000030ce\n"}, "37": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  tty_key_t *ptVar1;\n  tag_tty_key_t **key;\n  int iVar2;\n  \n  if (*[VAR1] == '\\0') {\n    return;\n  }\n  if ((tty_key_list_insert::key == (tty_key_t **)0x0) ||\n     (iVar2 = [FUNC3] ((char *)[VAR1] ,(char *)(*tty_key_list_insert::key)->key_seq), iVar2 < 1)) {\n    tty_key_list_insert::key = &key_list_head;\n  }\n  ptVar1 = *tty_key_list_insert::key;\n  key = tty_key_list_insert::key;\n  while( true ) {\n    tty_key_list_insert::key = key;\n    if (ptVar1 == (tty_key_t *)0x0) {\n      [FUNC2] (key,[VAR1] ,[VAR2] );\n      return;\n    }\n    iVar2 = [FUNC3] ((char *)[VAR1] ,(char *)ptVar1->key_seq);\n    if (iVar2 < 1) break;\n    key = &ptVar1->next;\n    ptVar1 = ptVar1->next;\n  }\n  [FUNC2] (key,[VAR1] ,[VAR2] );\n  return;\n}", "answer": {"VAR1": "key_seq", "VAR2": "aux_data", "FUNC2": "tty_key_list_insert_sequence", "FUNC3": "strcmp", "FUNC1": "tty_key_list_insert", "TYPE2": "void *", "TYPE1": "uchar *"}, "assembly": "CMP byte ptr [RDI],0x0\nJZ 0x0000523c\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R13,RSI\nMOV R12,RDI\nMOV RAX,qword ptr [0x0020c948]\nTEST RAX,RAX\nJZ 0x000051c8\nMOV RAX,qword ptr [RAX]\nMOV RSI,qword ptr [RAX]\nCALL 0x00002330\nTEST EAX,EAX\nJG 0x000051d6\nLEA RAX,[0x20d900]\nMOV qword ptr [0x0020c948],RAX\nMOV RBP,qword ptr [0x0020c948]\nMOV RBX,qword ptr [RBP]\nTEST RBX,RBX\nJZ 0x00005209\nMOV RSI,qword ptr [RBX]\nMOV RDI,R12\nCALL 0x00002330\nTEST EAX,EAX\nJLE 0x00005227\nLEA RBP,[RBX + 0x8]\nMOV qword ptr [0x0020c948],RBP\nMOV RBX,qword ptr [RBX + 0x8]\nTEST RBX,RBX\nJNZ 0x000051e6\nMOV RDX,R13\nMOV RSI,R12\nMOV RDI,RBP\nMOV EAX,0x0\nCALL 0x0000514e\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV RDX,R13\nMOV RSI,R12\nMOV RDI,RBP\nMOV EAX,0x0\nCALL 0x0000514e\nJMP 0x0000521c\nRET\n"}, "38": {"funcbody": "RinkjDevice * [FUNC1] (TYPE11 [VAR1] )\n{\n  _func_int_RinkjDevice_ptr_RinkjDeviceParams_ptr *p_Var1;\n  TYPE27 [VAR2] ;\n  RinkjDevice *pRVar2;\n  \n  pRVar2 = (RinkjDevice *)[FUNC4] (0x68);\n  pRVar2->set = [FUNC2] ;\n  pRVar2->write = [FUNC5] ;\n  pRVar2->init = [FUNC3] ;\n  pRVar2->init_happened = 0;\n  pRVar2[1].write = (_func_int_RinkjDevice_ptr_char_ptr_ptr *)[VAR1] ;\n  pRVar2[2].set = (_func_int_RinkjDevice_ptr_char_ptr *)0x0;\n  p_Var1 = DAT_0040ef58;\n  pRVar2[2].init = DAT_0040ef58;\n  pRVar2[2].write = (_func_int_RinkjDevice_ptr_char_ptr_ptr *)p_Var1;\n  *(undefined4 *)&pRVar2[2].field_0x1c = 1;\n  *(undefined4 *)&pRVar2[3].set = 1;\n  return pRVar2;\n}", "answer": {"VAR1": "dev_out", "VAR2": "result", "FUNC2": "rinkj_screen_eb_set", "FUNC3": "rinkj_screen_eb_init", "FUNC1": "rinkj_screen_eb_new", "TYPE2": "RinkjScreenEb *", "FUNC4": "malloc", "FUNC5": "rinkj_screen_eb_write", "TYPE1": "RinkjDevice *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nMOV EDI,0x68\nCALL 0x000f0c20\nLEA RDX,[0x3597b8]\nMOV qword ptr [RAX],RDX\nLEA RCX,[0x359339]\nMOV qword ptr [RAX + 0x10],RCX\nLEA RSI,[0x359102]\nMOV qword ptr [RAX + 0x8],RSI\nMOV dword ptr [RAX + 0x18],0x0\nMOV qword ptr [RAX + 0x30],RBX\nMOV qword ptr [RAX + 0x40],0x0\nMOVSD XMM0,qword ptr [0x0040ef58]\nMOVSD qword ptr [RAX + 0x48],XMM0\nMOVSD qword ptr [RAX + 0x50],XMM0\nMOV dword ptr [RAX + 0x5c],0x1\nMOV dword ptr [RAX + 0x60],0x1\nPOP RBX\nRET\n"}, "39": {"funcbody": "int [FUNC1] (TYPE10 [VAR1] ,TYPE24 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  uint uVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  long [VAR5] ;\n  \n  [VAR5] = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = 0;\n  [VAR7] = (TYPE70x0;\n  [VAR6] = ([TYPE6] )0x0;\n  if ([VAR1] != (TYPE10)0x0) {\n    [FUNC3] ([VAR1] ,&[VAR6] ,&[VAR7] );\n    if (([VAR4] != 0) && ([VAR7] != (TYPE70x0)) {\n      uVar1 = [FUNC4] ([VAR2] ,[VAR3] ,\"priv\",[VAR7] );\n      if (uVar1 == 0) goto LAB_0010d6da;\n    }\n    uVar1 = 1;\n    if ([VAR6] != ([TYPE6] )0x0) {\n      iVar2 = [FUNC4] ([VAR2] ,[VAR3] ,\"pub\",[VAR6] );\n      uVar1 = (uint)(iVar2 != 0);\n    }\n  }\nLAB_0010d6da:\n  if ([VAR5] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar1;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "dsa", "VAR2": "bld", "VAR3": "params", "VAR4": "include_private", "VAR5": "local_20", "VAR6": "pub", "FUNC2": "__stack_chk_fail", "FUNC3": "DSA_get0_key", "FUNC1": "dsa_key_todata", "TYPE3": "OSSL_PARAM *", "TYPE2": "OSSL_PARAM_BLD *", "FUNC4": "ossl_param_build_set_bn", "TYPE5": "undefined8", "TYPE4": "int", "TYPE7": "BIGNUM *", "TYPE6": "BIGNUM *", "VAR7": "priv", "TYPE1": "DSA *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x20\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP + 0x8],0x0\nMOV qword ptr [RSP + 0x10],0x0\nTEST RDI,RDI\nJZ 0x0010d6da\nMOV RBP,RSI\nMOV R12,RDX\nMOV EBX,ECX\nLEA RDX,[RSP + 0x8]\nLEA RSI,[RSP + 0x10]\nCALL 0x0016843d\nTEST EBX,EBX\nJZ 0x0010d6b1\nMOV RCX,qword ptr [RSP + 0x8]\nTEST RCX,RCX\nJZ 0x0010d6b1\nLEA RDX,[0x267b8f]\nMOV RSI,R12\nMOV RDI,RBP\nCALL 0x001d7935\nTEST EAX,EAX\nJZ 0x0010d6da\nMOV RCX,qword ptr [RSP + 0x10]\nMOV EAX,0x1\nTEST RCX,RCX\nJZ 0x0010d6da\nLEA RDX,[0x267b94]\nMOV RSI,R12\nMOV RDI,RBP\nCALL 0x001d7935\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nMOV RBX,qword ptr [RSP + 0x18]\nXOR RBX,qword ptr FS:[0x28]\nJNZ 0x0010d6f3\nADD RSP,0x20\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x00062640\n"}, "40": {"funcbody": "void [FUNC1] (void)\n{\n  object *pplVar1;\n  object *pplVar2;\n  object plVar3;\n  [TYPE1] [VAR1] ;\n  [TYPE2] [VAR2] ;\n  \n  pplVar2 = vs_base;\n  pplVar1 = vs_base + 1;\n  if (vs_limit <= vs_top) {\n    [FUNC3] ();\n  }\n  vs_top = pplVar1;\n  plVar3 = (*LnkLI59)(VVi[61],VVi[113],VVi[5],VVi[112]);\n  *pplVar2 = plVar3;\n  vs_base = pplVar2;\n  vs_top = pplVar1;\n  return;\n}", "answer": {"VAR1": "base", "VAR2": "sup", "FUNC2": "LnkTLI59", "FUNC3": "vs_overflow", "FUNC1": "L24", "TYPE2": "object *", "TYPE1": "object *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,qword ptr [0x00971288]\nLEA RBP,[RBX + 0x8]\nMOV RAX,qword ptr [0x0072c3d0]\nCMP qword ptr [0x00a86200],RAX\nJNC 0x0043167f\nMOV qword ptr [0x00a86200],RBP\nMOV RCX,qword ptr [0x00752b00]\nMOV RDX,qword ptr [0x007527a8]\nMOV RSI,qword ptr [0x00752b08]\nMOV RDI,qword ptr [0x00752968]\nMOV EAX,0x0\nCALL qword ptr [0x00752758]\nMOV qword ptr [RBX],RAX\nMOV qword ptr [0x00971288],RBX\nMOV qword ptr [0x00a86200],RBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x0011206a\nJMP 0x00431639\n"}, "41": {"funcbody": "/* Local variable p:char *[RDI:8] conflicts with parameter, skipped. */\nulong [FUNC1] ([TYPE1] [VAR1] )\n{\n  char cVar1;\n  uint uVar2;\n  char *pcVar4;\n  int iVar3;\n  \n  cVar1 = *[VAR1] ;\n  uVar2 = (int)cVar1;\n  if ((byte)(cVar1 + 0xbfU) < 0x1a) {\n    uVar2 = (int)cVar1 + 0x20;\n  }\n  if (uVar2 != 0) {\n    pcVar4 = (char *)((long)[VAR1] + 1);\n    cVar1 = *(char *)((long)[VAR1] + 1);\n    while (cVar1 != '\\0') {\n      iVar3 = (int)cVar1;\n      if ((byte)(cVar1 + 0xbfU) < 0x1a) {\n        iVar3 = cVar1 + 0x20;\n      }\n      uVar2 = iVar3 + uVar2 * 0x1f;\n      pcVar4 = pcVar4 + 1;\n      cVar1 = *pcVar4;\n    }\n  }\n  return (ulong)uVar2;\n}", "answer": {"VAR1": "key", "FUNC1": "hash_string_nocase", "TYPE1": "void *"}, "assembly": "MOVZX EAX,byte ptr [RDI]\nMOVSX EDX,AL\nSUB EAX,0x41\nLEA ECX,[RDX + 0x20]\nCMP AL,0x1a\nCMOVC EDX,ECX\nMOV EAX,EDX\nTEST EDX,EDX\nJZ 0x0001ad7f\nLEA RSI,[RDI + 0x1]\nMOVZX EDX,byte ptr [RDI + 0x1]\nTEST DL,DL\nJZ 0x0001ad7f\nMOV ECX,EAX\nSHL ECX,0x5\nSUB ECX,EAX\nMOVSX EAX,DL\nSUB EDX,0x41\nLEA EDI,[RAX + 0x20]\nCMP DL,0x1a\nCMOVC EAX,EDI\nADD EAX,ECX\nADD RSI,0x1\nMOVZX EDX,byte ptr [RSI]\nTEST DL,DL\nJNZ 0x0001ad5c\nMOV EAX,EAX\nRET\n"}, "42": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] )\n{\n  EC_METHOD *pEVar1;\n  uint uVar2;\n  \n  uVar2 = 0;\n  if (([VAR1] ->group != (EC_GROUP *)0x0) && (pEVar1 = [VAR1] ->group->meth, pEVar1 != (EC_METHOD *)0x0))\n  {\n    uVar2 = (uint)((*(byte *)&pEVar1->flags & 4) == 0);\n  }\n  return uVar2;\n}", "answer": {"VAR1": "eckey", "FUNC1": "EC_KEY_can_sign", "TYPE1": "EC_KEY *"}, "assembly": "MOV RDX,qword ptr [RDI + 0x18]\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x00197026\nMOV RDX,qword ptr [RDX]\nTEST RDX,RDX\nJZ 0x00197026\nTEST byte ptr [RDX],0x4\nSETZ AL\nMOVZX EAX,AL\nRET\n"}, "43": {"funcbody": "void [FUNC1] (TYPE11 [VAR1] ,[TYPE2] [VAR2] ,TYPE36 [VAR3] ,\n          TYPE41 [VAR4] ,TYPE56 [VAR5] ,[TYPE6] [VAR6] )\n{\n  if ([VAR1] != (TYPE11)0x0) {\n    [VAR1] ->flags = [VAR6] ;\n    [VAR1] ->issuer_cert = [VAR2] ;\n    [VAR1] ->subject_cert = [VAR3] ;\n    [VAR1] ->subject_req = [VAR4] ;\n    [VAR1] ->crl = [VAR5] ;\n    [VAR1] ->db_meth = (X509V3_CONF_METHOD *)0x0;\n    [VAR1] ->db = (void *)0x0;\n    *(undefined8 *)([VAR1] + 1) = 0;\n    return;\n  }\n  [FUNC2] ();\n  [FUNC3] (\"crypto/x509/v3_conf.c\",0x1c2,\"X509V3_set_ctx\");\n  [FUNC4] (0x22,0xc0102,(char *)0x0);\n  return;\n}", "answer": {"VAR1": "ctx", "VAR2": "issuer", "VAR3": "subject", "VAR4": "req", "VAR5": "crl", "VAR6": "flags", "FUNC2": "ERR_new", "FUNC3": "ERR_set_debug", "FUNC1": "X509V3_set_ctx", "TYPE3": "X509 *", "TYPE2": "X509 *", "FUNC4": "ERR_set_error", "TYPE5": "X509_CRL *", "TYPE4": "X509_REQ *", "TYPE6": "int", "TYPE1": "X509V3_CTX *"}, "assembly": "TEST RDI,RDI\nJZ 0x0016931b\nMOV dword ptr [RDI],R9D\nMOV qword ptr [RDI + 0x8],RSI\nMOV qword ptr [RDI + 0x10],RDX\nMOV qword ptr [RDI + 0x18],RCX\nMOV qword ptr [RDI + 0x20],R8\nMOV qword ptr [RDI + 0x28],0x0\nMOV qword ptr [RDI + 0x30],0x0\nMOV qword ptr [RDI + 0x38],0x0\nRET\nSUB RSP,0x8\nCALL 0x0010b9cb\nLEA RDX,[0x2f0ec8]\nMOV ESI,0x1c2\nLEA RDI,[0x2f0e46]\nCALL 0x0010bad8\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0x22\nMOV EAX,0x0\nCALL 0x0010bdef\nADD RSP,0x8\nRET\n"}, "44": {"funcbody": "void [FUNC1] (long param_1,long param_2,ulong param_3)\n{\n  long in_FS_OFFSET;\n  undefined auStack_338 [16];\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  long [VAR1] ;\n  \n  [VAR1] = *(long *)(in_FS_OFFSET + 0x28);\n  param_2 = param_2 - (int)param_3 * 2;\n  [FUNC3] (param_2 + -2,auStack_338,param_3,0x10);\n  [FUNC3] (param_2 + 6,&[VAR3] ,param_3 & 0xffffffff,0x10);\n  [FUNC3] (param_2 + 0xe,&[VAR2] ,param_3 & 0xffffffff,0x10);\n  [FUNC4] (param_1,auStack_338,param_3 & 0xffffffff,0,0x10);\n  [FUNC4] (param_1 + 8,&[VAR3] ,param_3 & 0xffffffff,0,0x10);\n  if ([VAR1] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "local_30", "VAR2": "local_318", "VAR3": "local_328", "FUNC2": "__stack_chk_fail", "FUNC3": "FUN_00ea7750", "FUNC1": "FUN_00ea1d60", "TYPE3": "undefined1", "TYPE2": "undefined1", "FUNC4": "FUN_00ea7c10", "TYPE1": "undefined8"}, "assembly": "PUSH R14\nPUSH R13\nMOV ECX,0x10\nPUSH R12\nPUSH RBP\nMOV R12,RDI\nPUSH RBX\nMOV RBX,RDX\nSUB RSP,0x310\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x308],RAX\nXOR EAX,EAX\nLEA EAX,[RDX + RDX*0x1]\nMOV R13,RSP\nLEA R14,[R13 + 0x10]\nCDQE\nSUB RSI,RAX\nLEA RBP,[RSI + -0x2]\nMOV RSI,R13\nMOV RDI,RBP\nCALL 0x00ea7750\nLEA RDI,[RBP + 0x8]\nMOV ECX,0x10\nMOV EDX,EBX\nMOV RSI,R14\nCALL 0x00ea7750\nLEA RSI,[R13 + 0x20]\nLEA RDI,[RBP + 0x10]\nMOV ECX,0x10\nMOV EDX,EBX\nCALL 0x00ea7750\nXOR ECX,ECX\nMOV R8D,0x10\nMOV EDX,EBX\nMOV RSI,R13\nMOV RDI,R12\nCALL 0x00ea7c10\nLEA RDI,[R12 + 0x8]\nXOR ECX,ECX\nMOV R8D,0x10\nMOV EDX,EBX\nMOV RSI,R14\nCALL 0x00ea7c10\nMOV RAX,qword ptr [RSP + 0x308]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x00ea1e21\nADD RSP,0x310\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nCALL 0x0010e490\n"}, "45": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  undefined8 uVar1;\n  long in_FS_OFFSET;\n  char *[VAR11] ;\n  undefined *[VAR10] ;\n  [TYPE1] [VAR9] ;\n  char *[VAR8] ;\n  [TYPE2] [VAR7] ;\n  [TYPE3] [VAR6] ;\n  undefined8 [VAR5] ;\n  long [VAR4] ;\n  \n  [VAR4] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR11] = \"dvhtool\";\n  [VAR10] = &DAT_0004cdad;\n  [VAR8] = \"--unix-to-vh\";\n  [VAR5] = 0;\n  [VAR9] = [VAR1] ;\n  [VAR7] = [VAR2] ;\n  [VAR6] = [VAR3] ;\n  [FUNC2] (&[VAR11] );\n  uVar1 = [FUNC4] (0,\"You will have to set `SystemPartition\\' and `OSLoader\\' manually.\",5);\n  [FUNC5] (\"%s\",uVar1);\n  if ([VAR4] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "install_device", "VAR2": "imgfile", "VAR3": "destname", "VAR4": "local_10", "VAR5": "local_18", "VAR6": "local_20", "FUNC2": "grub_util_exec", "FUNC3": "__stack_chk_fail", "FUNC1": "grub_install_sgi_setup", "TYPE3": "char *", "TYPE2": "char *", "FUNC4": "dcgettext", "TYPE5": "undefined8", "FUNC5": "grub_util_warn", "TYPE4": "undefined8", "TYPE7": "undefined8", "TYPE6": "undefined8", "TYPE9": "undefined8", "TYPE8": "undefined8", "VAR7": "local_28", "TYPE11": "undefined8", "VAR8": "local_30", "VAR9": "local_38", "TYPE10": "undefined8", "VAR10": "local_40", "VAR11": "local_48", "TYPE1": "char *"}, "assembly": "SUB RSP,0x48\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x38],RAX\nXOR EAX,EAX\nLEA RAX,[0x4cde7]\nMOV qword ptr [RSP],RAX\nLEA RAX,[0x4cdad]\nMOV qword ptr [RSP + 0x8],RAX\nMOV qword ptr [RSP + 0x10],RDI\nLEA RAX,[0x4cdef]\nMOV qword ptr [RSP + 0x18],RAX\nMOV qword ptr [RSP + 0x20],RSI\nMOV qword ptr [RSP + 0x28],RDX\nMOV qword ptr [RSP + 0x30],0x0\nMOV RDI,RSP\nCALL 0x00034f36\nMOV EDX,0x5\nLEA RSI,[0x4cef8]\nMOV EDI,0x0\nCALL 0x000061e0\nMOV RSI,RAX\nLEA RDI,[0x4bc54]\nMOV EAX,0x0\nCALL 0x0003520b\nMOV RAX,qword ptr [RSP + 0x38]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x0001a3a6\nADD RSP,0x48\nRET\nCALL 0x000061f0\n"}, "46": {"funcbody": "int [FUNC1] (TYPE15 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] )\n{\n  uint uVar1;\n  int iVar2;\n  BIGNUM *pBVar3;\n  BN_CTX *c;\n  \n  if (([VAR2] != ([TYPE2] )0x0) &&\n     (pBVar3 = [FUNC2] ((BIGNUM *)[VAR2] ,(BIGNUM *)[VAR1] ->field), pBVar3 == (BIGNUM *)0x0)) {\n    return 0;\n  }\n  if (([VAR3] == ([TYPE3] )0x0) && ([VAR4] == ([TYPE4] )0x0)) {\n    c = (BN_CTX *)0x0;\n    uVar1 = 1;\n    goto err;\n  }\n  if ([VAR1] ->meth->field_decode == (_func_int_EC_GROUP_ptr_BIGNUM_ptr_BIGNUM_ptr_BN_CTX_ptr *)0x0) {\n    if ([VAR3] != ([TYPE3] )0x0) {\n      pBVar3 = [FUNC2] ((BIGNUM *)[VAR3] ,(BIGNUM *)[VAR1] ->a);\n      if (pBVar3 == (BIGNUM *)0x0) {\n        c = (BN_CTX *)0x0;\n        uVar1 = 0;\n        goto err;\n      }\n      if ([VAR4] == ([TYPE4] )0x0) {\n        c = (BN_CTX *)0x0;\n        uVar1 = 1;\n        goto err;\n      }\n    }\n    pBVar3 = [FUNC2] ((BIGNUM *)[VAR4] ,(BIGNUM *)[VAR1] ->b);\n    uVar1 = (uint)(pBVar3 != (BIGNUM *)0x0);\n    c = (BN_CTX *)0x0;\n    goto err;\n  }\n  c = (BN_CTX *)0x0;\n  if (([VAR5] == ([TYPE5] )0x0) &&\n     ([VAR5] = [FUNC3] ([VAR1] ->libctx), c = [VAR5] , [VAR5] == (BN_CTX *)0x0)) {\n    return 0;\n  }\n  if ([VAR3] != ([TYPE3] )0x0) {\n    uVar1 = (*[VAR1] ->meth->field_decode)([VAR1] ,[VAR3] ,[VAR1] ->a,[VAR5] );\n    if (uVar1 == 0) goto err;\n    if ([VAR4] == ([TYPE4] )0x0) {\n      uVar1 = 1;\n      goto err;\n    }\n  }\n  iVar2 = (*[VAR1] ->meth->field_decode)([VAR1] ,[VAR4] ,[VAR1] ->b,[VAR5] );\n  uVar1 = (uint)(iVar2 != 0);\nerr:\n  [FUNC4] ((BN_CTX *)c);\n  return uVar1;\n}", "answer": {"VAR1": "group", "VAR2": "p", "VAR3": "a", "VAR4": "b", "VAR5": "ctx", "FUNC2": "BN_copy", "FUNC3": "BN_CTX_new_ex", "FUNC1": "ossl_ec_GFp_simple_group_get_curve", "TYPE3": "BIGNUM *", "TYPE2": "BIGNUM *", "FUNC4": "BN_CTX_free", "TYPE5": "BN_CTX *", "TYPE4": "BIGNUM *", "TYPE1": "EC_GROUP *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV R12,RDX\nMOV R14,RCX\nMOV R13,R8\nTEST RSI,RSI\nJZ 0x001942ca\nMOV RDI,RSI\nMOV RSI,qword ptr [RBX + 0x40]\nCALL 0x0007cf3d\nMOV EBP,0x0\nTEST RAX,RAX\nJZ 0x001943b8\nTEST R12,R12\nJNZ 0x001942d8\nTEST R14,R14\nJZ 0x001943a5\nMOV RAX,qword ptr [RBX]\nCMP qword ptr [RAX + 0x120],0x0\nJZ 0x0019435e\nMOV R15D,0x0\nTEST R13,R13\nJZ 0x00194340\nTEST R12,R12\nJZ 0x0019431e\nMOV RDX,qword ptr [RBX + 0x60]\nMOV RAX,qword ptr [RBX]\nMOV RCX,R13\nMOV RSI,R12\nMOV RDI,RBX\nCALL qword ptr [RAX + 0x120]\nMOV EBP,EAX\nTEST EAX,EAX\nJZ 0x001943b0\nTEST R14,R14\nJZ 0x001943c9\nMOV RDX,qword ptr [RBX + 0x68]\nMOV RAX,qword ptr [RBX]\nMOV RCX,R13\nMOV RSI,R14\nMOV RDI,RBX\nCALL qword ptr [RAX + 0x120]\nTEST EAX,EAX\nSETNZ BPL\nMOVZX EBP,BPL\nJMP 0x001943b0\nMOV RDI,qword ptr [RBX + 0xa8]\nCALL 0x00152138\nMOV R13,RAX\nMOV EBP,0x0\nTEST RAX,RAX\nJZ 0x001943b8\nMOV R15,RAX\nJMP 0x001942f0\nTEST R12,R12\nJZ 0x00194386\nMOV RSI,qword ptr [RBX + 0x60]\nMOV RDI,R12\nCALL 0x0007cf3d\nTEST RAX,RAX\nJZ 0x001943d0\nTEST R14,R14\nJNZ 0x00194386\nMOV R15D,0x0\nMOV EBP,0x1\nJMP 0x001943b0\nMOV RSI,qword ptr [RBX + 0x68]\nMOV RDI,R14\nCALL 0x0007cf3d\nTEST RAX,RAX\nSETNZ BPL\nMOVZX EBP,BPL\nMOV R15D,0x0\nJMP 0x001943b0\nMOV R15D,0x0\nMOV EBP,0x1\nMOV RDI,R15\nCALL 0x00152220\nMOV EAX,EBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV EBP,0x1\nJMP 0x001943b0\nMOV R15D,0x0\nMOV EBP,0x0\nJMP 0x001943b0\n"}, "47": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  ulong *puVar1;\n  int iVar2;\n  ulong *puVar3;\n  [TYPE9] [VAR9] ;\n  BIGNUM *pBVar4;\n  sbyte sVar5;\n  sbyte sVar6;\n  uint uVar7;\n  int iVar8;\n  int iVar9;\n  [TYPE4] [VAR4] ;\n  long lVar10;\n  [TYPE8] [VAR8] ;\n  ulong uVar11;\n  [TYPE10] [VAR10] ;\n  ulong uVar12;\n  ulong uVar13;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  iVar9 = [VAR3] + 0x3f;\n  if (-1 < [VAR3] ) {\n    iVar9 = [VAR3] ;\n  }\n  iVar9 = iVar9 >> 6;\n  pBVar4 = [FUNC3] ([VAR1] ,iVar9 + [VAR2] ->top + 1);\n  iVar8 = 0;\n  if (pBVar4 != (BIGNUM *)0x0) {\n    iVar8 = [VAR2] ->top;\n    if (iVar8 == 0) {\n      [VAR1] ->d[iVar9] = 0;\n    }\n    else {\n      uVar7 = -([VAR3] & 0x3fU) & 0x3f;\n      uVar13 = -(ulong)uVar7;\n      uVar13 = uVar13 | uVar13 >> 8;\n      puVar3 = [VAR2] ->d;\n      puVar1 = [VAR1] ->d + iVar9;\n      uVar12 = puVar3[(long)iVar8 + -1];\n      sVar5 = (sbyte)uVar7;\n      puVar1[iVar8] = uVar12 >> sVar5 & uVar13;\n      iVar2 = [VAR2] ->top;\n      iVar8 = iVar2 + -1;\n      sVar6 = (sbyte)([VAR3] & 0x3fU);\n      if (0 < iVar8) {\n        lVar10 = (long)iVar8 * 8;\n        do {\n          uVar11 = uVar12 << sVar6;\n          uVar12 = *(ulong *)((long)puVar3 + lVar10 + -8);\n          *(ulong *)((long)puVar1 + lVar10) = uVar12 >> sVar5 & uVar13 | uVar11;\n          lVar10 = lVar10 + -8;\n        } while (lVar10 != ((long)iVar8 - (ulong)(iVar2 - 2)) * 8 + -8);\n      }\n      *puVar1 = uVar12 << sVar6;\n    }\n    if (iVar9 != 0) {\n      [FUNC2] ([VAR1] ->d,0,(long)iVar9 << 3);\n    }\n    [VAR1] ->neg = [VAR2] ->neg;\n    [VAR1] ->top = iVar9 + [VAR2] ->top + 1;\n    iVar8 = 1;\n  }\n  return iVar8;\n}", "answer": {"VAR1": "r", "VAR2": "a", "VAR3": "n", "VAR4": "nw", "VAR5": "lb", "VAR6": "f", "FUNC2": "memset", "FUNC3": "bn_wexpand", "FUNC1": "bn_lshift_fixed_top", "TYPE3": "int", "TYPE2": "BIGNUM *", "TYPE5": "uint", "TYPE4": "int", "TYPE7": "ulong *", "TYPE6": "ulong *", "TYPE9": "int", "TYPE8": "ulong", "VAR7": "t", "VAR8": "l", "VAR9": "i", "TYPE10": "ulong", "VAR10": "m", "TYPE1": "BIGNUM *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R12,RDI\nMOV RBP,RSI\nMOV R13D,EDX\nLEA EBX,[RDX + 0x3f]\nTEST EDX,EDX\nCMOVNS EBX,EDX\nSAR EBX,0x6\nMOV ESI,EBX\nADD ESI,dword ptr [RBP + 0x8]\nADD ESI,0x1\nCALL 0x0007efda\nMOV EDX,0x0\nTEST RAX,RAX\nJZ 0x0008166e\nMOV EAX,dword ptr [RBP + 0x8]\nTEST EAX,EAX\nJZ 0x00081679\nAND R13D,0x3f\nMOV EDX,R13D\nNEG EDX\nAND EDX,0x3f\nMOV R8D,EDX\nNEG R8\nMOV RCX,R8\nSHR RCX,0x8\nOR R8,RCX\nMOV R10,qword ptr [RBP]\nMOVSXD RCX,EBX\nMOV RSI,qword ptr [R12]\nLEA R9,[RSI + RCX*0x8]\nCDQE\nMOV RDI,qword ptr [R10 + RAX*0x8 + -0x8]\nMOV RSI,RDI\nMOV ECX,EDX\nSHR RSI,CL\nMOV RCX,RSI\nAND RCX,R8\nMOV qword ptr [R9 + RAX*0x8],RCX\nMOV ECX,dword ptr [RBP + 0x8]\nLEA EAX,[RCX + -0x1]\nTEST EAX,EAX\nJLE 0x00081649\nCDQE\nLEA RSI,[RAX*0x8]\nLEA ECX,[RCX + -0x2]\nSUB RAX,RCX\nLEA R11,[-0x8 + RAX*0x8]\nMOV ECX,R13D\nSHL RDI,CL\nMOV R14,RDI\nMOV RDI,qword ptr [R10 + RSI*0x1 + -0x8]\nMOV RAX,RDI\nMOV ECX,EDX\nSHR RAX,CL\nAND RAX,R8\nOR RAX,R14\nMOV qword ptr [R9 + RSI*0x1],RAX\nSUB RSI,0x8\nCMP RSI,R11\nJNZ 0x00081620\nMOV ECX,R13D\nSHL RDI,CL\nMOV qword ptr [R9],RDI\nTEST EBX,EBX\nJNZ 0x0008168a\nMOV EAX,dword ptr [RBP + 0x10]\nMOV dword ptr [R12 + 0x10],EAX\nADD EBX,dword ptr [RBP + 0x8]\nADD EBX,0x1\nMOV dword ptr [R12 + 0x8],EBX\nMOV EDX,0x1\nMOV EAX,EDX\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOVSXD RAX,EBX\nMOV RDX,qword ptr [R12]\nMOV qword ptr [RDX + RAX*0x8],0x0\nJMP 0x00081652\nMOVSXD RDX,EBX\nSHL RDX,0x3\nMOV RDI,qword ptr [R12]\nMOV ESI,0x0\nCALL 0x00062240\nJMP 0x00081656\n"}, "48": {"funcbody": "void [FUNC1] (void)\n{\n  long lVar1;\n  \n  DAT_01b5e808 = &DAT_01b5d6c0;\n  _DAT_01b5e814 = 0x44a;\n  [FUNC3] (&DAT_01b5e800,9,0x79,&DAT_01283e60,1,1,&DAT_01283c60,4,4,0,0,0,1);\n  DAT_01b5e820 = &DAT_01b5c5a0;\n  _DAT_01b5e82c = 0x444;\n  [FUNC3] (&DAT_01b5e818,9,0x79,&DAT_01283be0,1,1,&DAT_012839e0,4,4,0,0,0,1);\n  DAT_01b5e838 = &DAT_01b5b9a0;\n  _DAT_01b5e844 = 0x300;\n  [FUNC3] (&DAT_01b5e830,9,0x31,&DAT_012839a0,1,1,&DAT_012838c0,4,4,0,0,0,1);\n  DAT_01b5e850 = &DAT_01b5a980;\n  _DAT_01b5e85c = 0x402;\n  [FUNC3] (&DAT_01b5e848,9,0x31,&DAT_01283880,1,1,&DAT_012837a0,4,4,0,0,0,1);\n  DAT_01b5e868 = &DAT_01b598e0;\n  _DAT_01b5e874 = 0x422;\n  [FUNC3] (&DAT_01b5e860,9,0x3f,&DAT_01283760,1,1,&DAT_01283660,4,4,0,0,0,1);\n  DAT_01b5e880 = &DAT_01b58860;\n  _DAT_01b5e88c = 0x41c;\n  [FUNC3] (&DAT_01b5e878,9,0x3f,&DAT_01283620,1,1,&DAT_01283520,4,4,0,0,0,1);\n  DAT_01b5e898 = &DAT_01b57fe0;\n  _DAT_01b5e8a4 = 0x220;\n  [FUNC3] (&DAT_01b5e890,9,0x19,&DAT_01283500,1,1,&DAT_012834c0,2,2,0,0,0,1);\n  DAT_01b5e8b0 = &DAT_01b57760;\n  _DAT_01b5e8bc = 0x220;\n  [FUNC3] (&DAT_01b5e8a8,9,0x19,&DAT_012834a0,1,1,&DAT_01283460,2,2,0,0,0,1);\n  DAT_01b5e8c8 = &DAT_01b56e20;\n  _DAT_01b5e8d4 = 0x250;\n  [FUNC3] (&DAT_01b5e8c0,9,0x3f,&DAT_01283420,1,1,&DAT_012833a0,2,2,0,0,0,1);\n  DAT_01b5e8e0 = &DAT_01b56620;\n  _DAT_01b5e8ec = 0x200;\n  [FUNC3] (&DAT_01b5e8d8,9,0x19,&DAT_01283380,1,1,&DAT_01283360,1,1,0,0,0,1);\n  lVar1 = 0;\n  do {\n    (&DAT_01b5e900)[lVar1] = (&DAT_01282900)[lVar1 * 2];\n    lVar1 = lVar1 + 1;\n  } while (lVar1 != 0x140);\n  [FUNC2] ();\n  return;\n}", "answer": {"FUNC2": "FUN_00188f68", "FUNC3": "FUN_00a76d10", "FUNC1": "FUN_0017b8d0"}, "assembly": "LEA RAX,[0x1b5d6c0]\nSUB RSP,0x10\nLEA RCX,[0x1283e60]\nPUSH 0x1\nLEA RDI,[0x1b5e800]\nPUSH 0x0\nMOV qword ptr [0x01b5e808],RAX\nLEA RAX,[0x1283c60]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x4\nMOV R9D,0x1\nPUSH 0x4\nPUSH RAX\nMOV R8D,0x1\nMOV EDX,0x79\nMOV ESI,0x9\nMOV dword ptr [0x01b5e814],0x44a\nCALL 0x00a76d10\nLEA RAX,[0x1b5c5a0]\nADD RSP,0x38\nLEA RCX,[0x1283be0]\nPUSH 0x1\nLEA RDI,[0x1b5e818]\nPUSH 0x0\nMOV qword ptr [0x01b5e820],RAX\nLEA RAX,[0x12839e0]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x4\nMOV R9D,0x1\nPUSH 0x4\nPUSH RAX\nMOV R8D,0x1\nMOV EDX,0x79\nMOV ESI,0x9\nMOV dword ptr [0x01b5e82c],0x444\nCALL 0x00a76d10\nLEA RAX,[0x1b5b9a0]\nADD RSP,0x38\nLEA RCX,[0x12839a0]\nPUSH 0x1\nLEA RDI,[0x1b5e830]\nPUSH 0x0\nMOV qword ptr [0x01b5e838],RAX\nLEA RAX,[0x12838c0]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x4\nMOV R9D,0x1\nPUSH 0x4\nPUSH RAX\nMOV R8D,0x1\nMOV EDX,0x31\nMOV ESI,0x9\nMOV dword ptr [0x01b5e844],0x300\nCALL 0x00a76d10\nLEA RAX,[0x1b5a980]\nADD RSP,0x38\nLEA RCX,[0x1283880]\nPUSH 0x1\nLEA RDI,[0x1b5e848]\nPUSH 0x0\nMOV qword ptr [0x01b5e850],RAX\nLEA RAX,[0x12837a0]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x4\nMOV R9D,0x1\nPUSH 0x4\nPUSH RAX\nMOV R8D,0x1\nMOV EDX,0x31\nMOV ESI,0x9\nMOV dword ptr [0x01b5e85c],0x402\nCALL 0x00a76d10\nLEA RAX,[0x1b598e0]\nADD RSP,0x38\nLEA RCX,[0x1283760]\nPUSH 0x1\nLEA RDI,[0x1b5e860]\nPUSH 0x0\nMOV qword ptr [0x01b5e868],RAX\nLEA RAX,[0x1283660]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x4\nMOV R9D,0x1\nPUSH 0x4\nPUSH RAX\nMOV R8D,0x1\nMOV EDX,0x3f\nMOV ESI,0x9\nMOV dword ptr [0x01b5e874],0x422\nCALL 0x00a76d10\nLEA RAX,[0x1b58860]\nADD RSP,0x38\nLEA RCX,[0x1283620]\nPUSH 0x1\nLEA RDI,[0x1b5e878]\nPUSH 0x0\nMOV qword ptr [0x01b5e880],RAX\nLEA RAX,[0x1283520]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x4\nMOV R9D,0x1\nPUSH 0x4\nPUSH RAX\nMOV R8D,0x1\nMOV EDX,0x3f\nMOV ESI,0x9\nMOV dword ptr [0x01b5e88c],0x41c\nCALL 0x00a76d10\nLEA RAX,[0x1b57fe0]\nADD RSP,0x38\nLEA RCX,[0x1283500]\nPUSH 0x1\nLEA RDI,[0x1b5e890]\nPUSH 0x0\nMOV qword ptr [0x01b5e898],RAX\nLEA RAX,[0x12834c0]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x2\nMOV R9D,0x1\nPUSH 0x2\nPUSH RAX\nMOV R8D,0x1\nMOV EDX,0x19\nMOV ESI,0x9\nMOV dword ptr [0x01b5e8a4],0x220\nCALL 0x00a76d10\nLEA RAX,[0x1b57760]\nADD RSP,0x38\nLEA RCX,[0x12834a0]\nPUSH 0x1\nLEA RDI,[0x1b5e8a8]\nPUSH 0x0\nMOV qword ptr [0x01b5e8b0],RAX\nLEA RAX,[0x1283460]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x2\nMOV R9D,0x1\nPUSH 0x2\nPUSH RAX\nMOV R8D,0x1\nMOV EDX,0x19\nMOV ESI,0x9\nMOV dword ptr [0x01b5e8bc],0x220\nCALL 0x00a76d10\nLEA RAX,[0x1b56e20]\nADD RSP,0x38\nLEA RCX,[0x1283420]\nPUSH 0x1\nLEA RDI,[0x1b5e8c0]\nPUSH 0x0\nMOV qword ptr [0x01b5e8c8],RAX\nLEA RAX,[0x12833a0]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x2\nMOV R9D,0x1\nPUSH 0x2\nPUSH RAX\nMOV R8D,0x1\nMOV EDX,0x3f\nMOV ESI,0x9\nMOV dword ptr [0x01b5e8d4],0x250\nCALL 0x00a76d10\nLEA RAX,[0x1b56620]\nADD RSP,0x38\nLEA RCX,[0x1283380]\nPUSH 0x1\nLEA RDI,[0x1b5e8d8]\nPUSH 0x0\nMOV qword ptr [0x01b5e8e0],RAX\nLEA RAX,[0x1283360]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x1\nMOV EDX,0x19\nPUSH 0x1\nPUSH RAX\nMOV R9D,0x1\nMOV R8D,0x1\nMOV ESI,0x9\nMOV dword ptr [0x01b5e8ec],0x200\nCALL 0x00a76d10\nLEA RCX,[0x1b5e900]\nLEA RDX,[0x1282900]\nADD RSP,0x40\nXOR EAX,EAX\nMOV ESI,dword ptr [RDX + RAX*0x8]\nMOV dword ptr [RCX + RAX*0x4],ESI\nINC RAX\nCMP RAX,0x140\nJNZ 0x0017bc5e\nPOP RAX\nJMP 0x00188f68\n"}, "49": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n          [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] ,[TYPE8] [VAR8] ,\n          [TYPE9] [VAR9] ,[TYPE10] [VAR10] ,[TYPE11] [VAR11] )\n{\n  int iVar1;\n  \n  iVar1 = 8;\n  do {\n    iVar1 = iVar1 + -1;\n  } while (iVar1 != 0);\n  return;\n}", "answer": {"VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "VAR5": "param_5", "VAR6": "param_6", "FUNC1": "__rsaz_512_reduce", "TYPE3": "undefined", "TYPE2": "undefined", "TYPE5": "undefined", "TYPE4": "undefined", "TYPE7": "undefined", "TYPE6": "undefined", "TYPE9": "undefined", "TYPE8": "undefined", "VAR7": "param_7", "TYPE11": "undefined8", "VAR8": "param_8", "VAR9": "param_9", "TYPE10": "undefined", "VAR10": "param_10", "VAR11": "param_11", "TYPE1": "undefined"}, "assembly": "MOV RBX,R8\nIMUL RBX,qword ptr [RSP + 0x88]\nMOV RAX,qword ptr [RBP]\nMOV ECX,0x8\nJMP 0x00213c40\nMUL RBX\nMOV RAX,qword ptr [RBP + 0x8]\nNEG R8\nMOV R8,RDX\nADC R8,0x0\nMUL RBX\nADD R9,RAX\nMOV RAX,qword ptr [RBP + 0x10]\nADC RDX,0x0\nADD R8,R9\nMOV R9,RDX\nADC R9,0x0\nMUL RBX\nADD R10,RAX\nMOV RAX,qword ptr [RBP + 0x18]\nADC RDX,0x0\nADD R9,R10\nMOV R10,RDX\nADC R10,0x0\nMUL RBX\nADD R11,RAX\nMOV RAX,qword ptr [RBP + 0x20]\nADC RDX,0x0\nADD R10,R11\nMOV RSI,qword ptr [RSP + 0x88]\nADC RDX,0x0\nMOV R11,RDX\nMUL RBX\nADD R12,RAX\nMOV RAX,qword ptr [RBP + 0x28]\nADC RDX,0x0\nIMUL RSI,R8\nADD R11,R12\nMOV R12,RDX\nADC R12,0x0\nMUL RBX\nADD R13,RAX\nMOV RAX,qword ptr [RBP + 0x30]\nADC RDX,0x0\nADD R12,R13\nMOV R13,RDX\nADC R13,0x0\nMUL RBX\nADD R14,RAX\nMOV RAX,qword ptr [RBP + 0x38]\nADC RDX,0x0\nADD R13,R14\nMOV R14,RDX\nADC R14,0x0\nMUL RBX\nMOV RBX,RSI\nADD R15,RAX\nMOV RAX,qword ptr [RBP]\nADC RDX,0x0\nADD R14,R15\nMOV R15,RDX\nADC R15,0x0\nDEC ECX\nJNZ 0x00213c40\nRET\n"}, "50": {"funcbody": "char * [FUNC1] (TYPE19 [VAR1] )\n{\n  char *pcVar1;\n  undefined8 uVar2;\n  \n  if ([VAR1] ->metric == (char *)0x0) {\n    pcVar1 = [VAR1] ->name;\n    if (pcVar1 == (char *)0x0) {\n      pcVar1 = [VAR1] ->int_name;\n      if (pcVar1 == (char *)0x0) {\n        uVar2 = [FUNC3] (0,\"Undefined Events\",5);\n        [FUNC4] (metricbuf,0x800,1,0x800,uVar2);\n      }\n      else {\n        uVar2 = [FUNC3] (0,\"%s Events\",5);\n        [FUNC4] (metricbuf,0x800,1,0x800,uVar2,pcVar1);\n      }\n    }\n    else {\n      uVar2 = [FUNC3] (0,\"%s Events\",5);\n      [FUNC4] (metricbuf,0x800,1,0x800,uVar2,pcVar1);\n    }\n  }\n  else {\n    uVar2 = [FUNC3] (0,[VAR1] ->metric,5);\n    [FUNC2] (metricbuf,0x800,\"%s\",uVar2);\n  }\n  return metricbuf;\n}", "answer": {"VAR1": "pctr", "FUNC2": "snprintf", "FUNC3": "dcgettext", "FUNC1": "hwc_i18n_metric", "FUNC4": "__snprintf_chk", "TYPE1": "Hwcentry.conflict *"}, "assembly": "PUSH RBX\nMOV RSI,qword ptr [RDI + 0x18]\nTEST RSI,RSI\nJNZ 0x00140a4a\nMOV RBX,qword ptr [RDI]\nTEST RBX,RBX\nJNZ 0x00140a82\nMOV RBX,qword ptr [RDI + 0x8]\nTEST RBX,RBX\nJZ 0x00140ac0\nMOV EDX,0x5\nLEA RSI,[0x2412a5]\nMOV EDI,0x0\nCALL 0x0008f510\nMOV R8,RAX\nMOV R9,RBX\nMOV ECX,0x800\nMOV EDX,0x1\nMOV ESI,0x800\nLEA RDI,[0x5cf060]\nMOV EAX,0x0\nCALL 0x0008f4a0\nJMP 0x00140a79\nMOV EDX,0x5\nMOV EDI,0x0\nCALL 0x0008f510\nMOV RCX,RAX\nLEA RDX,[0x26c426]\nMOV ESI,0x800\nLEA RDI,[0x5cf060]\nMOV EAX,0x0\nCALL 0x0008fbd0\nLEA RAX,[0x5cf060]\nPOP RBX\nRET\nMOV EDX,0x5\nLEA RSI,[0x2412a5]\nMOV EDI,0x0\nCALL 0x0008f510\nMOV R8,RAX\nMOV R9,RBX\nMOV ECX,0x800\nMOV EDX,0x1\nMOV ESI,0x800\nLEA RDI,[0x5cf060]\nMOV EAX,0x0\nCALL 0x0008f4a0\nJMP 0x00140a79\nMOV EDX,0x5\nLEA RSI,[0x2412af]\nMOV EDI,0x0\nCALL 0x0008f510\nMOV R8,RAX\nMOV ECX,0x800\nMOV EDX,0x1\nMOV ESI,0x800\nLEA RDI,[0x5cf060]\nMOV EAX,0x0\nCALL 0x0008f4a0\nJMP 0x00140a79\n"}, "51": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  int num;\n  ulong *ap;\n  BIGNUM *pBVar2;\n  ulong uVar3;\n  [TYPE9] [VAR9] ;\n  long lVar4;\n  [TYPE10] [VAR10] ;\n  long lVar5;\n  int iVar6;\n  ulong *puVar7;\n  [TYPE3] pBVar8;\n  [TYPE8] [VAR8] ;\n  [TYPE4] [VAR4] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  TYPE73 [VAR7] ;\n  \n  pBVar8 = [VAR2] ;\n  if ([VAR2] ->top < [VAR3] ->top) {\n    pBVar8 = [VAR3] ;\n    [VAR3] = [VAR2] ;\n  }\n  iVar1 = pBVar8->top;\n  num = [VAR3] ->top;\n  pBVar2 = [FUNC3] ((BIGNUM *)[VAR1] ,iVar1 + 1);\n  iVar6 = 0;\n  if (pBVar2 != (BIGNUM *)0x0) {\n    iVar6 = iVar1 - num;\n    [VAR1] ->top = iVar1;\n    ap = pBVar8->d;\n    puVar7 = [VAR1] ->d;\n    uVar3 = [FUNC2] (puVar7,ap,[VAR3] ->d,num);\n    puVar7 = puVar7 + num;\n    if (iVar6 != 0) {\n      lVar5 = 0;\n      do {\n        lVar4 = uVar3 + *(long *)((long)ap + lVar5 + (long)num * 8);\n        *(long *)((long)puVar7 + lVar5) = lVar4;\n        uVar3 = uVar3 & lVar4 == 0;\n        lVar5 = lVar5 + 8;\n      } while (lVar5 != (ulong)(iVar6 - 1) * 8 + 8);\n      puVar7 = puVar7 + (ulong)(iVar6 - 1) + 1;\n    }\n    *puVar7 = uVar3;\n    [VAR1] ->top = [VAR1] ->top + (int)uVar3;\n    [VAR1] ->neg = 0;\n    iVar6 = 1;\n  }\n  return iVar6;\n}", "answer": {"VAR1": "r", "VAR2": "a", "VAR3": "b", "VAR4": "max", "VAR5": "min", "VAR6": "ap", "FUNC2": "bn_add_words", "FUNC3": "bn_wexpand", "FUNC1": "BN_uadd", "TYPE3": "BIGNUM *", "TYPE2": "BIGNUM *", "TYPE5": "int", "TYPE4": "int", "TYPE7": "ulong * *", "TYPE6": "ulong *", "TYPE9": "ulong", "TYPE8": "ulong *", "VAR7": "bp", "VAR8": "rp", "VAR9": "carry", "TYPE10": "ulong", "VAR10": "t2", "TYPE1": "BIGNUM *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV R12,RSI\nMOV R15,RDX\nMOV EAX,dword ptr [RDX + 0x8]\nCMP dword ptr [RSI + 0x8],EAX\nJGE 0x0012e571\nMOV R12,RDX\nMOV R15,RSI\nMOV R13D,dword ptr [R12 + 0x8]\nMOV R14D,dword ptr [R15 + 0x8]\nLEA ESI,[R13 + 0x1]\nMOV RDI,RBX\nCALL 0x00078760\nMOV EDX,0x0\nTEST RAX,RAX\nJZ 0x0012e60e\nMOV EBP,R13D\nSUB EBP,R14D\nMOV dword ptr [RBX + 0x8],R13D\nMOV R13,qword ptr [R12]\nMOV R12,qword ptr [RBX]\nMOV ECX,R14D\nMOV RDX,qword ptr [R15]\nMOV RSI,R13\nMOV RDI,R12\nCALL 0x0012d934\nMOVSXD R14,R14D\nSHL R14,0x3\nLEA RDI,[R12 + R14*0x1]\nADD R14,R13\nTEST EBP,EBP\nJZ 0x0012e5fc\nLEA EDX,[RBP + -0x1]\nLEA RSI,[0x8 + RDX*0x8]\nMOV EDX,0x0\nMOV RCX,RAX\nADD RCX,qword ptr [R14 + RDX*0x1]\nMOV qword ptr [RDI + RDX*0x1],RCX\nTEST RCX,RCX\nSETZ CL\nMOVZX ECX,CL\nAND RAX,RCX\nADD RDX,0x8\nCMP RDX,RSI\nJNZ 0x0012e5d4\nLEA EDX,[RBP + -0x1]\nLEA RDI,[RDI + RDX*0x8 + 0x8]\nMOV qword ptr [RDI],RAX\nADD dword ptr [RBX + 0x8],EAX\nMOV dword ptr [RBX + 0x10],0x0\nMOV EDX,0x1\nMOV EAX,EDX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "52": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  \n  if ([VAR1] != ([TYPE1] )0x0) {\n    if ([VAR1] ->d != (ulong *)0x0) {\n      iVar1 = [FUNC3] ((BIGNUM *)[VAR1] ,2);\n      if (iVar1 == 0) {\n        [FUNC5] ((BIGNUM *)[VAR1] ,1);\n      }\n    }\n    iVar1 = [FUNC3] ((BIGNUM *)[VAR1] ,1);\n    if (iVar1 != 0) {\n      [FUNC2] ([VAR1] ,0x18);\n      [FUNC4] ([VAR1] );\n    }\n    return;\n  }\n  return;\n}", "answer": {"VAR1": "a", "FUNC2": "OPENSSL_cleanse", "FUNC3": "BN_get_flags", "FUNC1": "BN_clear_free", "FUNC4": "CRYPTO_free", "FUNC5": "bn_free_d", "TYPE1": "BIGNUM *"}, "assembly": "TEST RDI,RDI\nJZ 0x0007843c\nPUSH RBX\nMOV RBX,RDI\nCMP qword ptr [RDI],0x0\nJZ 0x000783f7\nMOV ESI,0x2\nCALL 0x00078360\nTEST EAX,EAX\nJZ 0x0007840a\nMOV ESI,0x1\nMOV RDI,RBX\nCALL 0x00078360\nTEST EAX,EAX\nJNZ 0x00078419\nPOP RBX\nRET\nMOV ESI,0x1\nMOV RDI,RBX\nCALL 0x00078366\nJMP 0x000783f7\nMOV ESI,0x18\nMOV RDI,RBX\nCALL 0x000a1120\nMOV EDX,0xdd\nLEA RSI,[0x25fd05]\nMOV RDI,RBX\nCALL 0x00099b68\nJMP 0x00078408\nRET\n"}, "53": {"funcbody": "/* breakpoint::allocate_location() */\nbp_location * breakpoint::[FUNC1] (void)\n{\n  bp_location *this;\n  breakpoint *in_RDI;\n  \n  this = (bp_location *)[FUNC3] (0x1b0);\n                    /* try { // try from 00275d98 to 00275d9c has its CatchHandler @ 00275d9f */\n  bp_location::[FUNC2] (this,in_RDI);\n  return this;\n}", "answer": {"FUNC2": "bp_location", "FUNC3": "operator.new", "FUNC1": "allocate_location"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV EDI,0x1b0\nCALL 0x006e1da7\nMOV RBX,RAX\nMOV RSI,RBP\nMOV RDI,RAX\nCALL 0x00175d08\nJMP 0x00175db7\n"}, "54": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] ,TYPE21 [VAR2] )\n{\n  int iVar1;\n  [TYPE3] [VAR3] ;\n  size_t __n;\n  \n  if (*(int *)([VAR2] + 0x88) != -1) {\n    iVar1 = [FUNC4] (*(EVP_CIPHER_CTX **)[VAR2] );\n    [VAR3] = 0;\n    if (-1 < iVar1) {\n      [VAR3] = [FUNC3] (*(EVP_CIPHER_CTX **)[VAR1] ,*(EVP_CIPHER_CTX **)[VAR2] );\n      if ([VAR3] != 0) {\n        __n = (size_t)iVar1;\n        [FUNC2] ([VAR1] + 8,[VAR2] + 8,__n);\n        [FUNC2] ([VAR1] + 0x28,[VAR2] + 0x28,__n);\n        [FUNC2] ([VAR1] + 0x48,[VAR2] + 0x48,__n);\n        [FUNC2] ([VAR1] + 0x68,[VAR2] + 0x68,__n);\n        *(undefined4 *)([VAR1] + 0x88) = *(undefined4 *)([VAR2] + 0x88);\n        [VAR3] = 1;\n      }\n    }\n    return [VAR3] ;\n  }\n  return 0;\n}", "answer": {"VAR1": "out", "VAR2": "in", "VAR3": "bl", "FUNC2": "memcpy", "FUNC3": "EVP_CIPHER_CTX_copy", "FUNC1": "CMAC_CTX_copy", "TYPE3": "int", "TYPE2": "CMAC_CTX *", "FUNC4": "EVP_CIPHER_CTX_get_block_size", "TYPE1": "CMAC_CTX *"}, "assembly": "MOV EAX,0x0\nCMP dword ptr [RSI + 0x88],-0x1\nJZ 0x00149a44\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RSI\nMOV RBP,RDI\nMOV RDI,qword ptr [RSI]\nCALL 0x0008d4de\nMOV R12D,EAX\nMOV EAX,0x0\nTEST R12D,R12D\nJS 0x001499e9\nMOV RSI,qword ptr [RBX]\nMOV RDI,qword ptr [RBP]\nCALL 0x0008ab65\nTEST EAX,EAX\nJNZ 0x001499ee\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOVSXD R12,R12D\nLEA RDI,[RBP + 0x8]\nLEA RSI,[RBX + 0x8]\nMOV RDX,R12\nCALL 0x00062840\nLEA RDI,[RBP + 0x28]\nLEA RSI,[RBX + 0x28]\nMOV RDX,R12\nCALL 0x00062840\nLEA RDI,[RBP + 0x48]\nLEA RSI,[RBX + 0x48]\nMOV RDX,R12\nCALL 0x00062840\nLEA RDI,[RBP + 0x68]\nLEA RSI,[RBX + 0x68]\nMOV RDX,R12\nCALL 0x00062840\nMOV EAX,dword ptr [RBX + 0x88]\nMOV dword ptr [RBP + 0x88],EAX\nMOV EAX,0x1\nJMP 0x001499e9\nRET\n"}, "55": {"funcbody": "void * [FUNC1] (TYPE13 [VAR1] )\n{\n  int iVar1;\n  [TYPE2] [VAR2] ;\n  void *pvVar2;\n  \n  if ([VAR1] == (TYPE13)0x0) {\n    [FUNC2] ();\n    [FUNC4] (\"crypto/stack/stack.c\",0x1a0,\"OPENSSL_sk_pop\");\n    [FUNC3] (0xb,0xc0102,(char *)0x0);\n    pvVar2 = (void *)0x0;\n  }\n  else if ([VAR1] ->num == 0) {\n    [FUNC2] ();\n    [FUNC4] (\"crypto/stack/stack.c\",0x1a4,\"OPENSSL_sk_pop\");\n    [FUNC3] (0xb,0x80106,(char *)0x0);\n    pvVar2 = (void *)0x0;\n  }\n  else {\n    iVar1 = [VAR1] ->num + -1;\n    pvVar2 = [VAR1] ->data[iVar1];\n    [VAR1] ->num = iVar1;\n  }\n  return pvVar2;\n}", "answer": {"VAR1": "st", "VAR2": "ret", "FUNC2": "ERR_new", "FUNC3": "ERR_set_error", "FUNC1": "OPENSSL_sk_pop", "TYPE2": "void *", "FUNC4": "ERR_set_debug", "TYPE1": "OPENSSL_STACK *"}, "assembly": "SUB RSP,0x8\nTEST RDI,RDI\nJZ 0x000b4db5\nMOV EAX,dword ptr [RDI]\nTEST EAX,EAX\nJZ 0x000b4df2\nLEA EDX,[RAX + -0x1]\nMOVSXD RCX,EDX\nMOV RAX,qword ptr [RDI + 0x8]\nMOV RAX,qword ptr [RAX + RCX*0x8]\nMOV dword ptr [RDI],EDX\nADD RSP,0x8\nRET\nCALL 0x00083e6e\nLEA RDX,[0x272940]\nMOV ESI,0x1a0\nLEA RDI,[0x2728d5]\nCALL 0x00083f7b\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0xb\nMOV EAX,0x0\nCALL 0x00084292\nMOV EAX,0x0\nJMP 0x000b4db0\nCALL 0x00083e6e\nLEA RDX,[0x272940]\nMOV ESI,0x1a4\nLEA RDI,[0x2728d5]\nCALL 0x00083f7b\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0xb\nMOV EAX,0x0\nCALL 0x00084292\nMOV EAX,0x0\nJMP 0x000b4db0\n"}, "56": {"funcbody": "int [FUNC1] (TYPE10 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  char cVar1;\n  OSSL_PARAM_BLD_DEF *pOVar2;\n  TYPE59 [VAR5] ;\n  long lVar3;\n  int size;\n  [TYPE3] pcVar4;\n  \n  if ([VAR4] == 0) {\n    lVar3 = -1;\n    pcVar4 = [VAR3] ;\n    do {\n      if (lVar3 == 0) break;\n      lVar3 = lVar3 + -1;\n      cVar1 = *pcVar4;\n      pcVar4 = pcVar4 + 1;\n    } while (cVar1 != '\\0');\n    size = ~(uint)lVar3 - 1;\n  }\n  else {\n    size = (int)[VAR4] ;\n    if (0x7fffffff < [VAR4] ) {\n      [FUNC5] ();\n      [FUNC3] (\"crypto/param_build.c\",0x104,\"OSSL_PARAM_BLD_push_utf8_ptr\");\n      [FUNC2] (0xf,0x70,(char *)0x0);\n      return 0;\n    }\n  }\n  pOVar2 = [FUNC4] ([VAR1] ,[VAR2] ,size,8,6,0);\n  if (pOVar2 != (OSSL_PARAM_BLD_DEF *)0x0) {\n    pOVar2->string = [VAR3] ;\n  }\n  return (uint)(pOVar2 != (OSSL_PARAM_BLD_DEF *)0x0);\n}", "answer": {"VAR1": "bld", "VAR2": "key", "VAR3": "buf", "VAR4": "bsize", "VAR5": "pd", "FUNC2": "ERR_set_error", "FUNC3": "ERR_set_debug", "FUNC1": "OSSL_PARAM_BLD_push_utf8_ptr", "TYPE3": "char *", "TYPE2": "char *", "FUNC4": "param_push", "TYPE5": "OSSL_PARAM_BLD_DEF *", "FUNC5": "ERR_new", "TYPE4": "size_t", "TYPE1": "OSSL_PARAM_BLD *"}, "assembly": "PUSH RBX\nMOV R10,RDI\nMOV RBX,RDX\nTEST RCX,RCX\nJNZ 0x001adf85\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,RDX\nSCASB.REPNE RDI\nNOT RCX\nLEA RDX,[RCX + -0x1]\nMOV R9D,0x0\nMOV R8D,0x6\nMOV ECX,0x8\nMOV RDI,R10\nCALL 0x001ad975\nMOV EDX,0x0\nTEST RAX,RAX\nJZ 0x001adf81\nMOV qword ptr [RAX + 0x28],RBX\nMOV EDX,0x1\nMOV EAX,EDX\nPOP RBX\nRET\nMOV RDX,RCX\nCMP RCX,0x7fffffff\nJBE 0x001adf55\nCALL 0x00081b39\nLEA RDX,[0x2959f0]\nMOV ESI,0x104\nLEA RDI,[0x295918]\nCALL 0x00081c46\nMOV EDX,0x0\nMOV ESI,0x70\nMOV EDI,0xf\nMOV EAX,0x0\nCALL 0x00081f5d\nMOV EDX,0x0\nJMP 0x001adf81\n"}, "57": {"funcbody": "ulong [FUNC1] (long param_1,long param_2,long param_3,long param_4)\n{\n  ulong uVar1;\n  ulong uVar2;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  long [VAR4] ;\n  ulong [VAR3] ;\n  [TYPE2] [VAR2] ;\n  [TYPE1] [VAR1] ;\n  \n  [VAR3] = 0;\n  for ([VAR4] = 0; [VAR4] < param_4; [VAR4] = [VAR4] + 1) {\n    uVar2 = *(ulong *)(param_2 + [VAR4] * 8);\n    uVar1 = *(long *)(param_3 + [VAR4] * 8) + [VAR3] ;\n    [VAR3] = (ulong)(uVar1 < [VAR3] ) + (ulong)(uVar2 < uVar1);\n    *(ulong *)([VAR4] * 8 + param_1) = uVar2 - uVar1;\n  }\n  return [VAR3] ;\n}", "answer": {"VAR1": "local_10", "VAR2": "local_18", "VAR3": "local_20", "VAR4": "local_28", "VAR5": "local_30", "VAR6": "local_38", "FUNC1": "mpn_sub_n", "TYPE3": "undefined8", "TYPE2": "undefined8", "TYPE5": "undefined8", "TYPE4": "undefined8", "TYPE7": "undefined8", "TYPE6": "undefined8", "TYPE8": "undefined8", "VAR7": "local_40", "VAR8": "local_48", "TYPE1": "undefined8"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nMOV qword ptr [RBP + -0x28],RDI\nMOV qword ptr [RBP + -0x30],RSI\nMOV qword ptr [RBP + -0x38],RDX\nMOV qword ptr [RBP + -0x40],RCX\nMOV qword ptr [RBP + -0x20],0x0\nMOV qword ptr [RBP + -0x18],0x0\nJMP 0x00001358\nMOV RAX,qword ptr [RBP + -0x20]\nLEA RDX,[RAX*0x8]\nMOV RAX,qword ptr [RBP + -0x30]\nADD RAX,RDX\nMOV RAX,qword ptr [RAX]\nMOV qword ptr [RBP + -0x10],RAX\nMOV RAX,qword ptr [RBP + -0x20]\nLEA RDX,[RAX*0x8]\nMOV RAX,qword ptr [RBP + -0x38]\nADD RAX,RDX\nMOV RAX,qword ptr [RAX]\nMOV qword ptr [RBP + -0x8],RAX\nMOV RAX,qword ptr [RBP + -0x18]\nADD qword ptr [RBP + -0x8],RAX\nMOV RAX,qword ptr [RBP + -0x8]\nCMP RAX,qword ptr [RBP + -0x18]\nSETC AL\nMOVZX EAX,AL\nMOV qword ptr [RBP + -0x18],RAX\nMOV RAX,qword ptr [RBP + -0x10]\nCMP RAX,qword ptr [RBP + -0x8]\nSETC AL\nMOVZX EAX,AL\nADD qword ptr [RBP + -0x18],RAX\nMOV RAX,qword ptr [RBP + -0x20]\nLEA RDX,[RAX*0x8]\nMOV RAX,qword ptr [RBP + -0x28]\nADD RDX,RAX\nMOV RAX,qword ptr [RBP + -0x10]\nSUB RAX,qword ptr [RBP + -0x8]\nMOV qword ptr [RDX],RAX\nADD qword ptr [RBP + -0x20],0x1\nMOV RAX,qword ptr [RBP + -0x20]\nCMP RAX,qword ptr [RBP + -0x40]\nJL 0x000012d5\nMOV RAX,qword ptr [RBP + -0x18]\nPOP RBP\nRET\n"}, "58": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  if ((*(uint *)((long)[VAR1] ->data + 8) & 4) == 0) {\n    iVar1 = 0x103c;\n  }\n  else {\n    *[VAR2] = *(size_t *)((long)[VAR1] ->data + 0x18);\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "mbox", "VAR2": "pcount", "VAR3": "imbx", "VAR4": "mbox-local", "VAR5": "pcount-local", "FUNC1": "_imap_messages_count", "TYPE3": "_mu_imap_mailbox *", "TYPE2": "size_t *", "TYPE5": "size_t *", "TYPE4": "mu_mailbox_t", "TYPE1": "mu_mailbox_t"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nMOV qword ptr [RBP + -0x18],RDI\nMOV qword ptr [RBP + -0x20],RSI\nMOV RAX,qword ptr [RBP + -0x18]\nMOV RAX,qword ptr [RAX + 0x60]\nMOV qword ptr [RBP + -0x8],RAX\nMOV RAX,qword ptr [RBP + -0x8]\nMOV EAX,dword ptr [RAX + 0x8]\nAND EAX,0x4\nTEST EAX,EAX\nJZ 0x00012d88\nMOV RAX,qword ptr [RBP + -0x8]\nMOV RDX,qword ptr [RAX + 0x18]\nMOV RAX,qword ptr [RBP + -0x20]\nMOV qword ptr [RAX],RDX\nMOV EAX,0x0\nJMP 0x00012d8d\nMOV EAX,0x103c\nPOP RBP\nRET\n"}, "59": {"funcbody": "undefined  [16] [FUNC1] (long param_1)\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  uint uVar4;\n  undefined4 uVar5;\n  undefined8 uVar6;\n  long lVar7;\n  ulong uVar8;\n  undefined auVar9 [16];\n  undefined8 uStack_28;\n  \n  lVar2 = *(long *)(param_1 + 0x20);\n  *(long *)(\"__isoc99_sscanf\" + lVar2 + 4) = param_1;\n  uVar4 = [FUNC2] (\"__isoc99_sscanf\" + lVar2 + 4,1,\"GLIBC_2.3.2\" + lVar2 + 0xb,lVar2 + 0x2cc50);\n  uVar8 = (ulong)uVar4;\n  if (uVar4 == 0) {\n    uVar6 = [FUNC9] ();\n    iVar1 = *(int *)(param_1 + 0x78);\n    *(undefined8 *)(\"shmat\" + lVar2 + 2) = uVar6;\n    lVar3 = *(long *)(\"GLIBC_2.2.5\" + lVar2 + 2);\n    *(long *)(\"ZLIB_1.2.0\" + lVar2 + 8) = lVar3;\n    uVar6 = [FUNC6] (iVar1 * lVar3);\n    iVar1 = *(int *)(param_1 + 0x78);\n    *(undefined8 *)(\"ZLIB_1.2.0.2\" + lVar2 + 5) = uVar6;\n    lVar7 = [FUNC6] ((long)iVar1 * *(long *)(\"ZLIB_1.2.0\" + lVar2 + 8));\n    lVar3 = *(long *)(\"ZLIB_1.2.0.2\" + lVar2 + 5);\n    *(long *)(\"ZLIB_1.2.0\" + lVar2) = lVar7;\n    if (((lVar3 == 0) || (lVar7 == 0)) || (*(long *)(\"shmat\" + lVar2 + 2) == 0)) {\n      uVar8 = 0xfffffff4;\n      [FUNC7] (param_1);\n    }\n    else {\n      lVar3 = *(long *)(param_1 + 0x20);\n      *(long *)(lVar3 + 0x1d8) = param_1;\n      [FUNC4] (lVar3);\n      *(undefined4 *)((long)&__DT_SYMTAB[0x18d].st_value + lVar3 + 4) = 0x1f;\n      *(undefined8 *)(&__DT_STRTAB + lVar3) = 0;\n      *(undefined4 *)(\"_ITM_deregisterTMCloneTable\" + lVar3 + 5) = 0;\n      *(undefined4 *)(\"posix_memalign\" + lVar3 + 5) = 0;\n      *(undefined8 *)((long)&__DT_SYMTAB[0x189].st_value + lVar3) = 0;\n      *(undefined **)(\"asin\" + lVar3 + 1) = &DAT_0126ef40;\n      *(undefined8 *)((long)&__DT_SYMTAB[0x189].st_size + lVar3) = 0;\n      *(undefined8 *)((long)&__DT_SYMTAB[0x18a].st_name + lVar3) = 1;\n      *(undefined4 *)((long)&__DT_SYMTAB[0x18a].st_value + lVar3) = 0;\n      *(undefined **)(\"atanf\" + lVar3 + 4) = &DAT_0126ef00;\n      *(undefined8 *)(&__DT_SYMTAB[0x18d].st_info + lVar3) = 0x700000001;\n      *(undefined8 *)(\"libm.so.6\" + lVar3 + 7) = 0x100000001;\n      *(undefined4 *)(param_1 + 0xa0) = 0;\n      *(undefined4 *)(lVar3 + 0x220) = 0;\n      *(undefined8 *)(\"_ITM_deregisterTMCloneTable\" + lVar3 + 9) = 0;\n      *(undefined4 *)((long)&__DT_SYMTAB[0x18a].st_value + lVar3 + 4) = 1;\n      [FUNC8] (lVar3);\n      uVar4 = [FUNC3] (param_1);\n      if ((int)uVar4 < 0) {\n        uVar8 = (ulong)uVar4;\n        [FUNC7] (param_1);\n      }\n      else {\n        [FUNC5] (\"GLIBC_2.6\" + lVar2 + 1);\n        uVar5 = 0x27;\n        if (*(int *)(\"GLIBC_2.17\" + lVar2 + 1) != 0x7f) {\n          uVar5 = 2;\n        }\n        *(undefined4 *)(param_1 + 0x88) = uVar5;\n      }\n    }\n  }\n  auVar9._8_8_ = uStack_28;\n  auVar9._0_8_ = uVar8;\n  return auVar9;\n}", "answer": {"FUNC2": "FUN_00153a03", "FUNC3": "FUN_0016590b", "FUNC1": "FUN_00153e2f", "FUNC6": "FUN_00fb8e00", "FUNC7": "FUN_00153de4", "FUNC4": "FUN_00165e42", "FUNC5": "FUN_0015400c", "FUNC8": "FUN_00165d76", "FUNC9": "FUN_00fad150"}, "assembly": "PUSH R13\nPUSH R12\nMOV R12,RDI\nPUSH RBP\nPUSH RBX\nMOV ESI,0x1\nSUB RSP,0x8\nMOV RBP,qword ptr [RDI + 0x20]\nMOV qword ptr [RBP + 0x3878],RDI\nLEA RCX,[RBP + 0x2cc50]\nLEA RDX,[RBP + 0x3d00]\nLEA RDI,[RBP + 0x3878]\nCALL 0x00153a03\nTEST EAX,EAX\nMOV R13D,EAX\nJNZ 0x00154001\nCALL 0x00fad150\nMOVSXD RDI,dword ptr [R12 + 0x78]\nMOV qword ptr [RBP + 0x3870],RAX\nMOV RAX,qword ptr [RBP + 0x3ca0]\nIMUL RDI,RAX\nMOV qword ptr [RBP + 0x3c90],RAX\nCALL 0x00fb8e00\nMOVSXD RDI,dword ptr [R12 + 0x78]\nMOV qword ptr [RBP + 0x3c80],RAX\nIMUL RDI,qword ptr [RBP + 0x3c90]\nCALL 0x00fb8e00\nCMP qword ptr [RBP + 0x3c80],0x0\nMOV qword ptr [RBP + 0x3c88],RAX\nJZ 0x00153ed2\nTEST RAX,RAX\nJZ 0x00153ed2\nCMP qword ptr [RBP + 0x3870],0x0\nJNZ 0x00153ee5\nMOV RDI,R12\nMOV R13D,0xfffffff4\nCALL 0x00153de4\nJMP 0x00154001\nMOV RBX,qword ptr [R12 + 0x20]\nMOV RDI,RBX\nMOV qword ptr [RBX + 0x1d8],R12\nCALL 0x00165e42\nLEA RAX,[0x126ef40]\nMOV dword ptr [RBX + 0x281c],0x1f\nMOV RDI,RBX\nMOV qword ptr [RBX + 0x2828],0x0\nMOV dword ptr [RBX + 0x2838],0x0\nMOV dword ptr [RBX + 0x3864],0x0\nMOV qword ptr [RBX + 0x27b8],0x0\nMOV qword ptr [RBX + 0x2968],RAX\nLEA RAX,[0x126ef00]\nMOV qword ptr [RBX + 0x27c0],0x0\nMOV qword ptr [RBX + 0x27c8],0x1\nMOV dword ptr [RBX + 0x27d0],0x0\nMOV qword ptr [RBX + 0x2970],RAX\nMOV RAX,0x700000001\nMOV qword ptr [RBX + 0x2814],RAX\nMOV RAX,0x100000001\nMOV qword ptr [RBX + 0x2830],RAX\nMOV dword ptr [R12 + 0xa0],0x0\nMOV dword ptr [RBX + 0x220],0x0\nMOV qword ptr [RBX + 0x283c],0x0\nMOV dword ptr [RBX + 0x27d4],0x1\nCALL 0x00165d76\nMOV RDI,R12\nCALL 0x0016590b\nTEST EAX,EAX\nMOV EBX,EAX\nJNS 0x00153fd9\nMOV RDI,R12\nMOV R13D,EBX\nCALL 0x00153de4\nJMP 0x00154001\nLEA RDI,[RBP + 0x3ce0]\nCALL 0x0015400c\nCMP dword ptr [RBP + 0x3cc0],0x7f\nMOV EAX,0x27\nMOV EDX,0x2\nCMOVNZ EAX,EDX\nMOV dword ptr [R12 + 0x88],EAX\nPOP RDX\nMOV EAX,R13D\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\n"}, "60": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  OSSL_PARAM *pOVar2;\n  [TYPE4] [VAR4] ;\n  TYPE35 [VAR3] ;\n  \n  pOVar2 = [FUNC2] ([VAR2] ,\"encoded-pub-key\");\n  [VAR4] ._0_4_ = 1;\n  if ((pOVar2 != (OSSL_PARAM *)0x0) && ([VAR4] ._0_4_ = 0, pOVar2->data_type == 5)) {\n    iVar1 = [FUNC3] ((DH *)[VAR1] ,(uchar *)pOVar2->data,pOVar2->data_size);\n    [VAR4] ._0_4_ = (uint)(iVar1 != 0);\n  }\n  return (uint)[VAR4] ;\n}", "answer": {"VAR1": "key", "VAR2": "params", "VAR3": "dh", "VAR4": "p", "FUNC2": "OSSL_PARAM_locate_const", "FUNC3": "ossl_dh_buf2key", "FUNC1": "dh_set_params", "TYPE3": "DH *", "TYPE2": "OSSL_PARAM *", "TYPE4": "OSSL_PARAM *", "TYPE1": "void *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nMOV RDI,RSI\nLEA RSI,[0x25f9e4]\nCALL 0x0009b60e\nMOV RCX,RAX\nMOV EAX,0x1\nTEST RCX,RCX\nJZ 0x000f0f82\nMOV EAX,0x0\nCMP dword ptr [RCX + 0x8],0x5\nJZ 0x000f0f84\nPOP RBX\nRET\nMOV RDX,qword ptr [RCX + 0x18]\nMOV RSI,qword ptr [RCX + 0x10]\nMOV RDI,RBX\nCALL 0x00148d92\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x000f0f82\n"}, "61": {"funcbody": "MagickBooleanType [FUNC1] ([TYPE1] [VAR1] )\n{\n  if ([VAR1] == (TYPE10x0) {\n    [FUNC2] (\"magick_info != (MagickInfo *) NULL\",\"MagickCore/magick.c\",0x3ec,\"GetMagickStealth\");\n  }\n  if ([VAR1] ->signature == 0xabacadab) {\n    return [VAR1] ->flags >> 7 & 1;\n  }\n  [FUNC2] (\"magick_info->signature == MagickCoreSignature\",\"MagickCore/magick.c\",0x3ed,\n        \"GetMagickStealth\");\n}", "answer": {"VAR1": "magick_info", "FUNC2": "__assert_fail", "FUNC1": "GetMagickStealth", "TYPE1": "MagickInfo *"}, "assembly": "SUB RSP,0x8\nTEST RDI,RDI\nJZ 0x00130562\nMOV EAX,0xabacadab\nCMP qword ptr [RDI + 0x60],RAX\nJNZ 0x00130581\nMOV EAX,dword ptr [RDI + 0x54]\nSHR EAX,0x7\nAND EAX,0x1\nADD RSP,0x8\nRET\nLEA RCX,[0x323070]\nMOV EDX,0x3ec\nLEA RSI,[0x322ebf]\nLEA RDI,[0x30d158]\nCALL 0x0004a360\nLEA RCX,[0x323070]\nMOV EDX,0x3ed\nLEA RSI,[0x322ebf]\nLEA RDI,[0x30d180]\nCALL 0x0004a360\n"}, "62": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  CRYPTO_RWLOCK **ptr;\n  TYPE24 [VAR2] ;\n  CRYPTO_RWLOCK *pCVar1;\n  \n  ptr = (CRYPTO_RWLOCK **)[FUNC4] (0x10,\"providers/implementations/rands/drbg.c\",0x117);\n  if (ptr == (CRYPTO_RWLOCK **)0x0) {\n    ptr = (CRYPTO_RWLOCK **)0x0;\n  }\n  else {\n    pCVar1 = [FUNC2] ();\n    *ptr = pCVar1;\n    if (pCVar1 == (CRYPTO_RWLOCK *)0x0) {\n      [FUNC3] (ptr);\n      ptr = (CRYPTO_RWLOCK **)0x0;\n    }\n  }\n  return ptr;\n}", "answer": {"VAR1": "libctx", "VAR2": "dngbl", "FUNC2": "CRYPTO_THREAD_lock_new", "FUNC3": "FUNC1", "FUNC1": "prov_drbg_nonce_ossl_ctx_new", "TYPE2": "PROV_DRBG_NONCE_GLOBAL *", "FUNC4": "CRYPTO_zalloc", "TYPE1": "OSSL_LIB_CTX *"}, "assembly": "PUSH RBX\nMOV EDX,0x117\nLEA RSI,[0x2b8c18]\nMOV EDI,0x10\nCALL 0x000b93e3\nTEST RAX,RAX\nJZ 0x002279ed\nMOV RBX,RAX\nCALL 0x000c0126\nMOV qword ptr [RBX],RAX\nTEST RAX,RAX\nJZ 0x002279d2\nMOV RAX,RBX\nPOP RBX\nRET\nMOV EDX,0x11e\nLEA RSI,[0x2b8c18]\nMOV RDI,RBX\nCALL 0x000b930b\nMOV EBX,0x0\nJMP 0x002279cd\nMOV EBX,0x0\nJMP 0x002279cd\n"}, "63": {"funcbody": "uint [FUNC1] (void)\n{\n  uint uVar1;\n  \n  uVar1 = 0;\n  if ((DAT_0057a434._4_4_ & 0x80230000) == 0x80230000) {\n    uVar1 = DAT_0057a434._4_4_ & 0x80230000;\n  }\n  return uVar1;\n}", "answer": {"FUNC1": "ossl_rsaz_avx512ifma_eligible"}, "assembly": "MOV ECX,dword ptr [0x0057a438]\nXOR EAX,EAX\nAND ECX,0x80230000\nCMP ECX,0x80230000\nCMOVZ EAX,ECX\nRET\n"}, "64": {"funcbody": "void [FUNC5] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n          [TYPE5] [VAR5] )\n{\n  int n2;\n  [TYPE6] [VAR6] ;\n  ulong *puVar1;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  \n  n2 = [VAR4] / 2;\n  [FUNC4] ([VAR1] ,[VAR2] ,[VAR3] ,n2,0,0,[VAR5] );\n  if (n2 < 0x20) {\n    [FUNC2] ([VAR5] ,[VAR2] ,[VAR3] + n2,n2);\n    [FUNC2] ([VAR5] + n2,[VAR2] + n2,[VAR3] ,n2);\n    puVar1 = [VAR1] + n2;\n    [FUNC3] (puVar1,puVar1,[VAR5] ,n2);\n    [FUNC3] (puVar1,puVar1,[VAR5] + n2,n2);\n  }\n  else {\n    [FUNC5] ([VAR5] ,[VAR2] ,[VAR3] + n2,n2,[VAR5] + [VAR4] );\n    puVar1 = [VAR1] + n2;\n    [FUNC3] (puVar1,puVar1,[VAR5] ,n2);\n    [FUNC5] ([VAR5] ,[VAR2] + n2,[VAR3] ,n2,[VAR5] + [VAR4] );\n    [FUNC3] (puVar1,puVar1,[VAR5] ,n2);\n  }\n  return;\n}", "answer": {"VAR1": "r", "VAR2": "a", "VAR3": "b", "VAR4": "n2", "VAR5": "t", "VAR6": "n", "FUNC2": "bn_mul_low_normal", "FUNC3": "bn_add_words", "FUNC1": "bn_mul_low_recursive", "TYPE3": "ulong *", "TYPE2": "ulong *", "FUNC4": "FUNC1", "TYPE5": "ulong *", "FUNC5": "FUNC1", "TYPE4": "int", "TYPE7": "undefined8", "TYPE6": "int", "TYPE8": "undefined8", "VAR7": "local_40", "VAR8": "local_48", "TYPE1": "ulong *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x20\nMOV qword ptr [RSP + 0x8],RDI\nMOV RBP,RSI\nMOV R14,RDX\nMOV R12D,ECX\nMOV R13,R8\nMOV EBX,ECX\nSHR EBX,0x1f\nADD EBX,ECX\nSAR EBX,0x1\nPUSH R8\nMOV R9D,0x0\nMOV R8D,0x0\nMOV ECX,EBX\nCALL 0x0007d69a\nADD RSP,0x10\nCMP EBX,0x1f\nJG 0x0007e6d8\nMOVSXD R12,EBX\nSHL R12,0x3\nLEA RDX,[R14 + R12*0x1]\nMOV ECX,EBX\nMOV RSI,RBP\nMOV RDI,R13\nCALL 0x0007e544\nLEA R15,[R13 + R12*0x1]\nLEA RSI,[RBP + R12*0x1]\nMOV ECX,EBX\nMOV RDX,R14\nMOV RDI,R15\nCALL 0x0007e544\nADD R12,qword ptr [RSP]\nMOV ECX,EBX\nMOV RDX,R13\nMOV RSI,R12\nMOV RDI,R12\nCALL 0x00131b34\nMOV ECX,EBX\nMOV RDX,R15\nMOV RSI,R12\nMOV RDI,R12\nCALL 0x00131b34\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOVSXD R12,R12D\nLEA RAX,[R13 + R12*0x8]\nMOVSXD RSI,EBX\nLEA R15,[RSI*0x8]\nLEA RDX,[R14 + R15*0x1]\nMOV qword ptr [RSP + 0x8],RAX\nMOV R8,RAX\nMOV ECX,EBX\nMOV RSI,RBP\nMOV RDI,R13\nCALL 0x0007e630\nMOV R12,qword ptr [RSP]\nADD R12,R15\nMOV ECX,EBX\nMOV RDX,R13\nMOV RSI,R12\nMOV RDI,R12\nCALL 0x00131b34\nLEA RSI,[RBP + R15*0x1]\nMOV R8,qword ptr [RSP + 0x8]\nMOV ECX,EBX\nMOV RDX,R14\nMOV RDI,R13\nCALL 0x0007e630\nMOV ECX,EBX\nMOV RDX,R13\nMOV RSI,R12\nMOV RDI,R12\nCALL 0x00131b34\nJMP 0x0007e6c9\n"}, "65": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  ulong uVar1;\n  [TYPE2] [VAR2] ;\n  int iVar2;\n  [TYPE3] [VAR3] ;\n  ulong *puVar3;\n  \n  iVar2 = [VAR1] ->top;\n  if (0 < iVar2) {\n    puVar3 = [VAR1] ->d + (long)iVar2 + -1;\n    uVar1 = [VAR1] ->d[(long)iVar2 + -1];\n    while ((uVar1 == 0 && (iVar2 = iVar2 + -1, iVar2 != 0))) {\n      puVar3 = puVar3 + -1;\n      uVar1 = *puVar3;\n    }\n    [VAR1] ->top = iVar2;\n  }\n  if ([VAR1] ->top == 0) {\n    [VAR1] ->neg = 0;\n  }\n  return;\n}", "answer": {"VAR1": "a", "VAR2": "tmp_top", "VAR3": "ftl", "FUNC1": "bn_correct_top", "TYPE3": "ulong *", "TYPE2": "int", "TYPE1": "BIGNUM *"}, "assembly": "MOV EAX,dword ptr [RDI + 0x8]\nTEST EAX,EAX\nJLE 0x00078223\nMOVSXD RDX,EAX\nMOV RCX,qword ptr [RDI]\nLEA RCX,[RCX + RDX*0x8]\nLEA RDX,[RCX + -0x8]\nCMP qword ptr [RCX + -0x8],0x0\nJNZ 0x00078220\nSUB EAX,0x1\nJZ 0x00078220\nSUB RDX,0x8\nCMP qword ptr [RDX],0x0\nJZ 0x00078211\nMOV dword ptr [RDI + 0x8],EAX\nCMP dword ptr [RDI + 0x8],0x0\nJNZ 0x00078230\nMOV dword ptr [RDI + 0x10],0x0\nRET\n"}, "66": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  char *pcVar1;\n  \n  if (json_unescape::transtab[0] == '\\0') {\n    return -1;\n  }\n  if ([VAR1] == json_unescape::transtab[0]) {\n    pcVar1 = json_unescape::transtab;\n  }\n  else {\n    pcVar1 = json_unescape::transtab;\n    do {\n      pcVar1 = pcVar1 + 2;\n      if (*pcVar1 == '\\0') {\n        return -1;\n      }\n    } while (*pcVar1 != [VAR1] );\n  }\n  *[VAR2] = pcVar1[1];\n  return 0;\n}", "answer": {"VAR1": "c", "VAR2": "o", "FUNC1": "json_unescape", "TYPE2": "char *", "TYPE1": "char"}, "assembly": "MOV ECX,EDI\nMOVZX EDX,byte ptr [0x00232008]\nMOV EAX,0xffffffff\nTEST DL,DL\nJZ 0x00018d0b\nCMP DIL,DL\nJZ 0x00018cfd\nLEA RAX,[0x232008]\nADD RAX,0x2\nMOVZX EDX,byte ptr [RAX]\nTEST DL,DL\nJZ 0x00018d06\nCMP DL,CL\nJNZ 0x00018ce2\nMOVZX EAX,byte ptr [RAX + 0x1]\nMOV byte ptr [RSI],AL\nMOV EAX,0x0\nRET\nLEA RAX,[0x232008]\nJMP 0x00018cf1\nMOV EAX,0xffffffff\nRET\n"}, "67": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  uint uVar1;\n  int iVar2;\n  \n  uVar1 = [FUNC3] ();\n  if (uVar1 != 0) {\n    uVar1 = [FUNC2] ((SHA_CTX *)[VAR1] );\n    if (uVar1 != 0) {\n      iVar2 = [FUNC4] ([VAR1] ,[VAR2] );\n      uVar1 = (uint)(iVar2 != 0);\n    }\n  }\n  return uVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "params", "FUNC2": "SHA1_Init", "FUNC3": "ossl_prov_is_running", "FUNC1": "sha1_internal_init", "TYPE2": "OSSL_PARAM *", "FUNC4": "sha1_set_ctx_params", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RSI\nCALL 0x000cb83f\nTEST EAX,EAX\nJNZ 0x000e00b0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RDI,RBX\nCALL 0x001dc617\nTEST EAX,EAX\nJZ 0x000e00a9\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x000e003c\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x000e00a9\n"}, "68": {"funcbody": "ngx_listening_t * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  sa_family_t sVar1;\n  long lVar2;\n  ngx_listening_t *pnVar3;\n  [TYPE4] [VAR4] ;\n  sockaddr *sa;\n  [TYPE5] [VAR5] ;\n  size_t size;\n  [TYPE6] [VAR6] ;\n  u_char *__dest;\n  ulong uVar4;\n  undefined8 *puVar5;\n  long in_FS_OFFSET;\n  byte bVar6;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  \n  bVar6 = 0;\n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  pnVar3 = (ngx_listening_t *)[FUNC2] (&[VAR1] ->cycle->listening);\n  if (pnVar3 != (ngx_listening_t *)0x0) {\n    *(undefined8 *)pnVar3 = 0;\n    *(undefined8 *)&pnVar3->field_0x120 = 0;\n    puVar5 = (undefined8 *)((ulong)&pnVar3->sockaddr & 0xfffffffffffffff8);\n    uVar4 = (ulong)(((int)pnVar3 - (int)puVar5) + 0x128U >> 3);\n    for (; uVar4 != 0; uVar4 = uVar4 - 1) {\n      *puVar5 = 0;\n      puVar5 = puVar5 + (ulong)bVar6 * -2 + 1;\n    }\n    sa = (sockaddr *)[FUNC3] ([VAR1] ->pool,(ulong)[VAR3] );\n    if (sa == (sockaddr *)0x0) {\n      pnVar3 = (ngx_listening_t *)0x0;\n    }\n    else {\n      [FUNC8] (sa,[VAR2] ,(ulong)[VAR3] );\n      pnVar3->sockaddr = sa;\n      pnVar3->socklen = [VAR3] ;\n      size = [FUNC5] (sa,[VAR3] ,[VAR8] ,0x71,1);\n      (pnVar3->addr_text).len = size;\n      sVar1 = pnVar3->sockaddr->sa_family;\n      if (sVar1 == 2) {\n        pnVar3->addr_text_max_len = 0xf;\n      }\n      else if (sVar1 == 10) {\n        pnVar3->addr_text_max_len = 0x2d;\n      }\n      else if (sVar1 == 1) {\n        pnVar3->addr_text_max_len = 0x71;\n        size = size + 1;\n      }\n      else {\n        pnVar3->addr_text_max_len = 0x71;\n      }\n      __dest = (u_char *)[FUNC4] ([VAR1] ->pool,size);\n      (pnVar3->addr_text).data = __dest;\n      if (__dest == (u_char *)0x0) {\n        pnVar3 = (ngx_listening_t *)0x0;\n      }\n      else {\n        [FUNC8] (__dest,[VAR8] ,size);\n        (pnVar3->sentinel).color = '\\0';\n        (pnVar3->rbtree).root = &pnVar3->sentinel;\n        (pnVar3->rbtree).sentinel = &pnVar3->sentinel;\n        (pnVar3->rbtree).insert = [FUNC7] ;\n        pnVar3->fd = -1;\n        pnVar3->type = 1;\n        pnVar3->backlog = 0x1ff;\n        pnVar3->rcvbuf = -1;\n        pnVar3->sndbuf = -1;\n        pnVar3->fastopen = -1;\n      }\n    }\n  }\n  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pnVar3;\n  }\n  [FUNC6] ();\n}", "answer": {"VAR1": "cf", "VAR2": "sockaddr", "VAR3": "socklen", "VAR4": "ls", "VAR5": "sa", "VAR6": "len", "FUNC2": "ngx_array_push", "FUNC3": "ngx_palloc", "FUNC1": "ngx_create_listening", "FUNC6": "__stack_chk_fail", "TYPE3": "socklen_t", "FUNC7": "ngx_udp_rbtree_insert_value", "TYPE2": "sockaddr *", "FUNC4": "ngx_pnalloc", "TYPE5": "sockaddr *", "FUNC5": "ngx_sock_ntop", "TYPE4": "ngx_listening_t *", "TYPE7": "undefined8", "TYPE6": "size_t", "FUNC8": "memcpy", "TYPE8": "u_char[113]", "VAR7": "local_40", "VAR8": "text", "TYPE1": "ngx_conf_t *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x88\nMOV RBP,RDI\nMOV R13,RSI\nMOV R12D,EDX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x78],RAX\nXOR EAX,EAX\nMOV RAX,qword ptr [RDI + 0x10]\nLEA RDI,[RAX + 0xc0]\nCALL 0x0001bd22\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000292cc\nMOV qword ptr [RAX],0x0\nMOV qword ptr [RAX + 0x120],0x0\nLEA RDI,[RAX + 0x8]\nAND RDI,-0x8\nMOV RCX,RAX\nSUB RCX,RDI\nADD ECX,0x128\nSHR ECX,0x3\nMOV ECX,ECX\nMOV EAX,0x0\nSTOSQ.REP RDI\nMOV R15D,R12D\nMOV RDI,qword ptr [RBP + 0x18]\nMOV RSI,R15\nCALL 0x0001b9e7\nMOV R14,RAX\nTEST RAX,RAX\nJZ 0x0002930f\nMOV RDX,R15\nMOV RSI,R13\nMOV RDI,RAX\nCALL 0x00018210\nMOV qword ptr [RBX + 0x8],R14\nMOV dword ptr [RBX + 0x10],R12D\nMOV RDX,RSP\nMOV R8D,0x1\nMOV ECX,0x71\nMOV ESI,R12D\nMOV RDI,R14\nCALL 0x00021ae8\nMOV R12,RAX\nMOV qword ptr [RBX + 0x20],RAX\nMOV RAX,qword ptr [RBX + 0x8]\nMOVZX EAX,word ptr [RAX]\nCMP AX,0x2\nJZ 0x00029302\nCMP AX,0xa\nJZ 0x00029247\nCMP AX,0x1\nJZ 0x000292f1\nMOV qword ptr [RBX + 0x18],0x71\nJMP 0x0002924f\nMOV qword ptr [RBX + 0x18],0x2d\nMOV RDI,qword ptr [RBP + 0x18]\nMOV RSI,R12\nCALL 0x0001ba31\nMOV qword ptr [RBX + 0x28],RAX\nTEST RAX,RAX\nJZ 0x00029316\nMOV RSI,RSP\nMOV RDX,R12\nMOV RDI,RAX\nCALL 0x00018210\nMOV byte ptr [RBX + 0x110],0x0\nLEA RAX,[RBX + 0xf0]\nMOV qword ptr [RBX + 0xd8],RAX\nMOV qword ptr [RBX + 0xe0],RAX\nLEA RAX,[0x3b950]\nMOV qword ptr [RBX + 0xe8],RAX\nMOV dword ptr [RBX],0xffffffff\nMOV dword ptr [RBX + 0x30],0x1\nMOV dword ptr [RBX + 0x34],0x1ff\nMOV dword ptr [RBX + 0x38],0xffffffff\nMOV dword ptr [RBX + 0x3c],0xffffffff\nMOV dword ptr [RBX + 0x124],0xffffffff\nMOV RAX,RBX\nMOV RDX,qword ptr [RSP + 0x78]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x0002931d\nADD RSP,0x88\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV qword ptr [RBX + 0x18],0x71\nADD R12,0x1\nJMP 0x0002924f\nMOV qword ptr [RBX + 0x18],0xf\nJMP 0x0002924f\nMOV EBX,0x0\nJMP 0x000292cc\nMOV EBX,0x0\nJMP 0x000292cc\nCALL 0x00017f50\n"}, "69": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  code *pcVar1;\n  int iVar2;\n  void *key;\n  TYPE54 [VAR5] ;\n  \n  key = [FUNC2] ([VAR1] );\n  pcVar1 = *(code **)((long)key + 0x100);\n  if (pcVar1 == (code *)0x0) {\n    iVar2 = [FUNC5] ([VAR1] );\n    if (iVar2 == 0) {\n      [FUNC4] ([VAR3] ,[VAR2] ,[VAR4] ,key,[VAR1] ->iv,*(block128_f *)((long)key + 0xf8));\n    }\n    else {\n      [FUNC3] ([VAR3] ,[VAR2] ,[VAR4] ,key,[VAR1] ->iv,*(block128_f *)((long)key + 0xf8));\n    }\n  }\n  else {\n    iVar2 = [FUNC5] ([VAR1] );\n    (*pcVar1)([VAR3] ,[VAR2] ,[VAR4] ,key,[VAR1] ->iv,iVar2);\n  }\n  return 1;\n}", "answer": {"VAR1": "ctx", "VAR2": "out", "VAR3": "in", "VAR4": "len", "VAR5": "dat", "FUNC2": "EVP_CIPHER_CTX_get_cipher_data", "FUNC3": "CRYPTO_cbc128_encrypt", "FUNC1": "aes_cbc_cipher", "TYPE3": "uchar *", "TYPE2": "uchar *", "FUNC4": "CRYPTO_cbc128_decrypt", "TYPE5": "EVP_AES_KEY *", "FUNC5": "EVP_CIPHER_CTX_is_encrypting", "TYPE4": "size_t", "TYPE1": "EVP_CIPHER_CTX *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV R14,RSI\nMOV R13,RDX\nMOV R15,RCX\nCALL 0x000ba4fc\nMOV RBP,RAX\nMOV R12,qword ptr [RAX + 0x100]\nTEST R12,R12\nJZ 0x001cf0ad\nMOV RDI,RBX\nCALL 0x000ba4e9\nMOV R9D,EAX\nLEA R8,[RBX + 0x28]\nMOV RCX,RBP\nMOV RDX,R15\nMOV RSI,R14\nMOV RDI,R13\nCALL R12\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV RDI,RBX\nCALL 0x000ba4e9\nTEST EAX,EAX\nJNZ 0x001cf0d7\nMOV R9,qword ptr [RBP + 0xf8]\nLEA R8,[RBX + 0x28]\nMOV RCX,RBP\nMOV RDX,R15\nMOV RSI,R14\nMOV RDI,R13\nCALL 0x001f404d\nJMP 0x001cf099\nMOV R9,qword ptr [RBP + 0xf8]\nLEA R8,[RBX + 0x28]\nMOV RCX,RBP\nMOV RDX,R15\nMOV RSI,R14\nMOV RDI,R13\nCALL 0x001f3f00\nJMP 0x001cf099\n"}, "70": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  void *vmacctx;\n  TYPE33 [VAR3] ;\n  TYPE20 [VAR2] ;\n  \n  iVar1 = [FUNC4] ();\n  if ((iVar1 != 0) && (vmacctx = [FUNC6] (*[VAR1] ), vmacctx != (void *)0x0)) {\n    iVar1 = [FUNC3] (*(EVP_CIPHER_CTX **)((long)vmacctx + 8),*(EVP_CIPHER_CTX **)((long)[VAR1] + 8));\n    if ((iVar1 != 0) &&\n       (iVar1 = [FUNC5] ((PROV_CIPHER *)((long)vmacctx + 0x10),(PROV_CIPHER *)((long)[VAR1] + 0x10)),\n       iVar1 != 0)) {\n      return vmacctx;\n    }\n    [FUNC2] (vmacctx);\n  }\n  return (void *)0x0;\n}", "answer": {"VAR1": "vsrc", "VAR2": "src", "VAR3": "dst", "FUNC2": "gmac_free", "FUNC3": "EVP_CIPHER_CTX_copy", "FUNC1": "gmac_dup", "FUNC6": "gmac_new", "TYPE3": "gmac_data_st *", "TYPE2": "gmac_data_st *", "FUNC4": "ossl_prov_is_running", "FUNC5": "ossl_prov_cipher_copy", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nCALL 0x000c3c98\nTEST EAX,EAX\nJZ 0x000f8636\nMOV RDI,qword ptr [RBX]\nCALL 0x000f8578\nMOV RBP,RAX\nTEST RAX,RAX\nJZ 0x000f863d\nMOV RSI,qword ptr [RBX + 0x8]\nMOV RDI,qword ptr [RAX + 0x8]\nCALL 0x0008601b\nTEST EAX,EAX\nJZ 0x000f8627\nLEA RSI,[RBX + 0x10]\nLEA RDI,[RBP + 0x10]\nCALL 0x000c46cf\nTEST EAX,EAX\nJZ 0x000f8627\nMOV RAX,RBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RDI,RBP\nCALL 0x000f8545\nMOV EBP,0x0\nJMP 0x000f861d\nMOV EBP,0x0\nJMP 0x000f861d\nMOV EBP,0x0\nJMP 0x000f861d\n"}, "71": {"funcbody": "void [FUNC1] (TYPE17 [VAR1] ,TYPE26 [VAR2] )\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  TYPE46 [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR4] .func = [VAR2] ;\n  if ([VAR1] != (TYPE17)0x0) {\n    [FUNC2] ([VAR1] ,(_func_void_void_ptr_ptr *)0x0,[FUNC4] ,&[VAR4] );\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "sa", "VAR2": "leaf", "VAR3": "local_10", "VAR4": "tramp", "FUNC2": "sa_doall", "FUNC3": "__stack_chk_fail", "FUNC1": "ossl_sa_doall", "TYPE3": "undefined8", "TYPE2": "_func_void_ossl_uintmax_t_void_ptr *", "FUNC4": "trampoline", "TYPE4": "trampoline_st", "TYPE1": "OPENSSL_SA *"}, "assembly": "SUB RSP,0x18\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],RSI\nTEST RDI,RDI\nJZ 0x001a8f9d\nMOV RCX,RSP\nLEA RDX,[0x1a8ea2]\nMOV ESI,0x0\nCALL 0x001a8daf\nMOV RAX,qword ptr [RSP + 0x8]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x001a8fb2\nADD RSP,0x18\nRET\nCALL 0x000627e0\n"}, "72": {"funcbody": "_Bool [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  [TYPE2] pzVar1;\n  _Bool _Var2;\n  zend_string **ppzVar3;\n  zend_string **ppzVar4;\n  \n  if ((*(byte *)&[VAR2] ->ce_flags & 1) == 0) {\n    while ([VAR1] = ([VAR1] ->field_2).parent, [VAR2] != [VAR1] ) {\n      if ([VAR1] == ([TYPE2] )0x0) {\n        return false;\n      }\n    }\n    _Var2 = true;\n  }\n  else {\n    _Var2 = false;\n    if ([VAR1] ->num_interfaces != 0) {\n      if (([TYPE2] )(([VAR1] ->field_39).interface_names)->name == [VAR2] ) {\n        return true;\n      }\n      ppzVar3 = &(([VAR1] ->field_39).interface_names)->lc_name;\n      ppzVar4 = ppzVar3;\n      do {\n        if (ppzVar4 == ppzVar3 + ([VAR1] ->num_interfaces - 1)) {\n          return false;\n        }\n        pzVar1 = ([TYPE2] )*ppzVar4;\n        ppzVar4 = ppzVar4 + 1;\n      } while (pzVar1 != [VAR2] );\n      return true;\n    }\n  }\n  return _Var2;\n}", "answer": {"VAR1": "instance_ce", "VAR2": "ce", "FUNC1": "instanceof_function_slow", "TYPE2": "zend_class_entry *", "TYPE1": "zend_class_entry *"}, "assembly": "TEST byte ptr [RSI + 0x1c],0x1\nJZ 0x0039e4d6\nMOV EDX,dword ptr [RDI + 0x1a8]\nMOV EAX,0x0\nTEST EDX,EDX\nJZ 0x0039e4f5\nMOV RAX,qword ptr [RDI + 0x1b0]\nCMP qword ptr [RAX],RSI\nJZ 0x0039e4ea\nADD RAX,0x8\nLEA EDX,[RDX + -0x1]\nLEA RDX,[RAX + RDX*0x8]\nCMP RAX,RDX\nJZ 0x0039e4d0\nADD RAX,0x8\nCMP qword ptr [RAX + -0x8],RSI\nJNZ 0x0039e4bb\nMOV EAX,0x1\nRET\nMOV EAX,0x0\nRET\nMOV RDI,qword ptr [RDI + 0x10]\nCMP RSI,RDI\nJZ 0x0039e4f0\nTEST RDI,RDI\nJNZ 0x0039e4d6\nMOV EAX,0x0\nRET\nMOV EAX,0x1\nRET\nMOV EAX,0x1\nRET\n"}, "73": {"funcbody": "void [FUNC2] ([TYPE1] [VAR1] )\n{\n  int in_EDX;\n  char *in_RSI;\n  \n  if (free_impl == (CRYPTO_free_fn)PTR_[FUNC2] _00581f40) {\n    [FUNC3] ([VAR1] );\n  }\n  else {\n    (*free_impl)([VAR1] ,in_RSI,in_EDX);\n  }\n  return;\n}", "answer": {"VAR1": "ptr", "FUNC2": "FUNC1", "FUNC3": "free", "FUNC1": "CRYPTO_free", "TYPE1": "void *"}, "assembly": "SUB RSP,0x8\nMOV RAX,qword ptr [0x00582680]\nCMP RAX,qword ptr [0x00581f40]\nJZ 0x000b140d\nCALL RAX\nADD RSP,0x8\nRET\nCALL 0x00065410\nJMP 0x000b1408\n"}, "74": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,...)\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  [TYPE3] [VAR3] ;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  [TYPE18] [VAR18] ;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  undefined8 [VAR15] ;\n  undefined8 [VAR14] ;\n  undefined8 [VAR13] ;\n  undefined8 [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  if (in_AL != '\\0') {\n    [VAR11] ._0_4_ = in_XMM0_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR18] [0].gp_offset = 0x10;\n  [VAR18] [0].fp_offset = 0x30;\n  [VAR18] [0].overflow_arg_area = &stack0x00000008;\n  [VAR18] [0].reg_save_area = &[VAR16] ;\n  [VAR15] = in_RDX;\n  [VAR14] = in_RCX;\n  [VAR13] = in_R8;\n  [VAR12] = in_R9;\n  iVar2 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR18] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC3] ();\n}", "answer": {"TYPE17": "undefined8", "TYPE18": "va_list", "VAR1": "resultp", "VAR2": "format", "VAR3": "result", "VAR4": "local_18", "VAR5": "local_28", "VAR6": "local_38", "FUNC2": "u16_u16_vasprintf", "FUNC3": "__stack_chk_fail", "FUNC1": "u16_u16_asprintf", "TYPE3": "int", "VAR14": "local_a0", "TYPE2": "uint16_t *", "VAR15": "local_a8", "TYPE5": "undefined1[16]", "VAR12": "local_90", "TYPE4": "undefined1[16]", "VAR13": "local_98", "TYPE7": "undefined1[16]", "VAR18": "args", "TYPE6": "undefined1[16]", "TYPE9": "undefined1[16]", "VAR16": "local_b8", "TYPE8": "undefined1[16]", "VAR17": "local_c0", "VAR7": "local_48", "TYPE11": "undefined1[16]", "VAR8": "local_58", "TYPE12": "undefined8", "VAR9": "local_68", "TYPE10": "undefined1[16]", "VAR10": "local_78", "TYPE15": "undefined8", "VAR11": "local_88", "TYPE16": "undefined1", "TYPE1": "uint16_t * *", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "SUB RSP,0xd8\nMOV qword ptr [RSP + 0x30],RDX\nMOV qword ptr [RSP + 0x38],RCX\nMOV qword ptr [RSP + 0x40],R8\nMOV qword ptr [RSP + 0x48],R9\nTEST AL,AL\nJZ 0x000287c8\nMOVAPS xmmword ptr [RSP + 0x50],XMM0\nMOVAPS xmmword ptr [RSP + 0x60],XMM1\nMOVAPS xmmword ptr [RSP + 0x70],XMM2\nMOVAPS xmmword ptr [RSP + 0x80],XMM3\nMOVAPS xmmword ptr [RSP + 0x90],XMM4\nMOVAPS xmmword ptr [RSP + 0xa0],XMM5\nMOVAPS xmmword ptr [RSP + 0xb0],XMM6\nMOVAPS xmmword ptr [RSP + 0xc0],XMM7\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0x10\nMOV dword ptr [RSP + 0x4],0x30\nLEA RAX,[RSP + 0xe0]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nMOV RDX,RSP\nCALL 0x000120c0\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0002881e\nADD RSP,0xd8\nRET\nCALL 0x00011890\n"}, "75": {"funcbody": "undefined  [16]\n[FUNC1] (undefined [VAR1] ,undefined [VAR2] ,undefined [VAR3] ,undefined [VAR4] ,undefined [VAR5] ,undefined [VAR6] ,\n     uint [VAR7] )\n{\n  undefined auVar1 [16];\n  undefined7 in_register_00000009;\n  undefined7 in_register_00000011;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  undefined7 in_register_00000031;\n  undefined7 in_register_00000039;\n  undefined7 in_register_00000081;\n  undefined7 in_register_00000089;\n  undefined8 uStack_50;\n  [TYPE8] [VAR8] ;\n  \n  lVar2 = CONCAT71(in_register_00000039,[VAR1] );\n  lVar4 = CONCAT71(in_register_00000031,[VAR2] );\n  do {\n    auVar1._4_4_ = 0;\n    auVar1._0_4_ = [VAR7] ;\n    lVar3 = lVar2 + 0x10;\n    [FUNC2] (lVar2,lVar4,CONCAT71(in_register_00000011,[VAR3] ),\n          CONCAT71(in_register_00000009,[VAR4] ) & 0xffffffff,CONCAT71(in_register_00000081,[VAR5] ),\n          CONCAT71(in_register_00000089,[VAR6] ));\n    auVar1._8_8_ = uStack_50;\n    lVar2 = lVar3;\n    lVar4 = lVar4 + 0x10;\n  } while (CONCAT71(in_register_00000039,[VAR1] ) + 0x80 != lVar3);\n  return auVar1;\n}", "answer": {"VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "VAR5": "param_5", "VAR6": "param_6", "FUNC2": "FUN_00ea6750", "FUNC1": "FUN_00bc2740", "TYPE3": "undefined", "TYPE2": "undefined", "TYPE5": "undefined", "TYPE4": "undefined", "TYPE7": "undefined4", "TYPE6": "undefined", "TYPE8": "undefined8", "VAR7": "param_7", "VAR8": "local_40", "TYPE1": "undefined"}, "assembly": "PUSH R15\nPUSH R14\nLEA RAX,[RDI + 0x80]\nPUSH R13\nPUSH R12\nMOV R15,RDX\nPUSH RBP\nPUSH RBX\nMOV R14D,ECX\nMOV R13,R8\nMOV R12,R9\nMOV RBX,RDI\nSUB RSP,0x18\nMOV RBP,RSI\nMOV qword ptr [RSP + 0x8],RAX\nNOP dword ptr [RAX]\nSUB RSP,0x8\nMOV RDX,R15\nMOV RSI,RBP\nMOV EAX,dword ptr [RSP + 0x58]\nMOV RDI,RBX\nMOV R9,R12\nMOV R8,R13\nMOV ECX,R14D\nADD RBX,0x10\nADD RBP,0x10\nPUSH RAX\nCALL 0x00ea6750\nPOP RAX\nPOP RDX\nCMP qword ptr [RSP + 0x8],RBX\nJNZ 0x00bc2770\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "76": {"funcbody": "int [FUNC1] (TYPE14 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         TYPE53 [VAR5] )\n{\n  int iVar1;\n  [TYPE6] [VAR6] ;\n  long in_FS_OFFSET;\n  [TYPE8] [VAR8] ;\n  long [VAR7] ;\n  \n  [VAR7] = *(long *)(in_FS_OFFSET + 0x28);\n  if ([VAR2] == 1) {\n    iVar1 = [FUNC2] ([VAR1] ->libctx,&[VAR1] ->params,1,(long)[VAR3] ,(long)[VAR4] ,&[VAR8] ,[VAR5] );\n  }\n  else {\n    iVar1 = [FUNC4] ([VAR1] ->libctx,&[VAR1] ->params,1,(long)[VAR3] ,(long)[VAR4] ,&[VAR8] ,[VAR5] );\n  }\n  if (0 < iVar1) {\n    [VAR1] ->dirty_cnt = [VAR1] ->dirty_cnt + 1;\n  }\n  if ([VAR7] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "dh", "VAR2": "type", "VAR3": "pbits", "VAR4": "qbits", "VAR5": "cb", "VAR6": "ret", "FUNC2": "ossl_ffc_params_FIPS186_2_generate", "FUNC3": "__stack_chk_fail", "FUNC1": "ossl_dh_generate_ffc_parameters", "TYPE3": "int", "TYPE2": "int", "FUNC4": "ossl_ffc_params_FIPS186_4_generate", "TYPE5": "BN_GENCB *", "TYPE4": "int", "TYPE7": "undefined8", "TYPE6": "int", "TYPE8": "int", "VAR7": "local_10", "VAR8": "res", "TYPE1": "DH *"}, "assembly": "PUSH RBX\nSUB RSP,0x10\nMOV RBX,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nCMP ESI,0x1\nJZ 0x001494d0\nMOVSXD RDX,EDX\nLEA RSI,[RDI + 0x8]\nMOV RDI,qword ptr [RDI + 0xb0]\nSUB RSP,0x8\nPUSH R8\nLEA R9,[RSP + 0x14]\nMOVSXD R8,ECX\nMOV RCX,RDX\nMOV EDX,0x1\nCALL 0x001a017f\nADD RSP,0x10\nTEST EAX,EAX\nJLE 0x001494ba\nADD qword ptr [RBX + 0xc8],0x1\nMOV RBX,qword ptr [RSP + 0x8]\nXOR RBX,qword ptr FS:[0x28]\nJNZ 0x001494ff\nADD RSP,0x10\nPOP RBX\nRET\nMOVSXD RDX,EDX\nLEA RSI,[RDI + 0x8]\nMOV RDI,qword ptr [RDI + 0xb0]\nSUB RSP,0x8\nPUSH R8\nLEA R9,[RSP + 0x14]\nMOVSXD R8,ECX\nMOV RCX,RDX\nMOV EDX,0x1\nCALL 0x001a01a0\nADD RSP,0x10\nJMP 0x001494ae\nCALL 0x00062640\n"}, "77": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  uint uVar1;\n  int iVar2;\n  TYPE40 [VAR4] ;\n  \n  uVar1 = [FUNC5] ();\n  if ((uVar1 != 0) && (uVar1 = 1, ([VAR2] & 0x83U) != 0)) {\n    if (([VAR2] & 3U) == 3) {\n      iVar2 = [FUNC4] ((RSA *)[VAR1] );\n      uVar1 = (uint)(iVar2 != 0);\n    }\n    else {\n      if (([VAR2] & 1U) == 0) {\n        if (([VAR2] & 2U) == 0) {\n          return 1;\n        }\n      }\n      else {\n        iVar2 = [FUNC3] ((RSA *)[VAR1] );\n        if (([VAR2] & 2U) == 0) {\n          return (uint)(iVar2 != 0);\n        }\n        if (iVar2 == 0) {\n          return 0;\n        }\n      }\n      iVar2 = [FUNC2] ((RSA *)[VAR1] );\n      uVar1 = (uint)(iVar2 != 0);\n    }\n  }\n  return uVar1;\n}", "answer": {"VAR1": "keydata", "VAR2": "selection", "VAR3": "checktype", "VAR4": "rsa", "FUNC2": "ossl_rsa_validate_public", "FUNC3": "ossl_rsa_validate_private", "FUNC1": "rsa_validate", "TYPE3": "int", "TYPE2": "int", "FUNC4": "ossl_rsa_validate_pairwise", "FUNC5": "ossl_prov_is_running", "TYPE4": "RSA *", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV EBX,ESI\nCALL 0x000e859f\nTEST EAX,EAX\nJZ 0x0011b39d\nMOV EAX,0x1\nTEST BL,0x83\nJZ 0x0011b39d\nMOV EAX,EBX\nAND EAX,0x3\nCMP EAX,0x3\nJZ 0x0011b3a4\nTEST BL,0x1\nJNZ 0x0011b3b6\nTEST BL,0x2\nJNZ 0x0011b3c7\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RDI,RBP\nCALL 0x001e7e5d\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x0011b39d\nMOV RDI,RBP\nCALL 0x001e7e4f\nTEST BL,0x2\nJZ 0x0011b3d9\nTEST EAX,EAX\nJZ 0x0011b39d\nMOV RDI,RBP\nCALL 0x001e7e41\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x0011b39d\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x0011b39d\n"}, "78": {"funcbody": "OSSL_LIB_CTX * [FUNC1] (TYPE15 [VAR1] ,TYPE28 [VAR2] )\n{\n  int iVar1;\n  OSSL_LIB_CTX *libctx;\n  TYPE39 [VAR3] ;\n  \n  libctx = [FUNC3] ();\n  if (libctx != (OSSL_LIB_CTX *)0x0) {\n    iVar1 = [FUNC2] (libctx,[VAR2] );\n    if (iVar1 == 0) {\n      [FUNC4] (libctx);\n      libctx = (OSSL_LIB_CTX *)0x0;\n    }\n  }\n  return libctx;\n}", "answer": {"VAR1": "handle", "VAR2": "in", "VAR3": "ctx", "FUNC2": "ossl_bio_init_core", "FUNC3": "OSSL_LIB_CTX_new", "FUNC1": "OSSL_LIB_CTX_new_from_dispatch", "TYPE3": "OSSL_LIB_CTX *", "TYPE2": "OSSL_DISPATCH *", "FUNC4": "OSSL_LIB_CTX_free", "TYPE1": "OSSL_CORE_HANDLE *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nCALL 0x0012db8a\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x0012dd99\nMOV RSI,RBP\nMOV RDI,RAX\nCALL 0x001ebe49\nTEST EAX,EAX\nJZ 0x0012dda3\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RDI,RBX\nCALL 0x0012dd36\nMOV EBX,0x0\nJMP 0x0012dd99\n"}, "79": {"funcbody": "X509_VERIFY_PARAM * [FUNC1] ([TYPE1] [VAR1] )\n{\n  X509_VERIFY_PARAM *pXVar1;\n  \n  if ([VAR1] < 5) {\n    return default_table + [VAR1] ;\n  }\n  pXVar1 = (X509_VERIFY_PARAM *)[FUNC2] ((OPENSSL_STACK *)param_table,[VAR1] + -5);\n  return pXVar1;\n}", "answer": {"VAR1": "id", "FUNC2": "OPENSSL_sk_value", "FUNC1": "X509_VERIFY_PARAM_get0", "TYPE1": "int"}, "assembly": "CMP EDI,0x4\nJG 0x000d2658\nMOVSXD RDI,EDI\nLEA RAX,[RDI*0x8]\nSUB RAX,RDI\nSHL RAX,0x4\nLEA RDX,[0x534cc0]\nADD RAX,RDX\nRET\nSUB RSP,0x8\nLEA ESI,[RDI + -0x5]\nMOV RDI,qword ptr [0x0057f820]\nCALL 0x000b98ff\nADD RSP,0x8\nRET\n"}, "80": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC2] ();\n  if (iVar1 != 0) {\n    *[VAR3] = 0;\n    iVar1 = 1;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "vctx", "VAR2": "out", "VAR3": "outl", "VAR4": "outsize", "FUNC2": "ossl_prov_is_running", "FUNC1": "aes_xts_stream_final", "TYPE3": "size_t *", "TYPE2": "uchar *", "TYPE4": "size_t", "TYPE1": "void *"}, "assembly": "PUSH RBX\nMOV RBX,RDX\nCALL 0x00113846\nTEST EAX,EAX\nJZ 0x0011dee4\nMOV qword ptr [RBX],0x0\nMOV EAX,0x1\nPOP RBX\nRET\n"}, "81": {"funcbody": "/* luaopen_lfs(lua_State*) */\nundefined8 [FUNC1] (TYPE14 [VAR1] )\n{\n  [FUNC4] ([VAR1] ,\"directory metatable\");\n  [FUNC5] ([VAR1] ,0,0);\n  [FUNC7] ([VAR1] ,[FUNC2] ,0);\n  [FUNC11] ([VAR1] ,0xfffffffe,&DAT_0017aef2);\n  [FUNC7] ([VAR1] ,[FUNC8] ,0);\n  [FUNC11] ([VAR1] ,0xfffffffe,\"close\");\n  [FUNC11] ([VAR1] ,0xfffffffe,\"__index\");\n  [FUNC7] ([VAR1] ,[FUNC8] ,0);\n  [FUNC11] ([VAR1] ,0xfffffffe,&DAT_0017a68e);\n  [FUNC9] (_DAT_0017a2b0,[VAR1] ,0x88);\n  [FUNC5] ([VAR1] ,0,5);\n  [FUNC3] ([VAR1] ,&DAT_003d6c80,0);\n  [FUNC10] ([VAR1] ,\"_COPYRIGHT\");\n  [FUNC10] ([VAR1] ,\"Copyright (C) 2003-2009 Kepler Project\");\n  [FUNC6] ([VAR1] ,0xfffffffd);\n  [FUNC10] ([VAR1] ,\"_DESCRIPTION\");\n  [FUNC10] ([VAR1] ,\n         \"LuaFileSystem is a Lua library developed to complement the set of functions related to file systems offered by the standard Lua distribution\"\n        );\n  [FUNC6] ([VAR1] ,0xfffffffd);\n  [FUNC10] ([VAR1] ,\"_VERSION\");\n  [FUNC10] ([VAR1] ,\"LuaFileSystem 1.5.0\");\n  [FUNC6] ([VAR1] ,0xfffffffd);\n  return 1;\n}", "answer": {"FUNC11": "lua_setfield", "VAR1": "param_1", "FUNC10": "lua_pushstring", "FUNC2": "FUN_000c6ebf", "FUNC3": "luaL_setfuncs", "FUNC1": "luaopen_lfs", "FUNC6": "lua_settable", "FUNC7": "lua_pushcclosure", "FUNC4": "luaL_newmetatable", "FUNC5": "lua_createtable", "FUNC8": "FUN_000c6f33", "FUNC9": "luaL_checkversion_", "TYPE1": "lua_State *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nLEA RSI,[0x17aeba]\nCALL 0x0014af99\nMOV EDX,0x0\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x001372f5\nMOV EDX,0x0\nLEA RSI,[0xc6ebf]\nMOV RDI,RBX\nCALL 0x00136e77\nLEA RDX,[0x17aef2]\nMOV ESI,0xfffffffe\nMOV RDI,RBX\nCALL 0x001374bb\nMOV EDX,0x0\nLEA RSI,[0xc6f33]\nMOV RDI,RBX\nCALL 0x00136e77\nLEA RDX,[0x1a0fba]\nMOV ESI,0xfffffffe\nMOV RDI,RBX\nCALL 0x001374bb\nLEA RDX,[0x17a693]\nMOV ESI,0xfffffffe\nMOV RDI,RBX\nCALL 0x001374bb\nMOV EDX,0x0\nLEA RSI,[0xc6f33]\nMOV RDI,RBX\nCALL 0x00136e77\nLEA RDX,[0x17a68e]\nMOV ESI,0xfffffffe\nMOV RDI,RBX\nCALL 0x001374bb\nMOV ESI,0x88\nMOVSD XMM0,qword ptr [0x0017a2b0]\nMOV RDI,RBX\nCALL 0x0014c60a\nMOV EDX,0x5\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x001372f5\nMOV EDX,0x0\nLEA RSI,[0x3d6c80]\nMOV RDI,RBX\nCALL 0x0014bccf\nLEA RSI,[0x17aef7]\nMOV RDI,RBX\nCALL 0x00136d1e\nLEA RSI,[0x17af50]\nMOV RDI,RBX\nCALL 0x00136d1e\nMOV ESI,0xfffffffd\nMOV RDI,RBX\nCALL 0x00137426\nLEA RSI,[0x17af02]\nMOV RDI,RBX\nCALL 0x00136d1e\nLEA RSI,[0x17af78]\nMOV RDI,RBX\nCALL 0x00136d1e\nMOV ESI,0xfffffffd\nMOV RDI,RBX\nCALL 0x00137426\nLEA RSI,[0x17af0f]\nMOV RDI,RBX\nCALL 0x00136d1e\nLEA RSI,[0x17af18]\nMOV RDI,RBX\nCALL 0x00136d1e\nMOV ESI,0xfffffffd\nMOV RDI,RBX\nCALL 0x00137426\nMOV EAX,0x1\nPOP RBX\nRET\n"}, "82": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  X509_ALGOR **ppXVar1;\n  uint uVar2;\n  X509_ALGOR *pXVar3;\n  ASN1_BIT_STRING *pAVar4;\n  TYPE39 [VAR3] ;\n  \n  ppXVar1 = (X509_ALGOR **)*[VAR1] ;\n  if (*ppXVar1 == (X509_ALGOR *)0x0) {\n    pXVar3 = [FUNC3] ();\n    *ppXVar1 = pXVar3;\n    if (pXVar3 == (X509_ALGOR *)0x0) {\n      return 0;\n    }\n  }\n  uVar2 = 1;\n  if (ppXVar1[1] == (X509_ALGOR *)0x0) {\n    pAVar4 = [FUNC2] ();\n    ppXVar1[1] = (X509_ALGOR *)pAVar4;\n    uVar2 = (uint)(pAVar4 != (ASN1_BIT_STRING *)0x0);\n  }\n  return uVar2;\n}", "answer": {"VAR1": "pval", "VAR2": "it", "VAR3": "pubkey", "FUNC2": "ASN1_BIT_STRING_new", "FUNC3": "X509_ALGOR_new", "FUNC1": "x509_pubkey_ex_populate", "TYPE3": "X509_PUBKEY *", "TYPE2": "ASN1_ITEM *", "TYPE1": "ASN1_VALUE * *"}, "assembly": "PUSH RBX\nMOV RBX,qword ptr [RDI]\nCMP qword ptr [RBX],0x0\nJZ 0x000dc20d\nMOV EAX,0x1\nCMP qword ptr [RBX + 0x8],0x0\nJZ 0x000dc224\nPOP RBX\nRET\nCALL 0x0014637f\nMOV RDX,RAX\nMOV qword ptr [RBX],RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJNZ 0x000dc1ff\nJMP 0x000dc20b\nCALL 0x00074d15\nMOV qword ptr [RBX + 0x8],RAX\nTEST RAX,RAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x000dc20b\n"}, "83": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  [TYPE3] [VAR3] ;\n  int iVar1;\n  int type;\n  \n  type = 0;\n  do {\n    if (type != 0) {\n      iVar1 = [FUNC2] (type,[VAR2] );\n      if (((iVar1 != -1) && ((type != 5 || (iVar1 < 7)))) && ((type != 4 || (6 < iVar1)))) {\n        *[VAR1] = type;\n        return iVar1;\n      }\n      if (9 < type + 1) {\n        return -1;\n      }\n    }\n    type = type + 1;\n  } while( true );\n}", "answer": {"VAR1": "type", "VAR2": "dat", "VAR3": "ret", "FUNC2": "xnee_data2int", "FUNC1": "xnee_data2int_special", "TYPE3": "int", "TYPE2": "char *", "TYPE1": "int *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R13,RDI\nMOV R12,RSI\nMOV EBX,0x0\nJMP 0x0001ceea\nCMP EBP,0x4\nJNZ 0x0001cf0b\nCMP EAX,0x6\nJG 0x0001cf0b\nLEA EAX,[RBX + 0x1]\nCMP EAX,0x9\nJG 0x0001cf11\nADD RBX,0x1\nMOV EBP,EBX\nTEST EBX,EBX\nJZ 0x0001cee6\nMOV RSI,R12\nMOV EDI,EBX\nCALL 0x0001ce1a\nCMP EAX,-0x1\nJZ 0x0001cede\nCMP EBX,0x5\nJNZ 0x0001ced4\nCMP EAX,0x6\nJG 0x0001cede\nJMP 0x0001ced4\nMOV dword ptr [R13],EBP\nJMP 0x0001cf16\nMOV EAX,0xffffffff\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\n"}, "84": {"funcbody": "/* DWARF original prototype: bool check_keywords_in_file(sccs_file * this, char * filename) */\nbool __thiscall sccs_file::[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  [TYPE6] [VAR6] ;\n  FILE *__stream;\n  [TYPE3] [VAR3] ;\n  [TYPE4] [VAR4] ;\n  [TYPE5] [VAR5] ;\n  bool bVar2;\n  \n  __stream = [FUNC8] ([VAR2] ,\"r\");\n  [VAR5] = 10;\n  if (__stream == (FILE *)0x0) {\n    [FUNC5] (\"%s: Can\\'t open file for reading\",[VAR2] );\n    bVar2 = false;\n  }\n  else {\n    while (iVar1 = [FUNC2] ((FILE *)__stream), iVar1 != -1) {\n      bVar2 = [VAR5] == 0x25;\n      [VAR5] = iVar1;\n      if ((bVar2) && (bVar2 = [FUNC3] ((char)iVar1), bVar2)) {\n        iVar1 = [FUNC2] ((FILE *)__stream);\n        if (iVar1 == 0x25) {\n          [FUNC7] ((FILE *)__stream);\n          return bVar2;\n        }\n        if (iVar1 == -1) break;\n        [FUNC6] (iVar1,(FILE *)__stream);\n      }\n    }\n    [FUNC4] ([VAR1] ,[VAR2] );\n    [FUNC7] ((FILE *)__stream);\n    bVar2 = true;\n  }\n  return bVar2;\n}", "answer": {"VAR1": "this", "VAR2": "filename", "VAR3": "fp", "VAR4": "ch", "VAR5": "last", "VAR6": "peek", "FUNC2": "getc", "FUNC3": "is_id_keyword_letter", "FUNC1": "check_keywords_in_file", "FUNC6": "ungetc", "TYPE3": "FILE *", "FUNC7": "fclose", "TYPE2": "char *", "FUNC4": "no_id_keywords", "TYPE5": "int", "FUNC5": "errormsg_with_errno", "TYPE4": "int", "TYPE6": "int", "FUNC8": "fopen_as_real_user", "TYPE1": "sccs_file *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R14,RDI\nMOV R13,RSI\nLEA RSI,[0x16cc2]\nMOV RDI,R13\nCALL 0x00010411\nMOV R12,RAX\nMOV EBP,0xa\nTEST RAX,RAX\nJNZ 0x00005435\nMOV RSI,R13\nLEA RDI,[0x16188]\nMOV EAX,0x0\nCALL 0x000137e1\nMOV EBP,0x0\nJMP 0x00005497\nMOV EBP,EBX\nMOV RDI,R12\nCALL 0x00002790\nMOV EBX,EAX\nCMP EAX,-0x1\nJZ 0x0000547f\nCMP EBP,0x25\nJNZ 0x00005433\nMOVSX EDI,AL\nCALL 0x000052c2\nMOV EBP,EAX\nTEST AL,AL\nJZ 0x00005433\nMOV RDI,R12\nCALL 0x00002790\nCMP EAX,0x25\nJZ 0x00005475\nCMP EAX,-0x1\nJZ 0x0000547f\nMOV RSI,R12\nMOV EDI,EAX\nCALL 0x00002750\nJMP 0x00005433\nMOV RDI,R12\nCALL 0x00002990\nJMP 0x00005497\nMOV RSI,R13\nMOV RDI,R14\nCALL 0x00005398\nMOV RDI,R12\nCALL 0x00002990\nMOV EBP,0x1\nMOV EAX,EBP\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\n"}, "85": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  uint uVar6;\n  uint pos;\n  \n  iVar5 = transformation[0x2ad][VAR1];\n  iVar1 = transformation[0x289][VAR1];\n  iVar2 = transformation[0x2d2][VAR1];\n  iVar3 = [FUNC2] ([VAR2] + transformation[0x2ae][VAR1]);\n  uVar4 = 0;\n  if (1 < iVar3) {\n    uVar6 = iVar5 + [VAR2] ;\n    uVar4 = [FUNC5] ([VAR3] ,1,2,[VAR2] ,(ulong)uVar6,(ulong)uVar6);\n    if (uVar4 != 0) {\n      iVar3 = 3 - [VAR3] ;\n      iVar5 = [FUNC3] (iVar3,1,3,[VAR2] ,0,(ulong)uVar6,(ulong)uVar6,(ulong)(uint)(iVar1 + [VAR2] ));\n      uVar4 = 0;\n      if (iVar5 == 0) {\n        pos = iVar2 + [VAR2] ;\n        iVar5 = [FUNC4] (iVar3,0,1,(ulong)pos);\n        if ((iVar5 != 0) && (iVar5 = [FUNC5] ([VAR3] ,1,2,[VAR2] ,(ulong)uVar6,(ulong)pos), iVar5 == 0)) {\n          return 0;\n        }\n        iVar5 = [FUNC6] (pos,iVar3);\n        uVar4 = 1;\n        if (iVar5 != 0) {\n          iVar5 = [FUNC5] ([VAR3] ,1,2,[VAR2] ,(ulong)pos,(ulong)pos);\n          uVar4 = (uint)(iVar5 != 0);\n        }\n      }\n    }\n  }\n  return uVar4;\n}", "answer": {"VAR1": "trans", "VAR2": "move", "VAR3": "color", "VAR4": "action", "FUNC2": "countlib", "FUNC3": "play_attack_defend2_n", "FUNC1": "autohelperowl_defendpat273", "FUNC6": "is_legal", "TYPE3": "int", "TYPE2": "int", "FUNC4": "somewhere", "FUNC5": "play_attack_defend_n", "TYPE4": "int", "TYPE1": "int"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV EBX,ESI\nMOV R12D,EDX\nLEA RAX,[0xcc6f20]\nMOVSXD RDI,EDI\nMOV EBP,dword ptr [RAX + RDI*0x4 + 0x55a0]\nMOV R13D,dword ptr [RAX + RDI*0x4 + 0x5120]\nMOV R14D,dword ptr [RAX + RDI*0x4 + 0x5a40]\nMOV ECX,ESI\nADD ECX,dword ptr [RAX + RDI*0x4 + 0x55c0]\nMOV EDI,ECX\nCALL 0x0014105e\nMOV EDX,0x0\nCMP EAX,0x1\nJLE 0x001d16c9\nADD EBP,EBX\nMOV R9D,EBP\nMOV R8D,EBP\nMOV ECX,EBX\nMOV EDX,0x2\nMOV ESI,0x1\nMOV EDI,R12D\nMOV EAX,0x0\nCALL 0x001957e0\nMOV EDX,EAX\nTEST EAX,EAX\nJNZ 0x001d16da\nMOV EAX,EDX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV R15D,0x3\nSUB R15D,R12D\nADD R13D,EBX\nPUSH R13\nPUSH RBP\nMOV R9D,EBP\nMOV R8D,0x0\nMOV ECX,EBX\nMOV EDX,0x3\nMOV ESI,0x1\nMOV EDI,R15D\nMOV EAX,0x0\nCALL 0x0019599b\nADD RSP,0x10\nMOV EDX,0x0\nTEST EAX,EAX\nJNZ 0x001d16c9\nADD R14D,EBX\nMOV ECX,R14D\nMOV EDX,0x1\nMOV ESI,0x0\nMOV EDI,R15D\nCALL 0x001951e1\nTEST EAX,EAX\nJZ 0x001d175d\nMOV R9D,R14D\nMOV R8D,EBP\nMOV ECX,EBX\nMOV EDX,0x2\nMOV ESI,0x1\nMOV EDI,R12D\nMOV EAX,0x0\nCALL 0x001957e0\nMOV EDX,EAX\nTEST EAX,EAX\nJZ 0x001d16c9\nMOV ESI,R15D\nMOV EDI,R14D\nCALL 0x00140c7e\nMOV EDX,0x1\nTEST EAX,EAX\nJZ 0x001d16c9\nMOV R9D,R14D\nMOV R8D,R14D\nMOV ECX,EBX\nMOV EDX,0x2\nMOV ESI,0x1\nMOV EDI,R12D\nMOV EAX,0x0\nCALL 0x001957e0\nTEST EAX,EAX\nSETNZ DL\nMOVZX EDX,DL\nJMP 0x001d16c9\n"}, "86": {"funcbody": "/* Local variable namemap:OSSL_NAMEMAP *[RDI:8] conflicts with parameter, skipped. */\nvoid [FUNC1] ([TYPE1] [VAR1] )\n{\n  if ([VAR1] != ([TYPE1] )0x0) {\n    *(byte *)[VAR1] = *[VAR1] & 0xfe;\n    [FUNC2] ((OSSL_NAMEMAP *)[VAR1] );\n    return;\n  }\n  return;\n}", "answer": {"VAR1": "vnamemap", "FUNC2": "ossl_namemap_free", "FUNC1": "stored_namemap_free", "TYPE1": "void *"}, "assembly": "TEST RDI,RDI\nJZ 0x00097f5f\nSUB RSP,0x8\nAND byte ptr [RDI],0xfe\nCALL 0x00097f01\nADD RSP,0x8\nRET\nRET\n"}, "87": {"funcbody": "/* linux_nat_target::thread_alive(ptid_t) */\nbool linux_nat_target::[FUNC1] \n               (TYPE15 [VAR1] ,undefined [VAR2] ,undefined [VAR3] ,undefined [VAR4] ,undefined [VAR5] ,\n               undefined [VAR6] ,[TYPE7] [VAR7] ,undefined8 [VAR8] ,[TYPE9] [VAR9] )\n{\n  long lVar1;\n  \n  lVar1 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,[VAR4] ,[VAR5] ,[VAR6] ,(undefined4)[VAR7] ,[VAR8] );\n  return lVar1 != 0;\n}", "answer": {"VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "VAR5": "param_5", "VAR6": "param_6", "FUNC2": "find_lwp_pid", "FUNC1": "thread_alive", "TYPE3": "undefined", "TYPE2": "undefined", "TYPE5": "undefined", "TYPE4": "undefined", "TYPE7": "undefined8", "TYPE6": "undefined", "TYPE9": "undefined8", "TYPE8": "undefined8", "VAR7": "param_7", "VAR8": "param_8", "VAR9": "param_9", "TYPE1": "ptid_t"}, "assembly": "SUB RSP,0x10\nPUSH qword ptr [RSP + 0x28]\nPUSH qword ptr [RSP + 0x28]\nPUSH qword ptr [RSP + 0x28]\nCALL 0x003c0830\nTEST RAX,RAX\nSETNZ AL\nADD RSP,0x28\nRET\n"}, "88": {"funcbody": "ENGINE * [FUNC1] (TYPE17 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  long lVar1;\n  int iVar2;\n  int iVar3;\n  [TYPE5] [VAR5] ;\n  void *pvVar4;\n  ENGINE *e;\n  long in_FS_OFFSET;\n  TYPE77 [VAR7] ;\n  [TYPE6] [VAR6] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC5] (0x40,(OPENSSL_INIT_SETTINGS *)0x0);\n  if (*[VAR1] == (ENGINE_TABLE *)0x0) {\n    e = (ENGINE *)0x0;\n  }\n  else {\n    [FUNC11] ();\n    iVar2 = [FUNC7] (global_engine_lock);\n    e = (ENGINE *)0x0;\n    if (((iVar2 != 0) && ((OPENSSL_LHASH *)*[VAR1] != (OPENSSL_LHASH *)0x0)) &&\n       ([VAR7] .nid = [VAR2] , pvVar4 = [FUNC3] ((OPENSSL_LHASH *)*[VAR1] ,&[VAR7] ), pvVar4 != (void *)0x0)) {\n      if ((*(ENGINE **)((long)pvVar4 + 0x10) == (ENGINE *)0x0) ||\n         (iVar2 = [FUNC10] (*(ENGINE **)((long)pvVar4 + 0x10)), iVar2 == 0)) {\n        iVar2 = *(int *)((long)pvVar4 + 0x18);\n        if (*(int *)((long)pvVar4 + 0x18) == 0) {\n          do {\n            iVar3 = iVar2 + 1;\n            e = (ENGINE *)[FUNC8] (*(OPENSSL_STACK **)((long)pvVar4 + 8),iVar2);\n            if (e == (ENGINE *)0x0) goto LAB_0018216d;\n            iVar2 = iVar3;\n          } while (((e->funct_ref < 1) && (((byte)table_flags & 1) != 0)) ||\n                  (iVar3 = [FUNC10] (e), iVar3 == 0));\n          if ((*(ENGINE **)((long)pvVar4 + 0x10) != e) && (iVar2 = [FUNC10] (e), iVar2 != 0)) {\n            if (*(ENGINE **)((long)pvVar4 + 0x10) != (ENGINE *)0x0) {\n              [FUNC4] (*(ENGINE **)((long)pvVar4 + 0x10),0);\n            }\n            *(ENGINE **)((long)pvVar4 + 0x10) = e;\n          }\n        }\n        else {\n          e = *(ENGINE **)((long)pvVar4 + 0x10);\n        }\n      }\n      else {\n        e = *(ENGINE **)((long)pvVar4 + 0x10);\n      }\nLAB_0018216d:\n      *(undefined4 *)((long)pvVar4 + 0x18) = 1;\n    }\n    [FUNC2] (global_engine_lock);\n    [FUNC9] ();\n  }\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC6] ();\n  }\n  return e;\n}", "answer": {"FUNC11": "ERR_set_mark", "VAR1": "table", "VAR2": "nid", "VAR3": "f", "VAR4": "l", "FUNC10": "engine_unlocked_init", "VAR5": "initres", "VAR6": "local_20", "FUNC2": "CRYPTO_THREAD_unlock", "FUNC3": "OPENSSL_LH_retrieve", "FUNC1": "ossl_engine_table_select", "FUNC6": "__stack_chk_fail", "TYPE3": "char *", "FUNC7": "CRYPTO_THREAD_write_lock", "TYPE2": "int", "FUNC4": "engine_unlocked_finish", "TYPE5": "int", "FUNC5": "OPENSSL_init_crypto", "TYPE4": "int", "TYPE7": "ENGINE_PILE", "TYPE6": "undefined8", "FUNC8": "OPENSSL_sk_value", "FUNC9": "ERR_pop_to_mark", "VAR7": "tmplate", "TYPE1": "ENGINE_TABLE * *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x30\nMOV RBP,RDI\nMOV R12D,ESI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x28],RAX\nXOR EAX,EAX\nMOV ESI,0x0\nMOV EDI,0x40\nCALL 0x0009dc50\nCMP qword ptr [RBP],0x0\nJZ 0x001821d9\nCALL 0x000847b0\nLEA RAX,[0x576670]\nMOV RDI,qword ptr [RAX]\nCALL 0x000a63a3\nMOV EBX,0x0\nTEST EAX,EAX\nJNZ 0x0018212d\nLEA RAX,[0x576670]\nMOV RDI,qword ptr [RAX]\nCALL 0x000a63b9\nCALL 0x000847e6\nMOV RAX,RBX\nMOV RDX,qword ptr [RSP + 0x28]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x001821e3\nADD RSP,0x30\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,qword ptr [RBP]\nTEST RDI,RDI\nJZ 0x001820f9\nMOV dword ptr [RSP],R12D\nMOV RSI,RSP\nCALL 0x0009aa52\nMOV RBP,RAX\nTEST RAX,RAX\nJZ 0x001820f9\nMOV RDI,qword ptr [RAX + 0x10]\nTEST RDI,RDI\nJZ 0x00182162\nCALL 0x000814e4\nTEST EAX,EAX\nJZ 0x00182162\nMOV RBX,qword ptr [RBP + 0x10]\nJMP 0x0018216d\nMOV ESI,dword ptr [RBP + 0x18]\nTEST ESI,ESI\nJZ 0x00182185\nMOV RBX,qword ptr [RBP + 0x10]\nMOV dword ptr [RBP + 0x18],0x1\nJMP 0x001820f9\nMOV RDI,RBX\nCALL 0x000814e4\nTEST EAX,EAX\nJNZ 0x001821ae\nMOV ESI,R12D\nLEA R12D,[RSI + 0x1]\nMOV RDI,qword ptr [RBP + 0x8]\nCALL 0x000b776e\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x0018216d\nCMP dword ptr [RAX + 0xa0],0x0\nJG 0x00182176\nTEST byte ptr [0x00575020],0x1\nJNZ 0x00182182\nJMP 0x00182176\nCMP qword ptr [RBP + 0x10],RBX\nJZ 0x0018216d\nMOV RDI,RBX\nCALL 0x000814e4\nTEST EAX,EAX\nJZ 0x0018216d\nMOV RDI,qword ptr [RBP + 0x10]\nTEST RDI,RDI\nJZ 0x001821d3\nMOV ESI,0x0\nCALL 0x0008151f\nMOV qword ptr [RBP + 0x10],RBX\nJMP 0x0018216d\nMOV EBX,0x0\nJMP 0x0018210d\nCALL 0x00062640\n"}, "89": {"funcbody": "int [FUNC1] (TYPE18 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,TYPE47 [VAR4] ,\n         TYPE56 [VAR5] ,TYPE64 [VAR6] )\n{\n  OCB_BLOCK *in;\n  OCB_BLOCK *pOVar1;\n  ulong uVar2;\n  undefined8 *puVar3;\n  \n  [VAR1] ->encrypt = (block128_f)0x0;\n  ([VAR1] ->sess).checksum.a[1] = 0;\n  puVar3 = (undefined8 *)((ulong)&[VAR1] ->decrypt & 0xfffffffffffffff8);\n  uVar2 = (ulong)(((int)[VAR1] - (int)puVar3) + 0xb0U >> 3);\n  for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  [VAR1] ->l_index = 0;\n  [VAR1] ->max_l_index = 5;\n  pOVar1 = (OCB_BLOCK *)[FUNC6] (0x50,\"crypto/modes/ocb128.c\",0x9e);\n  [VAR1] ->l = pOVar1;\n  if (pOVar1 == (OCB_BLOCK *)0x0) {\n    [FUNC5] ();\n    [FUNC4] (\"crypto/modes/ocb128.c\",0x9f,\"CRYPTO_ocb128_init\");\n    [FUNC2] (0xf,0xc0100,(char *)0x0);\n  }\n  else {\n    [VAR1] ->encrypt = [VAR4] ;\n    [VAR1] ->decrypt = [VAR5] ;\n    [VAR1] ->stream = [VAR6] ;\n    [VAR1] ->keyenc = [VAR2] ;\n    [VAR1] ->keydec = [VAR3] ;\n    in = &[VAR1] ->l_star;\n    (*[VAR4] )((uchar *)in,in->c,[VAR2] );\n    [FUNC3] (in,&[VAR1] ->l_dollar);\n    [FUNC3] (&[VAR1] ->l_dollar,[VAR1] ->l);\n    [FUNC3] ([VAR1] ->l,[VAR1] ->l + 1);\n    [FUNC3] ([VAR1] ->l + 1,[VAR1] ->l + 2);\n    [FUNC3] ([VAR1] ->l + 2,[VAR1] ->l + 3);\n    [FUNC3] ([VAR1] ->l + 3,[VAR1] ->l + 4);\n    [VAR1] ->l_index = 4;\n  }\n  return (int)(pOVar1 != (OCB_BLOCK *)0x0);\n}", "answer": {"VAR1": "ctx", "VAR2": "keyenc", "VAR3": "keydec", "VAR4": "encrypt", "VAR5": "decrypt", "VAR6": "stream", "FUNC2": "ERR_set_error", "FUNC3": "ocb_double", "FUNC1": "CRYPTO_ocb128_init", "FUNC6": "FUNC1", "TYPE3": "void *", "TYPE2": "void *", "FUNC4": "ERR_set_debug", "TYPE5": "block128_f", "FUNC5": "ERR_new", "TYPE4": "block128_f", "TYPE6": "ocb128_f", "TYPE1": "OCB128_CONTEXT *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV R12,RSI\nMOV R13,RDX\nMOV RBP,RCX\nMOV R15,R8\nMOV R14,R9\nMOV qword ptr [RDI],0x0\nMOV qword ptr [RDI + 0xa8],0x0\nLEA RDI,[RDI + 0x8]\nAND RDI,-0x8\nMOV RCX,RBX\nSUB RCX,RDI\nADD ECX,0xb0\nSHR ECX,0x3\nMOV ECX,ECX\nMOV EAX,0x0\nSTOSQ.REP RDI\nMOV qword ptr [RBX + 0x28],0x0\nMOV qword ptr [RBX + 0x30],0x5\nMOV EDX,0x9e\nLEA RSI,[0x296a56]\nMOV EDI,0x50\nCALL 0x0009b4e7\nMOV qword ptr [RBX + 0x58],RAX\nTEST RAX,RAX\nJZ 0x001b0640\nMOV qword ptr [RBX],RBP\nMOV qword ptr [RBX + 0x8],R15\nMOV qword ptr [RBX + 0x20],R14\nMOV qword ptr [RBX + 0x10],R12\nMOV qword ptr [RBX + 0x18],R13\nLEA R13,[RBX + 0x38]\nMOV RDX,R12\nMOV RSI,R13\nMOV RDI,R13\nCALL RBP\nLEA RBP,[RBX + 0x48]\nMOV RSI,RBP\nMOV RDI,R13\nCALL 0x001b0340\nMOV RSI,qword ptr [RBX + 0x58]\nMOV RDI,RBP\nCALL 0x001b0340\nMOV RDI,qword ptr [RBX + 0x58]\nLEA RSI,[RDI + 0x10]\nCALL 0x001b0340\nMOV RDI,qword ptr [RBX + 0x58]\nLEA RSI,[RDI + 0x20]\nADD RDI,0x10\nCALL 0x001b0340\nMOV RDI,qword ptr [RBX + 0x58]\nLEA RSI,[RDI + 0x30]\nADD RDI,0x20\nCALL 0x001b0340\nMOV RDI,qword ptr [RBX + 0x58]\nLEA RSI,[RDI + 0x40]\nADD RDI,0x30\nCALL 0x001b0340\nMOV qword ptr [RBX + 0x28],0x4\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nCALL 0x00082e6e\nLEA RDX,[0x296a90]\nMOV ESI,0x9f\nLEA RDI,[0x296a56]\nCALL 0x00082f7b\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0xf\nMOV EAX,0x0\nCALL 0x00083292\nMOV EAX,0x0\nJMP 0x001b0631\n"}, "90": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] )\n{\n  int iVar1;\n  fiid_obj_t obj_cmd_rq;\n  int *piVar2;\n  [TYPE8] [VAR8] ;\n  \n  if ([VAR1] == (TYPE10x0) {\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = -1;\n    if ([VAR1] ->magic == 0xfafab0b0) {\n      iVar1 = [FUNC10] ([VAR7] );\n      if (iVar1 == 0) {\n        [VAR1] ->errnum = IPMI_ERR_PARAMETERS;\n        iVar1 = -1;\n      }\n      else {\n        iVar1 = [FUNC4] ([VAR7] ,(fiid_field_t *)PTR_tmpl_cmd_get_command_sub_function_enables_rs_0059d5b8\n                     );\n        if (iVar1 < 0) {\n          [FUNC9] ([VAR1] ,[VAR7] );\n          iVar1 = -1;\n        }\n        else {\n          obj_cmd_rq = [FUNC2] ((fiid_field_t *)\n                             PTR_tmpl_cmd_get_command_sub_function_enables_rq_0059e480);\n          if (obj_cmd_rq == (fiid_obj_t)0x0) {\n            piVar2 = [FUNC8] ();\n            [FUNC3] ([VAR1] ,*piVar2);\n            iVar1 = -1;\n          }\n          else {\n            iVar1 = [FUNC7] ([VAR2] ,[VAR3] ,[VAR4] ,[VAR5] ,[VAR6] ,obj_cmd_rq);\n            if (iVar1 < 0) {\n              piVar2 = [FUNC8] ();\n              [FUNC3] ([VAR1] ,*piVar2);\n              iVar1 = -1;\n            }\n            else {\n              iVar1 = [FUNC6] ([VAR1] ,'\\0','\\x06',obj_cmd_rq,[VAR7] );\n              iVar1 = iVar1 >> 0x1f;\n            }\n          }\n          [FUNC5] (obj_cmd_rq);\n        }\n      }\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "channel_number", "VAR3": "net_fn", "VAR4": "lun", "FUNC10": "fiid_obj_valid", "VAR5": "command", "VAR6": "net_fn_data", "FUNC2": "fiid_obj_create", "FUNC3": "api_set_api_errnum_by_errno", "FUNC1": "ipmi_cmd_get_command_sub_function_enables", "FUNC6": "api_ipmi_cmd", "TYPE3": "uint8_t", "FUNC7": "fill_cmd_get_command_sub_function_enables", "TYPE2": "uint8_t", "FUNC4": "FIID_OBJ_TEMPLATE_COMPARE", "TYPE5": "uint8_t", "FUNC5": "fiid_obj_destroy", "TYPE4": "uint8_t", "TYPE7": "fiid_obj_t", "TYPE6": "uint32_t", "FUNC8": "__errno_location", "FUNC9": "api_set_api_errnum_by_fiid_object", "TYPE8": "undefined4", "VAR7": "obj_cmd_rs", "VAR8": "local_3c", "TYPE1": "ipmi_ctx_t"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nTEST RDI,RDI\nJZ 0x0016ed32\nMOV EBX,0xffffffff\nCMP dword ptr [RDI],0xfafab0b0\nJNZ 0x0016ecd3\nMOV R15D,R9D\nMOV R13D,R8D\nMOV R12D,ECX\nMOV EBP,EDX\nMOV dword ptr [RSP + 0xc],ESI\nMOV RBX,RDI\nMOV RDI,qword ptr [RSP + 0x50]\nCALL 0x00165fe0\nTEST EAX,EAX\nJZ 0x0016ece4\nMOV RSI,qword ptr [0x0059d5b8]\nMOV RDI,qword ptr [RSP + 0x50]\nCALL 0x001669c0\nTEST EAX,EAX\nJS 0x0016ecf2\nMOV RDI,qword ptr [0x0059e480]\nCALL 0x001655f0\nMOV R14,RAX\nTEST RAX,RAX\nJZ 0x0016ed06\nMOVZX ECX,R13B\nMOVZX EDX,R12B\nMOVZX ESI,BPL\nMOVZX EDI,byte ptr [RSP + 0xc]\nMOV R9,RAX\nMOV R8D,R15D\nCALL 0x00165260\nTEST EAX,EAX\nJS 0x0016ed1c\nMOV R8,qword ptr [RSP + 0x50]\nMOV RCX,R14\nMOV EDX,0x6\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x0016a758\nSAR EAX,0x1f\nMOV EBX,EAX\nMOV RDI,R14\nCALL 0x00166f70\nMOV EAX,EBX\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV dword ptr [RBX + 0x40],0x1e\nMOV EBX,0xffffffff\nJMP 0x0016ecd3\nMOV RSI,qword ptr [RSP + 0x50]\nMOV RDI,RBX\nCALL 0x0016a2fa\nMOV EBX,0xffffffff\nJMP 0x0016ecd3\nCALL 0x00166780\nMOV ESI,dword ptr [RAX]\nMOV RDI,RBX\nCALL 0x0016a287\nMOV EBX,0xffffffff\nJMP 0x0016eccb\nCALL 0x00166780\nMOV ESI,dword ptr [RAX]\nMOV RDI,RBX\nCALL 0x0016a287\nMOV EBX,0xffffffff\nJMP 0x0016eccb\nMOV EBX,0xffffffff\nJMP 0x0016ecd3\n"}, "91": {"funcbody": "/* DWARF original prototype: Histable * convertto(HeapData * this, Histable_type type, Histable *\n   param_2) */\nHistable * __thiscall\nHeapData::[FUNC1] (TYPE18 [VAR1] ,TYPE20 [VAR2] ,[TYPE3] [VAR3] )\n{\n  if ([VAR1] ->histType != [VAR2] ) {\n    [VAR1] = (TYPE18)0x0;\n  }\n  return &[VAR1] ->super_Histable;\n}", "answer": {"VAR1": "this", "VAR2": "type", "VAR3": "param_3", "FUNC1": "convertto", "TYPE3": "Histable *", "TYPE2": "Histable_type", "TYPE1": "HeapData *"}, "assembly": "MOV RAX,RDI\nCMP dword ptr [RDI + 0x48],ESI\nMOV EDX,0x0\nCMOVNZ RAX,RDX\nRET\n"}, "92": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  BUF_MEM *a;\n  int iVar1;\n  TYPE35 [VAR3] ;\n  TYPE25 [VAR2] ;\n  \n  iVar1 = 0;\n  if (((([VAR1] != ([TYPE1] )0x0) && (iVar1 = 1, [VAR1] ->shutdown != 0)) && ([VAR1] ->init != 0))\n     && ((BUF_MEM **)[VAR1] ->ptr != (BUF_MEM **)0x0)) {\n    a = *[VAR1] ->ptr;\n    if ((*(byte *)((long)&[VAR1] ->flags + 1) & 2) != 0) {\n      a->data = (char *)0x0;\n    }\n    [FUNC2] (a);\n    return 1;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "a", "VAR2": "bb", "VAR3": "b", "FUNC2": "BUF_MEM_free", "FUNC1": "mem_buf_free", "TYPE3": "BUF_MEM *", "TYPE2": "BIO_BUF_MEM *", "TYPE1": "BIO *"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x001334f9\nMOV EAX,0x1\nCMP dword ptr [RDI + 0x2c],0x0\nJZ 0x001334f9\nCMP dword ptr [RDI + 0x28],0x0\nJZ 0x001334f9\nMOV RDX,qword ptr [RDI + 0x40]\nTEST RDX,RDX\nJZ 0x001334f9\nSUB RSP,0x8\nMOV RAX,qword ptr [RDX]\nTEST byte ptr [RDI + 0x31],0x2\nJZ 0x001334e7\nMOV qword ptr [RAX + 0x8],0x0\nMOV RDI,RAX\nCALL 0x00080fcf\nMOV EAX,0x1\nADD RSP,0x8\nRET\nRET\n"}, "93": {"funcbody": "void [FUNC1] (undefined [VAR1] ,undefined [VAR2] ,undefined [VAR3] ,undefined [VAR4] ,undefined [VAR5] ,undefined [VAR6] \n          ,[TYPE7] [VAR7] )\n{\n  undefined7 in_register_00000009;\n  undefined7 in_register_00000011;\n  undefined7 in_register_00000031;\n  undefined7 in_register_00000039;\n  undefined7 in_register_00000081;\n  undefined7 in_register_00000089;\n  [TYPE8] [VAR8] ;\n  \n  [FUNC3] ();\n  [FUNC2] (CONCAT71(in_register_00000039,[VAR1] ) + 0x20,CONCAT71(in_register_00000031,[VAR2] ) + 0x20,\n        CONCAT71(in_register_00000011,[VAR3] ),CONCAT71(in_register_00000009,[VAR4] ) & 0xffffffff,\n        CONCAT71(in_register_00000081,[VAR5] ),CONCAT71(in_register_00000089,[VAR6] ));\n  return;\n}", "answer": {"VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "VAR5": "param_5", "VAR6": "param_6", "FUNC2": "FUN_00ebda70", "FUNC3": "FUN_00ed2560", "FUNC1": "FUN_00bd8f70", "TYPE3": "undefined", "TYPE2": "undefined", "TYPE5": "undefined", "TYPE4": "undefined", "TYPE7": "undefined4", "TYPE6": "undefined", "TYPE8": "undefined4", "VAR7": "param_7", "VAR8": "local_3c", "TYPE1": "undefined"}, "assembly": "PUSH R15\nPUSH R14\nMOV R15,R9\nPUSH R13\nPUSH R12\nMOV R13D,ECX\nPUSH RBP\nPUSH RBX\nMOV RBP,RSI\nMOV RBX,RDI\nMOV R12,RDX\nMOV R14,R8\nSUB RSP,0x20\nMOV EAX,dword ptr [RSP + 0x58]\nPUSH RAX\nMOV dword ptr [RSP + 0x1c],EAX\nCALL 0x00ed2560\nMOV EAX,dword ptr [RSP + 0x1c]\nLEA RSI,[RBP + 0x20]\nLEA RDI,[RBX + 0x20]\nMOV R9,R15\nMOV R8,R14\nMOV ECX,R13D\nMOV RDX,R12\nMOV dword ptr [RSP + 0x60],EAX\nADD RSP,0x28\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nJMP 0x00ebda70\n"}, "94": {"funcbody": "int [FUNC1] (TYPE18 [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = [VAR1] ->funct_ref + -1;\n  [VAR1] ->funct_ref = iVar1;\n  if (iVar1 == 0) {\n    if ([VAR1] ->finish == (ENGINE_GEN_INT_FUNC_PTR)0x0) {\n      iVar1 = 1;\n    }\n    else {\n      if ([VAR2] == 0) {\n        iVar1 = (*[VAR1] ->finish)([VAR1] );\n      }\n      else {\n        [FUNC2] (global_engine_lock);\n        iVar1 = (*[VAR1] ->finish)([VAR1] );\n        iVar2 = [FUNC7] (global_engine_lock);\n        if (iVar2 == 0) {\n          return 0;\n        }\n      }\n      if (iVar1 == 0) {\n        return 0;\n      }\n    }\n  }\n  else {\n    iVar1 = 1;\n  }\n  iVar2 = [FUNC4] ([VAR1] ,0);\n  if (iVar2 == 0) {\n    [FUNC6] ();\n    [FUNC3] (\"crypto/engine/eng_init.c\",0x4a,\"engine_unlocked_finish\");\n    [FUNC5] (0x26,0x6a,(char *)0x0);\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "e", "VAR2": "unlock_for_handlers", "FUNC2": "CRYPTO_THREAD_unlock", "FUNC3": "ERR_set_debug", "FUNC1": "engine_unlocked_finish", "FUNC6": "ERR_new", "FUNC7": "CRYPTO_THREAD_write_lock", "TYPE2": "int", "FUNC4": "engine_free_util", "FUNC5": "ERR_set_error", "TYPE1": "ENGINE *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV EAX,dword ptr [RDI + 0xa0]\nSUB EAX,0x1\nMOV dword ptr [RDI + 0xa0],EAX\nTEST EAX,EAX\nJNZ 0x000af2e8\nMOV RAX,qword ptr [RDI + 0x68]\nTEST RAX,RAX\nJZ 0x000af307\nTEST ESI,ESI\nJNZ 0x000af2bf\nCALL RAX\nMOV EBP,EAX\nTEST EBP,EBP\nJNZ 0x000af2ed\nJMP 0x000af300\nLEA R12,[0x630430]\nMOV RDI,qword ptr [R12]\nCALL 0x000d30d3\nMOV RDI,RBX\nCALL qword ptr [RBX + 0x68]\nMOV EBP,EAX\nMOV RDI,qword ptr [R12]\nCALL 0x000d30bd\nTEST EAX,EAX\nJNZ 0x000af2b9\nMOV EBP,EAX\nJMP 0x000af300\nMOV EBP,0x1\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x000af6c2\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x000af30e\nMOV EAX,EBP\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV EBP,0x1\nJMP 0x000af2ed\nCALL 0x000b271b\nLEA RDX,[0x314aa0]\nMOV ESI,0x4a\nLEA RDI,[0x314a63]\nCALL 0x000b2828\nMOV EDX,0x0\nMOV ESI,0x6a\nMOV EDI,0x26\nMOV EAX,0x0\nCALL 0x000b2b3f\nMOV EBP,EBX\nJMP 0x000af300\n"}, "95": {"funcbody": "int [FUNC1] (void)\n{\n  int iVar1;\n  \n  if (param_table != (stack_st_X509_VERIFY_PARAM *)0x0) {\n    iVar1 = [FUNC2] ((OPENSSL_STACK *)param_table);\n    return iVar1 + 5;\n  }\n  return 5;\n}", "answer": {"FUNC2": "OPENSSL_sk_num", "FUNC1": "X509_VERIFY_PARAM_get_count"}, "assembly": "MOV RDI,qword ptr [0x00573df8]\nMOV EAX,0x5\nTEST RDI,RDI\nJZ 0x000bd5f9\nSUB RSP,0x8\nCALL 0x000b2431\nADD EAX,0x5\nADD RSP,0x8\nRET\nRET\n"}, "96": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] )\n{\n  X509_NAME *a;\n  int iVar1;\n  int iVar2;\n  [TYPE10] [VAR10] ;\n  void *data;\n  undefined4 extraout_var;\n  [TYPE7] [VAR7] ;\n  [TYPE8] [VAR8] ;\n  int iVar3;\n  [TYPE9] [VAR9] ;\n  TYPE64 [VAR6] ;\n  OPENSSL_STACK *st;\n  long in_FS_OFFSET;\n  [TYPE13] [VAR13] ;\n  [TYPE12] [VAR12] ;\n  long [VAR11] ;\n  \n  [VAR11] = *(long *)(in_FS_OFFSET + 0x28);\n  a = (X509_NAME *)*[VAR1] ;\n  if (a->modified == 0) {\nLAB_000c1377:\n    iVar2 = (int)a->bytes->length;\n    if ([VAR2] != ([TYPE2] )0x0) {\n      [FUNC10] (*[VAR2] ,a->bytes->data,(long)iVar2);\n      *[VAR2] = *[VAR2] + iVar2;\n    }\n  }\n  else {\n    [VAR13] .s = (stack_st_STACK_OF_X509_NAME_ENTRY *)0x0;\n    [VAR13] .s = (stack_st_STACK_OF_X509_NAME_ENTRY *)[FUNC7] ();\n    if ((OPENSSL_STACK *)[VAR13] .s != (OPENSSL_STACK *)0x0) {\n      iVar2 = -1;\n      iVar3 = 0;\n      st = (OPENSSL_STACK *)0x0;\n      while( true ) {\n        iVar1 = [FUNC13] ((OPENSSL_STACK *)a->entries);\n        if (iVar1 <= iVar3) break;\n        data = [FUNC15] ((OPENSSL_STACK *)a->entries,iVar3);\n        if (*(int *)((long)data + 0x10) != iVar2) {\n          st = [FUNC7] ();\n          if (st == (OPENSSL_STACK *)0x0) goto memerr;\n          iVar2 = [FUNC2] ((OPENSSL_STACK *)[VAR13] .s,st);\n          if (iVar2 == 0) {\n            [FUNC8] (st);\n            goto memerr;\n          }\n          iVar2 = *(int *)((long)data + 0x10);\n        }\n        iVar1 = [FUNC2] (st,data);\n        if (iVar1 == 0) goto memerr;\n        iVar3 = iVar3 + 1;\n      }\n      iVar2 = [FUNC4] ((ASN1_VALUE **)&[VAR13] .s,(uchar **)0x0,(ASN1_ITEM *)local_it_20122,-1,-1);\n      iVar3 = [FUNC14] ((BUF_MEM *)a->bytes,(long)iVar2);\n      if (CONCAT44(extraout_var,iVar3) != 0) {\n        [VAR12] = ([TYPE12] a->bytes->data;\n        [FUNC4] ((ASN1_VALUE **)&[VAR13] .s,&[VAR12] ,(ASN1_ITEM *)local_it_20122,-1,-1);\n        [FUNC12] ((OPENSSL_STACK *)[VAR13] .s,[FUNC11] );\n        a->modified = 0;\n        if (iVar2 < 0) goto LAB_000c139b;\n        iVar2 = [FUNC16] (a);\n        if (iVar2 == 0) {\n          iVar2 = -1;\n          goto LAB_000c139b;\n        }\n        goto LAB_000c1377;\n      }\n    }\nmemerr:\n    [FUNC12] ((OPENSSL_STACK *)[VAR13] .s,[FUNC11] );\n    [FUNC6] ();\n    [FUNC9] (\"crypto/x509/x_name.c\",0x117,\"x509_name_encode\");\n    [FUNC5] (0xd,0xc0100,(char *)0x0);\n    iVar2 = -1;\n  }\nLAB_000c139b:\n  if ([VAR11] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC3] ();\n}", "answer": {"FUNC12": "OPENSSL_sk_pop_free", "FUNC11": "local_sk_X509_NAME_ENTRY_free", "FUNC14": "BUF_MEM_grow", "VAR1": "val", "FUNC13": "OPENSSL_sk_num", "VAR2": "out", "VAR3": "it", "VAR4": "tag", "FUNC10": "memcpy", "VAR5": "aclass", "VAR6": "a", "FUNC2": "OPENSSL_sk_push", "FUNC16": "x509_name_canon", "FUNC3": "__stack_chk_fail", "FUNC15": "OPENSSL_sk_value", "FUNC1": "x509_name_ex_i2d", "FUNC6": "ERR_new", "TYPE3": "ASN1_ITEM *", "FUNC7": "OPENSSL_sk_new_null", "TYPE2": "uchar * *", "FUNC4": "ASN1_item_ex_i2d", "TYPE5": "int", "VAR12": "p", "FUNC5": "ERR_set_error", "TYPE4": "int", "VAR13": "intname", "TYPE7": "int", "TYPE6": "X509_NAME *", "FUNC8": "OPENSSL_sk_free", "TYPE9": "X509_NAME_ENTRY *", "FUNC9": "ERR_set_debug", "TYPE8": "int", "VAR7": "ret", "TYPE11": "undefined8", "VAR8": "i", "TYPE12": "uchar *", "VAR9": "entry", "TYPE10": "int", "VAR10": "len", "VAR11": "local_40", "TYPE1": "ASN1_VALUE * *", "TYPE13": "anon_union_8_2_94730013"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV R15,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV R12,qword ptr [RDI]\nCMP dword ptr [R12 + 0x8],0x0\nJNZ 0x000c13c0\nMOV RAX,qword ptr [R12 + 0x10]\nMOV RDX,qword ptr [RAX]\nMOV EBP,EDX\nTEST R15,R15\nJZ 0x000c139b\nMOVSXD RBX,EDX\nMOV RDI,qword ptr [R15]\nMOV RSI,qword ptr [RAX + 0x8]\nMOV RDX,RBX\nCALL 0x00062840\nADD qword ptr [R15],RBX\nMOV EAX,EBP\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x000c1543\nADD RSP,0x28\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV qword ptr [RSP + 0x8],0x0\nCALL 0x000b2842\nMOV qword ptr [RSP + 0x8],RAX\nTEST RAX,RAX\nJZ 0x000c13f3\nMOV R14D,0xffffffff\nMOV EBX,0x0\nMOV R13D,0x0\nJMP 0x000c1456\nMOV RDI,R13\nCALL 0x000b24f5\nLEA RSI,[0xc0be1]\nMOV RDI,qword ptr [RSP + 0x8]\nCALL 0x000b286d\nCALL 0x00080fee\nLEA RDX,[0x26f9d0]\nMOV ESI,0x117\nLEA RDI,[0x26f918]\nCALL 0x000810fb\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0xd\nMOV EAX,0x0\nCALL 0x00081412\nMOV EBP,0xffffffff\nJMP 0x000c139b\nMOV RSI,RBP\nMOV RDI,R13\nCALL 0x000b2306\nTEST EAX,EAX\nJZ 0x000c13f3\nADD EBX,0x1\nMOV RDI,qword ptr [R12]\nCALL 0x000b28b0\nCMP EBX,EAX\nJGE 0x000c14a3\nMOV ESI,EBX\nMOV RDI,qword ptr [R12]\nCALL 0x000b28be\nMOV RBP,RAX\nCMP dword ptr [RAX + 0x10],R14D\nJZ 0x000c1444\nCALL 0x000b2842\nMOV R13,RAX\nTEST RAX,RAX\nJZ 0x000c13f3\nMOV RSI,RAX\nMOV RDI,qword ptr [RSP + 0x8]\nCALL 0x000b2306\nTEST EAX,EAX\nJZ 0x000c13eb\nMOV R14D,dword ptr [RBP + 0x10]\nJMP 0x000c1444\nLEA RDI,[RSP + 0x8]\nMOV R8D,0xffffffff\nMOV ECX,R8D\nLEA RDX,[0x522c80]\nMOV ESI,0x0\nCALL 0x0006f1e7\nMOV EBP,EAX\nMOVSXD RSI,EAX\nMOV RDI,qword ptr [R12 + 0x10]\nCALL 0x0007f5ab\nTEST RAX,RAX\nJZ 0x000c13f3\nMOV RAX,qword ptr [R12 + 0x10]\nMOV RAX,qword ptr [RAX + 0x8]\nMOV qword ptr [RSP + 0x10],RAX\nLEA RSI,[RSP + 0x10]\nLEA RDI,[RSP + 0x8]\nMOV R8D,0xffffffff\nMOV ECX,R8D\nLEA RDX,[0x522c80]\nCALL 0x0006f1e7\nLEA RSI,[0xc0be1]\nMOV RDI,qword ptr [RSP + 0x8]\nCALL 0x000b286d\nMOV dword ptr [R12 + 0x8],0x0\nTEST EBP,EBP\nJS 0x000c139b\nMOV RDI,R12\nCALL 0x000c0e5c\nTEST EAX,EAX\nJNZ 0x000c1377\nMOV EBP,0xffffffff\nJMP 0x000c139b\nCALL 0x00062640\n"}, "97": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  \n  [FUNC2] (1);\n  if (_rl_explicit_arg == 0) {\n    iVar1 = [FUNC3] ();\n    [VAR1] = iVar1 + _history_base + 1;\n  }\n  saved_history_logical_offset = [VAR1] ;\n  _rl_saved_internal_startup_hook = __rl_internal_startup_hook;\n  __rl_internal_startup_hook = [FUNC4] ;\n  return 0;\n}", "answer": {"VAR1": "count", "VAR2": "c", "FUNC2": "rl_newline", "FUNC3": "where_history", "FUNC1": "rl_operate_and_get_next", "TYPE2": "int", "FUNC4": "set_saved_history", "TYPE1": "int"}, "assembly": "PUSH RBX\nMOV EBX,EDI\nMOV EDI,0x1\nCALL 0x00002170\nLEA RAX,[0x2040]\nCMP dword ptr [RAX],0x0\nJZ 0x00000c53\nMOV dword ptr [0x00000d48],EBX\nLEA RAX,[0x2168]\nMOV RDX,qword ptr [RAX]\nMOV qword ptr [0x00000d60],RDX\nLEA RCX,[0xb4b]\nMOV qword ptr [RAX],RCX\nMOV EAX,0x0\nPOP RBX\nRET\nCALL 0x000020e0\nLEA RDX,[0x2160]\nADD EAX,dword ptr [RDX]\nMOV EBX,EAX\nADD EBX,0x1\nJMP 0x00000c2b\n"}, "98": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  BIGNUM *pBVar1;\n  \n  pBVar1 = [FUNC2] (*[VAR1] ,[VAR2] ,(BIGNUM *)0x0);\n  *[VAR3] = pBVar1;\n  if (pBVar1 != (BIGNUM *)0x0) {\n    *[VAR1] = *[VAR1] + [VAR2] ;\n  }\n  return (int)(pBVar1 != (BIGNUM *)0x0);\n}", "answer": {"VAR1": "in", "VAR2": "nbyte", "VAR3": "r", "FUNC2": "BN_lebin2bn", "FUNC1": "read_lebn", "TYPE3": "BIGNUM * *", "TYPE2": "uint", "TYPE1": "uchar * *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,RDI\nMOV EBX,ESI\nMOV R12,RDX\nMOV EDX,0x0\nMOV RDI,qword ptr [RDI]\nCALL 0x0007822f\nMOV RDX,RAX\nMOV qword ptr [R12],RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x001b64cc\nMOV EBX,EBX\nADD qword ptr [RBP],RBX\nMOV EAX,0x1\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "99": {"funcbody": "/* DWARF original prototype: void resize(HashMap<char*,_Module*> * this) */\nvoid __thiscall HashMap<char*,_Module*>::[FUNC1] (TYPE17 [VAR1] )\n{\n  int iVar1;\n  Hash_t **ppHVar2;\n  Hash *pHVar3;\n  Hash_t *pHVar4;\n  int iVar5;\n  Hash_t **ppHVar6;\n  [TYPE2] [VAR2] ;\n  TYPE48 [VAR4] ;\n  TYPE54 [VAR5] ;\n  TYPE33 [VAR3] ;\n  \n  iVar1 = [VAR1] ->hash_sz;\n  iVar5 = iVar1 * 2 + 1;\n  [VAR1] ->hash_sz = iVar5;\n  ppHVar2 = [VAR1] ->hashTable;\n  if ((ulong)(long)iVar5 < 0x1000000000000000) {\n    ppHVar6 = (Hash_t **)[FUNC3] ((long)iVar5 << 3);\n    [VAR1] ->hashTable = ppHVar6;\n    if (0 < [VAR1] ->hash_sz) {\n      iVar5 = 0;\n      do {\n        [VAR1] ->hashTable[iVar5] = (Hash_t *)0x0;\n        iVar5 = iVar5 + 1;\n      } while (iVar5 < [VAR1] ->hash_sz);\n    }\n    [VAR1] ->nelem = 0;\n    if (0 < iVar1) {\n      ppHVar6 = ppHVar2;\n      do {\n        pHVar4 = *ppHVar6;\n        while (pHVar4 != (Hash_t *)0x0) {\n          [FUNC6] ([VAR1] ,pHVar4->key,pHVar4->val);\n          pHVar3 = pHVar4->next;\n          [FUNC4] (pHVar4,0x18);\n          pHVar4 = pHVar3;\n        }\n        ppHVar6 = ppHVar6 + 1;\n      } while (ppHVar6 != ppHVar2 + (ulong)(iVar1 - 1) + 1);\n    }\n    if (ppHVar2 != (Hash_t **)0x0) {\n      [FUNC2] (ppHVar2);\n    }\n    return;\n  }\n  [FUNC5] ();\n}", "answer": {"VAR1": "this", "VAR2": "old_hash_sz", "VAR3": "old_hash_table", "VAR4": "p", "VAR5": "old_p", "FUNC2": "operator.delete[]", "FUNC3": "operator.new[]", "FUNC1": "resize", "FUNC6": "put", "TYPE3": "Hash_t * *", "TYPE2": "int", "FUNC4": "operator.delete", "TYPE5": "Hash_t *", "FUNC5": "__cxa_throw_bad_array_new_length", "TYPE4": "Hash_t *", "TYPE1": "HashMap<char*,_Module*> *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R12,RDI\nMOV EBX,dword ptr [RDI + 0x14]\nLEA EDI,[RBX + RBX*0x1 + 0x1]\nMOV dword ptr [R12 + 0x14],EDI\nMOV R14,qword ptr [R12]\nMOVSXD RDI,EDI\nMOV RAX,0xfffffffffffffff\nCMP RDI,RAX\nJA 0x000dea68\nSHL RDI,0x3\nCALL 0x0008fa60\nMOV qword ptr [R12],RAX\nCMP dword ptr [R12 + 0x14],0x0\nJLE 0x000dea4e\nMOV EAX,0x0\nMOVSXD RCX,EAX\nMOV RDX,qword ptr [R12]\nMOV qword ptr [RDX + RCX*0x8],0x0\nADD EAX,0x1\nCMP dword ptr [R12 + 0x14],EAX\nJG 0x000dea35\nMOV dword ptr [R12 + 0x18],0x0\nTEST EBX,EBX\nJLE 0x000deaa9\nMOV R13,R14\nLEA EAX,[RBX + -0x1]\nLEA R15,[R14 + RAX*0x8 + 0x8]\nJMP 0x000dea76\nCALL 0x000902e0\nADD R13,0x8\nCMP R13,R15\nJZ 0x000deaa9\nMOV RBX,qword ptr [R13]\nTEST RBX,RBX\nJZ 0x000dea6d\nMOV RDX,qword ptr [RBX + 0x8]\nMOV RSI,qword ptr [RBX]\nMOV RDI,R12\nCALL 0x000deac6\nMOV RBP,qword ptr [RBX + 0x10]\nMOV ESI,0x18\nMOV RDI,RBX\nCALL 0x0008ffa0\nMOV RBX,RBP\nTEST RBP,RBP\nJNZ 0x000dea7f\nJMP 0x000dea6d\nTEST R14,R14\nJZ 0x000deab6\nMOV RDI,R14\nCALL 0x000901e0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "100": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] ,TYPE21 [VAR2] ,TYPE30 [VAR3] )\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = [FUNC3] ((EVP_PKEY *)[VAR3] ->p2);\n  iVar2 = 0;\n  if (iVar1 == 6) {\n    iVar2 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,7);\n  }\n  return iVar2;\n}", "answer": {"VAR1": "state", "VAR2": "translation", "VAR3": "ctx", "FUNC2": "get_rsa_payload_factor", "FUNC3": "EVP_PKEY_get_base_id", "FUNC1": "get_rsa_payload_f8", "TYPE3": "translation_ctx_st *", "TYPE2": "translation_st *", "TYPE1": "state"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV EBP,EDI\nMOV R12,RSI\nMOV RBX,RDX\nMOV RDI,qword ptr [RDX + 0x20]\nCALL 0x0008cd05\nMOV EDX,0x0\nCMP EAX,0x6\nJZ 0x00182061\nMOV EAX,EDX\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV ECX,0x7\nMOV RDX,RBX\nMOV RSI,R12\nMOV EDI,EBP\nCALL 0x00181f0a\nMOV EDX,EAX\nJMP 0x0018205a\n"}, "101": {"funcbody": "driver_return_code_t\n[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,[TYPE5] [VAR5] )\n{\n  driver_return_code_t dVar1;\n  \n  switch([VAR4] ) {\n  case CDIO_READ_MODE_AUDIO:\n    dVar1 = [FUNC4] ([VAR1] ,[VAR2] ,[VAR3] ,[VAR5] );\n    break;\n  case CDIO_READ_MODE_M1F1:\n    dVar1 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,false,[VAR5] );\n    break;\n  case CDIO_READ_MODE_M1F2:\n    dVar1 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,true,[VAR5] );\n    break;\n  case CDIO_READ_MODE_M2F1:\n    dVar1 = [FUNC3] ([VAR1] ,[VAR2] ,[VAR3] ,false,[VAR5] );\n    break;\n  case CDIO_READ_MODE_M2F2:\n    dVar1 = [FUNC3] ([VAR1] ,[VAR2] ,[VAR3] ,true,[VAR5] );\n    break;\n  default:\n    return DRIVER_OP_ERROR;\n  }\n  return dVar1;\n}", "answer": {"VAR1": "p_cdio", "VAR2": "p_buf", "VAR3": "i_lsn", "VAR4": "read_mode", "VAR5": "i_blocks", "FUNC2": "cdio_read_mode1_sectors", "FUNC3": "cdio_read_mode2_sectors", "FUNC1": "cdio_read_sectors", "TYPE3": "lsn_t", "TYPE2": "void *", "FUNC4": "cdio_read_audio_sectors", "TYPE5": "uint32_t", "TYPE4": "cdio_read_mode_t", "TYPE1": "CdIo_t *"}, "assembly": "MOV EAX,0xffffffff\nCMP ECX,0x4\nJA 0x000182e4\nSUB RSP,0x8\nMOV EAX,ECX\nLEA RCX,[0x1e0a0]\nMOVSXD RAX,dword ptr [RCX + RAX*0x4]\nADD RAX,RCX\nJMP RAX\nMOV ECX,R8D\nCALL 0x00006f20\nADD RSP,0x8\nRET\nMOV ECX,0x0\nCALL 0x00007250\nJMP 0x000182af\nMOV ECX,0x1\nCALL 0x00007250\nJMP 0x000182af\nMOV ECX,0x0\nCALL 0x00006af0\nJMP 0x000182af\nMOV ECX,0x1\nCALL 0x00006af0\nJMP 0x000182af\nRET\n"}, "102": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  undefined8 uVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  TYPE30 [VAR3] ;\n  TYPE21 [VAR2] ;\n  \n  iVar2 = [FUNC3] ();\n  if (iVar2 == 0) {\n    puVar3 = (undefined8 *)0x0;\n  }\n  else {\n    puVar3 = (undefined8 *)[FUNC2] (0xd8,\"providers/implementations/digests/sha2_prov.c\",0x5e);\n    if (puVar3 != (undefined8 *)0x0) {\n      uVar1 = *(undefined8 *)((long)[VAR1] + 8);\n      *puVar3 = *[VAR1] ;\n      puVar3[1] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0x18);\n      puVar3[2] = *(undefined8 *)((long)[VAR1] + 0x10);\n      puVar3[3] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0x28);\n      puVar3[4] = *(undefined8 *)((long)[VAR1] + 0x20);\n      puVar3[5] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0x38);\n      puVar3[6] = *(undefined8 *)((long)[VAR1] + 0x30);\n      puVar3[7] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0x48);\n      puVar3[8] = *(undefined8 *)((long)[VAR1] + 0x40);\n      puVar3[9] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0x58);\n      puVar3[10] = *(undefined8 *)((long)[VAR1] + 0x50);\n      puVar3[0xb] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0x68);\n      puVar3[0xc] = *(undefined8 *)((long)[VAR1] + 0x60);\n      puVar3[0xd] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0x78);\n      puVar3[0xe] = *(undefined8 *)((long)[VAR1] + 0x70);\n      puVar3[0xf] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0x88);\n      puVar3[0x10] = *(undefined8 *)((long)[VAR1] + 0x80);\n      puVar3[0x11] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0x98);\n      puVar3[0x12] = *(undefined8 *)((long)[VAR1] + 0x90);\n      puVar3[0x13] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0xa8);\n      puVar3[0x14] = *(undefined8 *)((long)[VAR1] + 0xa0);\n      puVar3[0x15] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 0xb8);\n      puVar3[0x16] = *(undefined8 *)((long)[VAR1] + 0xb0);\n      puVar3[0x17] = uVar1;\n      uVar1 = *(undefined8 *)((long)[VAR1] + 200);\n      puVar3[0x18] = *(undefined8 *)((long)[VAR1] + 0xc0);\n      puVar3[0x19] = uVar1;\n      puVar3[0x1a] = *(undefined8 *)((long)[VAR1] + 0xd0);\n    }\n  }\n  return puVar3;\n}", "answer": {"VAR1": "ctx", "VAR2": "in", "VAR3": "ret", "FUNC2": "FUNC1", "FUNC3": "ossl_prov_is_running", "FUNC1": "sha512_256_dupctx", "TYPE3": "SHA512_CTX *", "TYPE2": "SHA512_CTX *", "TYPE1": "void *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCALL 0x000ffe66\nTEST EAX,EAX\nJZ 0x00114ed5\nMOV EDX,0x5e\nLEA RSI,[0x297d78]\nMOV EDI,0xd8\nCALL 0x000cfaa2\nTEST RAX,RAX\nJZ 0x00114ed3\nMOV RSI,qword ptr [RBX]\nMOV RDI,qword ptr [RBX + 0x8]\nMOV qword ptr [RAX],RSI\nMOV qword ptr [RAX + 0x8],RDI\nMOV RSI,qword ptr [RBX + 0x10]\nMOV RDI,qword ptr [RBX + 0x18]\nMOV qword ptr [RAX + 0x10],RSI\nMOV qword ptr [RAX + 0x18],RDI\nMOV RSI,qword ptr [RBX + 0x20]\nMOV RDI,qword ptr [RBX + 0x28]\nMOV qword ptr [RAX + 0x20],RSI\nMOV qword ptr [RAX + 0x28],RDI\nMOV RSI,qword ptr [RBX + 0x30]\nMOV RDI,qword ptr [RBX + 0x38]\nMOV qword ptr [RAX + 0x30],RSI\nMOV qword ptr [RAX + 0x38],RDI\nMOV RSI,qword ptr [RBX + 0x40]\nMOV RDI,qword ptr [RBX + 0x48]\nMOV qword ptr [RAX + 0x40],RSI\nMOV qword ptr [RAX + 0x48],RDI\nMOV RSI,qword ptr [RBX + 0x50]\nMOV RDI,qword ptr [RBX + 0x58]\nMOV qword ptr [RAX + 0x50],RSI\nMOV qword ptr [RAX + 0x58],RDI\nMOV RSI,qword ptr [RBX + 0x60]\nMOV RDI,qword ptr [RBX + 0x68]\nMOV qword ptr [RAX + 0x60],RSI\nMOV qword ptr [RAX + 0x68],RDI\nMOV RSI,qword ptr [RBX + 0x70]\nMOV RDI,qword ptr [RBX + 0x78]\nMOV qword ptr [RAX + 0x70],RSI\nMOV qword ptr [RAX + 0x78],RDI\nMOV RSI,qword ptr [RBX + 0x80]\nMOV RDI,qword ptr [RBX + 0x88]\nMOV qword ptr [RAX + 0x80],RSI\nMOV qword ptr [RAX + 0x88],RDI\nMOV RSI,qword ptr [RBX + 0x90]\nMOV RDI,qword ptr [RBX + 0x98]\nMOV qword ptr [RAX + 0x90],RSI\nMOV qword ptr [RAX + 0x98],RDI\nMOV RSI,qword ptr [RBX + 0xa0]\nMOV RDI,qword ptr [RBX + 0xa8]\nMOV qword ptr [RAX + 0xa0],RSI\nMOV qword ptr [RAX + 0xa8],RDI\nMOV RSI,qword ptr [RBX + 0xb0]\nMOV RDI,qword ptr [RBX + 0xb8]\nMOV qword ptr [RAX + 0xb0],RSI\nMOV qword ptr [RAX + 0xb8],RDI\nMOV RSI,qword ptr [RBX + 0xc0]\nMOV RDI,qword ptr [RBX + 0xc8]\nMOV qword ptr [RAX + 0xc0],RSI\nMOV qword ptr [RAX + 0xc8],RDI\nMOV RDX,qword ptr [RBX + 0xd0]\nMOV qword ptr [RAX + 0xd0],RDX\nPOP RBX\nRET\nMOV EAX,0x0\nJMP 0x00114ed3\n"}, "103": {"funcbody": "ulong [FUNC1] (undefined8 param_1,undefined8 param_2,undefined8 param_3)\n{\n  ulong uVar1;\n  long in_FS_OFFSET;\n  [TYPE4] [VAR4] ;\n  undefined4 [VAR3] ;\n  undefined **[VAR2] ;\n  long [VAR1] ;\n  \n  [VAR1] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR2] = &PTR_s_cpucount_0174d7c0;\n  uVar1 = [FUNC4] (&[VAR2] ,&PTR_s_count_01668620,param_3,&[VAR3] );\n  if ((int)uVar1 == 0) {\n    [FUNC2] ([VAR3] );\n    uVar1 = uVar1 & 0xffffffff;\n  }\n  if ([VAR1] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar1;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "local_10", "VAR2": "local_18", "VAR3": "local_1c", "VAR4": "local_2c", "FUNC2": "FUN_00fc2ea0", "FUNC3": "__stack_chk_fail", "FUNC1": "FUN_001cc2c0", "TYPE3": "undefined4", "TYPE2": "undefined8", "FUNC4": "FUN_00fdb940", "TYPE4": "undefined4", "TYPE1": "undefined8"}, "assembly": "SUB RSP,0x38\nLEA RSI,[0x1668620]\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x28],RAX\nXOR EAX,EAX\nLEA RCX,[RSP + 0x1c]\nLEA RAX,[0x174d7c0]\nLEA RDI,[RSP + 0x20]\nMOV qword ptr [RSP + 0x20],RAX\nCALL 0x00fdb940\nTEST EAX,EAX\nJNZ 0x001cc30b\nMOV EDI,dword ptr [RSP + 0x1c]\nMOV dword ptr [RSP + 0xc],EAX\nCALL 0x00fc2ea0\nMOV EAX,dword ptr [RSP + 0xc]\nMOV RSI,qword ptr [RSP + 0x28]\nXOR RSI,qword ptr FS:[0x28]\nJNZ 0x001cc320\nADD RSP,0x38\nRET\nCALL 0x0010e490\n"}, "104": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  int iVar1;\n  [TYPE7] [VAR7] ;\n  [TYPE8] [VAR8] ;\n  \n  iVar1 = [FUNC2] ();\n  if (iVar1 != 0) {\n    if ([VAR4] < [VAR6] ) {\n      [FUNC4] ();\n      [FUNC5] (\"providers/implementations/ciphers/ciphercommon.c\",0x212,\"ossl_cipher_generic_cipher\");\n      [FUNC3] (0x39,0x6a,(char *)0x0);\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = (**(code **)(*(long *)((long)[VAR1] + 0xa8) + 8))([VAR1] ,[VAR2] ,[VAR5] ,[VAR6] );\n      if (iVar1 == 0) {\n        [FUNC4] ();\n        [FUNC5] (\"providers/implementations/ciphers/ciphercommon.c\",0x217,\"ossl_cipher_generic_cipher\")\n        ;\n        [FUNC3] (0x39,0x66,(char *)0x0);\n        iVar1 = 0;\n      }\n      else {\n        *[VAR3] = [VAR6] ;\n        iVar1 = 1;\n      }\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "vctx", "VAR2": "out", "VAR3": "outl", "VAR4": "outsize", "VAR5": "in", "VAR6": "inl", "FUNC2": "ossl_prov_is_running", "FUNC3": "ERR_set_error", "FUNC1": "ossl_cipher_generic_cipher", "TYPE3": "size_t *", "TYPE2": "uchar *", "FUNC4": "ERR_new", "TYPE5": "uchar *", "FUNC5": "ERR_set_debug", "TYPE4": "size_t", "TYPE7": "PROV_CIPHER_CTX *", "TYPE6": "size_t", "TYPE8": "undefined8", "VAR7": "ctx", "VAR8": "local_40", "TYPE1": "void *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV R12,RDI\nMOV R14,RSI\nMOV qword ptr [RSP + 0x8],RDX\nMOV R13,RCX\nMOV R15,R8\nMOV RBP,R9\nCALL 0x000da70b\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x0011d965\nCMP R13,RBP\nJC 0x0011d976\nMOV RAX,qword ptr [R12 + 0xa8]\nMOV RCX,RBP\nMOV RDX,R15\nMOV RSI,R14\nMOV RDI,R12\nCALL qword ptr [RAX + 0x8]\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x0011d9b3\nMOV RAX,qword ptr [RSP + 0x8]\nMOV qword ptr [RAX],RBP\nMOV EBX,0x1\nMOV EAX,EBX\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nCALL 0x0008cf23\nLEA RDX,[0x2859b0]\nMOV ESI,0x212\nLEA RDI,[0x2858e0]\nCALL 0x0008d030\nMOV EDX,0x0\nMOV ESI,0x6a\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x0008d347\nMOV EBX,0x0\nJMP 0x0011d965\nCALL 0x0008cf23\nLEA RDX,[0x2859b0]\nMOV ESI,0x217\nLEA RDI,[0x2858e0]\nCALL 0x0008d030\nMOV EDX,0x0\nMOV ESI,0x66\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x0008d347\nJMP 0x0011d965\n"}, "105": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  void *pvVar1;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  pvVar1 = [FUNC3] ([VAR1] ,[VAR2] );\n  if (pvVar1 == (void *)0x0) {\n    [FUNC2] ();\n  }\n  return pvVar1;\n}", "answer": {"VAR1": "p", "VAR2": "size", "VAR3": "newp", "VAR4": "p-local", "VAR5": "size-local", "FUNC2": "mu_alloc_die", "FUNC3": "realloc", "FUNC1": "mu_realloc", "TYPE3": "void *", "TYPE2": "size_t", "TYPE5": "size_t", "TYPE4": "void *", "TYPE1": "void *"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nSUB RSP,0x20\nMOV qword ptr [RBP + -0x18],RDI\nMOV qword ptr [RBP + -0x20],RSI\nMOV RDX,qword ptr [RBP + -0x20]\nMOV RAX,qword ptr [RBP + -0x18]\nMOV RSI,RDX\nMOV RDI,RAX\nCALL 0x000279f0\nMOV qword ptr [RBP + -0x8],RAX\nCMP qword ptr [RBP + -0x8],0x0\nJNZ 0x0002abc7\nCALL 0x00024d50\nMOV RAX,qword ptr [RBP + -0x8]\nLEAVE\nRET\n"}, "106": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  wchar_t wVar1;\n  char *pcVar2;\n  [TYPE3] [VAR3] ;\n  byte *s1;\n  [TYPE4] [VAR4] ;\n  \n  pcVar2 = (char *)[FUNC2] (0,[VAR1] ,5);\n  if ([VAR1] == pcVar2) {\n    s1 = (byte *)[FUNC3] ();\n    if ((*s1 & 0xdf) == 0x55) {\n      if (((((s1[1] & 0xdf) == 0x54) && ((s1[2] & 0xdf) == 0x46)) && (s1[3] == 0x2d)) &&\n         (wVar1 = [FUNC4] ((char *)s1,\"UTF-8\",'8','\\0','\\0','\\0','\\0'), wVar1 != L'\\0')) {\n        if (*[VAR1] == '`') {\n          return &DAT_0001d31b;\n        }\n        return &DAT_0001d30c;\n      }\n    }\n    else if ((((*s1 & 0xdf) == 0x47) && ((s1[1] & 0xdf) == 0x42)) &&\n            ((s1[2] == 0x31 &&\n             ((s1[3] == 0x38 &&\n              (wVar1 = [FUNC4] ((char *)s1,\"GB18030\",'0','3','0','\\0','\\0'), wVar1 != L'\\0')))))) {\n      if (*[VAR1] == '`') {\n        return &DAT_0001d317;\n      }\n      return &DAT_0001d310;\n    }\n    pcVar2 = \"\\\"\";\n    if ([VAR2] != clocale_quoting_style) {\n      pcVar2 = \"\\'\";\n    }\n  }\n  return pcVar2;\n}", "answer": {"VAR1": "msgid", "VAR2": "s", "VAR3": "translation", "VAR4": "locale_code", "FUNC2": "dcgettext", "FUNC3": "locale_charset", "FUNC1": "gettext_quote", "TYPE3": "char *", "TYPE2": "quoting_style", "FUNC4": "strcaseeq4", "TYPE4": "char *", "TYPE1": "char *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV EBP,ESI\nMOV EDX,0x5\nMOV RSI,RDI\nMOV EDI,0x0\nCALL 0x000031c0\nCMP RBX,RAX\nJZ 0x0000f8e4\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x00016f4f\nMOVZX EDX,byte ptr [RAX]\nAND EDX,0xffffffdf\nCMP DL,0x55\nJZ 0x0000f972\nCMP DL,0x47\nJNZ 0x0000f9dd\nMOVZX EDX,byte ptr [RAX + 0x1]\nAND EDX,0xffffffdf\nCMP DL,0x42\nJNZ 0x0000f9dd\nCMP byte ptr [RAX + 0x2],0x31\nJNZ 0x0000f9dd\nCMP byte ptr [RAX + 0x3],0x38\nJNZ 0x0000f9dd\nSUB RSP,0x8\nPUSH 0x0\nMOV R9D,0x0\nMOV R8D,0x30\nMOV ECX,0x33\nMOV EDX,0x30\nLEA RSI,[0x1d325]\nMOV RDI,RAX\nCALL 0x0000f77c\nADD RSP,0x10\nTEST EAX,EAX\nJZ 0x0000f9dd\nCMP byte ptr [RBX],0x60\nLEA RAX,[0x1d317]\nLEA RDX,[0x1d310]\nCMOVNZ RAX,RDX\nJMP 0x0000f8dd\nMOVZX EDX,byte ptr [RAX + 0x1]\nAND EDX,0xffffffdf\nCMP DL,0x54\nJNZ 0x0000f9dd\nMOVZX EDX,byte ptr [RAX + 0x2]\nAND EDX,0xffffffdf\nCMP DL,0x46\nJNZ 0x0000f9dd\nCMP byte ptr [RAX + 0x3],0x2d\nJNZ 0x0000f9dd\nSUB RSP,0x8\nPUSH 0x0\nMOV R9D,0x0\nMOV R8D,0x0\nMOV ECX,0x0\nMOV EDX,0x38\nLEA RSI,[0x1d31f]\nMOV RDI,RAX\nCALL 0x0000f77c\nADD RSP,0x10\nTEST EAX,EAX\nJZ 0x0000f9dd\nCMP byte ptr [RBX],0x60\nLEA RAX,[0x1d31b]\nLEA RDX,[0x1d30c]\nCMOVNZ RAX,RDX\nJMP 0x0000f8dd\nCMP EBP,0x9\nLEA RAX,[0x1d315]\nLEA RDX,[0x1d313]\nCMOVNZ RAX,RDX\nJMP 0x0000f8dd\n"}, "107": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  wchar_t wVar1;\n  \n  if ([VAR2] < L'\\0') {\n    [FUNC2] ([VAR1] ,-[VAR2] );\n  }\n  else if ([VAR2] != L'\\0') {\n    do {\n      wVar1 = [FUNC3] ([VAR1] ,L'\\0');\n      if (wVar1 != L'\\0') {\n        return;\n      }\n      [VAR2] = [VAR2] + L'\\xffffffff';\n    } while ([VAR2] != L'\\0');\n  }\n  return;\n}", "answer": {"VAR1": "window", "VAR2": "count", "FUNC2": "info_global_next_node", "FUNC3": "backward_move_node_structure", "FUNC1": "info_global_prev_node", "TYPE2": "wchar_t", "TYPE1": "WINDOW *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV EBX,ESI\nTEST ESI,ESI\nJS 0x0001ff25\nTEST ESI,ESI\nJZ 0x0001ff1e\nMOV ESI,0x0\nMOV RDI,RBP\nCALL 0x0001ec6f\nTEST EAX,EAX\nJNZ 0x0001ff1e\nSUB EBX,0x1\nJNZ 0x0001ff08\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nNEG ESI\nCALL 0x0001ff2e\nJMP 0x0001ff1e\n"}, "108": {"funcbody": "/* DWARF original prototype: void wait_queues(DbeThreadPool * this) */\nvoid __thiscall DbeThreadPool::[FUNC1] ([TYPE1] [VAR1] )\n{\n  [TYPE3] [VAR3] ;\n  DbeQueue *pDVar1;\n  [TYPE2] [VAR2] ;\n  long lVar2;\n  long in_FS_OFFSET;\n  [TYPE5] [VAR5] ;\n  long [VAR4] ;\n  \n  [VAR4] = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC6] ((pthread_mutex_t *)[VAR1] );\n  [VAR1] ->no_new_queues = true;\n  [FUNC2] ((pthread_mutex_t *)[VAR1] );\n  [FUNC8] ((pthread_cond_t *)&[VAR1] ->p_cond_var);\n  while( true ) {\n    pDVar1 = [FUNC3] ([VAR1] );\n    if (pDVar1 == (DbeQueue *)0x0) break;\n    (*pDVar1->func)(pDVar1->arg);\n    [FUNC5] (pDVar1,0x20);\n  }\n  [VAR3] = ([TYPE3] )[VAR1] ->threads->count;\n  if (0 < [VAR3] ) {\n    lVar2 = 0;\n    do {\n      [FUNC7] (*(pthread_t *)((long)[VAR1] ->threads->data + lVar2),&[VAR5] );\n      lVar2 = lVar2 + 8;\n    } while (lVar2 != (ulong)([VAR3] - 1) * 8 + 8);\n  }\n  if ([VAR4] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC4] ();\n}", "answer": {"VAR1": "this", "VAR2": "q", "VAR3": "sz", "VAR4": "local_30", "VAR5": "retval", "FUNC2": "pthread_mutex_unlock", "FUNC3": "get_queue", "FUNC1": "wait_queues", "FUNC6": "pthread_mutex_lock", "TYPE3": "int", "FUNC7": "pthread_join", "TYPE2": "DbeQueue *", "FUNC4": "__stack_chk_fail", "TYPE5": "void *", "FUNC5": "operator.delete", "TYPE4": "undefined8", "FUNC8": "pthread_cond_broadcast", "TYPE1": "DbeThreadPool *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBP,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nCALL 0x0008fd50\nMOV byte ptr [RBP + 0x58],0x1\nMOV RDI,RBP\nCALL 0x0008f870\nLEA RDI,[RBP + 0x28]\nCALL 0x0008f5b0\nMOV RDI,RBP\nCALL 0x000a2a56\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000a2d40\nMOV RDI,qword ptr [RAX + 0x8]\nCALL qword ptr [RBX]\nMOV ESI,0x20\nMOV RDI,RBX\nCALL 0x0008f9b0\nJMP 0x000a2d1b\nMOV RAX,qword ptr [RBP + 0x60]\nMOV RAX,qword ptr [RAX + 0x10]\nTEST EAX,EAX\nJLE 0x000a2d7c\nLEA EAX,[RAX + -0x1]\nLEA R13,[0x8 + RAX*0x8]\nMOV EBX,0x0\nMOV R12,RSP\nMOV RAX,qword ptr [RBP + 0x60]\nMOV RAX,qword ptr [RAX + 0x8]\nMOV RDI,qword ptr [RAX + RBX*0x1]\nMOV RSI,R12\nCALL 0x0008f6a0\nADD RBX,0x8\nCMP RBX,R13\nJNZ 0x000a2d5f\nMOV RAX,qword ptr [RSP + 0x8]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x000a2d97\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nCALL 0x0008fab0\n"}, "109": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  int iVar1;\n  ASN1_TIME *a;\n  [TYPE7] [VAR7] ;\n  ASN1_TIME *b;\n  [TYPE8] [VAR8] ;\n  char *pcVar2;\n  char *pcVar3;\n  int iVar4;\n  [TYPE9] [VAR9] ;\n  \n  a = [FUNC6] ((ASN1_TIME *)0x0,[VAR5] );\n  b = [FUNC6] ((ASN1_TIME *)0x0,[VAR6] );\n  if ((a != (ASN1_TIME *)0x0) && (b != (ASN1_TIME *)0x0)) {\n    iVar1 = [FUNC3] ((ASN1_TIME *)a,(ASN1_TIME *)b);\n    iVar4 = 1;\n    if (iVar1 < 0) goto LAB_00067b07;\n  }\n  pcVar2 = [FUNC5] ((ASN1_TIME *)b);\n  pcVar3 = [FUNC5] ((ASN1_TIME *)a);\n  [FUNC4] ((char *)0x0,[VAR1] ,[VAR2] ,\"time_t\",[VAR3] ,[VAR4] ,\"<\",\"[%s] compared to [%s]\",pcVar3,pcVar2);\n  iVar4 = 0;\nLAB_00067b07:\n  [FUNC2] (a);\n  [FUNC2] (b);\n  return iVar4;\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "s1", "VAR4": "s2", "VAR5": "t1", "VAR6": "t2", "FUNC2": "ASN1_STRING_free", "FUNC3": "ASN1_TIME_compare", "FUNC1": "test_time_t_lt", "FUNC6": "ASN1_TIME_set", "TYPE3": "char *", "TYPE2": "int", "FUNC4": "test_fail_message", "TYPE5": "time_t", "FUNC5": "print_time", "TYPE4": "char *", "TYPE7": "ASN1_TIME *", "TYPE6": "time_t", "TYPE9": "undefined8", "TYPE8": "ASN1_TIME *", "VAR7": "at1", "VAR8": "at2", "VAR9": "local_40", "TYPE1": "char *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV qword ptr [RSP + 0x8],RDI\nMOV R13D,ESI\nMOV R14,RDX\nMOV R15,RCX\nMOV RBP,R9\nMOV RSI,R8\nMOV EDI,0x0\nCALL 0x0006b9d4\nMOV RBX,RAX\nMOV RSI,RBP\nMOV EDI,0x0\nCALL 0x0006b9d4\nMOV RBP,RAX\nTEST RBX,RBX\nJZ 0x00067ab3\nTEST RAX,RAX\nJZ 0x00067ab3\nMOV RSI,RAX\nMOV RDI,RBX\nCALL 0x0006c155\nMOV R12D,0x1\nTEST EAX,EAX\nJS 0x00067b07\nMOV RDI,RBP\nCALL 0x00064f5d\nMOV R12,RAX\nMOV RDI,RBX\nCALL 0x00064f5d\nPUSH R12\nPUSH RAX\nLEA RAX,[0x25dee6]\nPUSH RAX\nLEA RAX,[0x25ddd1]\nPUSH RAX\nMOV R9,R15\nMOV R8,R14\nLEA RCX,[0x25dedf]\nMOV EDX,R13D\nMOV RSI,qword ptr [RSP + 0x28]\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x00065092\nADD RSP,0x20\nMOV R12D,0x0\nMOV RDI,RBX\nCALL 0x0006cb1f\nMOV RDI,RBP\nCALL 0x0006cb1f\nMOV EAX,R12D\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "110": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  char *pcVar1;\n  undefined8 uVar2;\n  \n  [FUNC3] (stdout);\n  pcVar1 = prgr_name;\n  uVar2 = [FUNC4] (0,\"\\n%s: program aborted by signal %d\\n\",5);\n  [FUNC5] (stderr,1,uVar2,pcVar1,[VAR1] );\n  [FUNC2] (3);\n}", "answer": {"VAR1": "the_signal", "FUNC2": "exit", "FUNC3": "rpl_fflush", "FUNC1": "handle_signal", "FUNC4": "dcgettext", "FUNC5": "__fprintf_chk", "TYPE1": "int"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV EBP,EDI\nMOV RDI,qword ptr [0x00203020]\nCALL 0x000022a6\nMOV RBX,qword ptr [0x00203060]\nMOV EDX,0x5\nLEA RSI,[0x25a8]\nMOV EDI,0x0\nCALL 0x00000d20\nMOV R8D,EBP\nMOV RCX,RBX\nMOV RDX,RAX\nMOV ESI,0x1\nMOV RDI,qword ptr [0x00203040]\nMOV EAX,0x0\nCALL 0x00000e60\nMOV EDI,0x3\nCALL 0x00000e50\n"}, "111": {"funcbody": "int [FUNC5] (TYPE17 [VAR1] ,TYPE23 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         TYPE59 [VAR5] )\n{\n  char cVar1;\n  int iVar2;\n  OPENSSL_STACK *st;\n  TYPE64 [VAR6] ;\n  void *pvVar3;\n  TYPE76 [VAR7] ;\n  ulong uVar4;\n  int iVar5;\n  char *pcVar6;\n  long lVar7;\n  long in_FS_OFFSET;\n  byte bVar8;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  TYPE94 [VAR9] ;\n  long [VAR8] ;\n  \n  bVar8 = 0;\n  [VAR8] = *(long *)(in_FS_OFFSET + 0x28);\n  st = (OPENSSL_STACK *)[FUNC6] ((CONF *)[VAR5] ,[VAR4] );\n  if (st == (OPENSSL_STACK *)0x0) {\n    if ([VAR1] == (TYPE17)0x0) {\n      iVar5 = [FUNC2] ([VAR2] ,[VAR3] ,[VAR4] );\n    }\n    else {\n      iVar5 = [FUNC8] ([VAR1] ,[VAR3] ,[VAR4] );\n    }\n  }\n  else {\n    lVar7 = 0;\n    if ([VAR3] != (TYPE30x0) {\n      [FUNC9] ([VAR9] ,[VAR3] ,0x200);\n      [FUNC7] ([VAR9] ,\".\",0x200);\n      uVar4 = 0xffffffffffffffff;\n      pcVar6 = [VAR9] ;\n      do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + (ulong)bVar8 * -2 + 1;\n      } while (cVar1 != '\\0');\n      lVar7 = ~uVar4 - 1;\n    }\n    iVar5 = 0;\n    while( true ) {\n      iVar2 = [FUNC4] (st);\n      if (iVar2 <= iVar5) break;\n      pvVar3 = [FUNC10] (st,iVar5);\n      uVar4 = 0xffffffffffffffff;\n      pcVar6 = *(char **)((long)pvVar3 + 8);\n      do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + (ulong)bVar8 * -2 + 1;\n      } while (cVar1 != '\\0');\n      if (0x1ff < lVar7 + -1 + ~uVar4) {\nLAB_0024cc05:\n        iVar5 = 0;\n        goto LAB_0024cc0a;\n      }\n      [VAR9] [lVar7] = '\\0';\n      [FUNC7] ([VAR9] ,*(char **)((long)pvVar3 + 8),0x200);\n      iVar2 = [FUNC5] ([VAR1] ,[VAR2] ,[VAR9] ,*([TYPE4] *)((long)pvVar3 + 0x10),[VAR5] );\n      if (iVar2 == 0) goto LAB_0024cc05;\n      iVar5 = iVar5 + 1;\n    }\n    iVar5 = 1;\n  }\nLAB_0024cc0a:\n  if ([VAR8] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar5;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "prov", "VAR2": "provinfo", "VAR3": "name", "VAR4": "value", "FUNC10": "OPENSSL_sk_value", "VAR5": "cnf", "VAR6": "sect", "FUNC2": "ossl_provider_info_add_parameter", "FUNC3": "__stack_chk_fail", "FUNC1": "provider_conf_params", "FUNC6": "NCONF_get_section", "TYPE3": "char *", "FUNC7": "OPENSSL_strlcat", "TYPE2": "OSSL_PROVIDER_INFO *", "FUNC4": "OPENSSL_sk_num", "TYPE5": "CONF *", "FUNC5": "FUNC1", "TYPE4": "char *", "TYPE7": "CONF_VALUE *", "TYPE6": "stack_st_CONF_VALUE *", "FUNC8": "ossl_provider_add_parameter", "TYPE9": "char[512]", "FUNC9": "OPENSSL_strlcpy", "TYPE8": "undefined8", "VAR7": "sectconf", "TYPE11": "undefined8", "VAR8": "local_40", "VAR9": "buffer", "TYPE10": "undefined8", "VAR10": "local_250", "VAR11": "local_258", "TYPE1": "OSSL_PROVIDER *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x228\nMOV qword ptr [RSP],RDI\nMOV qword ptr [RSP + 0x8],RSI\nMOV RBX,RDX\nMOV RBP,RCX\nMOV R15,R8\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x218],RAX\nXOR EAX,EAX\nMOV RSI,RCX\nMOV RDI,R8\nCALL 0x0014e8d5\nTEST RAX,RAX\nJZ 0x0024cc2f\nMOV R13,RAX\nMOV R12D,0x0\nTEST RBX,RBX\nJZ 0x0024cb81\nLEA RBP,[RSP + 0x10]\nMOV EDX,0x200\nMOV RSI,RBX\nMOV RDI,RBP\nCALL 0x000a71e1\nMOV EDX,0x200\nLEA RSI,[0x2773f3]\nMOV RDI,RBP\nCALL 0x000a7254\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,RBP\nSCASB.REPNE RDI\nMOV RDX,RCX\nNOT RDX\nLEA R12,[RDX + -0x1]\nMOV EBX,0x0\nLEA R14,[RSP + 0x10]\nMOV RDI,R13\nCALL 0x000beb80\nCMP EAX,EBX\nJLE 0x0024cbfe\nMOV ESI,EBX\nMOV RDI,R13\nCALL 0x000beb8e\nMOV RBP,RAX\nMOV RDI,qword ptr [RAX + 0x8]\nMOV RCX,-0x1\nMOV EAX,0x0\nSCASB.REPNE RDI\nNOT RCX\nLEA RAX,[R12 + RCX*0x1 + -0x1]\nCMP RAX,0x1ff\nJA 0x0024cc05\nMOV byte ptr [RSP + R12*0x1 + 0x10],0x0\nMOV RSI,qword ptr [RBP + 0x8]\nMOV EDX,0x200\nMOV RDI,R14\nCALL 0x000a7254\nMOV RCX,qword ptr [RBP + 0x10]\nMOV R8,R15\nMOV RDX,R14\nMOV RSI,qword ptr [RSP + 0x8]\nMOV RDI,qword ptr [RSP]\nCALL 0x0024cae5\nTEST EAX,EAX\nJZ 0x0024cc05\nADD EBX,0x1\nJMP 0x0024cb8b\nMOV EAX,0x1\nJMP 0x0024cc0a\nMOV EAX,0x0\nMOV RDX,qword ptr [RSP + 0x218]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x0024cc57\nADD RSP,0x228\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV RDI,qword ptr [RSP]\nTEST RDI,RDI\nJZ 0x0024cc45\nMOV RDX,RBP\nMOV RSI,RBX\nCALL 0x000ac20f\nJMP 0x0024cc0a\nMOV RDX,RBP\nMOV RSI,RBX\nMOV RDI,qword ptr [RSP + 0x8]\nCALL 0x000ac221\nJMP 0x0024cc0a\nCALL 0x000627f0\n"}, "112": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  grub_err_t gVar1;\n  [TYPE4] [VAR4] ;\n  uint uVar2;\n  grub_disk_t source;\n  [TYPE3] [VAR3] ;\n  \n  source = [FUNC3] ([VAR1] );\n  if (source == (grub_disk_t)0x0) {\n    [FUNC5] ();\n    uVar2 = 0;\n  }\n  else {\n    gVar1 = [FUNC4] ([VAR1] ,source);\n    [FUNC2] (source);\n    if (gVar1 != GRUB_ERR_NONE) {\n      [FUNC5] ();\n    }\n    uVar2 = have_it;\n    if (have_it != 0) {\n      uVar2 = (uint)(search_uuid != (char *)0x0);\n    }\n  }\n  return uVar2;\n}", "answer": {"VAR1": "name", "VAR2": "data", "VAR3": "source", "VAR4": "err", "FUNC2": "grub_disk_close", "FUNC3": "grub_disk_open", "FUNC1": "grub_cryptodisk_scan_device", "TYPE3": "grub_disk_t", "TYPE2": "void *", "FUNC4": "grub_cryptodisk_scan_device_real", "FUNC5": "grub_print_error", "TYPE4": "grub_err_t", "TYPE1": "char *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nCALL 0x0000d4de\nTEST RAX,RAX\nJZ 0x000123a3\nMOV RBX,RAX\nMOV RSI,RAX\nMOV RDI,RBP\nCALL 0x00012287\nMOV EBP,EAX\nMOV RDI,RBX\nCALL 0x0000d455\nTEST EBP,EBP\nJNZ 0x000123af\nMOV EAX,dword ptr [0x00241cf0]\nTEST EAX,EAX\nJZ 0x0001239c\nCMP qword ptr [0x00241ce8],0x0\nSETNZ AL\nMOVZX EAX,AL\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x0000ade4\nMOV EAX,0x0\nJMP 0x0001239c\nCALL 0x0000ade4\nJMP 0x00012384\n"}, "113": {"funcbody": "termline * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  long lVar1;\n  wchar_t wVar2;\n  [TYPE4] [VAR4] ;\n  termline *ldata;\n  [TYPE5] [VAR5] ;\n  termchar *ptVar3;\n  long lVar4;\n  [TYPE3] [VAR3] ;\n  byte bVar5;\n  wchar_t wVar6;\n  long in_FS_OFFSET;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR7] .len = L'\\0';\n  bVar5 = 0;\n  wVar6 = L'\\0';\n  [VAR7] .data = [VAR1] ;\n  do {\n    wVar2 = [FUNC2] (&[VAR7] );\n    wVar6 = wVar6 | (wVar2 & 0x7fU) << (bVar5 & 0x1f);\n    bVar5 = bVar5 + 7;\n  } while ((wVar2 & 0x80U) != 0);\n  ldata = (termline *)[FUNC8] (1,0x20);\n  ptVar3 = (termchar *)[FUNC8] ((long)wVar6,0x18);\n  ldata->chars = ptVar3;\n  ldata->size = wVar6;\n  ldata->cols = wVar6;\n  ldata->temporary = L'\\x01';\n  ldata->cc_free = L'\\0';\n  if (L'\\0' < wVar6) {\n    lVar4 = 0;\n    wVar6 = L'\\0';\n    do {\n      *(undefined4 *)((long)&ldata->chars->cc_next + lVar4) = 0;\n      wVar6 = wVar6 + L'\\x01';\n      lVar4 = lVar4 + 0x18;\n    } while (wVar6 < ldata->cols);\n  }\n  ldata->lattr = 0;\n  bVar5 = 0;\n  do {\n    wVar6 = [FUNC2] (&[VAR7] );\n    ldata->lattr = ldata->lattr | (ushort)((wVar6 & 0x7fU) << (bVar5 & 0x1f));\n    bVar5 = bVar5 + 7;\n  } while ((wVar6 & 0x80U) != 0);\n  [FUNC7] (&[VAR7] ,ldata,[FUNC6] );\n  [FUNC7] (&[VAR7] ,ldata,[FUNC5] );\n  [FUNC7] (&[VAR7] ,ldata,[FUNC4] );\n  if ([VAR2] != ([TYPE2] )0x0) {\n    *[VAR2] = [VAR7] .len;\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return ldata;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "data", "VAR2": "bytes_used", "VAR3": "b", "VAR4": "byte", "VAR5": "ldata", "VAR6": "local_30", "FUNC2": "get", "FUNC3": "__stack_chk_fail", "FUNC1": "decompressline", "FUNC6": "readliteral_chr", "TYPE3": "buf *", "FUNC7": "readrle", "TYPE2": "wchar_t *", "FUNC4": "readliteral_cc", "TYPE5": "termline *", "FUNC5": "readliteral_attr", "TYPE4": "wchar_t", "TYPE7": "buf", "TYPE6": "undefined8", "FUNC8": "safemalloc", "VAR7": "buffer", "TYPE1": "uchar *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x20\nMOV R12,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],RDI\nMOV dword ptr [RSP + 0x8],0x0\nMOV EBP,0x0\nMOV R13D,0x0\nMOV R14,RSP\nMOV RDI,R14\nCALL 0x0002cce2\nMOV EDX,EAX\nAND EDX,0x7f\nMOV ECX,EBP\nSHL EDX,CL\nOR R13D,EDX\nADD EBP,0x7\nAND EAX,0x80\nMOV EBX,EAX\nJNZ 0x0002da2f\nMOV ESI,0x20\nMOV EDI,0x1\nCALL 0x000222ee\nMOV RBP,RAX\nMOVSXD RDI,R13D\nMOV ESI,0x18\nCALL 0x000222ee\nMOV qword ptr [RBP + 0x18],RAX\nMOV dword ptr [RBP + 0x8],R13D\nMOV dword ptr [RBP + 0x4],R13D\nMOV dword ptr [RBP + 0xc],0x1\nMOV dword ptr [RBP + 0x10],0x0\nTEST R13D,R13D\nJLE 0x0002daac\nMOV EDX,EBX\nMOV EAX,0x0\nMOV RCX,qword ptr [RBP + 0x18]\nMOV dword ptr [RCX + RAX*0x1 + 0x10],0x0\nADD EDX,0x1\nADD RAX,0x18\nCMP dword ptr [RBP + 0x4],EDX\nJG 0x0002da94\nMOV word ptr [RBP],0x0\nMOV R13,RSP\nMOV RDI,R13\nCALL 0x0002cce2\nMOV EDX,EAX\nAND EDX,0x7f\nMOV ECX,EBX\nSHL EDX,CL\nOR word ptr [RBP],DX\nADD EBX,0x7\nTEST AL,0x80\nJNZ 0x0002dab5\nMOV RBX,RSP\nLEA RDX,[0x2d681]\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x0002d852\nLEA RDX,[0x2ccf5]\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x0002d852\nLEA RDX,[0x2d7bc]\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x0002d852\nTEST R12,R12\nJZ 0x0002db17\nMOV EAX,dword ptr [RSP + 0x8]\nMOV dword ptr [R12],EAX\nMOV RAX,RBP\nMOV RSI,qword ptr [RSP + 0x18]\nXOR RSI,qword ptr FS:[0x28]\nJNZ 0x0002db37\nADD RSP,0x20\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nCALL 0x000111e0\n"}, "114": {"funcbody": "int [FUNC1] (TYPE17 [VAR1] ,[TYPE2] [VAR2] )\n{\n  BN_BLINDING **ppBVar1;\n  int iVar2;\n  rsa_st *prVar3;\n  \n  if (([VAR1] ->pkey).ptr == (void *)0x0) {\n    prVar3 = (rsa_st *)[FUNC2] ();\n    ([VAR1] ->pkey).rsa = prVar3;\n    if (prVar3 == (rsa_st *)0x0) {\n      return 0;\n    }\n  }\n  iVar2 = [FUNC3] (&(([VAR1] ->pkey).dsa)->params,&(([VAR2] ->pkey).dsa)->params);\n  if (iVar2 != 0) {\n    ppBVar1 = &(([VAR1] ->pkey).rsa)->blinding;\n    *ppBVar1 = (BN_BLINDING *)((long)&(*ppBVar1)->A + 1);\n    iVar2 = 1;\n  }\n  return iVar2;\n}", "answer": {"VAR1": "to", "VAR2": "from", "FUNC2": "DSA_new", "FUNC3": "ossl_ffc_params_copy", "FUNC1": "dsa_copy_parameters", "TYPE2": "EVP_PKEY *", "TYPE1": "EVP_PKEY *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RSI\nCMP qword ptr [RDI + 0x20],0x0\nJZ 0x001606ce\nMOV RSI,qword ptr [RBP + 0x20]\nADD RSI,0x8\nMOV RAX,qword ptr [RBX + 0x20]\nLEA RDI,[RAX + 0x8]\nCALL 0x001ab1b6\nTEST EAX,EAX\nJZ 0x001606c7\nMOV RAX,qword ptr [RBX + 0x20]\nADD qword ptr [RAX + 0xc0],0x1\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x00161dc5\nMOV RDX,RAX\nMOV qword ptr [RBX + 0x20],RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJNZ 0x0016069d\nJMP 0x001606c7\n"}, "115": {"funcbody": "EC_KEY * [FUNC1] (TYPE15 [VAR1] ,TYPE29 [VAR2] )\n{\n  EC_KEY *pEVar1;\n  TYPE33 [VAR3] ;\n  \n  if ([VAR1] == (TYPE15)0x0) {\n    pEVar1 = (EC_KEY *)0x0;\n  }\n  else {\n    pEVar1 = (EC_KEY *)[FUNC3] ((EVP_PKEY *)[VAR1] );\n    [FUNC2] ((EVP_PKEY *)[VAR1] );\n    if ((pEVar1 != (EC_KEY *)0x0) && ([VAR2] != (TYPE29)0x0)) {\n      [FUNC4] ((EC_KEY *)*[VAR2] );\n      *[VAR2] = pEVar1;\n    }\n  }\n  return pEVar1;\n}", "answer": {"VAR1": "key", "VAR2": "eckey", "VAR3": "dtmp", "FUNC2": "EVP_PKEY_free", "FUNC3": "EVP_PKEY_get1_EC_KEY", "FUNC1": "pkey_get_eckey", "TYPE3": "EC_KEY *", "TYPE2": "EC_KEY * *", "FUNC4": "EC_KEY_free", "TYPE1": "EVP_PKEY *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nTEST RDI,RDI\nJZ 0x001b5bc0\nMOV RBP,RSI\nMOV RBX,RDI\nCALL 0x0019f74b\nMOV R12,RAX\nMOV RDI,RBX\nCALL 0x0008e5cd\nTEST R12,R12\nJZ 0x001b5bb8\nTEST RBP,RBP\nJZ 0x001b5bb8\nMOV RDI,qword ptr [RBP]\nCALL 0x001644b6\nMOV qword ptr [RBP],R12\nMOV RAX,R12\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV R12D,0x0\nJMP 0x001b5bb8\n"}, "116": {"funcbody": "int [FUNC1] (TYPE14 [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  [TYPE3] [VAR3] ;\n  long in_FS_OFFSET;\n  [TYPE5] [VAR5] ;\n  long [VAR4] ;\n  \n  [VAR4] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR5] = (TYPE50x0;\n  if ([VAR1] ->data_type == 4) {\n    [VAR5] = ([TYPE5] [VAR1] ->data;\n    [VAR3] = ([TYPE3] )([VAR5] != (TYPE50x0);\n  }\n  else {\n    if ([VAR1] ->data_type != 6) {\n      [VAR3] = 0;\n      goto LAB_00184a41;\n    }\n    [VAR3] = [FUNC3] ([VAR1] ,&[VAR5] );\n  }\n  if ([VAR3] != 0) {\n    iVar1 = [FUNC2] ([VAR5] );\n    [VAR3] = 0;\n    if (-1 < iVar1) {\n      *[VAR2] = iVar1;\n      [VAR3] = 1;\n    }\n  }\nLAB_00184a41:\n  if ([VAR4] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return [VAR3] ;\n  }\n  [FUNC4] ();\n}", "answer": {"VAR1": "p", "VAR2": "id", "VAR3": "i", "VAR4": "local_10", "VAR5": "name", "FUNC2": "ossl_ec_encoding_name2id", "FUNC3": "OSSL_PARAM_get_utf8_ptr", "FUNC1": "ossl_ec_encoding_param2id", "TYPE3": "int", "TYPE2": "int *", "FUNC4": "__stack_chk_fail", "TYPE5": "char *", "TYPE4": "undefined8", "TYPE1": "OSSL_PARAM *"}, "assembly": "PUSH RBX\nSUB RSP,0x10\nMOV RBX,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],0x0\nMOV EAX,dword ptr [RDI + 0x8]\nCMP EAX,0x4\nJZ 0x00184a2c\nCMP EAX,0x6\nJZ 0x00184a57\nMOV EAX,0x0\nJMP 0x00184a41\nMOV RAX,qword ptr [RDI + 0x10]\nMOV qword ptr [RSP],RAX\nTEST RAX,RAX\nSETNZ AL\nMOVZX EAX,AL\nTEST EAX,EAX\nJNZ 0x00184a61\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00184a7e\nADD RSP,0x10\nPOP RBX\nRET\nMOV RSI,RSP\nCALL 0x000a3c2c\nJMP 0x00184a3d\nMOV RDI,qword ptr [RSP]\nCALL 0x00183b01\nMOV EDX,EAX\nMOV EAX,0x0\nTEST EDX,EDX\nJS 0x00184a41\nMOV dword ptr [RBX],EDX\nMOV EAX,0x1\nJMP 0x00184a41\nCALL 0x000654a0\n"}, "117": {"funcbody": "X509_ALGOR *\n[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,[TYPE5] [VAR5] )\n{\n  int iVar1;\n  X509_ALGOR *a;\n  [TYPE6] [VAR6] ;\n  \n  a = [FUNC3] ();\n  if (a == (X509_ALGOR *)0x0) {\n    [FUNC4] ();\n    [FUNC7] (\"crypto/asn1/p5_pbe.c\",0x61,\"PKCS5_pbe_set_ex\");\n    [FUNC5] (0xd,0xc0100,(char *)0x0);\n  }\n  else {\n    iVar1 = [FUNC2] ((X509_ALGOR *)a,[VAR1] ,[VAR2] ,[VAR3] ,[VAR4] ,[VAR5] );\n    if (iVar1 == 0) {\n      [FUNC6] (a);\n      a = (X509_ALGOR *)0x0;\n    }\n  }\n  return (X509_ALGOR *)a;\n}", "answer": {"VAR1": "alg", "VAR2": "iter", "VAR3": "salt", "VAR4": "saltlen", "VAR5": "ctx", "VAR6": "ret", "FUNC2": "PKCS5_pbe_set0_algor_ex", "FUNC3": "X509_ALGOR_new", "FUNC1": "PKCS5_pbe_set_ex", "FUNC6": "X509_ALGOR_free", "TYPE3": "uchar *", "FUNC7": "ERR_set_debug", "TYPE2": "int", "FUNC4": "ERR_new", "TYPE5": "OSSL_LIB_CTX *", "FUNC5": "ERR_set_error", "TYPE4": "int", "TYPE6": "X509_ALGOR *", "TYPE1": "int"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV EBP,EDI\nMOV R12D,ESI\nMOV R13,RDX\nMOV R14D,ECX\nMOV R15,R8\nCALL 0x00128d64\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x0020ac65\nMOV R9,R15\nMOV R8D,R14D\nMOV RCX,R13\nMOV EDX,R12D\nMOV ESI,EBP\nMOV RDI,RAX\nCALL 0x0020a959\nTEST EAX,EAX\nJZ 0x0020ac9d\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nCALL 0x00080e6e\nLEA RDX,[0x2b8260]\nMOV ESI,0x61\nLEA RDI,[0x2b823e]\nCALL 0x00080f7b\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0xd\nMOV EAX,0x0\nCALL 0x00081292\nJMP 0x0020ac53\nMOV RDI,RBX\nCALL 0x00128d7a\nMOV EBX,0x0\nJMP 0x0020ac53\n"}, "118": {"funcbody": "X509_POLICY_NODE * [FUNC1] (TYPE10 [VAR1] ,TYPE25 [VAR2] ,TYPE30 [VAR3] )\n{\n  int iVar1;\n  X509_POLICY_NODE *pXVar2;\n  int i;\n  TYPE45 [VAR4] ;\n  \n  i = 0;\n  while( true ) {\n    iVar1 = [FUNC3] ((OPENSSL_STACK *)[VAR1] ->nodes);\n    if (iVar1 <= i) {\n      return (X509_POLICY_NODE *)0x0;\n    }\n    pXVar2 = (X509_POLICY_NODE *)[FUNC2] ((OPENSSL_STACK *)[VAR1] ->nodes,i);\n    if ((pXVar2->parent == [VAR2] ) &&\n       (iVar1 = [FUNC4] ((ASN1_OBJECT *)pXVar2->data->valid_policy,(ASN1_OBJECT *)[VAR3] ), iVar1 == 0))\n    break;\n    i = i + 1;\n  }\n  return pXVar2;\n}", "answer": {"VAR1": "level", "VAR2": "parent", "VAR3": "id", "VAR4": "node", "FUNC2": "OPENSSL_sk_value", "FUNC3": "OPENSSL_sk_num", "FUNC1": "ossl_policy_level_find_node", "TYPE3": "ASN1_OBJECT *", "TYPE2": "X509_POLICY_NODE *", "FUNC4": "OBJ_cmp", "TYPE4": "X509_POLICY_NODE *", "TYPE1": "X509_POLICY_LEVEL *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R12,RDI\nMOV R13,RSI\nMOV R14,RDX\nMOV EBX,0x0\nJMP 0x002c4da1\nADD EBX,0x1\nMOV RDI,qword ptr [R12 + 0x8]\nCALL 0x0015ed56\nCMP EAX,EBX\nJLE 0x002c4dd9\nMOV RDI,qword ptr [R12 + 0x8]\nMOV ESI,EBX\nCALL 0x0015ed64\nMOV RBP,RAX\nCMP qword ptr [RAX + 0x8],R13\nJNZ 0x002c4d9e\nMOV RAX,qword ptr [RAX]\nMOV RDI,qword ptr [RAX + 0x8]\nMOV RSI,R14\nCALL 0x00143862\nTEST EAX,EAX\nJNZ 0x002c4d9e\nJMP 0x002c4dde\nMOV EBP,0x0\nMOV RAX,RBP\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\n"}, "119": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  uint uVar1;\n  char *pcVar2;\n  uint uVar3;\n  ulong __n;\n  long lVar4;\n  uint uVar5;\n  int iVar6;\n  [TYPE5] [VAR5] ;\n  uint uVar7;\n  [TYPE4] [VAR4] ;\n  \n  if ([VAR1] == (TYPE10x0) {\n    return -1;\n  }\n  if ([VAR1] ->magic != 0xf00fd00d) {\n    return -1;\n  }\n  if ([VAR2] == (TYPE20x0) {\n    [VAR1] ->errnum = FIID_ERR_PARAMETERS;\n    return -1;\n  }\n  uVar5 = [VAR1] ->data_len;\n  __n = (ulong)[VAR3] ;\n  if (uVar5 <= [VAR3] ) {\n    __n = (ulong)uVar5;\n  }\n  uVar3 = (uint)__n;\n  uVar7 = uVar3 * 8;\n  if (uVar3 < uVar5) {\n    uVar5 = [VAR1] ->field_data->max_field_len;\n    if (uVar5 == 0) {\n      [FUNC2] ([VAR1] ->data,[VAR2] ,__n);\n      iVar6 = 0;\n      [VAR5] = 0;\n      goto LAB_001a7d9d;\n    }\n    if (uVar7 <= uVar5) {\n      if ((uVar5 & 7) != 0) goto LAB_001a7d27;\n      [FUNC2] ([VAR1] ->data,[VAR2] ,__n);\n      iVar6 = 0;\n      [VAR5] = 0;\n      goto LAB_001a7d9d;\n    }\n    [VAR5] = 0;\n    do {\n      [VAR5] = [VAR5] + 1;\n      uVar1 = [VAR1] ->field_data[VAR5].max_field_len;\n      if (uVar1 == 0) goto LAB_001a7d4c;\n      uVar5 = uVar5 + uVar1;\n    } while (uVar5 < uVar7);\n    if ((uVar5 & 7) != 0) {\nLAB_001a7d27:\n      [VAR1] ->errnum = FIID_ERR_DATA_NOT_BYTE_ALIGNED;\n      return -1;\n    }\n  }\n  else {\n    [VAR5] = [VAR1] ->field_data_len - 1;\n  }\nLAB_001a7d4c:\n  [FUNC2] ([VAR1] ->data,[VAR2] ,__n);\n  if ([VAR5] == 0) {\n    iVar6 = 0;\n  }\n  else {\n    lVar4 = 0;\n    iVar6 = 0;\n    do {\n      pcVar2 = [VAR1] ->field_data->key + lVar4 + -4;\n      *(uint *)(pcVar2 + 0x108) = *(uint *)pcVar2;\n      iVar6 = iVar6 + *(int *)((long)&[VAR1] ->field_data->set_field_len + lVar4);\n      lVar4 = lVar4 + 0x11c;\n    } while (lVar4 != ((ulong)([VAR5] - 1) + 1) * 0x11c);\n  }\nLAB_001a7d9d:\n  uVar5 = [VAR1] ->field_data[VAR5].max_field_len;\n  uVar1 = uVar7 - iVar6;\n  if (uVar5 + iVar6 <= uVar7) {\n    uVar1 = uVar5;\n  }\n  [VAR1] ->field_data[VAR5].set_field_len = uVar1;\n  [VAR1] ->errnum = FIID_ERR_SUCCESS;\n  return uVar3;\n}", "answer": {"VAR1": "obj", "VAR2": "data", "VAR3": "data_len", "VAR4": "data_bits_len", "VAR5": "key_index_end", "FUNC2": "memcpy", "FUNC1": "fiid_obj_set_all", "TYPE3": "uint", "TYPE2": "void *", "TYPE5": "uint", "TYPE4": "uint", "TYPE1": "fiid_obj_t"}, "assembly": "TEST RDI,RDI\nJZ 0x001a7ddd\nCMP dword ptr [RDI],0xf00fd00d\nJNZ 0x001a7de3\nTEST RSI,RSI\nJZ 0x001a7d38\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,RDI\nMOV EAX,dword ptr [RDI + 0x10]\nCMP EAX,EDX\nCMOVBE EDX,EAX\nMOV R13D,EDX\nLEA R14D,[RDX*0x8]\nCMP EAX,EDX\nJBE 0x001a7d45\nMOV RDX,qword ptr [RDI + 0x18]\nMOV EBX,dword ptr [RDX]\nTEST EBX,EBX\nJZ 0x001a7e03\nCMP R14D,EBX\nJBE 0x001a7de9\nMOV R12D,0x0\nADD R12D,0x1\nMOV EAX,R12D\nIMUL RAX,RAX,0x11c\nMOV EAX,dword ptr [RDX + RAX*0x1]\nTEST EAX,EAX\nJZ 0x001a7d4c\nADD EBX,EAX\nCMP R14D,EBX\nJA 0x001a7d06\nTEST BL,0x7\nJZ 0x001a7d4c\nMOV dword ptr [RBP + 0x4],0x12\nMOV EAX,0xffffffff\nJMP 0x001a7dcf\nMOV dword ptr [RDI + 0x4],0x5\nMOV EAX,0xffffffff\nRET\nMOV EAX,dword ptr [RDI + 0x20]\nLEA R12D,[RAX + -0x1]\nMOV RDI,qword ptr [RBP + 0x8]\nMOV EDX,R13D\nCALL 0x00167210\nTEST R12D,R12D\nJZ 0x001a7dd8\nLEA ESI,[R12 + -0x1]\nADD RSI,0x1\nIMUL RSI,RSI,0x11c\nMOV EDX,0x0\nMOV EBX,0x0\nMOV RAX,RDX\nADD RAX,qword ptr [RBP + 0x18]\nMOV ECX,dword ptr [RAX]\nMOV dword ptr [RAX + 0x108],ECX\nMOV RAX,qword ptr [RBP + 0x18]\nADD EBX,dword ptr [RAX + RDX*0x1 + 0x108]\nADD RDX,0x11c\nCMP RDX,RSI\nJNZ 0x001a7d77\nMOV R12D,R12D\nIMUL R12,R12,0x11c\nADD R12,qword ptr [RBP + 0x18]\nMOV EDX,dword ptr [R12]\nLEA ECX,[RDX + RBX*0x1]\nMOV EAX,R14D\nSUB EAX,EBX\nCMP ECX,R14D\nCMOVBE EAX,EDX\nMOV dword ptr [R12 + 0x108],EAX\nMOV dword ptr [RBP + 0x4],0x0\nMOV EAX,R13D\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV EBX,R12D\nJMP 0x001a7d9d\nMOV EAX,0xffffffff\nRET\nMOV EAX,0xffffffff\nRET\nAND EBX,0x7\nJNZ 0x001a7d27\nMOV RDI,qword ptr [RBP + 0x8]\nMOV EDX,R13D\nCALL 0x00167210\nMOV R12D,EBX\nJMP 0x001a7d9d\nMOV RDI,qword ptr [RDI + 0x8]\nMOV EDX,R13D\nCALL 0x00167210\nMOV R12D,EBX\nJMP 0x001a7d9d\n"}, "120": {"funcbody": "/* DWARF original prototype: void AiPlayer(AiPlayer * this, Player * name, MottiRulesManager * aa)\n    */\nvoid __thiscall AiPlayer::[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  [VAR1] ->_vptr_AiPlayer = (_func_int_varargs **)&PTR_think_0024ad50;\n  [VAR1] ->player_ = [VAR2] ;\n  [VAR1] ->attackprecision_ = DAT_0003fcd0;\n  ([VAR1] ->vectEnnemyHouse_).\n  super__Vector_base<AiPlayer::coordinate2DM,_std::allocator<AiPlayer::coordinate2DM>_>._M_impl.\n  _M_start = (pointer)0x0;\n  ([VAR1] ->vectEnnemyHouse_).\n  super__Vector_base<AiPlayer::coordinate2DM,_std::allocator<AiPlayer::coordinate2DM>_>._M_impl.\n  _M_finish = (pointer)0x0;\n  ([VAR1] ->vectEnnemyHouse_).\n  super__Vector_base<AiPlayer::coordinate2DM,_std::allocator<AiPlayer::coordinate2DM>_>._M_impl.\n  _M_end_of_storage = (pointer)0x0;\n  ([VAR1] ->vectColorizedCoord_).\n  super__Vector_base<AiPlayer::coordinate2DM,_std::allocator<AiPlayer::coordinate2DM>_>._M_impl.\n  _M_start = (pointer)0x0;\n  ([VAR1] ->vectColorizedCoord_).\n  super__Vector_base<AiPlayer::coordinate2DM,_std::allocator<AiPlayer::coordinate2DM>_>._M_impl.\n  _M_finish = (pointer)0x0;\n  ([VAR1] ->vectColorizedCoord_).\n  super__Vector_base<AiPlayer::coordinate2DM,_std::allocator<AiPlayer::coordinate2DM>_>._M_impl.\n  _M_end_of_storage = (pointer)0x0;\n  ([VAR1] ->lastChoice_).\n  super__Vector_base<AiPlayer::coordinate2DM,_std::allocator<AiPlayer::coordinate2DM>_>._M_impl.\n  _M_start = (pointer)0x0;\n  ([VAR1] ->lastChoice_).\n  super__Vector_base<AiPlayer::coordinate2DM,_std::allocator<AiPlayer::coordinate2DM>_>._M_impl.\n  _M_finish = (pointer)0x0;\n  ([VAR1] ->lastChoice_).\n  super__Vector_base<AiPlayer::coordinate2DM,_std::allocator<AiPlayer::coordinate2DM>_>._M_impl.\n  _M_end_of_storage = (pointer)0x0;\n                    /* try { // try from 001075b5 to 001075b9 has its CatchHandler @ 001075c5 */\n  RandomGenerator::[FUNC2] (&[VAR1] ->randGen_);\n  [VAR1] ->rules_ = [VAR3] ;\n  return;\n}", "answer": {"VAR1": "this", "VAR2": "name", "VAR3": "aa", "FUNC2": "RandomGenerator", "FUNC1": "AiPlayer", "TYPE3": "MottiRulesManager *", "TYPE2": "Player *", "TYPE1": "AiPlayer *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RDX\nLEA RAX,[0x24ad50]\nMOV qword ptr [RDI],RAX\nMOV qword ptr [RDI + 0x8],RSI\nMOV RAX,qword ptr [0x0003fcd0]\nMOV qword ptr [RDI + 0x18],RAX\nMOV qword ptr [RDI + 0x20],0x0\nMOV qword ptr [RDI + 0x28],0x0\nMOV qword ptr [RDI + 0x30],0x0\nMOV qword ptr [RDI + 0x38],0x0\nMOV qword ptr [RDI + 0x40],0x0\nMOV qword ptr [RDI + 0x48],0x0\nMOV qword ptr [RDI + 0x50],0x0\nMOV qword ptr [RDI + 0x58],0x0\nMOV qword ptr [RDI + 0x60],0x0\nLEA RDI,[RDI + 0x68]\nCALL 0x0002a08a\nMOV qword ptr [RBX + 0x78],RBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "121": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  char *pcVar1;\n  [TYPE4] [VAR4] ;\n  \n  if ([VAR3] != ([TYPE3] )0x0) {\n    return [VAR3] ;\n  }\n  pcVar1 = [FUNC3] ([VAR1] ,[VAR2] );\n  if (pcVar1 == (char *)0x0) {\n    [FUNC2] (1,1,(sw_logspec *)0x0,2,\"swlib.c\",0xb23,\"swlib_attribute_check_default\",\n          \"ERROR: no default value found for attribute: %s %s\\n\",[VAR1] ,[VAR2] );\n    pcVar1 = \"\";\n  }\n  return pcVar1;\n}", "answer": {"VAR1": "object", "VAR2": "keyword", "VAR3": "value", "VAR4": "d", "FUNC2": "swutil_cpp_doif_writef", "FUNC3": "swsdflt_get_default_value", "FUNC1": "swlib_attribute_check_default", "TYPE3": "char *", "TYPE2": "char *", "TYPE4": "char *", "TYPE1": "char *"}, "assembly": "MOV RAX,RDX\nTEST RDX,RDX\nJZ 0x00018955\nRET\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RSI\nCALL 0x0001aa8b\nTEST RAX,RAX\nJZ 0x00018972\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nPUSH RBP\nPUSH RBX\nLEA RAX,[0x425f8]\nPUSH RAX\nLEA RAX,[0x428b0]\nPUSH RAX\nMOV R9D,0xb23\nLEA R8,[0x42728]\nMOV ECX,0x2\nMOV EDX,0x0\nMOV ESI,0x1\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x0001b278\nADD RSP,0x20\nLEA RAX,[0x44385]\nJMP 0x0001896b\n"}, "122": {"funcbody": "void [FUNC1] (undefined8 *param_1,undefined8 *param_2,undefined8 param_3,undefined8 param_4)\n{\n  undefined8 uVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  [TYPE1] [VAR1] ;\n  [TYPE15] [VAR15] ;\n  [TYPE14] [VAR14] ;\n  [TYPE13] [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  \n  uVar5 = *param_2;\n  uVar6 = param_2[1];\n  uVar7 = param_2[2];\n  uVar8 = param_2[3];\n  uVar1 = param_2[4];\n  uVar2 = param_2[5];\n  uVar3 = param_2[6];\n  uVar4 = param_2[7];\n  if ((DAT_0057d498 & 0x80100) == 0x80100) {\n    [FUNC2] (param_1,param_2,param_4);\n  }\n  else {\n    [FUNC3] ();\n  }\n  *param_1 = uVar5;\n  param_1[1] = uVar6;\n  param_1[2] = uVar7;\n  param_1[3] = uVar8;\n  param_1[4] = uVar1;\n  param_1[5] = uVar2;\n  param_1[6] = uVar3;\n  param_1[7] = uVar4;\n  return;\n}", "answer": {"VAR1": "local_res0", "VAR2": "local_8", "VAR3": "local_10", "VAR4": "local_18", "VAR5": "local_20", "VAR6": "local_28", "FUNC2": "__rsaz_512_reducex", "FUNC3": "__rsaz_512_reduce", "FUNC1": "rsaz_512_mul_by_one", "TYPE3": "undefined8", "VAR14": "local_b8", "TYPE2": "undefined8", "VAR15": "local_c8", "TYPE5": "undefined8", "VAR12": "local_98", "TYPE4": "undefined8", "VAR13": "local_a8", "TYPE7": "undefined8", "TYPE6": "undefined8", "TYPE9": "undefined1[16]", "TYPE8": "undefined8", "VAR7": "local_30", "TYPE11": "undefined1[16]", "VAR8": "local_48", "TYPE12": "undefined1[16]", "VAR9": "local_68", "TYPE10": "undefined1[16]", "VAR10": "local_78", "TYPE15": "undefined1[16]", "VAR11": "local_88", "TYPE1": "undefined1", "TYPE13": "undefined1[16]", "TYPE14": "undefined1[16]"}, "assembly": "PUSH RBX\nPUSH RBP\nPUSH R12\nPUSH R13\nPUSH R14\nPUSH R15\nSUB RSP,0x98\nMOV EAX,dword ptr [0x0057d498]\nMOV RBP,RDX\nMOV qword ptr [RSP + 0x80],RCX\nMOV R8,qword ptr [RSI]\nPXOR XMM0,XMM0\nMOV R9,qword ptr [RSI + 0x8]\nMOV R10,qword ptr [RSI + 0x10]\nMOV R11,qword ptr [RSI + 0x18]\nMOV R12,qword ptr [RSI + 0x20]\nMOV R13,qword ptr [RSI + 0x28]\nMOV R14,qword ptr [RSI + 0x30]\nMOV R15,qword ptr [RSI + 0x38]\nMOVDQA xmmword ptr [RSP],XMM0\nMOVDQA xmmword ptr [RSP + 0x10],XMM0\nMOVDQA xmmword ptr [RSP + 0x20],XMM0\nMOVDQA xmmword ptr [RSP + 0x30],XMM0\nMOVDQA xmmword ptr [RSP + 0x40],XMM0\nMOVDQA xmmword ptr [RSP + 0x50],XMM0\nMOVDQA xmmword ptr [RSP + 0x60],XMM0\nAND EAX,0x80100\nCMP EAX,0x80100\nJZ 0x0021cd80\nCALL 0x0021cde0\nJMP 0x0021cd8d\nMOV RDX,qword ptr [RSP + 0x80]\nCALL 0x0021cee0\nMOV qword ptr [RDI],R8\nMOV qword ptr [RDI + 0x8],R9\nMOV qword ptr [RDI + 0x10],R10\nMOV qword ptr [RDI + 0x18],R11\nMOV qword ptr [RDI + 0x20],R12\nMOV qword ptr [RDI + 0x28],R13\nMOV qword ptr [RDI + 0x30],R14\nMOV qword ptr [RDI + 0x38],R15\nLEA RAX,[RSP + 0xc8]\nMOV R15,qword ptr [RAX + -0x30]\nMOV R14,qword ptr [RAX + -0x28]\nMOV R13,qword ptr [RAX + -0x20]\nMOV R12,qword ptr [RAX + -0x18]\nMOV RBP,qword ptr [RAX + -0x10]\nMOV RBX,qword ptr [RAX + -0x8]\nLEA RSP,[RAX]\nRET\n"}, "123": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  EVP_PKEY *pEVar1;\n  _func_int_EVP_PKEY_ptr *p_Var2;\n  int iVar3;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  \n  pEVar1 = [VAR1] ->pkey;\n  if (pEVar1 == (EVP_PKEY *)0x0) {\n    [FUNC5] ();\n    [FUNC4] (\"crypto/evp/pmeth_check.c\",0xa6,\"EVP_PKEY_pairwise_check\");\n    [FUNC3] (6,0x9a,(char *)0x0);\n    iVar3 = 0;\n  }\n  else {\n    iVar3 = [FUNC2] ([VAR1] ,3,0);\n    if (iVar3 == -1) {\n      if (pEVar1->type != 0) {\n        p_Var2 = [VAR1] ->pmeth->check;\n        if (p_Var2 != (_func_int_EVP_PKEY_ptr *)0x0) {\n          iVar3 = (*p_Var2)(pEVar1);\n          return iVar3;\n        }\n        if ((pEVar1->ameth != (EVP_PKEY_ASN1_METHOD *)0x0) &&\n           (p_Var2 = pEVar1->ameth->pkey_check, p_Var2 != (_func_int_EVP_PKEY_ptr *)0x0)) {\n          iVar3 = (*p_Var2)(pEVar1);\n          return iVar3;\n        }\n      }\n      [FUNC5] ();\n      [FUNC4] (\"crypto/evp/pmeth_check.c\",0xbe,\"EVP_PKEY_pairwise_check\");\n      [FUNC3] (6,0x96,(char *)0x0);\n      iVar3 = -2;\n    }\n  }\n  return iVar3;\n}", "answer": {"VAR1": "ctx", "VAR2": "pkey", "VAR3": "ok", "FUNC2": "try_provided_check", "FUNC3": "ERR_set_error", "FUNC1": "EVP_PKEY_pairwise_check", "TYPE3": "int", "TYPE2": "EVP_PKEY *", "FUNC4": "ERR_set_debug", "FUNC5": "ERR_new", "TYPE1": "EVP_PKEY_CTX *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,qword ptr [RDI + 0x88]\nTEST RBP,RBP\nJZ 0x001a526b\nMOV RBX,RDI\nMOV EDX,0x0\nMOV ESI,0x3\nCALL 0x001a4ed1\nCMP EAX,-0x1\nJZ 0x001a52a8\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x00089475\nLEA RDX,[0x29caf0]\nMOV ESI,0xa6\nLEA RDI,[0x29cad3]\nCALL 0x00089582\nMOV EDX,0x0\nMOV ESI,0x9a\nMOV EDI,0x6\nMOV EAX,0x0\nCALL 0x00089899\nMOV EAX,0x0\nJMP 0x001a5264\nCMP dword ptr [RBP],0x0\nJZ 0x001a52e1\nMOV RAX,qword ptr [RBX + 0x78]\nMOV RAX,qword ptr [RAX + 0xe0]\nTEST RAX,RAX\nJZ 0x001a52c5\nMOV RDI,RBP\nCALL RAX\nJMP 0x001a5264\nMOV RAX,qword ptr [RBP + 0x8]\nTEST RAX,RAX\nJZ 0x001a52e1\nMOV RAX,qword ptr [RAX + 0xe0]\nTEST RAX,RAX\nJZ 0x001a52e1\nMOV RDI,RBP\nCALL RAX\nJMP 0x001a5264\nCALL 0x00089475\nLEA RDX,[0x29caf0]\nMOV ESI,0xbe\nLEA RDI,[0x29cad3]\nCALL 0x00089582\nMOV EDX,0x0\nMOV ESI,0x96\nMOV EDI,0x6\nMOV EAX,0x0\nCALL 0x00089899\nMOV EAX,0xfffffffe\nJMP 0x001a5264\n"}, "124": {"funcbody": "void [FUNC1] (long *param_1)\n{\n  long lVar1;\n  \n  lVar1 = *param_1;\n  if (lVar1 != 0) {\n    [FUNC3] (lVar1 + 8);\n    [FUNC3] (lVar1 + 0x10);\n    [FUNC3] (lVar1 + 0x18);\n    [FUNC3] (lVar1 + 0x20);\n    [FUNC2] (lVar1 + 0x8460);\n    [FUNC4] (lVar1 + 0x48);\n    [FUNC4] (param_1);\n    return;\n  }\n  return;\n}", "answer": {"FUNC2": "thunk_FUN_00fd7f60", "FUNC3": "FUN_0019b75d", "FUNC1": "FUN_00918320", "FUNC4": "FUN_00fd7f60"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,qword ptr [RDI]\nTEST RBX,RBX\nJZ 0x00918380\nMOV RBP,RDI\nLEA RDI,[RBX + 0x8]\nCALL 0x0019b75d\nLEA RDI,[RBX + 0x10]\nCALL 0x0019b75d\nLEA RDI,[RBX + 0x18]\nCALL 0x0019b75d\nLEA RDI,[RBX + 0x20]\nCALL 0x0019b75d\nLEA RDI,[RBX + 0x8460]\nCALL 0x00186bcb\nLEA RDI,[RBX + 0x48]\nCALL 0x00fd7f60\nADD RSP,0x8\nMOV RDI,RBP\nPOP RBX\nPOP RBP\nJMP 0x00fd7f60\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "125": {"funcbody": "void [FUNC1] (undefined8 param_1,undefined8 param_2,undefined4 param_3)\n{\n  long in_FS_OFFSET;\n  undefined auStack_68 [72];\n  long [VAR1] ;\n  \n  [VAR1] = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC3] (auStack_68,param_2,8,param_3,9);\n  [FUNC4] (param_1,auStack_68,param_3,8);\n  if ([VAR1] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "local_20", "FUNC2": "__stack_chk_fail", "FUNC3": "FUN_00ecc570", "FUNC1": "FUN_00be5160", "FUNC4": "FUN_00ecd990", "TYPE1": "undefined8"}, "assembly": "PUSH R12\nPUSH RBP\nMOV ECX,EDX\nPUSH RBX\nMOV R12,RDI\nMOV RBP,RDX\nMOV R8D,0x9\nMOV EDX,0x8\nSUB RSP,0x50\nMOV RBX,RSP\nMOV RDI,RBX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x48],RAX\nXOR EAX,EAX\nCALL 0x00ecc570\nMOV ECX,0x8\nMOV EDX,EBP\nMOV RSI,RBX\nMOV RDI,R12\nCALL 0x00ecd990\nMOV RAX,qword ptr [RSP + 0x48]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x00be51c1\nADD RSP,0x50\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x0010cf30\n"}, "126": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  int *piVar1;\n  char *pcVar2;\n  \n  piVar1 = [FUNC2] ();\n  pcVar2 = [FUNC3] (*piVar1);\n  [FUNC4] (\"test/testutil/tests.c\",0x90,\"%s: %s\",[VAR1] ,pcVar2);\n  return;\n}", "answer": {"VAR1": "s", "FUNC2": "__errno_location", "FUNC3": "strerror", "FUNC1": "test_perror", "FUNC4": "test_error", "TYPE1": "char *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCALL 0x00002310\nMOV EDI,dword ptr [RAX]\nCALL 0x00002230\nMOV R8,RAX\nMOV RCX,RBX\nLEA RDX,[0x10a18]\nMOV ESI,0x90\nLEA RDI,[0x10a1f]\nMOV EAX,0x0\nCALL 0x00009d75\nPOP RBX\nRET\n"}, "127": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] ,[TYPE8] [VAR8] )\n{\n  int iVar1;\n  [TYPE9] [VAR9] ;\n  \n  if (([VAR5] != ([TYPE5] )0x0) || (iVar1 = 1, [VAR7] != (TYPE70x0)) {\n    if (([VAR6] == [VAR8] && [VAR7] != (TYPE70x0) &&\n       (([VAR5] != ([TYPE5] )0x0 && (iVar1 = [FUNC2] ([VAR5] ,[VAR7] ,[VAR6] ), iVar1 == 0)))) {\n      return 1;\n    }\n    [FUNC3] ((char *)0x0,[VAR1] ,[VAR2] ,\"memory\",[VAR3] ,[VAR4] ,\"==\",(uchar *)[VAR5] ,[VAR6] ,(uchar *)[VAR7] ,[VAR8] );\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "st1", "VAR4": "st2", "VAR5": "s1", "VAR6": "n1", "FUNC2": "memcmp", "FUNC3": "test_fail_memory_message", "FUNC1": "test_mem_eq", "TYPE3": "char *", "TYPE2": "int", "TYPE5": "void *", "TYPE4": "char *", "TYPE7": "void *", "TYPE6": "size_t", "TYPE9": "undefined8", "TYPE8": "size_t", "VAR7": "s2", "VAR8": "n2", "VAR9": "local_40", "TYPE1": "char *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV R12,qword ptr [RSP + 0x50]\nTEST R8,R8\nSETZ R10B\nTEST R12,R12\nSETZ R11B\nTEST R10B,R10B\nJZ 0x00009f0e\nMOV EAX,0x1\nTEST R11B,R11B\nJZ 0x00009f0e\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV RBP,R9\nMOV RBX,R8\nMOV R15,RCX\nMOV R14,RDX\nMOV R13D,ESI\nMOV qword ptr [RSP + 0x8],RDI\nCMP R9,qword ptr [RSP + 0x58]\nSETNZ AL\nOR AL,R11B\nJNZ 0x00009f4d\nTEST R10B,R10B\nJNZ 0x00009f4d\nMOV RDX,R9\nMOV RSI,R12\nMOV RDI,R8\nCALL 0x00004590\nMOV EDX,EAX\nMOV EAX,0x1\nTEST EDX,EDX\nJZ 0x00009eff\nSUB RSP,0x8\nPUSH qword ptr [RSP + 0x60]\nPUSH R12\nPUSH RBP\nPUSH RBX\nLEA RAX,[0xdb52]\nPUSH RAX\nMOV R9,R15\nMOV R8,R14\nLEA RCX,[0xdb36]\nMOV EDX,R13D\nMOV RSI,qword ptr [RSP + 0x38]\nMOV EDI,0x0\nCALL 0x0000c193\nADD RSP,0x30\nMOV EAX,0x0\nJMP 0x00009eff\n"}, "128": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,TYPE26 [VAR2] ,TYPE36 [VAR3] )\n{\n  code *pcVar1;\n  int iVar2;\n  X509_NAME *pXVar3;\n  ASN1_INTEGER *pAVar4;\n  \n  pcVar1 = *(code **)(*(long *)([VAR1] [1].sha1_hash + 0x10) + 0x18);\n  iVar2 = 0;\n  if (pcVar1 != (code *)0x0) {\n    pXVar3 = [FUNC3] ([VAR3] );\n    pAVar4 = [FUNC2] ((X509 *)[VAR3] );\n    iVar2 = (*pcVar1)([VAR1] ,[VAR2] ,pAVar4,pXVar3);\n  }\n  return iVar2;\n}", "answer": {"VAR1": "crl", "VAR2": "ret", "VAR3": "x", "FUNC2": "X509_get0_serialNumber", "FUNC3": "X509_get_issuer_name", "FUNC1": "X509_CRL_get0_by_cert", "TYPE3": "X509 *", "TYPE2": "X509_REVOKED * *", "TYPE1": "X509_CRL *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV RAX,qword ptr [RDI + 0xd0]\nMOV R12,qword ptr [RAX + 0x18]\nMOV EAX,0x0\nTEST R12,R12\nJZ 0x000bf3ac\nMOV RBP,RDX\nMOV R13,RSI\nMOV RBX,RDI\nMOV RDI,RDX\nCALL 0x000b513f\nMOV R14,RAX\nMOV RDI,RBP\nCALL 0x000b514e\nMOV RCX,R14\nMOV RDX,RAX\nMOV RSI,R13\nMOV RDI,RBX\nCALL R12\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\n"}, "129": {"funcbody": "int [FUNC1] (TYPE12 [VAR1] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC3] ((X509 *)[VAR1] );\n  if (iVar1 != 0) {\n    iVar1 = [FUNC2] ((X509 *)[VAR1] );\n  }\n  return iVar1;\n}", "answer": {"VAR1": "x", "FUNC2": "check_ca", "FUNC3": "ossl_x509v3_cache_extensions", "FUNC1": "X509_check_ca", "TYPE1": "X509 *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCALL 0x000efa6f\nTEST EAX,EAX\nJZ 0x000f049c\nMOV RDI,RBX\nCALL 0x000eefc6\nPOP RBX\nRET\n"}, "130": {"funcbody": "undefined8 [FUNC1] (long param_1,long param_2)\n{\n  long lVar1;\n  undefined *puVar2;\n  \n  puVar2 = PTR_stderr_01237ff8;\n  [FUNC5] (\"Object DYNAMICBLOCKPURGEPREVENTER:\\n\",*(FILE **)PTR_stderr_01237ff8);\n  lVar1 = *(long *)(*(long *)(param_2 + 0x38) + 8);\n  [FUNC2] (*(undefined8 *)puVar2,1,\"Object handle: %u.%u.%lX\\n\",*(undefined *)(param_2 + 0x40),\n        *(undefined *)(param_2 + 0x41),*(undefined8 *)(param_2 + 0x48));\n  [FUNC2] (*(undefined8 *)puVar2,1,\"flag: %u [BS 70]\\n\",*(undefined2 *)(lVar1 + 8));\n  if (0x19 < *(uint *)(param_1 + 0x1c)) {\n    [FUNC4] (param_1,*(undefined8 *)(param_2 + 0x78));\n  }\n  if (*(int *)(param_2 + 0x30) != 1) {\n    [FUNC3] (\"obj->supertype == DWG_SUPERTYPE_OBJECT\",\"dwg.spec\",0x1dba,\n          \"dwg_print_DYNAMICBLOCKPURGEPREVENTER\");\n  }\n  lVar1 = *(long *)(lVar1 + 0x10);\n  if (lVar1 != 0) {\n    [FUNC2] (*(undefined8 *)PTR_stderr_01237ff8,1,\"block: HANDLE(%u.%u.%lX) abs:%lX [%d]\\n\",\n          *(undefined *)(lVar1 + 8),*(undefined *)(lVar1 + 9),*(undefined8 *)(lVar1 + 0x10),\n          *(undefined8 *)(lVar1 + 0x20),0);\n  }\n  return 0;\n}", "answer": {"FUNC2": "__fprintf_chk", "FUNC3": "__assert_fail", "FUNC1": "dwg_print_DYNAMICBLOCKPURGEPREVENTER", "FUNC4": "bit_set_position", "FUNC5": "fputs"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R13,RDI\nMOV RBX,RSI\nMOV RBP,qword ptr [0x01237ff8]\nMOV RSI,qword ptr [RBP]\nLEA RDI,[0xf36f90]\nCALL 0x0006d030\nMOV RAX,qword ptr [RBX + 0x38]\nMOV R12,qword ptr [RAX + 0x8]\nMOVZX ECX,byte ptr [RBX + 0x40]\nMOV R9,qword ptr [RBX + 0x48]\nMOVZX R8D,byte ptr [RBX + 0x41]\nLEA RDX,[0xf29555]\nMOV ESI,0x1\nMOV RDI,qword ptr [RBP]\nMOV AL,0x0\nCALL 0x0006d610\nMOVZX ECX,word ptr [R12 + 0x8]\nLEA RDX,[0xf292df]\nMOV ESI,0x1\nMOV RDI,qword ptr [RBP]\nMOV AL,0x0\nCALL 0x0006d610\nCMP dword ptr [R13 + 0x1c],0x19\nJBE 0x00476162\nMOV RSI,qword ptr [RBX + 0x78]\nMOV RDI,R13\nCALL 0x00073e20\nCMP dword ptr [RBX + 0x30],0x1\nJZ 0x00476187\nLEA RCX,[0xf412a0]\nMOV EDX,0x1dba\nLEA RSI,[0xef294c]\nLEA RDI,[0xf08fb8]\nCALL 0x0006d020\nMOV RAX,qword ptr [R12 + 0x10]\nTEST RAX,RAX\nJZ 0x004761c4\nMOVZX ECX,byte ptr [RAX + 0x8]\nPUSH 0x0\nPUSH qword ptr [RAX + 0x20]\nMOV R9,qword ptr [RAX + 0x10]\nMOVZX R8D,byte ptr [RAX + 0x9]\nLEA RDX,[0xf32188]\nMOV ESI,0x1\nMOV RAX,qword ptr [0x01237ff8]\nMOV RDI,qword ptr [RAX]\nMOV AL,0x0\nCALL 0x0006d610\nADD RSP,0x10\nMOV EAX,0x0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\n"}, "131": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  OSSL_PARAM *p;\n  [TYPE4] [VAR4] ;\n  uint uVar2;\n  TYPE35 [VAR3] ;\n  \n  p = [FUNC2] ([VAR2] ,\"encrypt-level\");\n  uVar2 = 1;\n  if (p != (OSSL_PARAM *)0x0) {\n    iVar1 = [FUNC3] (p,(int *)((long)[VAR1] + 8));\n    uVar2 = (uint)(iVar1 != 0);\n  }\n  return uVar2;\n}", "answer": {"VAR1": "vctx", "VAR2": "params", "VAR3": "ctx", "VAR4": "p", "FUNC2": "OSSL_PARAM_locate_const", "FUNC3": "OSSL_PARAM_get_int", "FUNC1": "key2pvk_set_ctx_params", "TYPE3": "key2ms_ctx_st *", "TYPE2": "OSSL_PARAM *", "TYPE4": "OSSL_PARAM *", "TYPE1": "void *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nMOV RDI,RSI\nLEA RSI,[0x279288]\nCALL 0x0009e68e\nMOV EDX,0x1\nTEST RAX,RAX\nJZ 0x000e79b9\nLEA RSI,[RBX + 0x8]\nMOV RDI,RAX\nCALL 0x0009e8b7\nTEST EAX,EAX\nSETNZ DL\nMOVZX EDX,DL\nMOV EAX,EDX\nPOP RBX\nRET\n"}, "132": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,TYPE43 [VAR4] ,\n         TYPE56 [VAR5] ,TYPE64 [VAR6] ,[TYPE7] [VAR7] )\n{\n  [TYPE10] [VAR10] ;\n  int iVar1;\n  EVP_PKEY *pk;\n  OSSL_LIB_CTX *libctx;\n  [TYPE9] [VAR9] ;\n  BIO *out;\n  [TYPE8] [VAR8] ;\n  \n  if (([VAR3] & 1U) != 0) {\n    pk = (EVP_PKEY *)[FUNC8] ();\n    if (pk == (EVP_PKEY *)0x0) {\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = (*[VAR5] )(pk,[VAR2] );\n      if ((iVar1 != 0) &&\n         (([VAR6] == (TYPE64)0x0 ||\n          (iVar1 = [FUNC4] ((ossl_passphrase_data_st *)((long)[VAR1] + 0x10),[VAR6] ,[VAR7] ), iVar1 != 0)))) {\n        libctx = [FUNC6] (*[VAR1] );\n        out = [FUNC7] (*[VAR1] ,[VAR4] );\n        iVar1 = 0;\n        if (out != (BIO *)0x0) {\n          iVar1 = [FUNC2] (out,pk,*(int *)((long)[VAR1] + 8),[FUNC9] ,(void *)((long)[VAR1] + 0x10),libctx,\n                        (char *)0x0);\n          [FUNC5] ((BIO *)out);\n        }\n      }\n    }\n    [FUNC3] ((EVP_PKEY *)pk);\n    return iVar1;\n  }\n  return 0;\n}", "answer": {"VAR1": "vctx", "VAR2": "key", "VAR3": "selection", "VAR4": "cout", "VAR5": "set1_key", "VAR6": "pw_cb", "FUNC2": "i2b_PVK_bio_ex", "FUNC3": "EVP_PKEY_free", "FUNC1": "key2pvk_encode", "FUNC6": "ossl_prov_ctx_get0_libctx", "TYPE3": "int", "FUNC7": "ossl_bio_new_from_core_bio", "TYPE2": "void *", "FUNC4": "ossl_pw_set_ossl_passphrase_cb", "TYPE5": "evp_pkey_set1_fn *", "FUNC5": "BIO_free", "TYPE4": "OSSL_CORE_BIO *", "TYPE7": "void *", "TYPE6": "OSSL_PASSPHRASE_CALLBACK *", "FUNC8": "EVP_PKEY_new", "TYPE9": "OSSL_LIB_CTX *", "FUNC9": "ossl_pw_pvk_password", "TYPE8": "key2ms_ctx_st *", "VAR7": "pw_cbarg", "VAR8": "ctx", "VAR9": "libctx", "TYPE10": "int", "VAR10": "ret", "TYPE1": "void *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nAND EDX,0x1\nMOV EBX,EDX\nJNZ 0x00109c3a\nMOV EAX,EBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV R12,R9\nMOV RBX,R8\nMOV R13,RCX\nMOV R15,RSI\nMOV RBP,RDI\nCALL 0x000ad986\nMOV R14,RAX\nTEST RAX,RAX\nJZ 0x00109ce6\nMOV RSI,R15\nMOV RDI,RAX\nCALL RBX\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x00109cd9\nTEST R12,R12\nJZ 0x00109c84\nLEA RDI,[RBP + 0x10]\nMOV RDX,qword ptr [RSP + 0x40]\nMOV RSI,R12\nCALL 0x000bfae0\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x00109cd9\nMOV RDI,qword ptr [RBP]\nCALL 0x0012b4f7\nMOV R15,RAX\nMOV RSI,R13\nMOV RDI,qword ptr [RBP]\nCALL 0x000e975b\nMOV R12,RAX\nMOV EBX,0x0\nTEST RAX,RAX\nJZ 0x00109cd9\nMOV EDX,dword ptr [RBP + 0x8]\nSUB RSP,0x8\nPUSH 0x0\nMOV R9,R15\nLEA R8,[RBP + 0x10]\nLEA RCX,[0xc03cf]\nMOV RSI,R14\nMOV RDI,RAX\nCALL 0x001ecbe7\nMOV EBX,EAX\nMOV RDI,R12\nCALL 0x00075b6a\nADD RSP,0x10\nMOV RDI,R14\nCALL 0x000ae289\nJMP 0x00109c29\nMOV EBX,0x0\nJMP 0x00109cd9\n"}, "133": {"funcbody": "void [FUNC1] (TYPE19 [VAR1] ,TYPE25 [VAR2] ,[TYPE3] [VAR3] )\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR5] .fn = [VAR2] ;\n  [VAR5] .fnarg = [VAR3] ;\n  if ([VAR1] != (TYPE19)0x0) {\n    [FUNC2] ((OPENSSL_SA *)[VAR1] ->algs,[FUNC3] ,&[VAR5] );\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC4] ();\n}", "answer": {"VAR1": "store", "VAR2": "fn", "VAR3": "fnarg", "VAR4": "local_10", "VAR5": "data", "FUNC2": "ossl_sa_doall_arg", "FUNC3": "alg_do_each", "FUNC1": "ossl_method_store_do_all", "TYPE3": "void *", "TYPE2": "_func_void_int_void_ptr_void_ptr *", "FUNC4": "__stack_chk_fail", "TYPE5": "alg_do_each_data_st", "TYPE4": "undefined8", "TYPE1": "OSSL_METHOD_STORE *"}, "assembly": "SUB RSP,0x28\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],RSI\nMOV qword ptr [RSP + 0x8],RDX\nTEST RDI,RDI\nJZ 0x000a3ec8\nMOV RDX,RSP\nMOV RDI,qword ptr [RDI + 0x8]\nLEA RSI,[0xa37b6]\nCALL 0x001ae77e\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x000a3edd\nADD RSP,0x28\nRET\nCALL 0x000626a0\n"}, "134": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  [TYPE4] size;\n  _Bool _Var1;\n  zend_result zVar2;\n  spl_fixedarray *array;\n  long in_FS_OFFSET;\n  [TYPE4] [VAR4] ;\n  long [VAR3] ;\n  \n  [VAR3] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR4] = 0;\n  zVar2 = [FUNC3] (([VAR1] ->This).u2.next,\"|l\",&[VAR4] );\n  size = [VAR4] ;\n  if (zVar2 != FAILURE) {\n    if ([VAR4] < 0) {\n      [FUNC4] (1,\"must be greater than or equal to 0\");\n    }\n    else {\n      array = (spl_fixedarray *)(([VAR1] ->This).value.lval + -0x20);\n      _Var1 = [FUNC6] (array);\n      if (_Var1) {\n        [FUNC5] (array,size);\n      }\n    }\n  }\n  if ([VAR3] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "execute_data", "VAR2": "return_value", "VAR3": "local_20", "VAR4": "size", "FUNC2": "__stack_chk_fail", "FUNC3": "zend_parse_parameters", "FUNC1": "zim_SplFixedArray___construct", "FUNC6": "spl_fixedarray_empty", "TYPE3": "undefined8", "TYPE2": "zval *", "FUNC4": "zend_argument_value_error", "FUNC5": "spl_fixedarray_init", "TYPE4": "zend_long", "TYPE1": "zend_execute_data *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBX,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],0x0\nMOV RDX,RSP\nMOV EDI,dword ptr [RDI + 0x2c]\nLEA RSI,[0xd22725]\nCALL 0x003b6551\nCMP EAX,-0x1\nJZ 0x0029d50a\nMOV RBP,qword ptr [RSP]\nTEST RBP,RBP\nJS 0x0029d521\nMOV RBX,qword ptr [RBX + 0x20]\nSUB RBX,0x20\nMOV RDI,RBX\nCALL 0x0029bd7e\nTEST AL,AL\nJNZ 0x0029d539\nMOV RAX,qword ptr [RSP + 0x8]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x0029d546\nADD RSP,0x18\nPOP RBX\nPOP RBP\nRET\nLEA RSI,[0x53f980]\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x003addf0\nJMP 0x0029d50a\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x0029bd87\nJMP 0x0029d50a\nCALL 0x000ef7e0\n"}, "135": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  undefined *puVar1;\n  \n  puVar1 = PTR_[FUNC2] _00222fd0;\n  if (PTR_[FUNC2] _00222fd0 != (undefined *)0x0) {\n    puVar1 = (undefined *)(*(code *)PTR_[FUNC2] _00222fd0)();\n  }\n  return (int)puVar1;\n}", "answer": {"VAR1": "ctx", "FUNC2": "__gmon_start__", "FUNC1": "_init", "TYPE1": "EVP_PKEY_CTX *"}, "assembly": "SUB RSP,0x8\nMOV RAX,qword ptr [0x00222fd0]\nTEST RAX,RAX\nJZ 0x000033ba\nCALL RAX\nADD RSP,0x8\nRET\n"}, "136": {"funcbody": "/* address_location_spec::~address_location_spec() */\nvoid __thiscall address_location_spec::[FUNC1] (address_location_spec *this)\n{\n  *(undefined **)this = &DAT_00bfef30;\n  if (*(address_location_spec **)(this + 8) != this + 0x18) {\n    [FUNC2] (*(address_location_spec **)(this + 8));\n    return;\n  }\n  return;\n}", "answer": {"FUNC2": "operator.delete", "FUNC1": "~address_location_spec"}, "assembly": "LEA RAX,[0xbfef30]\nMOV qword ptr [RDI],RAX\nMOV RDX,qword ptr [RDI + 0x8]\nLEA RAX,[RDI + 0x18]\nCMP RDX,RAX\nJZ 0x003ddfbe\nSUB RSP,0x8\nMOV RDI,RDX\nCALL 0x006e1ec6\nADD RSP,0x8\nRET\nRET\n"}, "137": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,...\n          )\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  [TYPE15] [VAR15] ;\n  undefined8 [VAR14] ;\n  undefined8 [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  if (in_AL != '\\0') {\n    [VAR12] ._0_4_ = in_XMM0_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR17] [0].gp_offset = 0x20;\n  [VAR17] [0].fp_offset = 0x30;\n  [VAR17] [0].overflow_arg_area = &stack0x00000008;\n  [VAR17] [0].reg_save_area = &[VAR15] ;\n  [VAR14] = in_R8;\n  [VAR13] = in_R9;\n  [FUNC3] ([VAR1] ,\" debug\",adns_if_none,[VAR2] ,[VAR3] ,[VAR4] ,[VAR17] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"TYPE17": "va_list", "VAR1": "ads", "VAR2": "serv", "VAR3": "qu", "VAR4": "fmt", "VAR5": "local_18", "VAR6": "local_28", "FUNC2": "__stack_chk_fail", "FUNC3": "adns__vdiag", "FUNC1": "adns__debug", "TYPE3": "adns_query", "VAR14": "local_98", "TYPE2": "int", "VAR15": "local_b8", "TYPE5": "undefined1[16]", "VAR12": "local_88", "TYPE4": "char *", "VAR13": "local_90", "TYPE7": "undefined1[16]", "TYPE6": "undefined1[16]", "TYPE9": "undefined1[16]", "VAR16": "local_c0", "TYPE8": "undefined1[16]", "VAR17": "al", "VAR7": "local_38", "TYPE11": "undefined1[16]", "VAR8": "local_48", "TYPE12": "undefined1[16]", "VAR9": "local_58", "TYPE10": "undefined1[16]", "VAR10": "local_68", "TYPE15": "undefined1", "VAR11": "local_78", "TYPE16": "undefined8", "TYPE1": "adns_state", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "SUB RSP,0xd8\nMOV qword ptr [RSP + 0x40],R8\nMOV qword ptr [RSP + 0x48],R9\nTEST AL,AL\nJZ 0x0000f353\nMOVAPS xmmword ptr [RSP + 0x50],XMM0\nMOVAPS xmmword ptr [RSP + 0x60],XMM1\nMOVAPS xmmword ptr [RSP + 0x70],XMM2\nMOVAPS xmmword ptr [RSP + 0x80],XMM3\nMOVAPS xmmword ptr [RSP + 0x90],XMM4\nMOVAPS xmmword ptr [RSP + 0xa0],XMM5\nMOVAPS xmmword ptr [RSP + 0xb0],XMM6\nMOVAPS xmmword ptr [RSP + 0xc0],XMM7\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0x20\nMOV dword ptr [RSP + 0x4],0x30\nLEA RAX,[RSP + 0xe0]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nSUB RSP,0x8\nLEA RAX,[RSP + 0x8]\nPUSH RAX\nMOV R9,RCX\nMOV R8,RDX\nMOV ECX,ESI\nMOV EDX,0x0\nLEA RSI,[0x16dd4]\nCALL 0x0000f103\nADD RSP,0x10\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x0000f3c8\nADD RSP,0xd8\nRET\nCALL 0x00002e20\n"}, "138": {"funcbody": "/* _initialize_valprint() */\nvoid [FUNC1] (void)\n{\n  char *pcVar1;\n  char *pcVar2;\n  undefined auVar3 [16];\n  \n  pcVar1 = (char *)[FUNC14] (\"Generic command for showing print settings.\");\n  pcVar2 = (char *)[FUNC14] (\"Generic command for setting how things print.\");\n  auVar3 = [FUNC8] (\"print\",0xffffffff,pcVar2,pcVar1,(cmd_list_element **)&setprintlist,\n                 (cmd_list_element **)&showprintlist,(cmd_list_element **)&setlist,\n                 (cmd_list_element **)&showlist);\n  [FUNC6] (\"p\",auVar3._0_8_,0xffffffff,1,(cmd_list_element **)&setlist);\n  [FUNC6] (\"pr\",auVar3._0_8_,0xffffffff,1,(cmd_list_element **)&setlist);\n  [FUNC6] (\"p\",auVar3._8_8_,0xffffffff,1,(cmd_list_element **)&showlist);\n  [FUNC6] (\"pr\",auVar3._8_8_,0xffffffff,1,(cmd_list_element **)&showlist);\n  pcVar1 = (char *)[FUNC14] (\"Generic command for showing \\\"print raw\\\" settings.\");\n  pcVar2 = (char *)[FUNC14] (\"Generic command for setting what things to print in \\\"raw\\\" mode.\");\n  auVar3 = [FUNC8] (\"raw\",0xffffffff,pcVar2,pcVar1,(cmd_list_element **)&setprintrawlist,\n                 (cmd_list_element **)&showprintrawlist,(cmd_list_element **)&setprintlist,\n                 (cmd_list_element **)&showprintlist);\n  [FUNC4] (auVar3._0_8_,(char *)0x0);\n  [FUNC4] (auVar3._8_8_,(char *)0x0);\n  gdb::option::[FUNC12] ((option *)&Elf64_Ehdr_00000000.e_ident_class,0xc19900,value_print_option_defs,\n                      0x11,(cmd_list_element **)&setprintlist,(cmd_list_element **)&showprintlist);\n  pcVar1 = (char *)[FUNC14] (\"Show default input radix for entering numbers.\");\n  pcVar2 = (char *)[FUNC14] (\"Set default input radix for entering numbers.\");\n  [FUNC10] (\"input-radix\",4,&input_radix_1,pcVar2,pcVar1,(char *)0x0,[FUNC3] ,[FUNC5] ,\n         (cmd_list_element **)&setlist,(cmd_list_element **)&showlist);\n  pcVar1 = (char *)[FUNC14] (\"Show default output radix for printing of values.\");\n  pcVar2 = (char *)[FUNC14] (\"Set default output radix for printing of values.\");\n  [FUNC10] (\"output-radix\",4,&output_radix_1,pcVar2,pcVar1,(char *)0x0,[FUNC13] ,[FUNC2] ,\n         (cmd_list_element **)&setlist,(cmd_list_element **)&showlist);\n  pcVar1 = (char *)[FUNC14] (\n                         \"Set default input and output number radices.\\nUse \\'set input-radix\\' or \\'set output-radix\\' to independently set each.\\nWithout an argument, sets both radices back to the default value of 10.\"\n                         );\n  [FUNC7] (\"radix\",4,[FUNC11] ,pcVar1,(cmd_list_element **)&setlist);\n  pcVar1 = (char *)[FUNC14] (\n                         \"Show the default input and output number radices.\\nUse \\'show input-radix\\' or \\'show output-radix\\' to independently show each.\"\n                         );\n  [FUNC7] (\"radix\",4,[FUNC9] ,pcVar1,(cmd_list_element **)&showlist);\n  return;\n}", "answer": {"FUNC12": "add_setshow_cmds_for_options", "FUNC11": "set_radix", "FUNC14": "gettext", "FUNC13": "set_output_radix", "FUNC10": "add_setshow_zuinteger_cmd", "FUNC2": "show_output_radix", "FUNC3": "set_input_radix", "FUNC1": "_initialize_valprint", "FUNC6": "add_alias_cmd", "FUNC7": "add_cmd", "FUNC4": "deprecate_cmd", "FUNC5": "show_input_radix", "FUNC8": "add_setshow_prefix_cmd", "FUNC9": "show_radix"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nLEA RDI,[0x7e2440]\nCALL 0x000d0680\nMOV R12,RAX\nLEA RDI,[0x7e2470]\nCALL 0x000d0680\nLEA RBX,[0xc25a48]\nPUSH RBX\nLEA RBP,[0xc25a58]\nPUSH RBP\nLEA R9,[0xc259f8]\nLEA R8,[0xc25a00]\nMOV RCX,R12\nMOV RDX,RAX\nMOV ESI,0xffffffff\nLEA RDI,[0x74a69d]\nCALL 0x001c98ac\nMOV R13,RAX\nMOV R12,RDX\nADD RSP,0x10\nMOV R8,RBP\nMOV ECX,0x1\nMOV EDX,0xffffffff\nMOV RSI,R13\nLEA RDI,[0x7ae90b]\nCALL 0x001c836f\nMOV R8,RBP\nMOV ECX,0x1\nMOV EDX,0xffffffff\nMOV RSI,R13\nLEA RDI,[0x7f672a]\nCALL 0x001c836f\nMOV R8,RBX\nMOV ECX,0x1\nMOV EDX,0xffffffff\nMOV RSI,R12\nLEA RDI,[0x7ae90b]\nCALL 0x001c836f\nMOV R8,RBX\nMOV ECX,0x1\nMOV EDX,0xffffffff\nMOV RSI,R12\nLEA RDI,[0x7f672a]\nCALL 0x001c836f\nLEA RDI,[0x7e24a0]\nCALL 0x000d0680\nMOV R14,RAX\nLEA RDI,[0x7e24d8]\nCALL 0x000d0680\nLEA R13,[0xc259f8]\nPUSH R13\nLEA R12,[0xc25a00]\nPUSH R12\nLEA R9,[0xc3dc00]\nLEA R8,[0xc3dc08]\nMOV RCX,R14\nMOV RDX,RAX\nMOV ESI,0xffffffff\nLEA RDI,[0x717736]\nCALL 0x001c98ac\nMOV R14,RDX\nADD RSP,0x10\nMOV ESI,0x0\nMOV RDI,RAX\nCALL 0x001c75f2\nMOV ESI,0x0\nMOV RDI,R14\nCALL 0x001c75f2\nMOV R9,R13\nMOV R8,R12\nLEA RDX,[0xc3dc20]\nMOV ECX,0x11\nLEA RSI,[0xc19900]\nMOV EDI,0x4\nCALL 0x001cf1f2\nLEA RDI,[0x7e2518]\nCALL 0x000d0680\nMOV R12,RAX\nLEA RDI,[0x7e2548]\nCALL 0x000d0680\nPUSH RBX\nPUSH RBP\nLEA RCX,[0x5aaafc]\nPUSH RCX\nLEA RDX,[0x5ab4ad]\nPUSH RDX\nMOV R9D,0x0\nMOV R8,R12\nMOV RCX,RAX\nLEA RDX,[0xc198e4]\nMOV ESI,0x4\nLEA RDI,[0x7e1d88]\nCALL 0x001c9432\nADD RSP,0x20\nLEA RDI,[0x7e2578]\nCALL 0x000d0680\nMOV R12,RAX\nLEA RDI,[0x7e25b0]\nCALL 0x000d0680\nPUSH RBX\nPUSH RBP\nLEA RCX,[0x5aaaca]\nPUSH RCX\nLEA RSI,[0x5ab435]\nPUSH RSI\nMOV R9D,0x0\nMOV R8,R12\nMOV RCX,RAX\nLEA RDX,[0xc198e0]\nMOV ESI,0x4\nLEA RDI,[0x7e1d94]\nCALL 0x001c9432\nADD RSP,0x20\nLEA RDI,[0x7e25e8]\nCALL 0x000d0680\nMOV R8,RBP\nMOV RCX,RAX\nLEA RDX,[0x5ab4c3]\nMOV ESI,0x4\nLEA RDI,[0x7e1d8e]\nCALL 0x001c97db\nLEA RDI,[0x7e26a8]\nCALL 0x000d0680\nMOV R8,RBX\nMOV RCX,RAX\nLEA RDX,[0x5ab32b]\nMOV ESI,0x4\nLEA RDI,[0x7e1d8e]\nCALL 0x001c97db\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\n"}, "139": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  long [VAR3] ;\n  \n  [VAR3] = *(long *)(in_FS_OFFSET + 0x28);\n  uVar2 = [FUNC7] (\"mailutils\",\"incoming connection opened\");\n  [FUNC3] (1,uVar2);\n  if (debug_mode == 0) {\n    [VAR4] = 0x10;\n    iVar1 = [FUNC6] ([VAR1] ,(sockaddr *)[VAR2] ,&[VAR4] );\n    if (iVar1 < 0) {\n      piVar3 = [FUNC4] ();\n      pcVar4 = [FUNC2] (*piVar3);\n      uVar2 = [FUNC7] (\"mailutils\",\"cannot obtain IP address of client: %s\");\n      [FUNC3] (4,uVar2,pcVar4);\n      iVar1 = 1;\n    }\n    else {\n      iVar1 = 0;\n    }\n  }\n  else {\n    uVar2 = [FUNC7] (\"mailutils\",\"started in debugging mode\");\n    [FUNC3] (1,uVar2);\n    iVar1 = 1;\n  }\n  if ([VAR3] != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC5] ();\n  }\n  return iVar1;\n}", "answer": {"VAR1": "fd", "VAR2": "pcs", "VAR3": "local_20", "VAR4": "len", "VAR5": "fd-local", "VAR6": "pcs-local", "FUNC2": "strerror", "FUNC3": "mu_diag_output", "FUNC1": "pop3d_get_client_address", "FUNC6": "getpeername", "TYPE3": "undefined8", "FUNC7": "dgettext", "TYPE2": "sockaddr_in *", "FUNC4": "__errno_location", "TYPE5": "int", "FUNC5": "__stack_chk_fail", "TYPE4": "socklen_t", "TYPE6": "sockaddr_in *", "TYPE1": "int"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nPUSH RBX\nSUB RSP,0x28\nMOV dword ptr [RBP + -0x24],EDI\nMOV qword ptr [RBP + -0x30],RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RBP + -0x18],RAX\nXOR EAX,EAX\nLEA RSI,[0xc150]\nLEA RDI,[0xb97d]\nCALL 0x000048b0\nMOV RSI,RAX\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x000050c0\nMOV EAX,dword ptr [0x0020f070]\nTEST EAX,EAX\nJZ 0x00008da8\nLEA RSI,[0xc16b]\nLEA RDI,[0xb97d]\nCALL 0x000048b0\nMOV RSI,RAX\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x000050c0\nMOV EAX,0x1\nJMP 0x00008e0d\nMOV dword ptr [RBP + -0x1c],0x10\nMOV RCX,qword ptr [RBP + -0x30]\nLEA RDX,[RBP + -0x1c]\nMOV EAX,dword ptr [RBP + -0x24]\nMOV RSI,RCX\nMOV EDI,EAX\nCALL 0x00004a40\nTEST EAX,EAX\nJNS 0x00008e08\nCALL 0x00004fe0\nMOV EAX,dword ptr [RAX]\nMOV EDI,EAX\nCALL 0x00004e50\nMOV RBX,RAX\nLEA RSI,[0xc188]\nLEA RDI,[0xb97d]\nCALL 0x000048b0\nMOV RDX,RBX\nMOV RSI,RAX\nMOV EDI,0x4\nMOV EAX,0x0\nCALL 0x000050c0\nMOV EAX,0x1\nJMP 0x00008e0d\nMOV EAX,0x0\nMOV RCX,qword ptr [RBP + -0x18]\nXOR RCX,qword ptr FS:[0x28]\nJZ 0x00008e21\nCALL 0x00005020\nADD RSP,0x28\nPOP RBX\nPOP RBP\nRET\n"}, "140": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  void *vctx;\n  TYPE26 [VAR2] ;\n  PROV_CIPHER_HW *hw;\n  \n  iVar1 = [FUNC3] ();\n  if (iVar1 == 0) {\n    vctx = (void *)0x0;\n  }\n  else {\n    vctx = [FUNC5] (0x1c0,\"providers/implementations/ciphers/cipher_aes.c\",0x4d);\n    if (vctx != (void *)0x0) {\n      hw = [FUNC4] (0x100);\n      [FUNC2] (vctx,0x100,8,0x80,3,0,hw,[VAR1] );\n    }\n  }\n  return vctx;\n}", "answer": {"VAR1": "provctx", "VAR2": "ctx", "FUNC2": "ossl_cipher_generic_initkey", "FUNC3": "ossl_prov_is_running", "FUNC1": "aes_256_cfb1_newctx", "TYPE2": "PROV_AES_CTX *", "FUNC4": "ossl_prov_cipher_hw_aes_cfb1", "FUNC5": "CRYPTO_zalloc", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nCALL 0x000c3bc7\nTEST EAX,EAX\nJZ 0x000c6a73\nMOV EDX,0x4d\nLEA RSI,[0x2731f8]\nMOV EDI,0x1c0\nCALL 0x00099740\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000c6a69\nMOV EDI,0x100\nCALL 0x000cbb8e\nPUSH RBP\nPUSH RAX\nMOV R9D,0x0\nMOV R8D,0x3\nMOV ECX,0x80\nMOV EDX,0x8\nMOV ESI,0x100\nMOV RDI,RBX\nCALL 0x00107709\nADD RSP,0x10\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV EBX,0x0\nJMP 0x000c6a69\n"}, "141": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  TYPE32 [VAR3] ;\n  \n  if (([VAR1] == ([TYPE1] )0x0) &&\n     ([VAR1] = [FUNC3] (*[VAR2] ), (OSSL_METHOD_STORE *)[VAR1] == (OSSL_METHOD_STORE *)0x0)) {\n    return 0;\n  }\n  iVar1 = [FUNC2] ((OSSL_METHOD_STORE *)[VAR1] );\n  return iVar1;\n}", "answer": {"VAR1": "store", "VAR2": "data", "VAR3": "methdata", "FUNC2": "ossl_method_unlock_store", "FUNC3": "get_encoder_store", "FUNC1": "unreserve_encoder_store", "TYPE3": "encoder_data_st *", "TYPE2": "void *", "TYPE1": "void *"}, "assembly": "SUB RSP,0x8\nTEST RDI,RDI\nJZ 0x0019847f\nCALL 0x000b40de\nADD RSP,0x8\nRET\nMOV RDI,qword ptr [RSI]\nCALL 0x00197f70\nMOV RDI,RAX\nMOV EAX,0x0\nTEST RDI,RDI\nJNZ 0x00198475\nJMP 0x0019847a\n"}, "142": {"funcbody": "int [FUNC1] (TYPE10 [VAR1] ,TYPE28 [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  OSSL_LIB_CTX *libctx;\n  [TYPE4] [VAR4] ;\n  OSSL_NAMEMAP *namemap;\n  [TYPE5] [VAR5] ;\n  \n  iVar1 = 0;\n  if ([VAR1] != (TYPE10)0x0) {\n    iVar1 = 1;\n    if ([VAR1] ->prov != (OSSL_PROVIDER *)0x0) {\n      libctx = [FUNC2] ([VAR1] ->prov);\n      namemap = [FUNC3] (libctx);\n      iVar1 = [FUNC4] (namemap,[VAR1] ->scheme_id,[VAR2] ,[VAR3] );\n      return iVar1;\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "loader", "VAR2": "fn", "VAR3": "data", "VAR4": "libctx", "VAR5": "namemap", "FUNC2": "ossl_provider_libctx", "FUNC3": "ossl_namemap_stored", "FUNC1": "OSSL_STORE_LOADER_names_do_all", "TYPE3": "void *", "TYPE2": "_func_void_char_ptr_void_ptr *", "FUNC4": "ossl_namemap_doall_names", "TYPE5": "OSSL_NAMEMAP *", "TYPE4": "OSSL_LIB_CTX *", "TYPE1": "OSSL_STORE_LOADER *"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x000cdd2c\nMOV R8,qword ptr [RDI + 0x60]\nMOV EAX,0x1\nTEST R8,R8\nJZ 0x000cdd2c\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R12,RDX\nMOV RBP,RSI\nMOV RBX,RDI\nMOV RDI,R8\nCALL 0x000baa30\nMOV RDI,RAX\nCALL 0x000b21b0\nMOV ESI,dword ptr [RBX + 0x68]\nMOV RCX,R12\nMOV RDX,RBP\nMOV RDI,RAX\nCALL 0x000b1d8d\nPOP RBX\nPOP RBP\nPOP R12\nRET\nRET\n"}, "143": {"funcbody": "int [FUNC1] (TYPE18 [VAR1] ,TYPE27 [VAR2] ,[TYPE3] [VAR3] )\n{\n  long lVar1;\n  undefined8 *puVar2;\n  long in_FS_OFFSET;\n  byte bVar3;\n  TYPE51 [VAR5] ;\n  long [VAR4] ;\n  \n  bVar3 = 0;\n  [VAR4] = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC6] ([VAR1] ,[VAR2] );\n  puVar2 = (undefined8 *)[VAR5] ;\n  for (lVar1 = 0x10; lVar1 != 0; lVar1 = lVar1 + -1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + (ulong)bVar3 * -2 + 1;\n  }\n  [FUNC2] ([VAR5] ,[VAR3] ,[VAR2] ->key_length,0x80);\n  [FUNC4] ([VAR1] ,[VAR5] ,0x80);\n  [FUNC5] ([VAR5] ,0x80);\n  if ([VAR4] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 1;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "c", "VAR2": "P", "VAR3": "key", "VAR4": "local_20", "VAR5": "block", "FUNC2": "__memcpy_chk", "FUNC3": "__stack_chk_fail", "FUNC1": "ossl_blake2b_init_key", "FUNC6": "blake2b_init_param", "TYPE3": "void *", "TYPE2": "BLAKE2B_PARAM *", "FUNC4": "ossl_blake2b_update", "TYPE5": "uint8_t[128]", "FUNC5": "OPENSSL_cleanse", "TYPE4": "undefined8", "TYPE1": "BLAKE2B_CTX *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x90\nMOV RBP,RDI\nMOV RBX,RSI\nMOV R12,RDX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x88],RAX\nXOR EAX,EAX\nCALL 0x000d9f6a\nMOV RDI,RSP\nMOV ECX,0x10\nMOV EAX,0x0\nSTOSQ.REP RDI\nMOVZX EDX,byte ptr [RBX + 0x1]\nMOV RBX,RSP\nMOV ECX,0x80\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x00062300\nMOV EDX,0x80\nMOV RSI,RBX\nMOV RDI,RBP\nCALL 0x000da0fd\nMOV ESI,0x80\nMOV RDI,RBX\nCALL 0x000a4410\nMOV RCX,qword ptr [RSP + 0x88]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x000da24d\nMOV EAX,0x1\nADD RSP,0x90\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x00062640\n"}, "144": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] )\n{\n  uint uVar1;\n  RAND_POOL *pool;\n  [TYPE9] [VAR9] ;\n  size_t sVar2;\n  [TYPE10] [VAR10] ;\n  size_t __n;\n  uchar *__src;\n  [TYPE8] [VAR8] ;\n  \n  if (*(int *)((long)[VAR1] + 8) == 1) {\n    pool = [FUNC4] ([VAR4] ,1,[VAR3] ,[VAR3] );\n    if (pool == (RAND_POOL *)0x0) {\n      [FUNC6] ();\n      [FUNC7] (\"providers/implementations/rands/seed_src.c\",0x6d,\"seed_src_generate\");\n      [FUNC5] (0x39,0xc0100,(char *)0x0);\n      uVar1 = 0;\n    }\n    else {\n      sVar2 = [FUNC9] (pool);\n      if (sVar2 != 0) {\n        __n = [FUNC10] (pool);\n        __src = [FUNC8] (pool);\n        [FUNC2] ([VAR2] ,__src,__n);\n      }\n      [FUNC3] (pool);\n      uVar1 = (uint)(sVar2 != 0);\n    }\n  }\n  else {\n    [FUNC6] ();\n    [FUNC7] (\"providers/implementations/rands/seed_src.c\",0x67,\"seed_src_generate\");\n    [FUNC5] (0x39,(*(int *)((long)[VAR1] + 8) != 2) + 0xc0,(char *)0x0);\n    uVar1 = 0;\n  }\n  return uVar1;\n}", "answer": {"VAR1": "vseed", "VAR2": "out", "VAR3": "outlen", "VAR4": "strength", "FUNC10": "ossl_rand_pool_length", "VAR5": "prediction_resistance", "VAR6": "adin", "FUNC2": "memcpy", "FUNC3": "ossl_rand_pool_free", "FUNC1": "seed_src_generate", "FUNC6": "ERR_new", "TYPE3": "size_t", "FUNC7": "ERR_set_debug", "TYPE2": "uchar *", "FUNC4": "ossl_rand_pool_new", "TYPE5": "int", "FUNC5": "ERR_set_error", "TYPE4": "uint", "TYPE7": "size_t", "TYPE6": "uchar *", "FUNC8": "ossl_rand_pool_buffer", "TYPE9": "RAND_POOL *", "FUNC9": "ossl_pool_acquire_entropy", "TYPE8": "PROV_SEED_SRC *", "VAR7": "adin_len", "VAR8": "s", "VAR9": "pool", "TYPE10": "size_t", "VAR10": "entropy_available", "TYPE1": "void *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nCMP dword ptr [RDI + 0x8],0x1\nJZ 0x00101899\nCALL 0x00082d81\nLEA RDX,[0x277b10]\nMOV ESI,0x67\nLEA RDI,[0x277ad0]\nCALL 0x00082e8e\nCMP dword ptr [RBX + 0x8],0x2\nSETNZ SIL\nMOVZX ESI,SIL\nADD ESI,0xc0\nMOV EDX,0x0\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x000831a5\nMOV EAX,0x0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV RBP,RSI\nMOV EDI,ECX\nMOV RCX,RDX\nMOV ESI,0x1\nCALL 0x000a9e62\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x001018d6\nMOV RDI,RAX\nCALL 0x001022df\nMOV R12,RAX\nTEST RAX,RAX\nJNZ 0x00101916\nMOV RDI,RBX\nCALL 0x000aa03c\nTEST R12,R12\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x0010188e\nCALL 0x00082d81\nLEA RDX,[0x277b10]\nMOV ESI,0x6d\nLEA RDI,[0x277ad0]\nCALL 0x00082e8e\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x000831a5\nMOV EAX,0x0\nJMP 0x0010188e\nMOV RDI,RBX\nCALL 0x000aa0a4\nMOV R13,RAX\nMOV RDI,RBX\nCALL 0x000aa09b\nMOV RDX,R13\nMOV RSI,RAX\nMOV RDI,RBP\nCALL 0x00062b30\nJMP 0x001018c3\n"}, "145": {"funcbody": "int [FUNC1] (TYPE15 [VAR1] )\n{\n  int iVar1;\n  \n  iVar1 = 0;\n  if (([VAR1] ->version == SCT_VERSION_V1) && ([VAR1] ->hash_alg == '\\x04')) {\n    iVar1 = 0x29c;\n    if (([VAR1] ->sig_alg != '\\x01') && (iVar1 = 0x31a, [VAR1] ->sig_alg != '\\x03')) {\n      iVar1 = 0;\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "sct", "FUNC1": "SCT_get_signature_nid", "TYPE1": "SCT *"}, "assembly": "MOV EAX,0x0\nCMP dword ptr [RDI],0x0\nJNZ 0x0025a527\nCMP byte ptr [RDI + 0x40],0x4\nJZ 0x0025a529\nRET\nMOVZX EDX,byte ptr [RDI + 0x41]\nMOV EAX,0x29c\nCMP DL,0x1\nJZ 0x0025a527\nCMP DL,0x3\nMOV EAX,0x31a\nMOV EDX,0x0\nCMOVNZ EAX,EDX\nJMP 0x0025a527\n"}, "146": {"funcbody": "int [FUNC1] (TYPE18 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  RSA *key;\n  TYPE43 [VAR4] ;\n  \n  key = [FUNC3] ((RSA **)0x0,[VAR2] ,(long)[VAR3] );\n  if (key != (RSA *)0x0) {\n    [FUNC2] ((EVP_PKEY *)[VAR1] ,[VAR1] ->ameth->pkey_id,key);\n  }\n  return (uint)(key != (RSA *)0x0);\n}", "answer": {"VAR1": "pkey", "VAR2": "pder", "VAR3": "derlen", "VAR4": "rsa", "FUNC2": "EVP_PKEY_assign", "FUNC3": "d2i_RSAPrivateKey", "FUNC1": "old_rsa_priv_decode", "TYPE3": "int", "TYPE2": "uchar * *", "TYPE4": "RSA *", "TYPE1": "EVP_PKEY *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nMOVSXD RDX,EDX\nMOV EDI,0x0\nCALL 0x001c8715\nMOV ECX,0x0\nTEST RAX,RAX\nJZ 0x001c6da2\nMOV RCX,qword ptr [RBX + 0x8]\nMOV RDX,RAX\nMOV ESI,dword ptr [RCX]\nMOV RDI,RBX\nCALL 0x0008e810\nMOV ECX,0x1\nMOV EAX,ECX\nPOP RBX\nRET\n"}, "147": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  if ([VAR5] != [VAR6] ) {\n    return 1;\n  }\n  [FUNC2] ((char *)0x0,[VAR1] ,[VAR2] ,\"unsigned int\",[VAR3] ,[VAR4] ,\"!=\",\"[%u] compared to [%u]\",(ulong)[VAR5] ,\n        (ulong)[VAR5] );\n  return 0;\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "s1", "VAR4": "s2", "VAR5": "t1", "VAR6": "t2", "FUNC2": "test_fail_message", "FUNC1": "test_uint_ne", "TYPE3": "char *", "TYPE2": "int", "TYPE5": "uint", "TYPE4": "char *", "TYPE6": "uint", "TYPE1": "char *"}, "assembly": "MOV EAX,0x1\nCMP R8D,R9D\nJZ 0x0006c5fa\nRET\nSUB RSP,0x8\nMOV EAX,R8D\nMOV R9,RCX\nMOV R8,RDX\nMOV EDX,ESI\nPUSH RAX\nPUSH RAX\nLEA RAX,[0x266746]\nPUSH RAX\nLEA RAX,[0x26672e]\nPUSH RAX\nLEA RCX,[0x266739]\nMOV RSI,RDI\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x0006bc55\nMOV EAX,0x0\nADD RSP,0x28\nRET\n"}, "148": {"funcbody": "void [FUNC1] (TYPE18 [VAR1] ,TYPE26 [VAR2] )\n{\n  void **ppvVar1;\n  void **ppvVar2;\n  TYPE32 [VAR3] ;\n  [TYPE4] [VAR4] ;\n  int iVar3;\n  long lVar4;\n  \n  if ([VAR1] == (TYPE18)0x0) {\n    return;\n  }\n  iVar3 = [VAR1] ->num_nodes - 1;\n  if (-1 < iVar3) {\n    lVar4 = (long)iVar3 << 3;\n    do {\n      ppvVar2 = *(void ***)((long)[VAR1] ->b + lVar4);\n      while (ppvVar2 != (void **)0x0) {\n        ppvVar1 = (void **)ppvVar2[1];\n        (*[VAR2] )(*ppvVar2);\n        ppvVar2 = ppvVar1;\n      }\n      lVar4 = lVar4 + -8;\n      iVar3 = iVar3 + -1;\n    } while (-1 < iVar3);\n  }\n  return;\n}", "answer": {"VAR1": "lh", "VAR2": "func", "VAR3": "a", "VAR4": "n", "FUNC1": "OPENSSL_LH_doall", "TYPE3": "OPENSSL_LH_NODE *", "TYPE2": "OPENSSL_LH_DOALL_FUNC", "TYPE4": "OPENSSL_LH_NODE *", "TYPE1": "OPENSSL_LHASH *"}, "assembly": "TEST RDI,RDI\nJZ 0x000989ff\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R12D,dword ptr [RDI + 0x18]\nSUB R12D,0x1\nJS 0x000989f6\nMOV RBP,RSI\nMOV R14,RDI\nMOVSXD R13,R12D\nSHL R13,0x3\nMOV RAX,qword ptr [R14]\nMOV RAX,qword ptr [RAX + R13*0x1]\nTEST RAX,RAX\nJZ 0x000989ec\nMOV RBX,qword ptr [RAX + 0x8]\nMOV RDI,qword ptr [RAX]\nCALL RBP\nMOV RAX,RBX\nTEST RBX,RBX\nJNZ 0x000989db\nSUB R13,0x8\nSUB R12D,0x1\nJNS 0x000989cf\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nRET\n"}, "149": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         TYPE52 [VAR5] )\n{\n  int iVar1;\n  [TYPE6] [VAR6] ;\n  long in_FS_OFFSET;\n  [TYPE8] [VAR8] ;\n  long [VAR7] ;\n  \n  [VAR7] = *(long *)(in_FS_OFFSET + 0x28);\n  if ([VAR2] == 1) {\n    iVar1 = [FUNC3] ([VAR1] ->libctx,&[VAR1] ->params,1,(long)[VAR3] ,(long)[VAR4] ,&[VAR8] ,[VAR5] );\n  }\n  else {\n    iVar1 = [FUNC4] ([VAR1] ->libctx,&[VAR1] ->params,1,(long)[VAR3] ,(long)[VAR4] ,&[VAR8] ,[VAR5] );\n  }\n  if (0 < iVar1) {\n    [VAR1] ->dirty_cnt = [VAR1] ->dirty_cnt + 1;\n  }\n  if ([VAR7] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "dh", "VAR2": "type", "VAR3": "pbits", "VAR4": "qbits", "VAR5": "cb", "VAR6": "ret", "FUNC2": "__stack_chk_fail", "FUNC3": "ossl_ffc_params_FIPS186_2_generate", "FUNC1": "ossl_dh_generate_ffc_parameters", "TYPE3": "int", "TYPE2": "int", "FUNC4": "ossl_ffc_params_FIPS186_4_generate", "TYPE5": "BN_GENCB *", "TYPE4": "int", "TYPE7": "undefined8", "TYPE6": "int", "TYPE8": "int", "VAR7": "local_10", "VAR8": "res", "TYPE1": "DH *"}, "assembly": "PUSH RBX\nSUB RSP,0x10\nMOV RBX,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nCMP ESI,0x1\nJZ 0x0014a910\nMOVSXD RDX,EDX\nLEA RSI,[RDI + 0x8]\nMOV RDI,qword ptr [RDI + 0xb0]\nSUB RSP,0x8\nPUSH R8\nLEA R9,[RSP + 0x14]\nMOVSXD R8,ECX\nMOV RCX,RDX\nMOV EDX,0x1\nCALL 0x001a11ec\nADD RSP,0x10\nTEST EAX,EAX\nJLE 0x0014a8fa\nADD qword ptr [RBX + 0xc8],0x1\nMOV RBX,qword ptr [RSP + 0x8]\nXOR RBX,qword ptr FS:[0x28]\nJNZ 0x0014a93f\nADD RSP,0x10\nPOP RBX\nRET\nMOVSXD RDX,EDX\nLEA RSI,[RDI + 0x8]\nMOV RDI,qword ptr [RDI + 0xb0]\nSUB RSP,0x8\nPUSH R8\nLEA R9,[RSP + 0x14]\nMOVSXD R8,ECX\nMOV RCX,RDX\nMOV EDX,0x1\nCALL 0x001a120d\nADD RSP,0x10\nJMP 0x0014a8ee\nCALL 0x00062700\n"}, "150": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n          [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] ,[TYPE8] [VAR8] ,...)\n{\n  long lVar1;\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  [TYPE19] [VAR19] ;\n  [TYPE18] [VAR18] ;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  [TYPE15] [VAR15] ;\n  [TYPE14] [VAR14] ;\n  [TYPE13] [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  \n  if (in_AL != '\\0') {\n    [VAR16] ._0_4_ = in_XMM0_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR19] [0].gp_offset = 0x30;\n  [VAR19] [0].fp_offset = 0x30;\n  [VAR19] [0].overflow_arg_area = &stack0x00000018;\n  [VAR19] [0].reg_save_area = &[VAR17] ;\n  [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,[VAR4] ,[VAR5] ,[VAR6] ,[VAR7] ,[VAR8] ,[VAR19] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC3] ();\n}", "answer": {"TYPE19": "va_list", "TYPE17": "undefined1", "TYPE18": "undefined8", "VAR1": "prefix", "VAR2": "file", "VAR3": "line", "VAR4": "type", "VAR5": "left", "VAR6": "right", "FUNC2": "test_fail_message_va", "FUNC3": "__stack_chk_fail", "FUNC1": "test_fail_message", "TYPE3": "int", "VAR14": "local_68", "TYPE2": "char *", "VAR15": "local_78", "TYPE5": "char *", "VAR12": "local_48", "TYPE4": "char *", "VAR13": "local_58", "TYPE7": "char *", "VAR18": "local_c0", "TYPE6": "char *", "VAR19": "ap", "TYPE9": "undefined1[16]", "VAR16": "local_88", "TYPE8": "char *", "VAR17": "local_b8", "VAR7": "op", "TYPE11": "undefined1[16]", "VAR8": "fmt", "TYPE12": "undefined1[16]", "VAR9": "local_18", "TYPE10": "undefined1[16]", "VAR10": "local_28", "TYPE15": "undefined1[16]", "VAR11": "local_38", "TYPE16": "undefined1[16]", "TYPE1": "char *", "TYPE13": "undefined1[16]", "TYPE14": "undefined1[16]"}, "assembly": "SUB RSP,0xd8\nMOV R10,qword ptr [RSP + 0xe0]\nMOV R11,qword ptr [RSP + 0xe8]\nTEST AL,AL\nJZ 0x00069be4\nMOVAPS xmmword ptr [RSP + 0x50],XMM0\nMOVAPS xmmword ptr [RSP + 0x60],XMM1\nMOVAPS xmmword ptr [RSP + 0x70],XMM2\nMOVAPS xmmword ptr [RSP + 0x80],XMM3\nMOVAPS xmmword ptr [RSP + 0x90],XMM4\nMOVAPS xmmword ptr [RSP + 0xa0],XMM5\nMOVAPS xmmword ptr [RSP + 0xb0],XMM6\nMOVAPS xmmword ptr [RSP + 0xc0],XMM7\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0x30\nMOV dword ptr [RSP + 0x4],0x30\nLEA RAX,[RSP + 0xf0]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nSUB RSP,0x8\nLEA RAX,[RSP + 0x8]\nPUSH RAX\nPUSH R11\nPUSH R10\nCALL 0x00069b51\nADD RSP,0x20\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x00069c49\nADD RSP,0xd8\nRET\nCALL 0x00062730\n"}, "151": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE25 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,TYPE64 [VAR6] ,[TYPE7] [VAR7] )\n{\n  int iVar1;\n  \n  if ([VAR4] == ([TYPE4] )0x0) {\n    if (([VAR5] & 1U) == 0) {\n      if (([VAR5] & 0x84U) == 0) {\n        [FUNC10] ();\n        [FUNC9] (\"providers/implementations/encode_decode/encode_key2any.c\",0x5a7,\n              \"sm2_to_SM2_pem_encode\");\n        [FUNC6] (0x39,0x80106,(char *)0x0);\n        iVar1 = 0;\n      }\n      else {\n        iVar1 = [FUNC3] ((key2any_ctx_st *)[VAR1] ,[VAR2] ,[VAR3] ,0x494,\"SM2 PARAMETERS\",\n                      (check_key_type_fn *)0x0,[FUNC7] ,(OSSL_PASSPHRASE_CALLBACK *)0x0,(void *)0x0,\n                      (key_to_paramstring_fn *)0x0,(i2d_of_void *)PTR_[FUNC5] _00569f70);\n      }\n    }\n    else {\n      iVar1 = [FUNC3] ((key2any_ctx_st *)[VAR1] ,[VAR2] ,[VAR3] ,0x494,\"SM2 PRIVATE KEY\",\n                    (check_key_type_fn *)0x0,[FUNC4] ,[VAR6] ,[VAR7] ,[FUNC8] ,(i2d_of_void *)PTR_[FUNC2] _00569f30\n                   );\n    }\n  }\n  else {\n    [FUNC10] ();\n    [FUNC9] (\"providers/implementations/encode_decode/encode_key2any.c\",0x5a7,\"sm2_to_SM2_pem_encode\");\n    [FUNC6] (0x39,0x80106,(char *)0x0);\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "cout", "VAR3": "key", "VAR4": "key_abstract", "FUNC10": "ERR_new", "VAR5": "selection", "VAR6": "cb", "FUNC2": "i2d_ECPrivateKey", "FUNC3": "key2any_encode", "FUNC1": "sm2_to_SM2_pem_encode", "FUNC6": "ERR_set_error", "TYPE3": "void *", "FUNC7": "key_to_type_specific_pem_param_bio", "TYPE2": "OSSL_CORE_BIO *", "FUNC4": "key_to_type_specific_pem_priv_bio", "TYPE5": "int", "FUNC5": "i2d_ECParameters", "TYPE4": "OSSL_PARAM *", "TYPE7": "void *", "TYPE6": "OSSL_PASSPHRASE_CALLBACK *", "FUNC8": "prepare_ec_params", "FUNC9": "ERR_set_debug", "VAR7": "cbarg", "TYPE1": "void *"}, "assembly": "PUSH RBX\nTEST RCX,RCX\nJNZ 0x000ed46b\nTEST R8B,0x1\nJNZ 0x000ed4aa\nMOV EBX,R8D\nAND EBX,0x84\nJNZ 0x000ed4e9\nCALL 0x00081cae\nLEA RDX,[0x276640]\nMOV ESI,0x5a7\nLEA RDI,[0x276388]\nCALL 0x00081dbb\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x000820d2\nJMP 0x000ed4a6\nCALL 0x00081cae\nLEA RDX,[0x276640]\nMOV ESI,0x5a7\nLEA RDI,[0x276388]\nCALL 0x00081dbb\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x000820d2\nMOV EBX,0x0\nMOV EAX,EBX\nPOP RBX\nRET\nSUB RSP,0x8\nPUSH qword ptr [0x00569f30]\nLEA RAX,[0xef739]\nPUSH RAX\nPUSH qword ptr [RSP + 0x28]\nPUSH R9\nLEA RAX,[0xf0534]\nPUSH RAX\nMOV R9D,0x0\nLEA R8,[0x2763c1]\nMOV ECX,0x494\nCALL 0x000e892d\nMOV EBX,EAX\nADD RSP,0x30\nJMP 0x000ed4a6\nSUB RSP,0x8\nPUSH qword ptr [0x00569f70]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nLEA RAX,[0xf04fa]\nPUSH RAX\nMOV R9D,0x0\nLEA R8,[0x2763d1]\nMOV ECX,0x494\nCALL 0x000e892d\nMOV EBX,EAX\nADD RSP,0x30\nJMP 0x000ed4a6\n"}, "152": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  void *vctx;\n  TYPE24 [VAR2] ;\n  PROV_CIPHER_HW *hw;\n  \n  iVar1 = [FUNC4] ();\n  if (iVar1 == 0) {\n    vctx = (void *)0x0;\n  }\n  else {\n    vctx = [FUNC2] (0x1c0,\"providers/implementations/ciphers/cipher_aes.c\",0x4b);\n    if (vctx != (void *)0x0) {\n      hw = [FUNC3] (0x80);\n      [FUNC5] (vctx,0x80,8,0x80,3,0,hw,[VAR1] );\n    }\n  }\n  return vctx;\n}", "answer": {"VAR1": "provctx", "VAR2": "ctx", "FUNC2": "CRYPTO_zalloc", "FUNC3": "ossl_prov_cipher_hw_aes_cfb128", "FUNC1": "aes_128_cfb_newctx", "TYPE2": "PROV_AES_CTX *", "FUNC4": "ossl_prov_is_running", "FUNC5": "ossl_cipher_generic_initkey", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nCALL 0x000edf69\nTEST EAX,EAX\nJZ 0x000f0da1\nMOV EDX,0x4b\nLEA RSI,[0x28bc38]\nMOV EDI,0x1c0\nCALL 0x000b3c65\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000f0d97\nMOV EDI,0x80\nCALL 0x000f5f0e\nPUSH RBP\nPUSH RAX\nMOV R9D,0x0\nMOV R8D,0x3\nMOV ECX,0x80\nMOV EDX,0x8\nMOV ESI,0x80\nMOV RDI,RBX\nCALL 0x00131aab\nADD RSP,0x10\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV EBX,0x0\nJMP 0x000f0d97\n"}, "153": {"funcbody": "int [FUNC1] (TYPE10 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  \n  if ([VAR1] ->get_capabilities != (OSSL_FUNC_provider_get_capabilities_fn *)0x0) {\n    iVar1 = (*[VAR1] ->get_capabilities)([VAR1] ->provctx,[VAR2] ,[VAR3] ,[VAR4] );\n    return iVar1;\n  }\n  return 1;\n}", "answer": {"VAR1": "prov", "VAR2": "capability", "VAR3": "cb", "VAR4": "arg", "FUNC1": "ossl_provider_get_capabilities", "TYPE3": "OSSL_CALLBACK *", "TYPE2": "char *", "TYPE4": "void *", "TYPE1": "OSSL_PROVIDER *"}, "assembly": "MOV RAX,qword ptr [RDI + 0x88]\nTEST RAX,RAX\nJZ 0x000a0e9b\nSUB RSP,0x8\nMOV RDI,qword ptr [RDI + 0xd0]\nCALL RAX\nADD RSP,0x8\nRET\nMOV EAX,0x1\nRET\n"}, "154": {"funcbody": "/* NpingOps::setRole(int) */\nundefined4 __thiscall NpingOps::[FUNC1] (NpingOps *this,[TYPE1] [VAR1] )\n{\n  undefined4 uVar1;\n  undefined in_R8B;\n  undefined in_R9B;\n  \n  uVar1 = *(undefined4 *)(this + 0xec);\n  if (([VAR1] != 0x22 && [VAR1] != 0x44) && ([VAR1] != 0x66)) {\n    [FUNC2] (2,\"setRoleClient(): Invalid role supplied\",[VAR1] != 0x44,[VAR1] != 0x22,in_R8B,in_R9B);\n    return 0xffffffff;\n  }\n  *([TYPE1] *)(this + 0xec) = [VAR1] ;\n  this[0xf0] = (NpingOps)0x1;\n  return uVar1;\n}", "answer": {"VAR1": "param_1", "FUNC2": "nping_warning", "FUNC1": "setRole", "TYPE1": "int"}, "assembly": "MOV EAX,dword ptr [RDI + 0xec]\nCMP ESI,0x22\nSETNZ CL\nCMP ESI,0x44\nSETNZ DL\nTEST CL,DL\nJZ 0x000147c1\nCMP ESI,0x66\nJNZ 0x000147cf\nMOV dword ptr [RDI + 0xec],ESI\nMOV byte ptr [RDI + 0xf0],0x1\nRET\nSUB RSP,0x8\nLEA RSI,[0x77e80]\nMOV EDI,0x2\nMOV EAX,0x0\nCALL 0x0001ae3e\nMOV EAX,0xffffffff\nADD RSP,0x8\nRET\n"}, "155": {"funcbody": "size_t [FUNC1] (TYPE12 [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  size_t sVar2;\n  [TYPE3] [VAR3] ;\n  ulong uVar3;\n  ulong len;\n  [TYPE4] [VAR4] ;\n  \n  sVar2 = [FUNC6] ([VAR1] );\n  if ([VAR2] == 0) {\n    [FUNC3] ();\n    [FUNC2] (\"crypto/rand/rand_pool.c\",0xfc,\"ossl_rand_pool_bytes_needed\");\n    [FUNC4] (0x24,0x69,(char *)0x0);\n    len = 0;\n  }\n  else {\n    len = sVar2 * [VAR2] + 7 >> 3;\n    uVar3 = [VAR1] ->len;\n    if ([VAR1] ->max_len - uVar3 < len) {\n      [FUNC3] ();\n      [FUNC2] (\"crypto/rand/rand_pool.c\",0x104,\"ossl_rand_pool_bytes_needed\");\n      [FUNC4] (0x24,0x7d,(char *)0x0);\n      len = 0;\n    }\n    else {\n      if ((uVar3 < [VAR1] ->min_len) && (uVar3 = [VAR1] ->min_len - uVar3, len < uVar3)) {\n        len = uVar3;\n      }\n      iVar1 = [FUNC5] ([VAR1] ,len);\n      if (iVar1 == 0) {\n        [VAR1] ->len = 0;\n        [VAR1] ->max_len = 0;\n        len = 0;\n      }\n    }\n  }\n  return len;\n}", "answer": {"VAR1": "pool", "VAR2": "entropy_factor", "VAR3": "entropy_needed", "VAR4": "bytes_needed", "FUNC2": "ERR_set_debug", "FUNC3": "ERR_new", "FUNC1": "ossl_rand_pool_bytes_needed", "FUNC6": "ossl_rand_pool_entropy_needed", "TYPE3": "size_t", "TYPE2": "uint", "FUNC4": "ERR_set_error", "FUNC5": "rand_pool_grow", "TYPE4": "size_t", "TYPE1": "RAND_POOL *"}, "assembly": "PUSH R12\nPUSH RBX\nSUB RSP,0x8\nMOV R12,RDI\nMOV EBX,ESI\nCALL 0x000aa3cb\nTEST EBX,EBX\nJZ 0x000aa45b\nMOV EBX,EBX\nIMUL RAX,RBX\nLEA RBX,[RAX + 0x7]\nSHR RBX,0x3\nMOV RDX,qword ptr [R12 + 0x8]\nMOV RAX,qword ptr [R12 + 0x20]\nSUB RAX,RDX\nCMP RAX,RBX\nJC 0x000aa4a1\nMOV RAX,qword ptr [R12 + 0x18]\nCMP RDX,RAX\nJNC 0x000aa433\nSUB RAX,RDX\nCMP RBX,RAX\nCMOVC RBX,RAX\nMOV RSI,RBX\nMOV RDI,R12\nCALL 0x000a9fb1\nTEST EAX,EAX\nJNZ 0x000aa496\nMOV qword ptr [R12 + 0x8],0x0\nMOV qword ptr [R12 + 0x20],0x0\nMOV EBX,0x0\nJMP 0x000aa496\nCALL 0x00083eae\nLEA RDX,[0x271ed0]\nMOV ESI,0xfc\nLEA RDI,[0x271e40]\nCALL 0x00083fbb\nMOV EDX,0x0\nMOV ESI,0x69\nMOV EDI,0x24\nMOV EAX,0x0\nCALL 0x000842d2\nMOV EBX,0x0\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP R12\nRET\nCALL 0x00083eae\nLEA RDX,[0x271ed0]\nMOV ESI,0x104\nLEA RDI,[0x271e40]\nCALL 0x00083fbb\nMOV EDX,0x0\nMOV ESI,0x7d\nMOV EDI,0x24\nMOV EAX,0x0\nCALL 0x000842d2\nMOV EBX,0x0\nJMP 0x000aa496\n"}, "156": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE23 [VAR2] ,[TYPE3] [VAR3] )\n{\n  long lVar1;\n  int iVar2;\n  [TYPE4] TVar3;\n  [TYPE4] [VAR4] ;\n  [TYPE5] [VAR5] ;\n  ulong uVar4;\n  long in_FS_OFFSET;\n  undefined8 uStack_20;\n  TYPE70 [VAR7] ;\n  [TYPE6] [VAR6] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR1] ->type = [VAR3] ;\n  TVar3 = 8;\n  if ([VAR2] < 0) {\n    uVar4 = -[VAR2] ;\n    [VAR5] = 8;\n    do {\n      [VAR5] = [VAR5] - 1;\n      [VAR7] [[VAR5] - 1] = (uchar)uVar4;\n      uVar4 = uVar4 >> 8;\n      [VAR5] = [VAR5] ;\n    } while (uVar4 != 0);\n    [VAR1] ->type = [VAR3] | 0x100;\n    [VAR4] = [VAR5] ;\n  }\n  else {\n    do {\n      [VAR4] = TVar3 - 1;\n      [VAR7] [TVar3 - 1] = (uchar)[VAR2] ;\n      [VAR2] = (ulong)[VAR2] >> 8;\n      TVar3 = [VAR4] ;\n    } while ([VAR2] != 0);\n    [VAR1] ->type = [VAR3] & 0xfffffeff;\n  }\n  uStack_20 = (code *)0x121d61;\n  iVar2 = [FUNC3] ([VAR1] ,[VAR7] + [VAR4] ,8 - (int)[VAR4] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  uStack_20 = ASN1_INTEGER_dup;\n  [FUNC2] ();\n}", "answer": {"VAR1": "a", "VAR2": "r", "VAR3": "itype", "VAR4": "off", "VAR5": "off_1", "VAR6": "local_10", "FUNC2": "__stack_chk_fail", "FUNC3": "ASN1_STRING_set", "FUNC1": "asn1_string_set_int64", "TYPE3": "int", "TYPE2": "int64_t", "TYPE5": "size_t", "TYPE4": "size_t", "TYPE7": "uchar[8]", "TYPE6": "undefined8", "VAR7": "tbuf", "TYPE1": "ASN1_STRING *"}, "assembly": "SUB RSP,0x18\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV dword ptr [RDI + 0x4],EDX\nMOV RCX,RSI\nMOV EAX,0x8\nTEST RSI,RSI\nJS 0x00121d76\nSUB RAX,0x1\nMOV byte ptr [RSP + RAX*0x1],CL\nSHR RCX,0x8\nTEST RCX,RCX\nJNZ 0x00121d3b\nAND DH,0xfe\nMOV dword ptr [RDI + 0x4],EDX\nMOV EDX,0x8\nSUB EDX,EAX\nLEA RSI,[RSP + RAX*0x1]\nCALL 0x0006c3a8\nMOV RDI,qword ptr [RSP + 0x8]\nXOR RDI,qword ptr FS:[0x28]\nJNZ 0x00121d92\nADD RSP,0x18\nRET\nNEG RSI\nSUB RAX,0x1\nMOV byte ptr [RSP + RAX*0x1],SIL\nSHR RSI,0x8\nTEST RSI,RSI\nJNZ 0x00121d79\nOR DH,0x1\nMOV dword ptr [RDI + 0x4],EDX\nJMP 0x00121d51\nCALL 0x00062640\n"}, "157": {"funcbody": "int [FUNC1] (TYPE16 [VAR1] ,TYPE25 [VAR2] ,[TYPE3] [VAR3] )\n{\n  code *pcVar1;\n  int iVar2;\n  \n  pcVar1 = *(code **)(*(long *)[VAR1] + 0xc0);\n  if (pcVar1 == (code *)0x0) {\n    [FUNC2] ();\n    [FUNC4] (\"crypto/ec/ec_lib.c\",0x3eb,\"EC_POINT_is_on_curve\");\n    [FUNC3] (0x10,0xc0101,(char *)0x0);\n    iVar2 = 0;\n  }\n  else if ((*(long *)[VAR1] == *(long *)[VAR2] ) &&\n          (((*(int *)([VAR1] + 0x20) == 0 || (*(int *)([VAR1] + 0x20) == *(int *)([VAR2] + 8))) ||\n           (*(int *)([VAR2] + 8) == 0)))) {\n    iVar2 = (*pcVar1)();\n  }\n  else {\n    [FUNC2] ();\n    [FUNC4] (\"crypto/ec/ec_lib.c\",0x3ef,\"EC_POINT_is_on_curve\");\n    [FUNC3] (0x10,0x65,(char *)0x0);\n    iVar2 = 0;\n  }\n  return iVar2;\n}", "answer": {"VAR1": "group", "VAR2": "point", "VAR3": "ctx", "FUNC2": "ERR_new", "FUNC3": "ERR_set_error", "FUNC1": "EC_POINT_is_on_curve", "TYPE3": "BN_CTX *", "TYPE2": "EC_POINT *", "FUNC4": "ERR_set_debug", "TYPE1": "EC_GROUP *"}, "assembly": "SUB RSP,0x8\nMOV RAX,qword ptr [RDI]\nMOV RCX,qword ptr [RAX + 0xc0]\nTEST RCX,RCX\nJZ 0x00166083\nCMP RAX,qword ptr [RSI]\nJNZ 0x001660ce\nMOV EAX,dword ptr [RDI + 0x20]\nTEST EAX,EAX\nJNZ 0x001660c0\nCALL RCX\nJMP 0x00166109\nCALL 0x00081a2e\nLEA RDX,[0x291210]\nMOV ESI,0x3eb\nLEA RDI,[0x2910db]\nCALL 0x00081b3b\nMOV EDX,0x0\nMOV ESI,0xc0101\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x00081e52\nMOV EAX,0x0\nJMP 0x00166109\nMOV R8D,dword ptr [RSI + 0x8]\nCMP EAX,R8D\nJZ 0x0016607c\nTEST R8D,R8D\nJZ 0x0016607c\nCALL 0x00081a2e\nLEA RDX,[0x291210]\nMOV ESI,0x3ef\nLEA RDI,[0x2910db]\nCALL 0x00081b3b\nMOV EDX,0x0\nMOV ESI,0x65\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x00081e52\nMOV EAX,0x0\nADD RSP,0x8\nRET\n"}, "158": {"funcbody": "void [FUNC1] (TYPE12 [VAR1] )\n{\n  OPENSSL_STACK **ppOVar1;\n  TYPE24 [VAR2] ;\n  \n  ppOVar1 = (OPENSSL_STACK **)[FUNC5] (&poolkey);\n  if (ppOVar1 == (OPENSSL_STACK **)0x0) {\n    [FUNC2] ();\n    [FUNC7] (\"crypto/async/async.c\",0x8e,\"async_release_job\");\n    [FUNC4] (0x33,0xc0103,(char *)0x0);\n  }\n  else {\n    [FUNC6] ([VAR1] ->funcargs);\n    [VAR1] ->funcargs = (void *)0x0;\n    [FUNC3] (*ppOVar1,[VAR1] );\n  }\n  return;\n}", "answer": {"VAR1": "job", "VAR2": "pool", "FUNC2": "ERR_new", "FUNC3": "OPENSSL_sk_push", "FUNC1": "async_release_job", "FUNC6": "FUNC1", "FUNC7": "ERR_set_debug", "TYPE2": "async_pool *", "FUNC4": "ERR_set_error", "FUNC5": "CRYPTO_THREAD_get_local", "TYPE1": "ASYNC_JOB *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nLEA RDI,[0x577cd0]\nCALL 0x000a0b67\nTEST RAX,RAX\nJZ 0x0012a6b3\nMOV RBP,RAX\nMOV RDI,qword ptr [RBX + 0x480]\nMOV EDX,0x91\nLEA RSI,[0x27e017]\nCALL 0x00099c68\nMOV qword ptr [RBX + 0x480],0x0\nMOV RSI,RBX\nMOV RDI,qword ptr [RBP]\nCALL 0x000b1f1e\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x000815ae\nLEA RDX,[0x27e060]\nMOV ESI,0x8e\nLEA RDI,[0x27e017]\nCALL 0x000816bb\nMOV EDX,0x0\nMOV ESI,0xc0103\nMOV EDI,0x33\nMOV EAX,0x0\nCALL 0x000819d2\nJMP 0x0012a6ac\n"}, "159": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  long lVar1;\n  [TYPE4] [VAR4] ;\n  int iVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  [TYPE6] [VAR6] ;\n  long [VAR5] ;\n  \n  [VAR5] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR6] = 0;\n  if ([VAR1] == ([TYPE1] )0x0) {\n    [FUNC6] ();\n    [FUNC2] (\"crypto/bio/bio_lib.c\",0x1c8,\"BIO_gets\");\n    [FUNC5] (0x20,0xc0102,(char *)0x0);\n    iVar2 = -1;\n  }\n  else if (([VAR1] ->callback == (_func_603 *)0x0) || (*(long *)([VAR1] ->callback + 0x38) == 0)) {\n    [FUNC6] ();\n    [FUNC2] (\"crypto/bio/bio_lib.c\",0x1cc,\"BIO_gets\");\n    [FUNC5] (0x20,0x79,(char *)0x0);\n    iVar2 = -2;\n  }\n  else if ([VAR3] < 0) {\n    [FUNC6] ();\n    [FUNC2] (\"crypto/bio/bio_lib.c\",0x1d1,\"BIO_gets\");\n    [FUNC5] (0x20,0x7d,(char *)0x0);\n    iVar2 = -1;\n  }\n  else {\n    if (([VAR1] ->cb_arg != (char *)0x0) ||\n       (lVar3._0_4_ = [VAR1] ->init, lVar3._4_4_ = [VAR1] ->shutdown, lVar3 != 0)) {\n      lVar3 = [FUNC4] ((BIO *)[VAR1] ,5,[VAR2] ,(long)[VAR3] ,0,0,1,(size_t *)0x0);\n      iVar2 = (int)lVar3;\n      if (iVar2 < 1) goto LAB_000751c7;\n    }\n    if ([VAR1] ->num == 0) {\n      [FUNC6] ();\n      [FUNC2] (\"crypto/bio/bio_lib.c\",0x1dc,\"BIO_gets\");\n      [FUNC5] (0x20,0x78,(char *)0x0);\n      iVar2 = -1;\n    }\n    else {\n      iVar2 = (**(code **)([VAR1] ->callback + 0x38))([VAR1] ,[VAR2] ,[VAR3] );\n      if (0 < iVar2) {\n        [VAR6] = ([TYPE6] )iVar2;\n        iVar2 = 1;\n      }\n      if (([VAR1] ->cb_arg != (char *)0x0) ||\n         (lVar1._0_4_ = [VAR1] ->init, lVar1._4_4_ = [VAR1] ->shutdown, lVar1 != 0)) {\n        lVar3 = [FUNC4] ((BIO *)[VAR1] ,0x85,[VAR2] ,(long)[VAR3] ,0,0,(long)iVar2,&[VAR6] );\n        iVar2 = (int)lVar3;\n      }\n      if ((0 < iVar2) && (iVar2 = (int)[VAR6] , (ulong)(long)[VAR3] < [VAR6] )) {\n        iVar2 = -1;\n      }\n    }\n  }\nLAB_000751c7:\n  if ([VAR5] != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC3] ();\n  }\n  return iVar2;\n}", "answer": {"VAR1": "bp", "VAR2": "buf", "VAR3": "size", "VAR4": "ret", "VAR5": "local_20", "VAR6": "readbytes", "FUNC2": "ERR_set_debug", "FUNC3": "__stack_chk_fail", "FUNC1": "BIO_gets", "FUNC6": "ERR_new", "TYPE3": "int", "TYPE2": "char *", "FUNC4": "bio_call_callback", "TYPE5": "undefined8", "FUNC5": "ERR_set_error", "TYPE4": "int", "TYPE6": "size_t", "TYPE1": "BIO *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x10\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],0x0\nTEST RDI,RDI\nJZ 0x000751e4\nMOV RBP,RDI\nMOV R12,RSI\nMOV EBX,EDX\nMOV RAX,qword ptr [RDI + 0x8]\nTEST RAX,RAX\nJZ 0x00075221\nCMP qword ptr [RAX + 0x38],0x0\nJZ 0x00075221\nTEST EDX,EDX\nJS 0x00075261\nCMP qword ptr [RDI + 0x10],0x0\nJZ 0x000752a1\nMOVSXD RCX,EBX\nPUSH 0x0\nPUSH 0x1\nMOV R9D,0x0\nMOV R8D,0x0\nMOV RDX,R12\nMOV ESI,0x5\nMOV RDI,RBP\nCALL 0x00074647\nADD RSP,0x10\nTEST EAX,EAX\nJLE 0x000751c7\nCMP dword ptr [RBP + 0x28],0x0\nJZ 0x000752b1\nMOV RAX,qword ptr [RBP + 0x8]\nMOV EDX,EBX\nMOV RSI,R12\nMOV RDI,RBP\nCALL qword ptr [RAX + 0x38]\nTEST EAX,EAX\nJLE 0x0007517c\nCDQE\nMOV qword ptr [RSP],RAX\nMOV EAX,0x1\nCMP qword ptr [RBP + 0x10],0x0\nJZ 0x000752f1\nMOVSXD RCX,EBX\nMOV RDX,RSP\nPUSH RDX\nCDQE\nPUSH RAX\nMOV R9D,0x0\nMOV R8D,0x0\nMOV RDX,R12\nMOV ESI,0x85\nMOV RDI,RBP\nCALL 0x00074647\nADD RSP,0x10\nTEST EAX,EAX\nJLE 0x000751c7\nMOV RAX,qword ptr [RSP]\nMOVSXD RBX,EBX\nCMP RBX,RAX\nMOV EDX,0xffffffff\nCMOVC EAX,EDX\nMOV RSI,qword ptr [RSP + 0x8]\nXOR RSI,qword ptr FS:[0x28]\nJNZ 0x00075301\nADD RSP,0x10\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x0008372e\nLEA RDX,[0x261b88]\nMOV ESI,0x1c8\nLEA RDI,[0x261af0]\nCALL 0x0008383b\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0x20\nMOV EAX,0x0\nCALL 0x00083b52\nMOV EAX,0xffffffff\nJMP 0x000751c7\nCALL 0x0008372e\nLEA RDX,[0x261b88]\nMOV ESI,0x1cc\nLEA RDI,[0x261af0]\nCALL 0x0008383b\nMOV EDX,0x0\nMOV ESI,0x79\nMOV EDI,0x20\nMOV EAX,0x0\nCALL 0x00083b52\nMOV EAX,0xfffffffe\nJMP 0x000751c7\nCALL 0x0008372e\nLEA RDX,[0x261b88]\nMOV ESI,0x1d1\nLEA RDI,[0x261af0]\nCALL 0x0008383b\nMOV EDX,0x0\nMOV ESI,0x7d\nMOV EDI,0x20\nMOV EAX,0x0\nCALL 0x00083b52\nMOV EAX,0xffffffff\nJMP 0x000751c7\nCMP qword ptr [RDI + 0x18],0x0\nJNZ 0x00075129\nJMP 0x00075154\nCALL 0x0008372e\nLEA RDX,[0x261b88]\nMOV ESI,0x1dc\nLEA RDI,[0x261af0]\nCALL 0x0008383b\nMOV EDX,0x0\nMOV ESI,0x78\nMOV EDI,0x20\nMOV EAX,0x0\nCALL 0x00083b52\nMOV EAX,0xffffffff\nJMP 0x000751c7\nCMP qword ptr [RBP + 0x18],0x0\nJNZ 0x00075187\nJMP 0x000751b1\nCALL 0x00062640\n"}, "160": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  undefined8 uVar1;\n  ulong uVar2;\n  [TYPE3] [VAR3] ;\n  TYPE29 [VAR2] ;\n  undefined8 *puVar3;\n  byte bVar4;\n  \n  bVar4 = 0;\n  uVar1 = *[VAR1] ;\n  [FUNC4] (*(EVP_MAC_CTX **)((long)[VAR1] + 8));\n  [FUNC4] (*(EVP_MAC_CTX **)((long)[VAR1] + 0x10));\n  [FUNC2] (*(void **)((long)[VAR1] + 0x18),*(size_t *)((long)[VAR1] + 0x20),\n        \"providers/implementations/kdfs/tls1_prf.c\",0x82);\n  [FUNC3] ((void *)((long)[VAR1] + 0x28),*(size_t *)((long)[VAR1] + 0x428));\n  *(undefined8 *)((long)[VAR1] + 0x428) = 0;\n  puVar3 = (undefined8 *)((long)[VAR1] + 8U & 0xfffffffffffffff8);\n  uVar2 = (ulong)(((int)[VAR1] - (int)puVar3) + 0x430U >> 3);\n  for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;\n  }\n  *(undefined8 *)[VAR1] = uVar1;\n  return;\n}", "answer": {"VAR1": "vctx", "VAR2": "ctx", "VAR3": "provctx", "FUNC2": "CRYPTO_clear_free", "FUNC3": "OPENSSL_cleanse", "FUNC1": "kdf_tls1_prf_reset", "TYPE3": "void *", "TYPE2": "TLS1_PRF *", "FUNC4": "EVP_MAC_CTX_free", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,qword ptr [RDI]\nMOV RDI,qword ptr [RDI + 0x8]\nCALL 0x0019d098\nMOV RDI,qword ptr [RBX + 0x10]\nCALL 0x0019d098\nMOV RSI,qword ptr [RBX + 0x20]\nMOV RDI,qword ptr [RBX + 0x18]\nMOV ECX,0x82\nLEA RDX,[0x27a670]\nCALL 0x0009c630\nMOV RSI,qword ptr [RBX + 0x428]\nLEA RDI,[RBX + 0x28]\nCALL 0x000a4290\nMOV qword ptr [RBX + 0x428],0x0\nLEA RDI,[RBX + 0x8]\nAND RDI,-0x8\nMOV RCX,RBX\nSUB RCX,RDI\nADD ECX,0x430\nSHR ECX,0x3\nMOV ECX,ECX\nMOV EAX,0x0\nSTOSQ.REP RDI\nMOV qword ptr [RBX],RBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "161": {"funcbody": "int [FUNC1] (TYPE16 [VAR1] ,[TYPE2] [VAR2] )\n{\n  long lVar1;\n  int iVar2;\n  [TYPE3] [VAR3] ;\n  long in_FS_OFFSET;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR6] = 0xffffffff;\n  if (([VAR1] == (TYPE16)0x0) || ([VAR1] ->operation != 0x800)) {\n    [FUNC5] ();\n    [FUNC7] (\"crypto/evp/ec_ctrl.c\",0x1b,\"evp_pkey_ctx_getset_ecdh_param_checks\");\n    [FUNC3] (6,0x93,(char *)0x0);\n    iVar2 = -2;\n  }\n  else if ((([VAR1] ->keymgmt == (EVP_KEYMGMT *)0x0) && ([VAR1] ->pmeth != (EVP_PKEY_METHOD *)0x0)) &&\n          ([VAR1] ->pmeth->pkey_id != 0x198)) {\n    iVar2 = -1;\n  }\n  else {\n    [FUNC6] (\"kdf-outlen\",&[VAR6] );\n    [FUNC4] ();\n    iVar2 = [FUNC8] ([VAR1] ,[VAR5] );\n    if (iVar2 == -2) {\n      [FUNC5] ();\n      [FUNC7] (\"crypto/evp/ec_ctrl.c\",0xc2,\"EVP_PKEY_CTX_get_ecdh_kdf_outlen\");\n      [FUNC3] (6,0x93,(char *)0x0);\n    }\n    else if (iVar2 == 1) {\n      if ([VAR6] < 0x80000000) {\n        *[VAR2] = (int)[VAR6] ;\n      }\n      else {\n        iVar2 = -1;\n      }\n    }\n    else {\n      iVar2 = -1;\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "ctx", "VAR2": "plen", "VAR3": "ret", "VAR4": "local_20", "VAR5": "params", "VAR6": "len", "FUNC2": "__stack_chk_fail", "FUNC3": "ERR_set_error", "FUNC1": "EVP_PKEY_CTX_get_ecdh_kdf_outlen", "FUNC6": "OSSL_PARAM_construct_size_t", "TYPE3": "int", "FUNC7": "ERR_set_debug", "TYPE2": "int *", "FUNC4": "OSSL_PARAM_construct_end", "TYPE5": "OSSL_PARAM[2]", "FUNC5": "ERR_new", "TYPE4": "undefined8", "TYPE7": "undefined8", "TYPE6": "size_t", "FUNC8": "evp_pkey_ctx_get_params_strict", "TYPE9": "undefined8", "TYPE8": "undefined8", "VAR7": "local_98", "TYPE11": "undefined8", "VAR8": "local_a0", "VAR9": "local_a8", "TYPE10": "undefined8", "VAR10": "local_b0", "VAR11": "local_b8", "TYPE1": "EVP_PKEY_CTX *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0xa0\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x98],RAX\nXOR EAX,EAX\nMOV EAX,0xffffffff\nMOV qword ptr [RSP + 0x38],RAX\nTEST RDI,RDI\nJZ 0x00197f0e\nMOV RBX,RDI\nMOV R12,RSI\nCMP dword ptr [RDI],0x800\nJNZ 0x00197f0e\nCMP qword ptr [RDI + 0x20],0x0\nJZ 0x00197f4b\nMOV RBP,RSP\nLEA RDX,[RSP + 0x38]\nLEA RSI,[0x27bbfc]\nMOV RDI,RBP\nCALL 0x000a5d4c\nMOV RAX,qword ptr [RSP]\nMOV RDX,qword ptr [RSP + 0x8]\nMOV qword ptr [RSP + 0x40],RAX\nMOV qword ptr [RSP + 0x48],RDX\nMOV RAX,qword ptr [RSP + 0x10]\nMOV RDX,qword ptr [RSP + 0x18]\nMOV qword ptr [RSP + 0x50],RAX\nMOV qword ptr [RSP + 0x58],RDX\nMOV RAX,qword ptr [RSP + 0x20]\nMOV qword ptr [RSP + 0x60],RAX\nMOV RDI,RBP\nCALL 0x000a650b\nMOV RAX,qword ptr [RSP]\nMOV RDX,qword ptr [RSP + 0x8]\nMOV qword ptr [RSP + 0x68],RAX\nMOV qword ptr [RSP + 0x70],RDX\nMOV RAX,qword ptr [RSP + 0x10]\nMOV RDX,qword ptr [RSP + 0x18]\nMOV qword ptr [RSP + 0x78],RAX\nMOV qword ptr [RSP + 0x80],RDX\nMOV RAX,qword ptr [RSP + 0x20]\nMOV qword ptr [RSP + 0x88],RAX\nLEA RSI,[RSP + 0x40]\nMOV RDI,RBX\nCALL 0x0009c304\nMOV EBX,EAX\nCMP EAX,-0x2\nJZ 0x00197f6e\nCMP EAX,0x1\nJZ 0x00197fa9\nMOV EBX,0xffffffff\nMOV EAX,EBX\nMOV RCX,qword ptr [RSP + 0x98]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00197fc9\nADD RSP,0xa0\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x0008a597\nLEA RDX,[0x297100]\nMOV ESI,0x1b\nLEA RDI,[0x296fd2]\nCALL 0x0008a6a4\nMOV EDX,0x0\nMOV ESI,0x93\nMOV EDI,0x6\nMOV EAX,0x0\nCALL 0x0008a9bb\nMOV EBX,0xfffffffe\nJMP 0x00197ee9\nMOV RAX,qword ptr [RDI + 0x78]\nTEST RAX,RAX\nJZ 0x00197e3c\nCMP dword ptr [RAX],0x198\nJZ 0x00197e3c\nMOV EBX,0xffffffff\nJMP 0x00197ee9\nCALL 0x0008a597\nLEA RDX,[0x297040]\nMOV ESI,0xc2\nLEA RDI,[0x296fd2]\nCALL 0x0008a6a4\nMOV EDX,0x0\nMOV ESI,0x93\nMOV EDI,0x6\nMOV EAX,0x0\nCALL 0x0008a9bb\nJMP 0x00197ee9\nMOV RAX,qword ptr [RSP + 0x38]\nCMP RAX,0x7fffffff\nJA 0x00197fbf\nMOV dword ptr [R12],EAX\nJMP 0x00197ee9\nMOV EBX,0xffffffff\nJMP 0x00197ee9\nCALL 0x00062640\n"}, "162": {"funcbody": "/* expr::tuple_holding_operation<type*, std::unique_ptr<expr::operation,\n   std::default_delete<expr::operation> > >::uses_objfile(objfile*) const */\nundefined8 __thiscall\nexpr::\ntuple_holding_operation<type*,std::unique_ptr<expr::operation,std::default_delete<expr::operation>>>\n::[FUNC1] (tuple_holding_operation<type*,std::unique_ptr<expr::operation,std::default_delete<expr::operation>>>\n        *this,[TYPE1] [VAR1] )\n{\n  [TYPE1] poVar1;\n  undefined8 uVar2;\n  [TYPE1] poVar3;\n  \n  if (((*(byte *)(*(long *)(*(long *)(this + 0x10) + 0x30) + 2) & 4) != 0) &&\n     (poVar1 = *([TYPE1] *)(*(long *)(*(long *)(this + 0x10) + 0x30) + 0x10),\n     poVar1 != ([TYPE1] )0x0)) {\n    poVar3 = *([TYPE1] *)(poVar1 + 0x108);\n    if (*([TYPE1] *)(poVar1 + 0x108) == ([TYPE1] )0x0) {\n      poVar3 = poVar1;\n    }\n    if ([VAR1] == poVar3) {\n      return 1;\n    }\n  }\n  uVar2 = (**(code **)(**(long **)(this + 8) + 0x48))();\n  return uVar2;\n}", "answer": {"VAR1": "param_1", "FUNC1": "uses_objfile", "TYPE1": "objfile *"}, "assembly": "MOV RAX,qword ptr [RDI + 0x10]\nMOV RAX,qword ptr [RAX + 0x30]\nTEST byte ptr [RAX + 0x2],0x4\nJZ 0x000dbacb\nMOV RAX,qword ptr [RAX + 0x10]\nTEST RAX,RAX\nJZ 0x000dbacb\nMOV RDX,qword ptr [RAX + 0x108]\nTEST RDX,RDX\nCMOVZ RDX,RAX\nMOV EAX,0x1\nCMP RSI,RDX\nJZ 0x000dbade\nSUB RSP,0x8\nMOV RDI,qword ptr [RDI + 0x8]\nMOV RAX,qword ptr [RDI]\nCALL qword ptr [RAX + 0x48]\nADD RSP,0x8\nRET\nRET\n"}, "163": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,TYPE45 [VAR4] )\n{\n  int iVar1;\n  [TYPE5] [VAR5] ;\n  EVP_RAND_CTX *pEVar2;\n  BN_CTX *ctx;\n  [TYPE3] a;\n  [TYPE6] [VAR6] ;\n  \n  iVar1 = [FUNC8] ([VAR2] ,-1);\n  if (iVar1 == 0) {\n    return 0;\n  }\n  pEVar2 = [FUNC6] ([VAR1] ->libctx);\n  if (pEVar2 == (EVP_RAND_CTX *)0x0) {\n    return 0;\n  }\n  ctx = [FUNC9] ([VAR1] ->libctx);\n  if (ctx == (BN_CTX *)0x0) {\n    return 0;\n  }\n  a = [VAR3] ;\n  if (([VAR3] == ([TYPE3] )0x0) &&\n     ((a = ([TYPE3] )[FUNC11] (), a == ([TYPE3] )0x0 ||\n      (iVar1 = [FUNC5] ((BIGNUM *)a,0x10001), iVar1 == 0)))) {\n    iVar1 = 0;\n  }\n  else {\n    do {\n      iVar1 = [FUNC4] ([VAR1] ,(void *)0x0,[VAR2] ,a,ctx,[VAR4] );\n      if (iVar1 == 0) goto err;\n      iVar1 = [FUNC7] ([VAR1] ,[VAR2] ,a,ctx);\n      if (iVar1 < 0) {\n        iVar1 = 0;\n        goto err;\n      }\n    } while (iVar1 < 1);\n    iVar1 = [FUNC10] ([VAR1] ,ctx);\nerr:\n    if ([VAR3] != ([TYPE3] )0x0) goto LAB_001eafb5;\n  }\n  [FUNC3] ((BIGNUM *)a);\nLAB_001eafb5:\n  [FUNC2] ((BN_CTX *)ctx);\n  return iVar1;\n}", "answer": {"FUNC11": "BN_new", "VAR1": "rsa", "VAR2": "nbits", "VAR3": "efixed", "VAR4": "cb", "FUNC10": "ossl_rsa_sp800_56b_pairwise_test", "VAR5": "ok", "VAR6": "local_40", "FUNC2": "BN_CTX_free", "FUNC3": "BN_free", "FUNC1": "ossl_rsa_sp800_56b_generate_key", "FUNC6": "RAND_get0_private", "TYPE3": "BIGNUM *", "FUNC7": "ossl_rsa_sp800_56b_derive_params_from_pq", "TYPE2": "int", "FUNC4": "ossl_rsa_fips186_4_gen_prob_primes", "TYPE5": "int", "FUNC5": "BN_set_word", "TYPE4": "BN_GENCB *", "TYPE6": "undefined8", "FUNC8": "ossl_rsa_sp800_56b_validate_strength", "FUNC9": "BN_CTX_new_ex", "TYPE1": "RSA *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV R12,RDI\nMOV EBP,ESI\nMOV qword ptr [RSP + 0x8],RDX\nMOV R13,RCX\nMOV ESI,0xffffffff\nMOV EDI,EBP\nCALL 0x001ea9b2\nMOV EBX,EAX\nTEST EAX,EAX\nJNZ 0x001eaf03\nMOV EAX,EBX\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV RDI,qword ptr [R12 + 0x8]\nCALL 0x000bf93e\nMOV EBX,0x0\nTEST RAX,RAX\nJZ 0x001eaef2\nMOV RDI,qword ptr [R12 + 0x8]\nCALL 0x00156748\nMOV R14,RAX\nTEST RAX,RAX\nJZ 0x001eaef2\nMOV RAX,qword ptr [RSP + 0x8]\nMOV R15,RAX\nTEST RAX,RAX\nJZ 0x001eaf7b\nMOV R9,R13\nMOV R8,R14\nMOV RCX,R15\nMOV EDX,EBP\nMOV ESI,0x0\nMOV RDI,R12\nCALL 0x001ea6f4\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x001eafad\nMOV RCX,R14\nMOV RDX,R15\nMOV ESI,EBP\nMOV RDI,R12\nCALL 0x001eaa0a\nTEST EAX,EAX\nJS 0x001eafa8\nTEST EAX,EAX\nJLE 0x001eaf36\nMOV RSI,R14\nMOV RDI,R12\nCALL 0x001eadd5\nMOV EBX,EAX\nJMP 0x001eafad\nCALL 0x0007cace\nMOV R15,RAX\nTEST RAX,RAX\nJZ 0x001eaf99\nMOV ESI,0x10001\nMOV RDI,RAX\nCALL 0x0007d4a3\nTEST EAX,EAX\nJNZ 0x001eaf36\nMOV EBX,0x0\nMOV RDI,R15\nCALL 0x0007d2e6\nJMP 0x001eafb5\nMOV EBX,0x0\nCMP qword ptr [RSP + 0x8],0x0\nJZ 0x001eaf9e\nMOV RDI,R14\nCALL 0x00156830\nJMP 0x001eaef2\n"}, "164": {"funcbody": "undefined8\n[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n     undefined [VAR5] ,undefined [VAR6] ,[TYPE7] [VAR7] ,[TYPE8] [VAR8] ,[TYPE9] [VAR9] ,undefined8 [VAR10] ,\n     undefined8 [VAR11] ,undefined8 [VAR12] ,undefined8 [VAR13] )\n{\n  long lVar1;\n  undefined8 uVar2;\n  undefined7 in_register_00000081;\n  \n  lVar1 = [FUNC3] ();\n  if (lVar1 == 0) {\n    uVar2 = 0xffffffff;\n  }\n  else {\n    uVar2 = 0;\n    if (CONCAT71(in_register_00000081,[VAR5] ) != 0) {\n      uVar2 = [FUNC2] ((char)lVar1,[VAR5] ,[VAR6] ,(undefined)[VAR7] ,(undefined)[VAR8] ,(undefined)[VAR9] ,[VAR10] ,\n                    [VAR11] ,[VAR12] ,[VAR13] );\n    }\n  }\n  return uVar2;\n}", "answer": {"VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "VAR5": "param_5", "VAR6": "param_6", "FUNC2": "add_addr_to_dev", "FUNC3": "find_or_add_if", "FUNC1": "FUN_0002b5cd", "TYPE3": "undefined", "TYPE2": "undefined", "TYPE5": "undefined", "VAR12": "param_12", "TYPE4": "undefined", "VAR13": "param_13", "TYPE7": "undefined8", "TYPE6": "undefined", "TYPE9": "undefined8", "TYPE8": "undefined8", "VAR7": "param_7", "TYPE11": "undefined8", "VAR8": "param_8", "TYPE12": "undefined8", "VAR9": "param_9", "TYPE10": "undefined8", "VAR10": "param_10", "VAR11": "param_11", "TYPE1": "undefined", "TYPE13": "undefined8"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,R8\nMOV R12,R9\nMOV RBX,qword ptr [RSP + 0x50]\nMOV R8,RBX\nCALL 0x0002b58a\nTEST RAX,RAX\nJZ 0x0002b626\nMOV RDI,RAX\nMOV EAX,0x0\nTEST RBP,RBP\nJZ 0x0002b621\nPUSH RBX\nPUSH qword ptr [RSP + 0x50]\nPUSH qword ptr [RSP + 0x50]\nPUSH qword ptr [RSP + 0x50]\nMOV R9,qword ptr [RSP + 0x50]\nMOV R8,qword ptr [RSP + 0x48]\nMOV RCX,qword ptr [RSP + 0x40]\nMOV RDX,R12\nMOV RSI,RBP\nCALL 0x0002b0d9\nADD RSP,0x20\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV EAX,0xffffffff\nJMP 0x0002b621\n"}, "165": {"funcbody": "void [FUNC1] (long *param_1)\n{\n  long lVar1;\n  long lVar2;\n  int iVar3;\n  \n  lVar1 = *param_1;\n  iVar3 = [FUNC2] (lVar1 + 0x30,0xc4,0);\n  if (-1 < iVar3) {\n    lVar2 = *(long *)(lVar1 + 0x30);\n    *(undefined *)(lVar1 + 0x138) = 0xff;\n    *(undefined8 *)(lVar1 + 0x13c) = 0x7fffffff7fffffff;\n    *(undefined **)(lVar2 + 0x18) = &DAT_01281f80;\n    *(undefined4 *)(lVar2 + 0x20) = 0xd;\n  }\n  return;\n}", "answer": {"FUNC2": "FUN_00135671", "FUNC1": "FUN_001711bd"}, "assembly": "PUSH RBX\nMOV RBX,qword ptr [RDI]\nXOR EDX,EDX\nMOV ESI,0xc4\nLEA RDI,[RBX + 0x30]\nCALL 0x00135671\nTEST EAX,EAX\nJS 0x00171203\nMOV RDX,qword ptr [RBX + 0x30]\nLEA RSI,[0x1281f80]\nMOV RCX,0x7fffffff7fffffff\nMOV byte ptr [RBX + 0x138],0xff\nMOV qword ptr [RBX + 0x13c],RCX\nMOV qword ptr [RDX + 0x18],RSI\nMOV dword ptr [RDX + 0x20],0xd\nPOP RBX\nRET\n"}, "166": {"funcbody": "void [FUNC1] (ulong *param_1,ulong *param_2,ulong param_3,long param_4)\n{\n  ulong *puVar1;\n  ulong uVar2;\n  ulong uVar3;\n  undefined auVar4 [16];\n  undefined auVar5 [16];\n  undefined auVar6 [16];\n  undefined auVar7 [16];\n  undefined auVar8 [16];\n  undefined auVar9 [16];\n  undefined auVar10 [16];\n  undefined auVar11 [16];\n  ulong uVar12;\n  ulong uVar13;\n  ulong uVar14;\n  long lVar15;\n  ulong uVar16;\n  ulong uVar17;\n  ulong uVar18;\n  ulong uVar19;\n  ulong uVar20;\n  [TYPE1] [VAR1] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  \n  param_3 = param_3 >> 4;\n  if (param_3 != 0) {\n    uVar2 = param_1[3];\n    uVar3 = param_1[4];\n    uVar13 = *param_1;\n    uVar16 = param_1[1];\n    uVar17 = param_1[2];\n    uVar19 = (uVar3 >> 2) + uVar3;\n    do {\n      uVar14 = *param_2;\n      uVar18 = *param_2;\n      puVar1 = param_2 + 1;\n      uVar20 = uVar16 + *puVar1;\n      uVar12 = uVar20 + CARRY8(uVar13,uVar14);\n      param_2 = param_2 + 2;\n      lVar15 = uVar17 + param_4 +\n               (ulong)(CARRY8(uVar16,*puVar1) || CARRY8(uVar20,(ulong)CARRY8(uVar13,uVar14)));\n      auVar4._8_8_ = 0;\n      auVar4._0_8_ = uVar3;\n      auVar8._8_8_ = 0;\n      auVar8._0_8_ = uVar13 + uVar18;\n      auVar5._8_8_ = 0;\n      auVar5._0_8_ = uVar2;\n      auVar9._8_8_ = 0;\n      auVar9._0_8_ = uVar13 + uVar18;\n      auVar6._8_8_ = 0;\n      auVar6._0_8_ = uVar2;\n      auVar10._8_8_ = 0;\n      auVar10._0_8_ = uVar12;\n      auVar4 = auVar4 * auVar8 + auVar6 * auVar10;\n      uVar17 = auVar4._0_8_;\n      auVar7._8_8_ = 0;\n      auVar7._0_8_ = uVar19;\n      auVar11._8_8_ = 0;\n      auVar11._0_8_ = uVar12;\n      auVar5 = auVar7 * auVar11 + auVar5 * auVar9;\n      uVar20 = auVar5._0_8_;\n      uVar16 = auVar5._8_8_;\n      uVar13 = lVar15 * uVar19;\n      uVar18 = uVar17 + uVar13;\n      uVar14 = uVar16 + uVar18;\n      uVar18 = auVar4._8_8_ + (ulong)CARRY8(uVar17,uVar13) + lVar15 * uVar2 +\n               (ulong)CARRY8(uVar16,uVar18);\n      uVar16 = (uVar18 & 0xfffffffffffffffc) + (uVar18 >> 2);\n      uVar13 = uVar20 + uVar16;\n      uVar17 = (ulong)CARRY8(uVar20,uVar16);\n      uVar16 = uVar14 + uVar17;\n      uVar17 = (uVar18 & 3) + (ulong)CARRY8(uVar14,uVar17);\n      param_3 = param_3 - 1;\n    } while (param_3 != 0);\n    *param_1 = uVar13;\n    param_1[1] = uVar16;\n    param_1[2] = uVar17;\n  }\n  return;\n}", "answer": {"VAR1": "local_res0", "VAR2": "local_8", "VAR3": "local_10", "VAR4": "local_18", "VAR5": "local_20", "VAR6": "local_28", "FUNC1": "poly1305_blocks", "TYPE3": "undefined8", "TYPE2": "undefined8", "TYPE5": "undefined8", "TYPE4": "undefined8", "TYPE7": "undefined8", "TYPE6": "undefined8", "VAR7": "local_30", "TYPE1": "undefined1"}, "assembly": "SHR RDX,0x4\nJZ 0x0021feb2\nPUSH RBX\nPUSH RBP\nPUSH R12\nPUSH R13\nPUSH R14\nPUSH R15\nMOV R15,RDX\nMOV R11,qword ptr [RDI + 0x18]\nMOV R13,qword ptr [RDI + 0x20]\nMOV R14,qword ptr [RDI]\nMOV RBX,qword ptr [RDI + 0x8]\nMOV RBP,qword ptr [RDI + 0x10]\nMOV R12,R13\nSHR R13,0x2\nMOV RAX,R12\nADD R13,R12\nJMP 0x0021fe00\nADD R14,qword ptr [RSI]\nADC RBX,qword ptr [RSI + 0x8]\nLEA RSI,[RSI + 0x10]\nADC RBP,RCX\nMUL R14\nMOV R9,RAX\nMOV RAX,R11\nMOV R10,RDX\nMUL R14\nMOV R14,RAX\nMOV RAX,R11\nMOV R8,RDX\nMUL RBX\nADD R9,RAX\nMOV RAX,R13\nADC R10,RDX\nMUL RBX\nMOV RBX,RBP\nADD R14,RAX\nADC R8,RDX\nIMUL RBX,R13\nADD R9,RBX\nMOV RBX,R8\nADC R10,0x0\nIMUL RBP,R11\nADD RBX,R9\nMOV RAX,-0x4\nADC R10,RBP\nAND RAX,R10\nMOV RBP,R10\nSHR R10,0x2\nAND RBP,0x3\nADD RAX,R10\nADD R14,RAX\nADC RBX,0x0\nADC RBP,0x0\nMOV RAX,R12\nDEC R15\nJNZ 0x0021fe00\nMOV qword ptr [RDI],R14\nMOV qword ptr [RDI + 0x8],RBX\nMOV qword ptr [RDI + 0x10],RBP\nMOV R15,qword ptr [RSP]\nMOV R14,qword ptr [RSP + 0x8]\nMOV R13,qword ptr [RSP + 0x10]\nMOV R12,qword ptr [RSP + 0x18]\nMOV RBP,qword ptr [RSP + 0x20]\nMOV RBX,qword ptr [RSP + 0x28]\nLEA RSP,[RSP + 0x30]\nRET\n"}, "167": {"funcbody": "int [FUNC1] (TYPE16 [VAR1] ,TYPE26 [VAR2] )\n{\n  int iVar1;\n  \n  if ([VAR1] != (TYPE16)0x0) {\n    iVar1 = [FUNC5] ([VAR1] );\n    if ((((iVar1 == 0x197) && ([VAR1] ->poly[0] != 0)) && ([VAR1] ->poly[1] != 0)) && ([VAR1] ->poly[2] == 0)\n       ) {\n      iVar1 = 1;\n      if ([VAR2] != (TYPE26)0x0) {\n        *[VAR2] = [VAR1] ->poly[1];\n      }\n    }\n    else {\n      [FUNC4] ();\n      [FUNC3] (\"crypto/ec/ec_lib.c\",0x54a,\"EC_GROUP_get_trinomial_basis\");\n      [FUNC2] (0x10,0xc0101,(char *)0x0);\n      iVar1 = 0;\n    }\n    return iVar1;\n  }\n  return 0;\n}", "answer": {"VAR1": "group", "VAR2": "k", "FUNC2": "ERR_set_error", "FUNC3": "ERR_set_debug", "FUNC1": "EC_GROUP_get_trinomial_basis", "TYPE2": "uint *", "FUNC4": "ERR_new", "FUNC5": "EC_GROUP_get_field_type", "TYPE1": "EC_GROUP *"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x001643d9\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV RBX,RDI\nCALL 0x00162256\nCMP EAX,0x197\nJNZ 0x00164397\nCMP dword ptr [RBX + 0x48],0x0\nJZ 0x00164397\nMOV EDX,dword ptr [RBX + 0x4c]\nTEST EDX,EDX\nJZ 0x00164397\nCMP dword ptr [RBX + 0x50],0x0\nJNZ 0x00164397\nMOV EAX,0x1\nTEST RBP,RBP\nJZ 0x001643d2\nMOV dword ptr [RBP],EDX\nJMP 0x001643d2\nCALL 0x00080fae\nLEA RDX,[0x28f680]\nMOV ESI,0x54a\nLEA RDI,[0x28f5db]\nCALL 0x000810bb\nMOV EDX,0x0\nMOV ESI,0xc0101\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x000813d2\nMOV EAX,0x0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nRET\n"}, "168": {"funcbody": "int [FUNC1] (TYPE10 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  uint uVar2;\n  \n  if (([VAR1] == (TYPE10)0x0) || ([VAR2] == (TYPE20x0)) {\n    [FUNC2] ();\n    [FUNC4] (\"crypto/http/http_client.c\",0xd9,\"OSSL_HTTP_REQ_CTX_add1_header\");\n    [FUNC3] (0x3d,0xc0102,(char *)0x0);\n    uVar2 = 0;\n  }\n  else if ([VAR1] ->mem == (BIO *)0x0) {\n    [FUNC2] ();\n    [FUNC4] (\"crypto/http/http_client.c\",0xdd,\"OSSL_HTTP_REQ_CTX_add1_header\");\n    [FUNC3] (0x3d,0xc0101,(char *)0x0);\n    uVar2 = 0;\n  }\n  else {\n    iVar1 = [FUNC5] ((BIO *)[VAR1] ->mem,[VAR2] );\n    uVar2 = 0;\n    if (0 < iVar1) {\n      if ([VAR3] != (TYPE30x0) {\n        iVar1 = [FUNC6] ((BIO *)[VAR1] ->mem,\": \",2);\n        if (iVar1 != 2) {\n          return 0;\n        }\n        iVar1 = [FUNC5] ((BIO *)[VAR1] ->mem,[VAR3] );\n        if (iVar1 < 1) {\n          return 0;\n        }\n      }\n      iVar1 = [FUNC6] ((BIO *)[VAR1] ->mem,&DAT_00294f47,2);\n      uVar2 = (uint)(iVar1 == 2);\n    }\n  }\n  return uVar2;\n}", "answer": {"VAR1": "rctx", "VAR2": "name", "VAR3": "value", "FUNC2": "ERR_new", "FUNC3": "ERR_set_error", "FUNC1": "OSSL_HTTP_REQ_CTX_add1_header", "FUNC6": "BIO_write", "TYPE3": "char *", "TYPE2": "char *", "FUNC4": "ERR_set_debug", "FUNC5": "BIO_puts", "TYPE1": "OSSL_HTTP_REQ_CTX *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nTEST RDI,RDI\nJZ 0x0019fa36\nMOV RBX,RDI\nMOV RBP,RDX\nTEST RSI,RSI\nJZ 0x0019fa36\nMOV RDI,qword ptr [RDI + 0x58]\nTEST RDI,RDI\nJZ 0x0019fa7a\nCALL 0x000722f5\nMOV EDX,0x0\nTEST EAX,EAX\nJLE 0x0019fa71\nTEST RBP,RBP\nJZ 0x0019fa16\nMOV RDI,qword ptr [RBX + 0x58]\nMOV EDX,0x2\nLEA RSI,[0x2a8c00]\nCALL 0x0007227b\nMOV EDX,0x0\nCMP EAX,0x2\nJNZ 0x0019fa71\nMOV RDI,qword ptr [RBX + 0x58]\nMOV RSI,RBP\nCALL 0x000722f5\nMOV EDX,0x0\nTEST EAX,EAX\nJLE 0x0019fa71\nMOV RDI,qword ptr [RBX + 0x58]\nMOV EDX,0x2\nLEA RSI,[0x294f47]\nCALL 0x0007227b\nCMP EAX,0x2\nSETZ DL\nMOVZX EDX,DL\nJMP 0x0019fa71\nCALL 0x00080b6e\nLEA RDX,[0x293fd0]\nMOV ESI,0xd9\nLEA RDI,[0x293b93]\nCALL 0x00080c7b\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0x3d\nMOV EAX,0x0\nCALL 0x00080f92\nMOV EDX,0x0\nMOV EAX,EDX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x00080b6e\nLEA RDX,[0x293fd0]\nMOV ESI,0xdd\nLEA RDI,[0x293b93]\nCALL 0x00080c7b\nMOV EDX,0x0\nMOV ESI,0xc0101\nMOV EDI,0x3d\nMOV EAX,0x0\nCALL 0x00080f92\nMOV EDX,0x0\nJMP 0x0019fa71\n"}, "169": {"funcbody": "undefined8 [FUNC1] (long param_1)\n{\n  ushort uVar1;\n  short *psVar2;\n  int iVar3;\n  int iVar4;\n  undefined8 uVar5;\n  int iVar6;\n  int iVar7;\n  \n  if ((3 < *(int *)(param_1 + 0x10)) && (psVar2 = *(short **)(param_1 + 8), *psVar2 == 0x6b21)) {\n    iVar4 = 1;\n    iVar7 = 0;\n    iVar6 = 0;\n    do {\n      uVar1 = *(ushort *)((long)psVar2 + (long)(iVar4 * 2));\n      if ((uVar1 & 0xffef) == 0) {\n        if (uVar1 != 0) goto LAB_0045d603;\n      }\n      else {\n        if ((uVar1 != 0x76) && ((uVar1 & 0xffef) != 0x40)) {\n          return 0;\n        }\nLAB_0045d603:\n        iVar7 = iVar7 + 1;\n      }\n      iVar3 = (iVar6 + 2 + (uint)uVar1) * 2;\n      if (*(int *)(param_1 + 0x10) <= iVar3 + 3) {\n        if (iVar7 < 0xb) {\n          uVar5 = 0;\n          if (2 < iVar7) {\n            uVar5 = 0x31;\n          }\n          return uVar5;\n        }\n        return 100;\n      }\n      iVar6 = iVar6 + 2 + (uint)uVar1;\n      iVar4 = iVar6 + 1;\n    } while (*(short *)((long)psVar2 + (long)iVar3) == 0x6b21);\n  }\n  return 0;\n}", "answer": {"FUNC1": "FUN_0045d5d0"}, "assembly": "MOV R8D,dword ptr [RDI + 0x10]\nCMP R8D,0x3\nJLE 0x0045d660\nMOV RSI,qword ptr [RDI + 0x8]\nCMP word ptr [RSI],0x6b21\nJNZ 0x0045d660\nMOV EAX,0x1\nXOR EDI,EDI\nXOR EDX,EDX\nJMP 0x0045d621\nCMP ECX,0x76\nJZ 0x0045d603\nCMP AX,0x40\nJNZ 0x0045d660\nADD EDX,ECX\nADD EDI,0x1\nLEA ECX,[RDX + RDX*0x1]\nLEA EAX,[RCX + 0x3]\nCMP EAX,R8D\nJGE 0x0045d645\nMOVSXD RCX,ECX\nLEA EAX,[RDX + 0x1]\nCMP word ptr [RSI + RCX*0x1],0x6b21\nJNZ 0x0045d660\nADD EAX,EAX\nADD EDX,0x2\nCDQE\nMOVZX ECX,word ptr [RSI + RAX*0x1]\nMOV EAX,ECX\nAND AX,0xffef\nJNZ 0x0045d5f8\nTEST ECX,ECX\nJNZ 0x0045d603\nADD EDX,ECX\nLEA ECX,[RDX + RDX*0x1]\nLEA EAX,[RCX + 0x3]\nCMP EAX,R8D\nJL 0x0045d613\nCMP EDI,0xa\nMOV EAX,0x64\nJG 0x0045d662\nCMP EDI,0x3\nMOV EDX,0x31\nMOV EAX,0x0\nCMOVGE EAX,EDX\nRET\nXOR EAX,EAX\nRET\n"}, "170": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n          [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] ,[TYPE8] [VAR8] ,\n          [TYPE9] [VAR9] )\n{\n  int iVar1;\n  [TYPE10] [VAR10] ;\n  long lVar2;\n  int *piVar3;\n  char *pcVar4;\n  \n  if (([VAR3] & [VAR4] ) != 0) {\n    if ((([VAR6] == ([TYPE6] )0x0) ||\n        (([VAR2] < [VAR5] &&\n         (lVar2 = [FUNC2] ((long)[VAR2] ),\n         ([VAR6] ->__fds_bits[lVar2] & 1L << ((byte)([VAR2] % 0x40) & 0x3f)) != 0)))) &&\n       (iVar1 = (*[VAR7] )([VAR1] ,[VAR2] ,&[VAR8] ), iVar1 != 0)) {\n      if ([VAR9] == (TYPE90x0) {\n        piVar3 = [FUNC6] ();\n        pcVar4 = [FUNC4] (*piVar3);\n        [FUNC3] ([VAR1] ,-1,(adns_query)0x0,\"process fd failed after select: %s\",pcVar4);\n        [FUNC5] ([VAR1] );\n      }\n      else {\n        *[VAR9] = iVar1;\n      }\n    }\n    return;\n  }\n  return;\n}", "answer": {"VAR1": "ads", "VAR2": "fd", "VAR3": "revent", "VAR4": "pollflag", "VAR5": "maxfd", "VAR6": "fds", "FUNC2": "__fdelt_chk", "FUNC3": "adns__diag", "FUNC1": "fd_event", "FUNC6": "__errno_location", "TYPE3": "int", "TYPE2": "int", "FUNC4": "strerror", "TYPE5": "int", "FUNC5": "adns_globalsystemfailure", "TYPE4": "int", "TYPE7": "_func_int_adns_state_int_timeval_ptr *", "TYPE6": "fd_set *", "TYPE9": "int *", "TYPE8": "timeval", "VAR7": "func", "VAR8": "now", "VAR9": "r_r", "TYPE10": "int", "VAR10": "r", "TYPE1": "adns_state"}, "assembly": "TEST EDX,ECX\nJZ 0x0000a393\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,R9\nMOV R12D,ESI\nMOV RBX,RDI\nTEST R9,R9\nJNZ 0x0000a32c\nLEA RDX,[RSP + 0x28]\nMOV ESI,R12D\nMOV RDI,RBX\nCALL qword ptr [RSP + 0x20]\nTEST EAX,EAX\nJZ 0x0000a327\nCMP qword ptr [RSP + 0x38],0x0\nJZ 0x0000a35c\nMOV RBX,qword ptr [RSP + 0x38]\nMOV dword ptr [RBX],EAX\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCMP ESI,R8D\nJGE 0x0000a327\nMOVSXD RDI,ESI\nCALL 0x00002df0\nMOV EDX,R12D\nSAR EDX,0x1f\nSHR EDX,0x1a\nLEA ECX,[R12 + RDX*0x1]\nAND ECX,0x3f\nSUB ECX,EDX\nMOV EDX,0x1\nSHL RDX,CL\nTEST qword ptr [RBP + RAX*0x8],RDX\nJNZ 0x0000a305\nJMP 0x0000a327\nCALL 0x00002d40\nMOV EDI,dword ptr [RAX]\nCALL 0x000030b0\nMOV R8,RAX\nLEA RCX,[0x14990]\nMOV EDX,0x0\nMOV ESI,0xffffffff\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x0000dc61\nMOV RDI,RBX\nCALL 0x00009f42\nJMP 0x0000a327\nRET\n"}, "171": {"funcbody": "/* DWARF original prototype: void ~DefaultMap(DefaultMap<long_unsigned_int,_Vector<int>*> * this,\n   int __in_chrg) */\nvoid __thiscall\nDefaultMap<long_unsigned_int,_Vector<int>*>::[FUNC1] \n          (DefaultMap<long_unsigned_int,_Vector<int>*> *this,[TYPE1] [VAR1] )\n{\n  [FUNC3] (this,[VAR1] );\n  [FUNC2] (this,0x28);\n  return;\n}", "answer": {"VAR1": "__in_chrg", "FUNC2": "operator.delete", "FUNC3": "~DefaultMap", "FUNC1": "~DefaultMap", "TYPE1": "int"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCALL 0x0013af8a\nMOV ESI,0x28\nMOV RDI,RBX\nCALL 0x0008f9b0\nPOP RBX\nRET\n"}, "172": {"funcbody": "FILE * [FUNC1] (TYPE11 [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  FILE *pFVar4;\n  [TYPE3] [VAR3] ;\n  int *piVar5;\n  [TYPE4] [VAR4] ;\n  long in_FS_OFFSET;\n  TYPE67 [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((([VAR1] ->count < 1) && ((*(byte *)&[VAR1] ->flags & 2) != 0)) && ([VAR1] ->next_input < 1)) &&\n     ([VAR1] ->next_input_name == (char *)0x0)) {\n    iVar1 = SUB14([VAR2] != 0,0);\n    iVar3 = (*[VAR1] ->funcs->pipe)([VAR1] ,[VAR6] ,iVar1);\n    if (iVar3 < 0) {\n      pFVar4 = (FILE *)0x0;\n    }\n    else {\n      pFVar4 = (*[VAR1] ->funcs->fdopenw)([VAR1] ,[VAR6] [1],iVar1);\n      if (pFVar4 == (FILE *)0x0) {\n        piVar5 = [FUNC2] ();\n        iVar1 = *piVar5;\n        (*[VAR1] ->funcs->close)([VAR1] ,[VAR6] [0]);\n        (*[VAR1] ->funcs->close)([VAR1] ,[VAR6] [1]);\n        *piVar5 = iVar1;\n      }\n      else {\n        [VAR1] ->next_input = [VAR6] [0];\n      }\n    }\n  }\n  else {\n    piVar5 = [FUNC2] ();\n    *piVar5 = 0x16;\n    pFVar4 = (FILE *)0x0;\n  }\n  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pFVar4;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "obj", "VAR2": "binary", "VAR3": "f", "VAR4": "saved_errno", "VAR5": "local_30", "VAR6": "p", "FUNC2": "__errno_location", "FUNC3": "__stack_chk_fail", "FUNC1": "pex_input_pipe", "TYPE3": "FILE *", "TYPE2": "int", "TYPE5": "undefined8", "TYPE4": "int", "TYPE6": "int[2]", "TYPE1": "pex_obj *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nCMP dword ptr [RDI + 0x30],0x0\nJG 0x0012f6f6\nMOV RBX,RDI\nTEST byte ptr [RDI],0x2\nJZ 0x0012f6f6\nCMP dword ptr [RDI + 0x18],0x0\nJG 0x0012f6f6\nCMP qword ptr [RDI + 0x20],0x0\nJNZ 0x0012f6f6\nTEST ESI,ESI\nSETNZ BPL\nMOVZX EBP,BPL\nMOV RSI,RSP\nMOV RAX,qword ptr [RDI + 0x80]\nMOV EDX,EBP\nCALL qword ptr [RAX + 0x28]\nTEST EAX,EAX\nJS 0x0012f708\nMOV RAX,qword ptr [RBX + 0x80]\nMOV EDX,EBP\nMOV ESI,dword ptr [RSP + 0x4]\nMOV RDI,RBX\nCALL qword ptr [RAX + 0x38]\nMOV RBP,RAX\nTEST RAX,RAX\nJZ 0x0012f6c4\nMOV EAX,dword ptr [RSP]\nMOV dword ptr [RBX + 0x18],EAX\nMOV RAX,RBP\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0012f70f\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nCALL 0x00033370\nMOV R12,RAX\nMOV R13D,dword ptr [RAX]\nMOV RAX,qword ptr [RBX + 0x80]\nMOV ESI,dword ptr [RSP]\nMOV RDI,RBX\nCALL qword ptr [RAX + 0x18]\nMOV RAX,qword ptr [RBX + 0x80]\nMOV ESI,dword ptr [RSP + 0x4]\nMOV RDI,RBX\nCALL qword ptr [RAX + 0x18]\nMOV dword ptr [R12],R13D\nJMP 0x0012f6a6\nCALL 0x00033370\nMOV dword ptr [RAX],0x16\nMOV EBP,0x0\nJMP 0x0012f6a6\nMOV EBP,0x0\nJMP 0x0012f6a6\nCALL 0x000334e0\n"}, "173": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC2] ((BIGNUM *)[VAR5] ,(BIGNUM *)[VAR6] );\n  if (iVar1 != 0) {\n    [FUNC3] ((char *)0x0,[VAR1] ,[VAR2] ,\"BIGNUM\",[VAR3] ,[VAR4] ,\"==\",[VAR5] ,[VAR6] );\n  }\n  return (uint)(iVar1 == 0);\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "s1", "VAR4": "s2", "VAR5": "t1", "VAR6": "t2", "FUNC2": "BN_cmp", "FUNC3": "test_fail_bignum_message", "FUNC1": "test_BN_eq", "TYPE3": "char *", "TYPE2": "int", "TYPE5": "BIGNUM *", "TYPE4": "char *", "TYPE6": "BIGNUM *", "TYPE1": "char *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R12,RDI\nMOV R13D,ESI\nMOV R14,RDX\nMOV R15,RCX\nMOV RBX,R8\nMOV RBP,R9\nMOV RSI,R9\nMOV RDI,R8\nCALL 0x000022a0\nMOV EDX,0x1\nTEST EAX,EAX\nJNZ 0x000077d9\nMOV EAX,EDX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nSUB RSP,0x8\nPUSH RBP\nPUSH RBX\nLEA RAX,[0xad2c]\nPUSH RAX\nMOV R9,R15\nMOV R8,R14\nLEA RCX,[0xad15]\nMOV EDX,R13D\nMOV RSI,R12\nMOV EDI,0x0\nCALL 0x00009a1f\nADD RSP,0x20\nMOV EDX,0x0\nJMP 0x000077c8\n"}, "174": {"funcbody": "X509 * [FUNC1] (TYPE14 [VAR1] ,TYPE26 [VAR2] ,TYPE36 [VAR3] )\n{\n  long lVar1;\n  int iVar2;\n  X509 *a;\n  int i;\n  long in_FS_OFFSET;\n  TYPE55 [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ([VAR1] == (TYPE14)0x0) {\n    a = (X509 *)0x0;\n  }\n  else {\n    [VAR5] .cert_info.serialNumber.length = [VAR3] ->length;\n    [VAR5] .cert_info.serialNumber.type = [VAR3] ->type;\n    [VAR5] .cert_info.serialNumber.data = [VAR3] ->data;\n    [VAR5] .cert_info.serialNumber.flags = [VAR3] ->flags;\n    i = 0;\n    [VAR5] .cert_info.issuer = (X509_NAME *)[VAR2] ;\n    while( true ) {\n      iVar2 = [FUNC3] ((OPENSSL_STACK *)[VAR1] );\n      if (iVar2 <= i) break;\n      a = (X509 *)[FUNC4] ((OPENSSL_STACK *)[VAR1] ,i);\n      iVar2 = [FUNC2] (a,(X509 *)&[VAR5] );\n      if (iVar2 == 0) goto LAB_000c1778;\n      i = i + 1;\n    }\n    a = (X509 *)0x0;\n  }\nLAB_000c1778:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return a;\n  }\n  [FUNC5] ();\n}", "answer": {"VAR1": "sk", "VAR2": "name", "VAR3": "serial", "VAR4": "local_30", "VAR5": "x", "FUNC2": "X509_issuer_and_serial_cmp", "FUNC3": "OPENSSL_sk_num", "FUNC1": "X509_find_by_issuer_and_serial", "TYPE3": "ASN1_INTEGER *", "TYPE2": "X509_NAME *", "FUNC4": "OPENSSL_sk_value", "TYPE5": "X509", "FUNC5": "__stack_chk_fail", "TYPE4": "undefined8", "TYPE1": "stack_st_X509 *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x198\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x188],RAX\nXOR EAX,EAX\nTEST RDI,RDI\nJZ 0x000c179c\nMOV RBP,RDI\nMOV RCX,qword ptr [RDX]\nMOV RBX,qword ptr [RDX + 0x8]\nMOV qword ptr [RSP + 0x8],RCX\nMOV qword ptr [RSP + 0x10],RBX\nMOV RAX,qword ptr [RDX + 0x10]\nMOV qword ptr [RSP + 0x18],RAX\nMOV qword ptr [RSP + 0x30],RSI\nMOV EBX,0x0\nMOV R13,RSP\nMOV RDI,RBP\nCALL 0x000bd801\nCMP EAX,EBX\nJLE 0x000c1772\nMOV ESI,EBX\nMOV RDI,RBP\nCALL 0x000bd80f\nMOV R12,RAX\nMOV RSI,R13\nMOV RDI,RAX\nCALL 0x000c141b\nTEST EAX,EAX\nJZ 0x000c1778\nADD EBX,0x1\nJMP 0x000c1745\nMOV R12D,0x0\nMOV RAX,R12\nMOV RCX,qword ptr [RSP + 0x188]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x000c17a4\nADD RSP,0x198\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV R12D,0x0\nJMP 0x000c1778\nCALL 0x00062640\n"}, "175": {"funcbody": "void [FUNC1] (TYPE11 [VAR1] )\n{\n  byte bVar1;\n  uint uVar2;\n  uchar *puVar3;\n  \n  puVar3 = [VAR1] ->V + 0xf;\n  uVar2 = 1;\n  do {\n    bVar1 = *puVar3;\n    *puVar3 = (byte)(uVar2 + bVar1);\n    uVar2 = uVar2 + bVar1 >> 8;\n    puVar3 = puVar3 + -1;\n  } while (puVar3 != [VAR1] ->K + 0x1f);\n  return;\n}", "answer": {"VAR1": "ctr", "FUNC1": "inc_128", "TYPE1": "PROV_DRBG_CTR *"}, "assembly": "LEA RDX,[RDI + 0x63]\nADD RDI,0x53\nMOV EAX,0x1\nMOVZX ECX,byte ptr [RDX]\nADD EAX,ECX\nMOV byte ptr [RDX],AL\nSHR EAX,0x8\nSUB RDX,0x1\nCMP RDX,RDI\nJNZ 0x00129287\nRET\n"}, "176": {"funcbody": "/* DWARF original prototype: DbeInstr * map_jmid_to_PC(Experiment * this, Vaddr mid, int bci,\n   hrtime_t ts) */\nDbeInstr * __thiscall\nExperiment::[FUNC1] ([TYPE1] [VAR1] ,TYPE25 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  undefined4 extraout_var;\n  [TYPE5] [VAR5] ;\n  Function *pFVar2;\n  DbeInstr *pDVar3;\n  \n  if (([VAR2] == 0) || ([VAR1] ->jmaps == (PRBTree *)0x0)) {\n    pFVar2 = DbeSession::[FUNC3] (dbeSession);\n    pDVar3 = Function::[FUNC2] (pFVar2,0,(long)[VAR3] );\n    return pDVar3;\n  }\n  iVar1 = (*[VAR1] ->jmidHTable->_vptr_Map[3])();\n  pFVar2 = (Function *)CONCAT44(extraout_var,iVar1);\n  if (pFVar2 == (Function *)0x0) {\n    pFVar2 = (Function *)PRBTree::[FUNC4] ([VAR1] ->jmaps,[VAR2] ,[VAR4] );\n    if (pFVar2 == (Function *)0x0) goto LAB_000c4044;\n    (*[VAR1] ->jmidHTable->_vptr_Map[2])([VAR1] ->jmidHTable,[VAR2] ,pFVar2);\n  }\n  iVar1 = (*(pFVar2->super_Histable)._vptr_Histable[5])(pFVar2);\n  if (iVar1 == 2) {\n    pDVar3 = Function::[FUNC2] (pFVar2,0,(long)[VAR3] );\n    return pDVar3;\n  }\nLAB_000c4044:\n  pFVar2 = DbeSession::[FUNC3] (dbeSession);\n  pDVar3 = Function::[FUNC2] (pFVar2,0,[VAR2] );\n  return pDVar3;\n}", "answer": {"VAR1": "this", "VAR2": "mid", "VAR3": "bci", "VAR4": "ts", "VAR5": "jmthd", "FUNC2": "find_dbeinstr", "FUNC3": "get_JUnknown_Function", "FUNC1": "map_jmid_to_PC", "TYPE3": "int", "TYPE2": "Vaddr", "FUNC4": "locate_exact_match", "TYPE5": "JMethod *", "TYPE4": "hrtime_t", "TYPE1": "Experiment *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV EBP,EDX\nTEST RSI,RSI\nJZ 0x000c4062\nMOV R12,RDI\nMOV RBX,RSI\nMOV R14,RCX\nCMP qword ptr [RDI + 0xac0],0x0\nJZ 0x000c4062\nMOV RDI,qword ptr [RDI + 0xbd0]\nMOV RAX,qword ptr [RDI]\nCALL qword ptr [RAX + 0x18]\nMOV R13,RAX\nTEST RAX,RAX\nJZ 0x000c4087\nMOV RAX,qword ptr [R13]\nMOV RDI,R13\nCALL qword ptr [RAX + 0x28]\nCMP EAX,0x2\nJZ 0x000c40bb\nMOV RDI,qword ptr [0x005e4298]\nCALL 0x000abfbe\nMOV RDX,RBX\nMOV ESI,0x0\nMOV RDI,RAX\nCALL 0x000e100c\nJMP 0x000c407e\nMOV RDI,qword ptr [0x005e4298]\nCALL 0x000abfbe\nMOVSXD RDX,EBP\nMOV ESI,0x0\nMOV RDI,RAX\nCALL 0x000e100c\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV RDI,qword ptr [R12 + 0xac0]\nMOV RDX,R14\nMOV RSI,RBX\nCALL 0x000fed5c\nMOV R13,RAX\nTEST RAX,RAX\nJZ 0x000c4044\nMOV RDI,qword ptr [R12 + 0xbd0]\nMOV RAX,qword ptr [RDI]\nMOV RDX,R13\nMOV RSI,RBX\nCALL qword ptr [RAX + 0x10]\nJMP 0x000c4035\nMOVSXD RDX,EBP\nMOV ESI,0x0\nMOV RDI,R13\nCALL 0x000e100c\nJMP 0x000c407e\n"}, "177": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  OSSL_PROVIDER *prov;\n  ECX_KEY *key;\n  OSSL_LIB_CTX *libctx;\n  \n  libctx = (OSSL_LIB_CTX *)0x0;\n  if ([VAR1] ->keymgmt != (EVP_KEYMGMT *)0x0) {\n    prov = [FUNC3] ([VAR1] ->keymgmt);\n    libctx = [FUNC2] (prov);\n  }\n  key = [FUNC5] ((X509_ALGOR *)0x0,[VAR2] ,(int)[VAR3] ,[VAR1] ->ameth->pkey_id,KEY_OP_PRIVATE,libctx,\n              (char *)0x0);\n  if (key != (ECX_KEY *)0x0) {\n    [FUNC4] ((EVP_PKEY *)[VAR1] ,[VAR1] ->ameth->pkey_id,key);\n  }\n  return (uint)(key != (ECX_KEY *)0x0);\n}", "answer": {"VAR1": "pkey", "VAR2": "priv", "VAR3": "len", "FUNC2": "ossl_provider_libctx", "FUNC3": "EVP_KEYMGMT_get0_provider", "FUNC1": "ecx_set_priv_key", "TYPE3": "size_t", "TYPE2": "uchar *", "FUNC4": "EVP_PKEY_assign", "FUNC5": "ossl_ecx_key_op", "TYPE1": "EVP_PKEY *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV RBP,RSI\nMOV R12,RDX\nMOV RDI,qword ptr [RDI + 0x60]\nMOV R9D,0x0\nTEST RDI,RDI\nJZ 0x001a0c9a\nCALL 0x0009f3d7\nMOV RDI,RAX\nCALL 0x000b9b05\nMOV R9,RAX\nMOV RAX,qword ptr [RBX + 0x8]\nSUB RSP,0x8\nPUSH 0x0\nMOV R8D,0x1\nMOV ECX,dword ptr [RAX]\nMOV EDX,R12D\nMOV RSI,RBP\nMOV EDI,0x0\nCALL 0x001a00a1\nADD RSP,0x10\nMOV ECX,0x0\nTEST RAX,RAX\nJZ 0x001a0ce0\nMOV RCX,qword ptr [RBX + 0x8]\nMOV RDX,RAX\nMOV ESI,dword ptr [RCX]\nMOV RDI,RBX\nCALL 0x000a46af\nMOV ECX,0x1\nMOV EAX,ECX\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "178": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC3] ([VAR1] ,[VAR2] ,[VAR3] );\n  if (iVar1 != -1) {\n    iVar1 = [FUNC2] ([VAR1] ,[VAR4] );\n  }\n  return iVar1;\n}", "answer": {"VAR1": "a1", "VAR2": "a2", "VAR3": "a3", "VAR4": "z", "FUNC2": "winsch", "FUNC3": "wmove", "FUNC1": "mvwinsch", "TYPE3": "int", "TYPE2": "int", "TYPE4": "chtype", "TYPE1": "WINDOW *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV EBP,ECX\nCALL 0x0000a52d\nCMP EAX,-0x1\nJZ 0x000243b7\nMOV ESI,EBP\nMOV RDI,RBX\nCALL 0x00024bc8\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "179": {"funcbody": "void [FUNC1] (long param_1,long param_2,int param_3,int param_4)\n{\n  [FUNC2] ();\n  [FUNC2] (param_1 + 0x10,param_2 + 0x10,param_3,param_4);\n  param_2 = param_2 + param_4 * 8;\n  param_1 = param_1 + param_3 * 8;\n  [FUNC2] (param_1,param_2,param_3,param_4);\n  [FUNC2] (param_1 + 0x10,param_2 + 0x10,param_3,param_4);\n  return;\n}", "answer": {"FUNC2": "FUN_00dd7b80", "FUNC1": "FUN_00dd8770"}, "assembly": "PUSH R12\nPUSH RBP\nMOV R11,RDI\nPUSH RBX\nMOV RBX,RSI\nMOV EBP,EDX\nMOV R12D,ECX\nCALL 0x00dd7b80\nLEA RSI,[RBX + 0x10]\nLEA RDI,[R11 + 0x10]\nMOV ECX,R12D\nMOV EDX,EBP\nCALL 0x00dd7b80\nLEA ESI,[R12*0x8]\nLEA EDI,[RBP*0x8]\nMOV ECX,R12D\nMOV EDX,EBP\nMOVSXD RSI,ESI\nMOVSXD RDI,EDI\nADD RBX,RSI\nADD R11,RDI\nMOV RSI,RBX\nMOV RDI,R11\nCALL 0x00dd7b80\nLEA RSI,[RBX + 0x10]\nMOV ECX,R12D\nMOV EDX,EBP\nPOP RBX\nPOP RBP\nPOP R12\nLEA RDI,[R11 + 0x10]\nJMP 0x00dd7b80\n"}, "180": {"funcbody": "void [FUNC1] (undefined8 param_1,long param_2,ulong param_3)\n{\n  undefined8 *puVar1;\n  long lVar2;\n  long in_FS_OFFSET;\n  undefined auStack_b8 [32];\n  [TYPE11] [VAR11] ;\n  undefined8 [VAR10] ;\n  undefined8 [VAR9] ;\n  undefined8 [VAR8] ;\n  undefined8 [VAR7] ;\n  undefined8 [VAR6] ;\n  undefined8 [VAR5] ;\n  undefined8 [VAR4] ;\n  undefined8 [VAR3] ;\n  undefined8 [VAR2] ;\n  long [VAR1] ;\n  \n  [VAR1] = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC3] (auStack_b8,param_2,8,param_3 & 0xffffffff);\n  lVar2 = (long)(int)param_3;\n  param_2 = param_2 + param_3 * -2;\n  [VAR10] = *(undefined8 *)(param_2 + 2);\n  puVar1 = (undefined8 *)(param_2 + 2 + lVar2);\n  [VAR9] = *puVar1;\n  puVar1 = (undefined8 *)((long)puVar1 + lVar2);\n  [VAR8] = *puVar1;\n  puVar1 = (undefined8 *)((long)puVar1 + lVar2);\n  [VAR7] = *puVar1;\n  puVar1 = (undefined8 *)((long)puVar1 + lVar2);\n  [VAR6] = *puVar1;\n  puVar1 = (undefined8 *)((long)puVar1 + lVar2);\n  [VAR5] = *puVar1;\n  puVar1 = (undefined8 *)((long)puVar1 + lVar2);\n  [VAR4] = *puVar1;\n  [VAR3] = *(undefined8 *)((long)puVar1 + lVar2);\n  [VAR2] = *(undefined8 *)((long)puVar1 + lVar2 * 2);\n  [FUNC5] (&[VAR11] ,&[VAR8] ,8);\n  [FUNC2] (param_1,auStack_b8,&[VAR11] ,param_3 & 0xffffffff,8);\n  if ([VAR1] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC4] ();\n}", "answer": {"VAR1": "local_30", "VAR2": "local_38", "VAR3": "local_40", "VAR4": "local_48", "VAR5": "local_50", "VAR6": "local_58", "FUNC2": "FUN_00dee670", "FUNC3": "FUN_00ddb0c0", "FUNC1": "FUN_00deff60", "TYPE3": "undefined8", "TYPE2": "undefined8", "FUNC4": "__stack_chk_fail", "TYPE5": "undefined8", "FUNC5": "FUN_00de6fe0", "TYPE4": "undefined8", "TYPE7": "undefined8", "TYPE6": "undefined8", "TYPE9": "undefined8", "TYPE8": "undefined8", "VAR7": "local_60", "TYPE11": "undefined1", "VAR8": "local_68", "VAR9": "local_70", "TYPE10": "undefined8", "VAR10": "local_78", "VAR11": "local_98", "TYPE1": "undefined8"}, "assembly": "PUSH R13\nPUSH R12\nMOV ECX,EDX\nPUSH RBP\nPUSH RBX\nMOV RBP,RDX\nMOV RBX,RDI\nMOV EDX,0x8\nMOV R11,RSI\nSUB RSP,0x98\nMOV R12,RSP\nLEA R13,[RSP + 0x20]\nMOV RDI,R12\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x88],RAX\nXOR EAX,EAX\nCALL 0x00ddb0c0\nLEA RAX,[RBP + RBP*0x1]\nMOVSXD RDX,EBP\nLEA RSI,[RSP + 0x50]\nMOV RDI,R13\nSUB R11,RAX\nMOV RCX,qword ptr [R11 + 0x2]\nLEA RAX,[R11 + 0x2]\nADD RAX,RDX\nMOV qword ptr [RSP + 0x40],RCX\nMOV RCX,qword ptr [RAX]\nADD RAX,RDX\nMOV qword ptr [RSP + 0x48],RCX\nMOV RCX,qword ptr [RAX]\nADD RAX,RDX\nMOV qword ptr [RSP + 0x50],RCX\nMOV RCX,qword ptr [RAX]\nADD RAX,RDX\nMOV qword ptr [RSP + 0x58],RCX\nMOV RCX,qword ptr [RAX]\nADD RAX,RDX\nMOV qword ptr [RSP + 0x60],RCX\nMOV RCX,qword ptr [RAX]\nADD RAX,RDX\nMOV qword ptr [RSP + 0x68],RCX\nMOV RCX,qword ptr [RAX]\nMOV qword ptr [RSP + 0x70],RCX\nMOV RCX,qword ptr [RAX + RDX*0x1]\nMOV RAX,qword ptr [RAX + RDX*0x2]\nMOV EDX,0x8\nMOV qword ptr [RSP + 0x78],RCX\nMOV qword ptr [RSP + 0x80],RAX\nCALL 0x00de6fe0\nMOV R8D,0x8\nMOV ECX,EBP\nMOV RDX,R13\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x00dee670\nMOV RAX,qword ptr [RSP + 0x88]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x00df0058\nADD RSP,0x98\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nCALL 0x0010cf30\n"}, "181": {"funcbody": "/* linux_mntns_readlink(int, char const*, char*, unsigned long) */\nssize_t [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  char cVar1;\n  int iVar2;\n  ssize_t sVar3;\n  long lVar4;\n  char *pcVar5;\n  int *piVar6;\n  long lVar7;\n  [TYPE2] pcVar8;\n  undefined in_R9B;\n  undefined uVar9;\n  long in_FS_OFFSET;\n  byte bVar10;\n  int [VAR9] ;\n  int [VAR8] ;\n  int [VAR7] ;\n  int [VAR6] ;\n  long [VAR5] ;\n  \n  bVar10 = 0;\n  [VAR5] = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = [FUNC5] ([VAR1] );\n  if (iVar2 == -1) {\n    sVar3 = -1;\n  }\n  else if (iVar2 == 0) {\n    sVar3 = [FUNC9] ([VAR2] ,[VAR3] ,[VAR4] );\n  }\n  else {\n    if (iVar2 != 1) {\n      pcVar5 = (char *)[FUNC8] (\"%s: Assertion `%s\\' failed.\");\n      [FUNC3] (\"nat/linux-namespaces.c\",0x408,pcVar5,0x40,0x79,in_R9B);\n    }\n    lVar4 = [FUNC2] ();\n    lVar7 = -1;\n    pcVar8 = [VAR2] ;\n    do {\n      if (lVar7 == 0) break;\n      lVar7 = lVar7 + -1;\n      cVar1 = *pcVar8;\n      pcVar8 = pcVar8 + (ulong)bVar10 * -2 + 1;\n    } while (cVar1 != '\\0');\n    lVar7 = [FUNC6] (*(int *)(lVar4 + 4),4,-1,0,0,[VAR2] ,~(uint)lVar7);\n    if (lVar7 < 0) {\n      sVar3 = -1;\n    }\n    else {\n      lVar4 = [FUNC4] (*(int *)(lVar4 + 4),(mnsh_msg_type *)&[VAR7] ,&[VAR6] ,&[VAR9] ,&[VAR8] ,[VAR3] ,(int)[VAR4] );\n      uVar9 = SUB81([VAR3] ,0);\n      if (lVar4 < 0) {\n        [VAR9] = -1;\n        piVar6 = [FUNC10] ();\n        *piVar6 = [VAR8] ;\n      }\n      else {\n        if ([VAR7] != 7) {\n          pcVar5 = (char *)[FUNC8] (\"%s: Assertion `%s\\' failed.\");\n          [FUNC3] (\"nat/linux-namespaces.c\",0x357,pcVar5,0x20,0x92,uVar9);\n        }\n        if ([VAR6] != -1) {\n          pcVar5 = (char *)[FUNC8] (\"%s: Assertion `%s\\' failed.\");\n          [FUNC3] (\"nat/linux-namespaces.c\",0x358,pcVar5,0x20,0x8e,uVar9);\n        }\n        if ([VAR9] != lVar4) {\n          pcVar5 = (char *)[FUNC8] (\"%s: Assertion `%s\\' failed.\");\n          [FUNC3] (\"nat/linux-namespaces.c\",0x418,pcVar5,0x40,0xaa,uVar9);\n        }\n      }\n      sVar3 = (ssize_t)[VAR9] ;\n    }\n  }\n  if ([VAR5] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return sVar3;\n  }\n  [FUNC7] ();\n}", "answer": {"VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "FUNC10": "__errno_location", "VAR5": "local_30", "VAR6": "local_34", "FUNC2": "linux_mntns_get_helper", "FUNC3": "internal_error_loc", "FUNC1": "linux_mntns_readlink", "FUNC6": "mnsh_send_message", "TYPE3": "char *", "FUNC7": "__stack_chk_fail", "TYPE2": "char *", "FUNC4": "mnsh_recv_message", "TYPE5": "undefined8", "FUNC5": "linux_mntns_access_fs", "TYPE4": "ulong", "TYPE7": "undefined4", "TYPE6": "undefined4", "FUNC8": "gettext", "TYPE9": "undefined4", "FUNC9": "readlink", "TYPE8": "undefined4", "VAR7": "local_38", "VAR8": "local_3c", "VAR9": "local_40", "TYPE1": "int"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV RBX,RSI\nMOV RBP,RDX\nMOV R12,RCX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nCALL 0x0042d206\nCMP EAX,-0x1\nJZ 0x0042d8b3\nTEST EAX,EAX\nJNZ 0x0042d736\nMOV RDX,R12\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x000cff00\nMOV RBX,qword ptr [RSP + 0x18]\nXOR RBX,qword ptr FS:[0x28]\nJNZ 0x0042d8e3\nADD RSP,0x28\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nCMP EAX,0x1\nJNZ 0x0042d7e7\nCALL 0x0042cab0\nMOV R13,RAX\nMOV RDX,-0x1\nMOV EAX,0x0\nMOV RCX,RDX\nMOV RDI,RBX\nSCASB.REPNE RDI\nMOV RAX,RCX\nMOV EDI,dword ptr [R13 + 0x4]\nSUB RSP,0x8\nNOT EAX\nPUSH RAX\nMOV R9,RBX\nMOV R8D,0x0\nMOV ECX,0x0\nMOV ESI,0x4\nCALL 0x0042c580\nADD RSP,0x10\nTEST RAX,RAX\nJS 0x0042d8bf\nLEA RCX,[RSP + 0x8]\nLEA RDX,[RSP + 0x14]\nLEA RSI,[RSP + 0x10]\nMOV EDI,dword ptr [R13 + 0x4]\nSUB RSP,0x8\nPUSH R12\nMOV R9,RBP\nLEA R8,[RSP + 0x1c]\nCALL 0x0042cd7a\nADD RSP,0x10\nTEST RAX,RAX\nJS 0x0042d8cb\nCMP dword ptr [RSP + 0x10],0x7\nJNZ 0x0042d81a\nCMP dword ptr [RSP + 0x14],-0x1\nJNZ 0x0042d84d\nMOVSXD RDX,dword ptr [RSP + 0x8]\nCMP RDX,RAX\nJNZ 0x0042d880\nMOVSXD RAX,dword ptr [RSP + 0x8]\nJMP 0x0042d717\nLEA RDI,[0x706c44]\nCALL 0x000d0680\nLEA R8,[0x7a6479]\nLEA RCX,[0x7a6640]\nMOV RDX,RAX\nMOV ESI,0x408\nLEA RDI,[0x7a6393]\nMOV EAX,0x0\nCALL 0x006ddbcc\nLEA RDI,[0x706c44]\nCALL 0x000d0680\nLEA R8,[0x7a6492]\nLEA RCX,[0x7a6620]\nMOV RDX,RAX\nMOV ESI,0x357\nLEA RDI,[0x7a6393]\nMOV EAX,0x0\nCALL 0x006ddbcc\nLEA RDI,[0x706c44]\nCALL 0x000d0680\nLEA R8,[0x77528e]\nLEA RCX,[0x7a6620]\nMOV RDX,RAX\nMOV ESI,0x358\nLEA RDI,[0x7a6393]\nMOV EAX,0x0\nCALL 0x006ddbcc\nLEA RDI,[0x706c44]\nCALL 0x000d0680\nLEA R8,[0x7a64aa]\nLEA RCX,[0x7a6640]\nMOV RDX,RAX\nMOV ESI,0x418\nLEA RDI,[0x7a6393]\nMOV EAX,0x0\nCALL 0x006ddbcc\nMOV RAX,-0x1\nJMP 0x0042d717\nMOV RAX,-0x1\nJMP 0x0042d717\nMOV dword ptr [RSP + 0x8],0xffffffff\nCALL 0x000d1850\nMOV EDX,dword ptr [RSP + 0xc]\nMOV dword ptr [RAX],EDX\nJMP 0x0042d7dd\nCALL 0x000cff10\n"}, "182": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  OSSL_LIB_CTX *ctx;\n  OSSL_CORE_HANDLE **ppOVar1;\n  TYPE37 [VAR3] ;\n  OSSL_CORE_HANDLE *pOVar2;\n  TYPE46 [VAR4] ;\n  OSSL_CORE_HANDLE *pOVar3;\n  \n  ctx = [FUNC4] ([VAR1] );\n  ppOVar1 = (OSSL_CORE_HANDLE **)[FUNC3] (ctx,0x12,&child_prov_ossl_ctx_method);\n  [VAR3] ._0_4_ = 0;\n  if (ppOVar1 != (OSSL_CORE_HANDLE **)0x0) {\n    pOVar2 = [FUNC2] ([VAR1] );\n    [VAR4] ._0_4_ = 1;\n    [VAR3] ._0_4_ = (int)[VAR4] ;\n    if (*ppOVar1 != pOVar2) {\n      pOVar2 = ppOVar1[10];\n      pOVar3 = [FUNC2] ([VAR1] );\n      [VAR3] ._0_4_ = (*(code *)pOVar2)(pOVar3,[VAR2] );\n    }\n  }\n  return (int)[VAR3] ;\n}", "answer": {"VAR1": "prov", "VAR2": "deactivate", "VAR3": "gbl", "VAR4": "parent_handle", "FUNC2": "ossl_provider_get_parent", "FUNC3": "ossl_lib_ctx_get_data", "FUNC1": "ossl_provider_free_parent", "TYPE3": "child_prov_globals *", "TYPE2": "int", "FUNC4": "ossl_provider_libctx", "TYPE4": "OSSL_CORE_HANDLE *", "TYPE1": "OSSL_PROVIDER *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV R12D,ESI\nCALL 0x0013538a\nLEA RDX,[0x5a3c00]\nMOV ESI,0x12\nMOV RDI,RAX\nCALL 0x00129e83\nMOV RBP,RAX\nMOV EAX,0x0\nTEST RBP,RBP\nJZ 0x00133cbc\nMOV RDI,RBX\nCALL 0x0013616a\nMOV RDX,RAX\nMOV EAX,0x1\nCMP qword ptr [RBP],RDX\nJZ 0x00133cbc\nMOV RBP,qword ptr [RBP + 0x50]\nMOV RDI,RBX\nCALL 0x0013616a\nMOV ESI,R12D\nMOV RDI,RAX\nCALL RBP\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "183": {"funcbody": "uint [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  undefined8 uVar1;\n  TYPE40 [VAR4] ;\n  TYPE55 [VAR5] ;\n  \n  *(undefined8 *)[VAR3] = 0;\n  *(undefined8 *)((long)[VAR3] + 8) = 0;\n  *(undefined8 *)((long)[VAR3] + 0x10) = 0;\n  *(undefined8 *)((long)[VAR3] + 0x18) = 0;\n  *(undefined8 *)((long)[VAR3] + 0x20) = 0;\n  *(undefined8 *)((long)[VAR3] + 0x28) = 0;\n  *(undefined8 *)((long)[VAR3] + 0x30) = 0;\n  (*[VAR1] ->xvec->bfd_h_putx16)(0,[VAR3] );\n  (*[VAR1] ->xvec->bfd_h_putx16)(0xffff,(void *)((long)[VAR3] + 2));\n  (*[VAR1] ->xvec->bfd_h_putx16)(2,(void *)((long)[VAR3] + 4));\n  uVar1 = header_bigobj_classid._8_8_;\n  *(undefined8 *)((long)[VAR3] + 0xc) = header_bigobj_classid._0_8_;\n  *(undefined8 *)((long)[VAR3] + 0x14) = uVar1;\n  (*[VAR1] ->xvec->bfd_h_putx16)((bfd_vma)*(undefined2 *)((long)[VAR2] + 0x90),(void *)((long)[VAR3] + 6));\n  (*[VAR1] ->xvec->bfd_h_putx32)\n            ((bfd_vma)*(undefined4 *)((long)[VAR2] + 0x94),(void *)((long)[VAR3] + 0x2c));\n  (*[VAR1] ->xvec->bfd_h_putx32)(*(bfd_vma *)((long)[VAR2] + 0x98),(void *)((long)[VAR3] + 8));\n  (*[VAR1] ->xvec->bfd_h_putx32)(*(bfd_vma *)((long)[VAR2] + 0xa0),(void *)((long)[VAR3] + 0x30));\n  (*[VAR1] ->xvec->bfd_h_putx32)(*(bfd_vma *)((long)[VAR2] + 0xa8),(void *)((long)[VAR3] + 0x34));\n  return *(uint *)((long)[VAR1] ->xvec->backend_data + 0x50);\n}", "answer": {"VAR1": "abfd", "VAR2": "in", "VAR3": "out", "VAR4": "filehdr_out", "VAR5": "filehdr_in", "FUNC1": "coff_bigobj_swap_filehdr_out", "TYPE3": "void *", "TYPE2": "void *", "TYPE5": "internal_filehdr *", "TYPE4": "external_ANON_OBJECT_HEADER_BIGOBJ *", "TYPE1": "bfd *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,RDI\nMOV R12,RSI\nMOV RBX,RDX\nMOV qword ptr [RDX],0x0\nMOV qword ptr [RDX + 0x8],0x0\nMOV qword ptr [RDX + 0x10],0x0\nMOV qword ptr [RDX + 0x18],0x0\nMOV qword ptr [RDX + 0x20],0x0\nMOV qword ptr [RDX + 0x28],0x0\nMOV qword ptr [RDX + 0x30],0x0\nMOV RAX,qword ptr [RDI + 0x8]\nMOV RSI,RDX\nMOV EDI,0x0\nCALL qword ptr [RAX + 0xb0]\nLEA RSI,[RBX + 0x2]\nMOV RAX,qword ptr [RBP + 0x8]\nMOV EDI,0xffff\nCALL qword ptr [RAX + 0xb0]\nLEA RSI,[RBX + 0x4]\nMOV RAX,qword ptr [RBP + 0x8]\nMOV EDI,0x2\nCALL qword ptr [RAX + 0xb0]\nMOV RAX,qword ptr [0x001a1b40]\nMOV RDX,qword ptr [0x001a1b48]\nMOV qword ptr [RBX + 0xc],RAX\nMOV qword ptr [RBX + 0x14],RDX\nLEA RSI,[RBX + 0x6]\nMOVZX EDI,word ptr [R12 + 0x90]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0xb0]\nLEA RSI,[RBX + 0x2c]\nMOV EDI,dword ptr [R12 + 0x94]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x8]\nMOV RDI,qword ptr [R12 + 0x98]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x30]\nMOV RDI,qword ptr [R12 + 0xa0]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x34]\nMOV RDI,qword ptr [R12 + 0xa8]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nMOV RAX,qword ptr [RBP + 0x8]\nMOV RAX,qword ptr [RAX + 0x378]\nMOV EAX,dword ptr [RAX + 0x50]\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "184": {"funcbody": "undefined8 [FUNC1] (long param_1,char param_2)\n{\n  char cVar1;\n  long lVar2;\n  undefined8 uVar3;\n  bool bVar4;\n  \n  if (param_1 != 0) {\n    lVar2 = [FUNC2] ();\n    if (lVar2 == 0) {\n      uVar3 = 0xffffffff;\n    }\n    else {\n      bVar4 = false;\n      if (param_2 != '\\0') {\n        cVar1 = [FUNC3] (lVar2);\n        bVar4 = true;\n        if (cVar1 == '\\0') {\n          bVar4 = *(long *)(*(long *)(DAT_00227668 + 0x20) + 0x18) != 0;\n        }\n      }\n      *(bool *)(param_1 + 0x1c) = bVar4;\n      *(bool *)(lVar2 + 0x3f2) = bVar4;\n      uVar3 = 0;\n    }\n    return uVar3;\n  }\n  return 0xffffffff;\n}", "answer": {"FUNC2": "FUN_000097f2", "FUNC3": "FUN_000169c5", "FUNC1": "FUN_000157ce"}, "assembly": "TEST RDI,RDI\nJZ 0x00015835\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV EBX,ESI\nMOV R12,RDI\nCALL 0x000097f2\nMOV RBP,RAX\nTEST RAX,RAX\nJZ 0x0001583b\nMOV EAX,0x0\nTEST BL,BL\nJNZ 0x0001580a\nAND EAX,0x1\nMOV byte ptr [R12 + 0x1c],AL\nMOV byte ptr [RBP + 0x3f2],AL\nMOV EAX,0x0\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,RBP\nCALL 0x000169c5\nMOV EDX,EAX\nMOV EAX,0x1\nTEST DL,DL\nJNZ 0x000157f2\nMOV RAX,qword ptr [0x00227668]\nMOV RAX,qword ptr [RAX + 0x20]\nCMP qword ptr [RAX + 0x18],0x0\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x000157f2\nMOV EAX,0xffffffff\nRET\nMOV EAX,0xffffffff\nJMP 0x00015805\n"}, "185": {"funcbody": "gboolean [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  undefined8 *puVar1;\n  DenemoDirective *pDVar2;\n  [TYPE3] [VAR3] ;\n  DenemoObject *mudela_obj_new;\n  [TYPE4] [VAR4] ;\n  undefined8 uVar3;\n  \n  pDVar2 = [FUNC2] ([VAR1] );\n  if (pDVar2 == (DenemoDirective *)0x0) {\n    mudela_obj_new = [FUNC4] (\" \");\n    puVar1 = (undefined8 *)mudela_obj_new->object;\n    uVar3 = [FUNC6] ([VAR1] );\n    *puVar1 = uVar3;\n    *([TYPE2] *)(puVar1 + 4) = [VAR2] ;\n    [FUNC3] (Denemo.project,mudela_obj_new);\n  }\n  else {\n    [FUNC5] ((Denemo.project)->movement,(DenemoObject *)(Denemo.project)->movement->currentobject->data\n         );\n    pDVar2->tx = [VAR2] ;\n  }\n  return 1;\n}", "answer": {"VAR1": "tag", "VAR2": "value", "VAR3": "directive", "VAR4": "obj", "FUNC2": "get_standalone_directive", "FUNC3": "object_insert", "FUNC1": "standalone_directive_put_tx", "FUNC6": "g_string_new", "TYPE3": "DenemoDirective *", "TYPE2": "gint", "FUNC4": "lily_directive_new", "FUNC5": "store_for_undo_change", "TYPE4": "DenemoObject *", "TYPE1": "gchar *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV R12D,ESI\nCALL 0x00039d32\nTEST RAX,RAX\nJZ 0x00047682\nMOV RBX,RAX\nMOV RAX,qword ptr [0x003a3fb8]\nMOV RDI,qword ptr [RAX + 0x530]\nMOV RAX,qword ptr [RDI + 0x128]\nMOV RSI,qword ptr [RAX]\nCALL 0x0006e2d7\nMOV dword ptr [RBX + 0x20],R12D\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nLEA RDI,[0x125ea0]\nCALL 0x0005ed2c\nMOV RBX,RAX\nMOV R13,qword ptr [RAX + 0x48]\nMOV RDI,RBP\nCALL 0x00024800\nMOV qword ptr [R13],RAX\nMOV dword ptr [R13 + 0x20],R12D\nMOV RSI,RBX\nMOV RDI,qword ptr [0x003a3fb8]\nCALL 0x00033ade\nJMP 0x00047672\n"}, "186": {"funcbody": "int [FUNC1] (long param_1,undefined8 param_2)\n{\n  int iVar1;\n  \n  iVar1 = [FUNC2] (*(undefined8 *)(param_1 + 0x20),param_2,0x3fc);\n  if (0 < iVar1) {\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"FUNC2": "FUN_005a1ca0", "FUNC1": "FUN_00492f30"}, "assembly": "SUB RSP,0x8\nMOV RDI,qword ptr [RDI + 0x20]\nMOV EDX,0x3fc\nCALL 0x005a1ca0\nMOV EDX,0x0\nTEST EAX,EAX\nCMOVG EAX,EDX\nADD RSP,0x8\nRET\n"}, "187": {"funcbody": "bfd_reloc_status_type\n[FUNC1] (TYPE12 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n     TYPE53 [VAR5] )\n{\n  ulong uVar1;\n  byte bVar2;\n  ulong uVar3;\n  long lVar4;\n  ulong uVar5;\n  TYPE79 [VAR7] ;\n  ulong uVar6;\n  TYPE99 [VAR9] ;\n  TYPE86 [VAR8] ;\n  TYPE68 [VAR6] ;\n  \n  if ([VAR2] == 0) {\n    return bfd_reloc_ok;\n  }\n  lVar4 = 2L << ((char)[VAR2] - 1U & 0x3f);\n  uVar1 = lVar4 - 1;\n  uVar5 = -lVar4;\n  uVar3 = 0;\n  if ([VAR4] != 0) {\n    uVar3 = (2L << ((char)[VAR4] - 1U & 0x3f)) - 1;\n  }\n  bVar2 = (byte)[VAR3] ;\n  uVar3 = uVar1 << (bVar2 & 0x3f) | uVar3;\n  uVar6 = ([VAR5] & uVar3) >> (bVar2 & 0x3f);\n  if ([VAR1] != complain_overflow_bitfield) {\n    if ([VAR1] == complain_overflow_dont) {\n      return bfd_reloc_ok;\n    }\n    if ([VAR1] != complain_overflow_signed) {\n      if ([VAR1] == complain_overflow_unsigned) {\n        return ((uVar6 & uVar5) != 0) + bfd_reloc_ok;\n      }\n      [FUNC2] (\"reloc.c\",0x1ea,\"bfd_check_overflow\");\n    }\n    uVar5 = ~(uVar1 >> 1);\n  }\n  uVar6 = uVar6 & uVar5;\n  if (uVar6 == 0) {\n    return bfd_reloc_ok;\n  }\n  return ((uVar5 & uVar3 >> (bVar2 & 0x3f)) != uVar6) + bfd_reloc_ok;\n}", "answer": {"VAR1": "how", "VAR2": "bitsize", "VAR3": "rightshift", "VAR4": "addrsize", "VAR5": "relocation", "VAR6": "fieldmask", "FUNC2": "_bfd_abort", "FUNC1": "bfd_check_overflow", "TYPE3": "uint", "TYPE2": "uint", "TYPE5": "bfd_vma", "TYPE4": "uint", "TYPE7": "bfd_vma", "TYPE6": "bfd_vma", "TYPE9": "bfd_vma", "TYPE8": "bfd_vma", "VAR7": "signmask", "VAR8": "addrmask", "VAR9": "a", "TYPE1": "complain_overflow"}, "assembly": "TEST ESI,ESI\nJZ 0x00208a29\nMOV R9D,ECX\nLEA ECX,[RSI + -0x1]\nMOV ESI,0x2\nSHL RSI,CL\nLEA R10,[RSI + -0x1]\nNEG RSI\nMOV EAX,0x0\nTEST R9D,R9D\nJZ 0x002089b3\nLEA ECX,[R9 + -0x1]\nMOV R9D,0x2\nSHL R9,CL\nLEA RAX,[R9 + -0x1]\nMOV R9,R10\nMOV ECX,EDX\nSHL R9,CL\nOR R9,RAX\nAND R8,R9\nSHR R8,CL\nCMP EDI,0x1\nJZ 0x00208a0a\nCMP EDI,0x1\nJC 0x00208a2f\nCMP EDI,0x2\nJZ 0x00208a01\nCMP EDI,0x3\nJNZ 0x002089e5\nAND R8,RSI\nSETNZ AL\nMOVZX EAX,AL\nADD EAX,0x2\nRET\nSUB RSP,0x8\nLEA RDX,[0x27a990]\nMOV ESI,0x1ea\nLEA RDI,[0x26e6d7]\nCALL 0x001731ec\nMOV RSI,R10\nSHR RSI,0x1\nNOT RSI\nMOV EAX,0x2\nAND R8,RSI\nJZ 0x00208a34\nMOV ECX,EDX\nSHR R9,CL\nAND RSI,R9\nCMP RSI,R8\nSETNZ AL\nMOVZX EAX,AL\nADD EAX,0x2\nRET\nMOV EAX,0x2\nRET\nMOV EAX,0x2\nRET\n"}, "188": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  undefined8 uVar1;\n  [TYPE5] [VAR5] ;\n  ulong uVar2;\n  long lVar3;\n  \n  if (0xffffffff < [VAR4] ) {\n    [FUNC4] (\"b <= 0xffffffff\",\"ecc-mod-arith.c\",0x7f,\"_nettle_ecc_mod_addmul_1\");\n  }\n  uVar1 = [FUNC3] ([VAR2] ,[VAR3] ,[VAR1] ->size);\n  uVar2 = [FUNC3] ([VAR2] ,[VAR1] ->B,[VAR1] ->size,uVar1);\n  if (uVar2 < 2) {\n    lVar3 = [FUNC2] (uVar2,[VAR2] ,[VAR2] ,[VAR1] ->B,[VAR1] ->size);\n    if (lVar3 == 0) {\n      return;\n    }\n    [FUNC4] (\"hi == 0\",\"ecc-mod-arith.c\",0x85,\"_nettle_ecc_mod_addmul_1\");\n  }\n  [FUNC4] (\"hi <= 1\",\"ecc-mod-arith.c\",0x82,\"_nettle_ecc_mod_addmul_1\");\n}", "answer": {"VAR1": "m", "VAR2": "rp", "VAR3": "ap", "VAR4": "b", "VAR5": "hi", "FUNC2": "__gmpn_cnd_add_n", "FUNC3": "__gmpn_addmul_1", "FUNC1": "_nettle_ecc_mod_addmul_1", "TYPE3": "mp_limb_t *", "TYPE2": "mp_limb_t *", "FUNC4": "__assert_fail", "TYPE5": "mp_limb_t", "TYPE4": "mp_limb_t", "TYPE1": "ecc_modulo *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV EAX,0xffffffff\nCMP RCX,RAX\nJA 0x00013162\nMOV RBX,RDI\nMOV RBP,RSI\nMOV RSI,RDX\nMOVZX EDX,word ptr [RDI + 0x2]\nMOV RDI,RBP\nCALL 0x00009850\nMOVZX EDX,word ptr [RBX + 0x2]\nMOV RSI,qword ptr [RBX + 0x18]\nMOV RCX,RAX\nMOV RDI,RBP\nCALL 0x00009850\nCMP RAX,0x1\nJA 0x00013181\nMOV RCX,qword ptr [RBX + 0x18]\nMOVZX R8D,word ptr [RBX + 0x2]\nMOV RDX,RBP\nMOV RSI,RBP\nMOV RDI,RAX\nCALL 0x000098a0\nTEST RAX,RAX\nJNZ 0x000131a0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nLEA RCX,[0x1c150]\nMOV EDX,0x7f\nLEA RSI,[0x1c104]\nLEA RDI,[0x1c114]\nCALL 0x00008e70\nLEA RCX,[0x1c150]\nMOV EDX,0x82\nLEA RSI,[0x1c104]\nLEA RDI,[0x1c124]\nCALL 0x00008e70\nLEA RCX,[0x1c150]\nMOV EDX,0x85\nLEA RSI,[0x1c104]\nLEA RDI,[0x1c079]\nCALL 0x00008e70\n"}, "189": {"funcbody": "void [FUNC1] (undefined8 param_1,undefined8 param_2)\n{\n  int iVar1;\n  \n  iVar1 = [FUNC4] ();\n  if (iVar1 != 0) {\n    iVar1 = [FUNC3] (param_1,0);\n    if (iVar1 == 0) {\n      return;\n    }\n    iVar1 = [FUNC2] (param_1,1);\n    if (iVar1 == 0) {\n      return;\n    }\n  }\n  [FUNC5] (param_1,param_2,0);\n  return;\n}", "answer": {"FUNC2": "FUN_0021f55d", "FUNC3": "FUN_0021f1b1", "FUNC1": "FUN_0020fb22", "FUNC4": "FUN_0025e8af", "FUNC5": "FUN_0020b6a8"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RSI\nCALL 0x0025e8af\nTEST EAX,EAX\nJZ 0x0020fb59\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x0021f1b1\nTEST EAX,EAX\nJZ 0x0020fb69\nMOV ESI,0x1\nMOV RDI,RBX\nCALL 0x0021f55d\nTEST EAX,EAX\nJZ 0x0020fb69\nMOV EDX,0x0\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x0020b6a8\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "190": {"funcbody": "int [FUNC1] (TYPE16 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] )\n{\n  stack_st_X509_ATTRIBUTE *psVar1;\n  int iVar2;\n  \n  if ([VAR1] == (TYPE16)0x0) {\n    [FUNC5] ();\n    [FUNC4] (\"crypto/x509/x509_req.c\",0xf7,\"X509_REQ_add1_attr_by_OBJ\");\n    [FUNC2] (0xb,0xc0102,(char *)0x0);\n    iVar2 = 0;\n  }\n  else {\n    psVar1 = [FUNC3] ((stack_st_X509_ATTRIBUTE **)&[VAR1] [1].signature,[VAR2] ,[VAR3] ,[VAR4] ,[VAR5] );\n    iVar2 = 0;\n    if (psVar1 != (stack_st_X509_ATTRIBUTE *)0x0) {\n      *(undefined4 *)&[VAR1] ->signature = 1;\n      iVar2 = 1;\n    }\n  }\n  return iVar2;\n}", "answer": {"VAR1": "req", "VAR2": "obj", "VAR3": "type", "VAR4": "bytes", "VAR5": "len", "FUNC2": "ERR_set_error", "FUNC3": "X509at_add1_attr_by_OBJ", "FUNC1": "X509_REQ_add1_attr_by_OBJ", "TYPE3": "int", "TYPE2": "ASN1_OBJECT *", "FUNC4": "ERR_set_debug", "TYPE5": "int", "FUNC5": "ERR_new", "TYPE4": "uchar *", "TYPE1": "X509_REQ *"}, "assembly": "PUSH RBX\nTEST RDI,RDI\nJZ 0x00293178\nMOV RBX,RDI\nLEA RDI,[RDI + 0x30]\nCALL 0x0028f8b2\nMOV EDX,0x0\nTEST RAX,RAX\nJZ 0x00293174\nMOV dword ptr [RBX + 0x10],0x1\nMOV EDX,0x1\nMOV EAX,EDX\nPOP RBX\nRET\nCALL 0x001ab984\nLEA RDX,[0x3358c0]\nMOV ESI,0xf7\nLEA RDI,[0x335841]\nCALL 0x001aba91\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0xb\nMOV EAX,0x0\nCALL 0x001abda8\nMOV EDX,0x0\nJMP 0x00293174\n"}, "191": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE22 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,TYPE64 [VAR6] ,[TYPE7] [VAR7] )\n{\n  int iVar1;\n  \n  if ([VAR4] == ([TYPE4] )0x0) {\n    if (([VAR5] & 1U) == 0) {\n      if (([VAR5] & 0x84U) == 0) {\n        [FUNC9] ();\n        [FUNC2] (\"providers/implementations/encode_decode/encode_key2any.c\",0x5a7,\n              \"sm2_to_SM2_pem_encode\");\n        [FUNC5] (0x39,0x80106,(char *)0x0);\n        iVar1 = 0;\n      }\n      else {\n        iVar1 = [FUNC8] ((key2any_ctx_st *)[VAR1] ,[VAR2] ,[VAR3] ,0x494,\"SM2 PARAMETERS\",\n                      (check_key_type_fn *)0x0,[FUNC4] ,(OSSL_PASSPHRASE_CALLBACK *)0x0,(void *)0x0,\n                      (key_to_paramstring_fn *)0x0,(i2d_of_void *)PTR_[FUNC7] _00622f70);\n      }\n    }\n    else {\n      iVar1 = [FUNC8] ((key2any_ctx_st *)[VAR1] ,[VAR2] ,[VAR3] ,0x494,\"SM2 PRIVATE KEY\",\n                    (check_key_type_fn *)0x0,[FUNC6] ,[VAR6] ,[VAR7] ,[FUNC10] ,\n                    (i2d_of_void *)PTR_[FUNC3] _00622f30);\n    }\n  }\n  else {\n    [FUNC9] ();\n    [FUNC2] (\"providers/implementations/encode_decode/encode_key2any.c\",0x5a7,\"sm2_to_SM2_pem_encode\");\n    [FUNC5] (0x39,0x80106,(char *)0x0);\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "cout", "VAR3": "key", "VAR4": "key_abstract", "FUNC10": "prepare_ec_params", "VAR5": "selection", "VAR6": "cb", "FUNC2": "ERR_set_debug", "FUNC3": "i2d_ECPrivateKey", "FUNC1": "sm2_to_SM2_pem_encode", "FUNC6": "key_to_type_specific_pem_priv_bio", "TYPE3": "void *", "FUNC7": "i2d_ECParameters", "TYPE2": "OSSL_CORE_BIO *", "FUNC4": "key_to_type_specific_pem_param_bio", "TYPE5": "int", "FUNC5": "ERR_set_error", "TYPE4": "OSSL_PARAM *", "TYPE7": "void *", "TYPE6": "OSSL_PASSPHRASE_CALLBACK *", "FUNC8": "key2any_encode", "FUNC9": "ERR_new", "VAR7": "cbarg", "TYPE1": "void *"}, "assembly": "PUSH RBX\nTEST RCX,RCX\nJNZ 0x00113c94\nTEST R8B,0x1\nJNZ 0x00113cd3\nMOV EBX,R8D\nAND EBX,0x84\nJNZ 0x00113d12\nCALL 0x000b271b\nLEA RDX,[0x32a5a0]\nMOV ESI,0x5a7\nLEA RDI,[0x32a2f0]\nCALL 0x000b2828\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x000b2b3f\nJMP 0x00113ccf\nCALL 0x000b271b\nLEA RDX,[0x32a5a0]\nMOV ESI,0x5a7\nLEA RDI,[0x32a2f0]\nCALL 0x000b2828\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x000b2b3f\nMOV EBX,0x0\nMOV EAX,EBX\nPOP RBX\nRET\nSUB RSP,0x8\nPUSH qword ptr [0x00622f30]\nLEA RAX,[0x115f62]\nPUSH RAX\nPUSH qword ptr [RSP + 0x28]\nPUSH R9\nLEA RAX,[0x116d5d]\nPUSH RAX\nMOV R9D,0x0\nLEA R8,[0x32a329]\nMOV ECX,0x494\nCALL 0x0010f156\nMOV EBX,EAX\nADD RSP,0x30\nJMP 0x00113ccf\nSUB RSP,0x8\nPUSH qword ptr [0x00622f70]\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nLEA RAX,[0x116d23]\nPUSH RAX\nMOV R9D,0x0\nLEA R8,[0x32a339]\nMOV ECX,0x494\nCALL 0x0010f156\nMOV EBX,EAX\nADD RSP,0x30\nJMP 0x00113ccf\n"}, "192": {"funcbody": "/* Local variable gctx:rsa_gen_ctx *[RDI:8] conflicts with parameter, skipped. */\nint [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  uint uVar2;\n  OSSL_PARAM *pOVar3;\n  [TYPE3] [VAR3] ;\n  \n  if ([VAR2] == ([TYPE2] )0x0) {\n    return 1;\n  }\n  pOVar3 = [FUNC7] ([VAR2] ,\"bits\");\n  if (pOVar3 != (OSSL_PARAM *)0x0) {\n    iVar1 = [FUNC6] (pOVar3,(size_t *)((long)[VAR1] + 0x18));\n    if (iVar1 == 0) {\n      return 0;\n    }\n    if (*(ulong *)((long)[VAR1] + 0x18) < 0x200) {\n      [FUNC2] ();\n      [FUNC4] (\"providers/implementations/keymgmt/rsa_kmgmt.c\",0x203,\"rsa_gen_set_params\");\n      [FUNC5] (0x39,0xab,(char *)0x0);\n      return 0;\n    }\n  }\n  pOVar3 = [FUNC7] ([VAR2] ,\"primes\");\n  if ((pOVar3 != (OSSL_PARAM *)0x0) &&\n     (iVar1 = [FUNC6] (pOVar3,(size_t *)((long)[VAR1] + 0x28)), iVar1 == 0)) {\n    return 0;\n  }\n  pOVar3 = [FUNC7] ([VAR2] ,\"e\");\n  if ((pOVar3 != (OSSL_PARAM *)0x0) &&\n     (iVar1 = [FUNC3] (pOVar3,(BIGNUM **)((long)[VAR1] + 0x20)), iVar1 == 0)) {\n    return 0;\n  }\n  uVar2 = 1;\n  if (*(int *)((long)[VAR1] + 0x10) == 0x1000) {\n    iVar1 = [FUNC8] ((RSA_PSS_PARAMS_30 *)((long)[VAR1] + 0x30),(int *)((long)[VAR1] + 0x44),[VAR2] ,*[VAR1] );\n    uVar2 = (uint)(iVar1 != 0);\n  }\n  return uVar2;\n}", "answer": {"VAR1": "genctx", "VAR2": "params", "VAR3": "p", "FUNC2": "ERR_new", "FUNC3": "OSSL_PARAM_get_BN", "FUNC1": "rsa_gen_set_params", "FUNC6": "OSSL_PARAM_get_size_t", "TYPE3": "OSSL_PARAM *", "FUNC7": "OSSL_PARAM_locate_const", "TYPE2": "OSSL_PARAM *", "FUNC4": "ERR_set_debug", "FUNC5": "ERR_set_error", "FUNC8": "ossl_rsa_pss_params_30_fromdata", "TYPE1": "void *"}, "assembly": "MOV EAX,0x1\nTEST RSI,RSI\nJZ 0x0011c8cc\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV RBX,RDI\nLEA RSI,[0x281e01]\nMOV RDI,RBP\nCALL 0x000bdc36\nTEST RAX,RAX\nJZ 0x0011c815\nLEA RSI,[RBX + 0x18]\nMOV RDI,RAX\nCALL 0x000be92f\nTEST EAX,EAX\nJZ 0x0011c86b\nCMP qword ptr [RBX + 0x18],0x1ff\nJBE 0x0011c872\nLEA RSI,[0x27d4a6]\nMOV RDI,RBP\nCALL 0x000bdc36\nTEST RAX,RAX\nJZ 0x0011c839\nLEA RSI,[RBX + 0x28]\nMOV RDI,RAX\nCALL 0x000be92f\nTEST EAX,EAX\nJZ 0x0011c86b\nLEA RSI,[0x275507]\nMOV RDI,RBP\nCALL 0x000bdc36\nTEST RAX,RAX\nJZ 0x0011c85d\nLEA RSI,[RBX + 0x20]\nMOV RDI,RAX\nCALL 0x000be9ab\nTEST EAX,EAX\nJZ 0x0011c86b\nMOV EAX,0x1\nCMP dword ptr [RBX + 0x10],0x1000\nJZ 0x0011c8af\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x0009edef\nLEA RDX,[0x285e90]\nMOV ESI,0x203\nLEA RDI,[0x285e60]\nCALL 0x0009eefc\nMOV EDX,0x0\nMOV ESI,0xab\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x0009f213\nMOV EAX,0x0\nJMP 0x0011c86b\nLEA RSI,[RBX + 0x44]\nLEA RDI,[RBX + 0x30]\nMOV RCX,qword ptr [RBX]\nMOV RDX,RBP\nCALL 0x000cb251\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x0011c86b\nRET\n"}, "193": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  int *piVar2;\n  \n  iVar1 = [FUNC3] ([VAR1] ->sfd,0x891d,[VAR1] ->ifr);\n  if (iVar1 < 0) {\n    piVar2 = [FUNC5] ();\n    [FUNC4] (1,*piVar2,\"SIOCGIFMETRIC failed for interface `%s\\'\",[VAR1] ->ifr);\n  }\n  else {\n    [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,([VAR1] ->ifr->ifr_ifru).ifru_ivalue);\n  }\n  return;\n}", "answer": {"VAR1": "form", "VAR2": "argc", "VAR3": "argv", "FUNC2": "put_int", "FUNC3": "rpl_ioctl", "FUNC1": "fh_metric", "TYPE3": "char * *", "TYPE2": "int", "FUNC4": "error", "FUNC5": "__errno_location", "TYPE1": "format_data_t"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV EBP,ESI\nMOV R12,RDX\nMOV RDX,qword ptr [RDI + 0x8]\nMOV EDI,dword ptr [RDI + 0x10]\nMOV ESI,0x891d\nMOV EAX,0x0\nCALL 0x0000af31\nTEST EAX,EAX\nJS 0x00006f55\nMOV RAX,qword ptr [RBX + 0x8]\nMOV ECX,dword ptr [RAX + 0x10]\nMOV RDX,R12\nMOV ESI,EBP\nMOV RDI,RBX\nCALL 0x00006df5\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x00004210\nMOV RCX,qword ptr [RBX + 0x8]\nLEA RDX,[0x11d98]\nMOV ESI,dword ptr [RAX]\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x00004550\nJMP 0x00006f50\n"}, "194": {"funcbody": "X509_VERIFY_PARAM * [FUNC1] ([TYPE1] [VAR1] )\n{\n  long lVar1;\n  int i;\n  [TYPE2] [VAR2] ;\n  X509_VERIFY_PARAM *pXVar2;\n  long in_FS_OFFSET;\n  TYPE40 [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR4] .name = [VAR1] ;\n  if (param_table != (stack_st_X509_VERIFY_PARAM *)0x0) {\n    i = [FUNC3] ((OPENSSL_STACK *)param_table,&[VAR4] );\n    if (-1 < i) {\n      pXVar2 = (X509_VERIFY_PARAM *)[FUNC5] ((OPENSSL_STACK *)param_table,i);\n      goto LAB_000bfac7;\n    }\n  }\n  pXVar2 = (X509_VERIFY_PARAM *)[FUNC6] (&[VAR4] ,default_table,5,0x70,[FUNC4] );\nLAB_000bfac7:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pXVar2;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "name", "VAR2": "idx", "VAR3": "local_10", "VAR4": "pm", "FUNC2": "__stack_chk_fail", "FUNC3": "OPENSSL_sk_find", "FUNC1": "X509_VERIFY_PARAM_lookup", "FUNC6": "OBJ_bsearch_", "TYPE3": "undefined8", "TYPE2": "int", "FUNC4": "table_cmp_BSEARCH_CMP_FN", "FUNC5": "OPENSSL_sk_value", "TYPE4": "X509_VERIFY_PARAM", "TYPE1": "char *"}, "assembly": "SUB RSP,0x88\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x78],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],RDI\nMOV RDI,qword ptr [0x00576bb8]\nTEST RDI,RDI\nJZ 0x000bfaa7\nMOV RSI,RSP\nCALL 0x000b4280\nTEST EAX,EAX\nJNS 0x000bfadf\nMOV RDI,RSP\nLEA R8,[0xbf133]\nMOV ECX,0x70\nMOV EDX,0x5\nLEA RSI,[0x5257c0]\nCALL 0x000a4cba\nMOV RDX,qword ptr [RSP + 0x78]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x000bfaef\nADD RSP,0x88\nRET\nMOV ESI,EAX\nMOV RDI,qword ptr [0x00576bb8]\nCALL 0x000b487e\nJMP 0x000bfac7\nCALL 0x000627f0\n"}, "195": {"funcbody": "int [FUNC1] (void)\n{\n  long in_FS_OFFSET;\n  [TYPE2] [VAR2] ;\n  long [VAR1] ;\n  \n  [VAR1] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR2] = -1;\n  [FUNC3] (arg,&[VAR2] );\n  if ([VAR1] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return [VAR2] ;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "local_10", "VAR2": "result", "FUNC2": "__stack_chk_fail", "FUNC3": "opt_int", "FUNC1": "opt_int_arg", "TYPE2": "int", "TYPE1": "undefined8"}, "assembly": "SUB RSP,0x18\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP + 0x4],0xffffffff\nLEA RSI,[RSP + 0x4]\nMOV RDI,qword ptr [0x00576868]\nCALL 0x00068c80\nMOV EAX,dword ptr [RSP + 0x4]\nMOV RDX,qword ptr [RSP + 0x8]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x00068d3e\nADD RSP,0x18\nRET\nCALL 0x00062730\n"}, "196": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  EC_KEY *key;\n  int iVar1;\n  EC_GROUP *a;\n  TYPE45 [VAR4] ;\n  EC_GROUP *b;\n  [TYPE5] [VAR5] ;\n  OSSL_LIB_CTX *ctx;\n  BN_CTX *ctx_00;\n  TYPE30 [VAR3] ;\n  \n  iVar1 = [FUNC4] ();\n  if (iVar1 != 0) {\n    if (([VAR1] == ([TYPE1] )0x0) || ([VAR2] == (TYPE20x0)) {\n      iVar1 = 0;\n    }\n    else {\n      key = *(EC_KEY **)((long)[VAR1] + 8);\n      a = [FUNC3] ((EC_KEY *)key);\n      b = [FUNC3] ((EC_KEY *)[VAR2] );\n      ctx = [FUNC12] (key);\n      ctx_00 = [FUNC6] (ctx);\n      if (ctx_00 == (BN_CTX *)0x0) {\n        [FUNC2] ();\n        [FUNC13] (\"providers/implementations/exchange/ecdh_exch.c\",0x81,\"ecdh_match_params\");\n        [FUNC9] (0x39,0xc0100,(char *)0x0);\n        iVar1 = 0;\n      }\n      else {\n        if (((a != (EC_GROUP *)0x0) && (b != (EC_GROUP *)0x0)) &&\n           (iVar1 = [FUNC10] (a,b,(BN_CTX *)ctx_00), iVar1 == 0)) {\n          [FUNC5] ((BN_CTX *)ctx_00);\n          iVar1 = [FUNC7] (*[VAR1] ,(EC_KEY *)[VAR2] ,1);\n          if (iVar1 == 0) {\n            return 0;\n          }\n          iVar1 = [FUNC8] ((EC_KEY *)[VAR2] );\n          if (iVar1 == 0) {\n            return 0;\n          }\n          [FUNC11] (*(EC_KEY **)((long)[VAR1] + 0x10));\n          *([TYPE2] *)((long)[VAR1] + 0x10) = [VAR2] ;\n          return 1;\n        }\n        [FUNC2] ();\n        [FUNC13] (\"providers/implementations/exchange/ecdh_exch.c\",0x88,\"ecdh_match_params\");\n        [FUNC9] (0x39,0xcb,(char *)0x0);\n        [FUNC5] ((BN_CTX *)ctx_00);\n        iVar1 = 0;\n      }\n    }\n  }\n  return iVar1;\n}", "answer": {"FUNC12": "ossl_ec_key_get_libctx", "FUNC11": "EC_KEY_free", "VAR1": "vpecdhctx", "FUNC13": "ERR_set_debug", "VAR2": "vecdh", "VAR3": "pecdhctx", "VAR4": "group_priv", "FUNC10": "EC_GROUP_cmp", "VAR5": "group_peer", "FUNC2": "ERR_new", "FUNC3": "EC_KEY_get0_group", "FUNC1": "ecdh_set_peer", "FUNC6": "BN_CTX_new_ex", "TYPE3": "PROV_ECDH_CTX *", "FUNC7": "ossl_ec_check_key", "TYPE2": "void *", "FUNC4": "ossl_prov_is_running", "TYPE5": "EC_GROUP *", "FUNC5": "BN_CTX_free", "TYPE4": "EC_GROUP *", "FUNC8": "EC_KEY_up_ref", "FUNC9": "ERR_set_error", "TYPE1": "void *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV RBP,RSI\nCALL 0x000ccda7\nTEST EAX,EAX\nJZ 0x000f1496\nTEST RBX,RBX\nJZ 0x000f1491\nTEST RBP,RBP\nJZ 0x000f1491\nMOV R12,qword ptr [RBX + 0x8]\nMOV RDI,R12\nCALL 0x00169f4e\nMOV R13,RAX\nMOV RDI,RBP\nCALL 0x00169f4e\nMOV R14,RAX\nMOV RDI,R12\nCALL 0x00169f3f\nMOV RDI,RAX\nCALL 0x00138058\nMOV R12,RAX\nTEST RAX,RAX\nJZ 0x000f1454\nTEST R13,R13\nJZ 0x000f140f\nTEST R14,R14\nJZ 0x000f140f\nMOV RDX,RAX\nMOV RSI,R14\nMOV RDI,R13\nCALL 0x0016c99a\nTEST EAX,EAX\nJZ 0x000f149f\nCALL 0x00085359\nLEA RDX,[0x2783a0]\nMOV ESI,0x88\nLEA RDI,[0x278328]\nCALL 0x00085466\nMOV EDX,0x0\nMOV ESI,0xcb\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x0008577d\nMOV RDI,R12\nCALL 0x00138140\nMOV EAX,0x0\nJMP 0x000f1496\nCALL 0x00085359\nLEA RDX,[0x2783a0]\nMOV ESI,0x81\nLEA RDI,[0x278328]\nCALL 0x00085466\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x0008577d\nMOV EAX,0x0\nJMP 0x000f1496\nMOV EAX,0x0\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV RDI,R12\nCALL 0x00138140\nMOV EDX,0x1\nMOV RSI,RBP\nMOV RDI,qword ptr [RBX]\nCALL 0x00209b01\nTEST EAX,EAX\nJZ 0x000f1496\nMOV RDI,RBP\nCALL 0x001696f8\nTEST EAX,EAX\nJZ 0x000f1496\nMOV RDI,qword ptr [RBX + 0x10]\nCALL 0x00169320\nMOV qword ptr [RBX + 0x10],RBP\nMOV EAX,0x1\nJMP 0x000f1496\n"}, "197": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  long lVar1;\n  int iVar2;\n  TYPE71 [VAR7] ;\n  TYPE85 [VAR8] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  \n  lVar1 = *(long *)((long)[VAR1] + 8);\n  iVar2 = [FUNC6] ();\n  if (iVar2 != 0) {\n    if ([VAR2] == ([TYPE2] )0x0) {\n      *[VAR3] = 0x72;\n      iVar2 = 1;\n    }\n    else if ([VAR4] < 0x72) {\n      [FUNC3] ();\n      [FUNC5] (\"providers/implementations/signature/eddsa_sig.c\",0xc9,\"ed448_digest_sign\");\n      [FUNC4] (0x39,0x6a,(char *)0x0);\n      iVar2 = 0;\n    }\n    else {\n      iVar2 = [FUNC2] (*[VAR1] ,[VAR2] ,[VAR5] ,[VAR6] ,(uint8_t *)(lVar1 + 0x11),*(uint8_t **)(lVar1 + 0x50),\n                    (uint8_t *)0x0,0,*(char **)(lVar1 + 8));\n      if (iVar2 == 0) {\n        [FUNC3] ();\n        [FUNC5] (\"providers/implementations/signature/eddsa_sig.c\",0xd8,\"ed448_digest_sign\");\n        [FUNC4] (0x39,0xaf,(char *)0x0);\n        iVar2 = 0;\n      }\n      else {\n        *[VAR3] = 0x72;\n        iVar2 = 1;\n      }\n    }\n  }\n  return iVar2;\n}", "answer": {"VAR1": "vpeddsactx", "VAR2": "sigret", "VAR3": "siglen", "VAR4": "sigsize", "VAR5": "tbs", "VAR6": "tbslen", "FUNC2": "ossl_ed448_sign", "FUNC3": "ERR_new", "FUNC1": "ed448_digest_sign", "FUNC6": "ossl_prov_is_running", "TYPE3": "size_t *", "TYPE2": "uchar *", "FUNC4": "ERR_set_error", "TYPE5": "uchar *", "FUNC5": "ERR_set_debug", "TYPE4": "size_t", "TYPE7": "PROV_EDDSA_CTX *", "TYPE6": "size_t", "TYPE9": "undefined8", "TYPE8": "ECX_KEY *", "VAR7": "peddsactx", "VAR8": "edkey", "VAR9": "local_40", "TYPE10": "undefined8", "VAR10": "local_48", "TYPE1": "void *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBP,RDI\nMOV R12,RSI\nMOV R14,RDX\nMOV R15,RCX\nMOV qword ptr [RSP],R8\nMOV qword ptr [RSP + 0x8],R9\nMOV R13,qword ptr [RDI + 0x8]\nCALL 0x000cece0\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x0010a978\nTEST R12,R12\nJZ 0x0010a92f\nCMP R15,0x71\nJBE 0x0010a93d\nSUB RSP,0x8\nPUSH qword ptr [R13 + 0x8]\nPUSH 0x0\nPUSH 0x0\nMOV R9,qword ptr [R13 + 0x50]\nLEA R8,[R13 + 0x11]\nMOV RCX,qword ptr [RSP + 0x28]\nMOV RDX,qword ptr [RSP + 0x20]\nMOV RSI,R12\nMOV RDI,qword ptr [RBP]\nCALL 0x0015cc4c\nMOV EBX,EAX\nADD RSP,0x20\nTEST EAX,EAX\nJZ 0x0010a989\nMOV qword ptr [R14],0x72\nMOV EBX,0x1\nJMP 0x0010a978\nMOV qword ptr [R14],0x72\nMOV EBX,0x1\nJMP 0x0010a978\nCALL 0x00081b39\nLEA RDX,[0x278ba0]\nMOV ESI,0xc9\nLEA RDI,[0x278b68]\nCALL 0x00081c46\nMOV EDX,0x0\nMOV ESI,0x6a\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00081f5d\nMOV EBX,0x0\nMOV EAX,EBX\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nCALL 0x00081b39\nLEA RDX,[0x278ba0]\nMOV ESI,0xd8\nLEA RDI,[0x278b68]\nCALL 0x00081c46\nMOV EDX,0x0\nMOV ESI,0xaf\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00081f5d\nJMP 0x0010a978\n"}, "198": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  if (info_error_rings_bell_p != L'\\0') {\n    [FUNC5] ();\n  }\n  if (info_windows_initialized_p == 0) {\n    [FUNC3] (\"%s\",[VAR1] );\n  }\n  else if (echo_area_is_active == L'\\0') {\n    [FUNC2] (\"%s\",[VAR1] );\n  }\n  else {\n    [FUNC4] ([VAR1] );\n  }\n  return;\n}", "answer": {"VAR1": "error", "FUNC2": "window_message_in_echo_area", "FUNC3": "info_error", "FUNC1": "show_error_node", "FUNC4": "inform_in_echo_area", "FUNC5": "terminal_ring_bell", "TYPE1": "char *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCMP dword ptr [0x002478c4],0x0\nJNZ 0x0001c048\nCMP dword ptr [0x00249168],0x0\nJZ 0x0001c04f\nCMP dword ptr [0x00248f2c],0x0\nJZ 0x0001c065\nMOV RDI,RBX\nCALL 0x0000bb46\nPOP RBX\nRET\nCALL 0x00023a62\nJMP 0x0001c02c\nMOV RSI,RBX\nLEA RDI,[0x3a61c]\nMOV EAX,0x0\nCALL 0x0001bd17\nJMP 0x0001c046\nMOV RSI,RBX\nLEA RDI,[0x3a61c]\nMOV EAX,0x0\nCALL 0x00027f40\nJMP 0x0001c046\n"}, "199": {"funcbody": "BIGNUM * [FUNC1] (void)\n{\n  BIGNUM *pBVar1;\n  [TYPE1] [VAR1] ;\n  \n  pBVar1 = (BIGNUM *)[FUNC3] (0x18,\"crypto/bn/bn_lib.c\",0xf7);\n  if (pBVar1 == (BIGNUM *)0x0) {\n    [FUNC2] ();\n    [FUNC4] (\"crypto/bn/bn_lib.c\",0xf8,\"BN_new\");\n    [FUNC5] (3,0xc0100,(char *)0x0);\n  }\n  else {\n    pBVar1->flags = 1;\n  }\n  return pBVar1;\n}", "answer": {"VAR1": "ret", "FUNC2": "ERR_new", "FUNC3": "CRYPTO_zalloc", "FUNC1": "BN_new", "FUNC4": "ERR_set_debug", "FUNC5": "ERR_set_error", "TYPE1": "BIGNUM *"}, "assembly": "PUSH RBX\nMOV EDX,0xf7\nLEA RSI,[0x25e945]\nMOV EDI,0x18\nCALL 0x000991c0\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000771e8\nMOV dword ptr [RAX + 0x14],0x1\nMOV RAX,RBX\nPOP RBX\nRET\nCALL 0x00080a2e\nLEA RDX,[0x25e983]\nMOV ESI,0xf8\nLEA RDI,[0x25e945]\nCALL 0x00080b3b\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0x3\nMOV EAX,0x0\nCALL 0x00080e52\nJMP 0x000771e3\n"}, "200": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC2] ([VAR1] ,1);\n  if (iVar1 != 0) {\n    [FUNC3] ([VAR1] );\n    iVar1 = 1;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "prov", "FUNC2": "ossl_provider_deactivate", "FUNC3": "ossl_provider_free", "FUNC1": "OSSL_PROVIDER_unload", "TYPE1": "OSSL_PROVIDER *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nMOV ESI,0x1\nCALL 0x000d1ce5\nTEST EAX,EAX\nJNZ 0x000d011e\nPOP RBX\nRET\nMOV RDI,RBX\nCALL 0x000d1ea8\nMOV EAX,0x1\nJMP 0x000d011c\n"}, "201": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,...)\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  [TYPE15] [VAR15] ;\n  undefined8 [VAR14] ;\n  undefined8 [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  if (in_AL != '\\0') {\n    [VAR12] ._0_4_ = in_XMM0_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR17] [0].gp_offset = 0x20;\n  [VAR17] [0].fp_offset = 0x30;\n  [VAR17] [0].overflow_arg_area = &stack0x00000008;\n  [VAR17] [0].reg_save_area = &[VAR15] ;\n  [VAR14] = in_R8;\n  [VAR13] = in_R9;\n  [FUNC3] ([VAR1] ,[VAR2] ,[VAR3] ,[VAR4] ,[VAR17] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"TYPE17": "va_list", "VAR1": "stream", "VAR2": "command_name", "VAR3": "package", "VAR4": "version", "VAR5": "local_18", "VAR6": "local_28", "FUNC2": "__stack_chk_fail", "FUNC3": "version_etc_va", "FUNC1": "version_etc", "TYPE3": "char *", "VAR14": "local_98", "TYPE2": "char *", "VAR15": "local_b8", "TYPE5": "undefined1[16]", "VAR12": "local_88", "TYPE4": "char *", "VAR13": "local_90", "TYPE7": "undefined1[16]", "TYPE6": "undefined1[16]", "TYPE9": "undefined1[16]", "VAR16": "local_c0", "TYPE8": "undefined1[16]", "VAR17": "authors", "VAR7": "local_38", "TYPE11": "undefined1[16]", "VAR8": "local_48", "TYPE12": "undefined1[16]", "VAR9": "local_58", "TYPE10": "undefined1[16]", "VAR10": "local_68", "TYPE15": "undefined1", "VAR11": "local_78", "TYPE16": "undefined8", "TYPE1": "FILE *", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "SUB RSP,0xd8\nMOV qword ptr [RSP + 0x40],R8\nMOV qword ptr [RSP + 0x48],R9\nTEST AL,AL\nJZ 0x0000439a\nMOVAPS xmmword ptr [RSP + 0x50],XMM0\nMOVAPS xmmword ptr [RSP + 0x60],XMM1\nMOVAPS xmmword ptr [RSP + 0x70],XMM2\nMOVAPS xmmword ptr [RSP + 0x80],XMM3\nMOVAPS xmmword ptr [RSP + 0x90],XMM4\nMOVAPS xmmword ptr [RSP + 0xa0],XMM5\nMOVAPS xmmword ptr [RSP + 0xb0],XMM6\nMOVAPS xmmword ptr [RSP + 0xc0],XMM7\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0x20\nMOV dword ptr [RSP + 0x4],0x30\nLEA RAX,[RSP + 0xe0]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nMOV R8,RSP\nCALL 0x000042d5\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x000043f0\nADD RSP,0xd8\nRET\nCALL 0x000014b0\n"}, "202": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  watchpoint *pwVar1;\n  grecs_symtab *pgVar2;\n  \n  [FUNC4] ((timeval *)&([VAR1] ->rhead).tv,(__timezone_ptr_t)0x0);\n  pgVar2 = [FUNC3] (8);\n  ([VAR1] ->rhead).names = pgVar2;\n  if (pgVar2 == (grecs_symtab *)0x0) {\n    [FUNC2] ();\n  }\n  ([VAR1] ->rhead).next = (watchpoint *)0x0;\n  pwVar1 = recent_tail;\n  ([VAR1] ->rhead).prev = recent_tail;\n  if (pwVar1 != (watchpoint *)0x0) {\n    (pwVar1->rhead).next = [VAR1] ;\n  }\n  recent_head = [VAR1] ;\n  [FUNC5] (1);\n  return;\n}", "answer": {"VAR1": "wp", "FUNC2": "nomem_abend", "FUNC3": "grecs_symtab_create_default", "FUNC1": "watchpoint_recent_init", "FUNC4": "gettimeofday", "FUNC5": "alarm", "TYPE1": "watchpoint *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nLEA RDI,[RDI + 0x58]\nMOV ESI,0x0\nCALL 0x000041f0\nMOV EDI,0x8\nCALL 0x00014351\nMOV qword ptr [RBX + 0x50],RAX\nTEST RAX,RAX\nJZ 0x00008ccc\nMOV qword ptr [RBX + 0x48],0x0\nMOV RAX,qword ptr [0x0022b6a8]\nMOV qword ptr [RBX + 0x40],RAX\nTEST RAX,RAX\nJZ 0x00008cb9\nMOV qword ptr [RAX + 0x48],RBX\nMOV qword ptr [0x0022b6a0],RBX\nMOV EDI,0x1\nCALL 0x00004240\nPOP RBX\nRET\nCALL 0x00004c51\nJMP 0x00008c9d\n"}, "203": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR3] .arch = bfd_arch_i386;\n  [VAR3] .mach = 8;\n  [VAR3] .flavour = bfd_target_unknown_flavour;\n  [VAR3] .endian = BFD_ENDIAN_UNKNOWN;\n  [VAR3] .endian_code = BFD_ENDIAN_UNKNOWN;\n  [VAR3] .octets_per_byte = 1;\n  [VAR3] .disassembler_needs_relocs = false;\n  [VAR3] .fprintf_func = [FUNC5] ;\n  [VAR3] .fprintf_styled_func = [FUNC3] ;\n  [VAR3] .stream = (void *)0x0;\n  [VAR3] .disassembler_options = (char *)0x0;\n  [VAR3] .read_memory_func = [FUNC9] ;\n  [VAR3] .memory_error_func = [FUNC8] ;\n  [VAR3] .print_address_func = [FUNC4] ;\n  [VAR3] .symbol_at_address_func = [FUNC7] ;\n  [VAR3] .symbol_is_valid = [FUNC6] ;\n  [VAR3] .display_endian = BFD_ENDIAN_UNKNOWN;\n  [VAR3] .symtab = (asymbol **)0x0;\n  [VAR3] .symtab_size = 0;\n  [VAR3] .buffer_vma = 0;\n  [VAR3] .buffer_length = 8;\n  [VAR3] .buffer = [VAR1] ;\n  iVar2 = [FUNC2] (0,&[VAR3] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC10] ();\n}", "answer": {"VAR1": "pc", "VAR2": "local_10", "VAR3": "dis_info", "FUNC10": "__stack_chk_fail", "FUNC2": "print_insn_i386", "FUNC3": "fprintf_styled_func", "FUNC1": "parse_x86_AVX_instruction", "FUNC6": "symbol_is_valid", "TYPE3": "disassemble_info", "FUNC7": "symbol_at_address_func", "TYPE2": "undefined8", "FUNC4": "print_address_func", "FUNC5": "fprintf_func", "FUNC8": "memory_error_func", "FUNC9": "read_memory_func", "TYPE1": "uchar *"}, "assembly": "SUB RSP,0x128\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x118],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP + 0x24],0x8\nMOV qword ptr [RSP + 0x28],0x8\nMOV dword ptr [RSP + 0x20],0x0\nMOV dword ptr [RSP + 0x30],0x2\nMOV dword ptr [RSP + 0x34],0x2\nMOV dword ptr [RSP + 0xcc],0x1\nMOV byte ptr [RSP + 0xd8],0x0\nLEA RAX,[0x615f3]\nMOV qword ptr [RSP],RAX\nLEA RAX,[0x615f9]\nMOV qword ptr [RSP + 0x8],RAX\nMOV qword ptr [RSP + 0x10],0x0\nMOV qword ptr [RSP + 0xf0],0x0\nLEA RAX,[0x6206b]\nMOV qword ptr [RSP + 0x80],RAX\nLEA RAX,[0x6160d]\nMOV qword ptr [RSP + 0x88],RAX\nLEA RAX,[0x615ff]\nMOV qword ptr [RSP + 0x90],RAX\nLEA RAX,[0x61601]\nMOV qword ptr [RSP + 0x98],RAX\nLEA RAX,[0x61607]\nMOV qword ptr [RSP + 0xa0],RAX\nMOV dword ptr [RSP + 0xc8],0x2\nMOV qword ptr [RSP + 0x50],0x0\nMOV dword ptr [RSP + 0x5c],0x0\nMOV qword ptr [RSP + 0xb0],0x0\nMOV qword ptr [RSP + 0xa8],RDI\nMOV qword ptr [RSP + 0xb8],0x8\nMOV RSI,RSP\nMOV EDI,0x0\nCALL 0x000468c0\nMOV RDX,qword ptr [RSP + 0x118]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x00062066\nADD RSP,0x128\nRET\nCALL 0x000467d0\n"}, "204": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  [TYPE3] [VAR3] ;\n  bfd *pbVar2;\n  \n  do {\n    pbVar2 = [VAR1] ;\n    [VAR1] = pbVar2->my_archive;\n    if ([VAR1] == (bfd *)0x0) break;\n  } while (([VAR1] ->field_0x49 & 0x10) == 0);\n  if (pbVar2->iovec == (bfd_iovec *)0x0) {\n    [FUNC2] (bfd_error_invalid_operation);\n    iVar1 = -1;\n  }\n  else {\n    iVar1 = (*pbVar2->iovec->bstat)(pbVar2,[VAR2] );\n    if (iVar1 < 0) {\n      [FUNC2] (bfd_error_system_call);\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "abfd", "VAR2": "statbuf", "VAR3": "result", "FUNC2": "bfd_set_error", "FUNC1": "bfd_stat", "TYPE3": "int", "TYPE2": "stat *", "TYPE1": "bfd *"}, "assembly": "PUSH RBX\nJMP 0x001229fe\nMOV RDI,RAX\nMOV RAX,qword ptr [RDI + 0xe8]\nTEST RAX,RAX\nJZ 0x00122a10\nTEST byte ptr [RAX + 0x49],0x10\nJZ 0x001229fb\nMOV RAX,qword ptr [RDI + 0x18]\nTEST RAX,RAX\nJZ 0x00122a26\nCALL qword ptr [RAX + 0x30]\nMOV EBX,EAX\nTEST EAX,EAX\nJS 0x00122a37\nMOV EAX,EBX\nPOP RBX\nRET\nMOV EDI,0x5\nCALL 0x00090e34\nMOV EBX,0xffffffff\nJMP 0x00122a22\nMOV EDI,0x1\nCALL 0x00090e34\nJMP 0x00122a22\n"}, "205": {"funcbody": "int [FUNC1] (TYPE15 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int enc;\n  int iVar1;\n  void *key;\n  size_t bits;\n  ulong uVar2;\n  long in_FS_OFFSET;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  long [VAR5] ;\n  \n  [VAR5] = *(long *)(in_FS_OFFSET + 0x28);\n  uVar2 = 0x8000000;\n  if ([VAR4] < 0x8000000) {\n    uVar2 = [VAR4] ;\n  }\n  if (([VAR4] != 0) && (uVar2 <= [VAR4] )) {\n    do {\n      [VAR6] = [FUNC9] ([VAR1] );\n      enc = [FUNC2] ([VAR1] );\n      key = [FUNC6] ([VAR1] );\n      iVar1 = [FUNC5] ((EVP_CIPHER_CTX *)[VAR1] ,0x2000);\n      bits = uVar2 * 8;\n      if (iVar1 != 0) {\n        bits = uVar2;\n      }\n      [FUNC3] ([VAR3] ,[VAR2] ,bits,key,[VAR1] ->iv,&[VAR6] ,enc,(block128_f)PTR_[FUNC8] _00568fd0);\n      [FUNC7] ([VAR1] ,[VAR6] );\n      [VAR4] = [VAR4] - uVar2;\n      [VAR3] = [VAR3] + uVar2;\n      [VAR2] = [VAR2] + uVar2;\n      if ([VAR4] < uVar2) {\n        uVar2 = [VAR4] ;\n      }\n    } while (([VAR4] != 0) && (uVar2 <= [VAR4] ));\n  }\n  if ([VAR5] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 1;\n  }\n  [FUNC4] ();\n}", "answer": {"VAR1": "ctx", "VAR2": "out", "VAR3": "in", "VAR4": "inl", "VAR5": "local_40", "VAR6": "num", "FUNC2": "EVP_CIPHER_CTX_is_encrypting", "FUNC3": "CRYPTO_cfb128_1_encrypt", "FUNC1": "aria_192_cfb1_cipher", "FUNC6": "EVP_CIPHER_CTX_get_cipher_data", "TYPE3": "uchar *", "FUNC7": "EVP_CIPHER_CTX_set_num", "TYPE2": "uchar *", "FUNC4": "__stack_chk_fail", "TYPE5": "undefined8", "FUNC5": "EVP_CIPHER_CTX_test_flags", "TYPE4": "size_t", "TYPE7": "undefined8", "TYPE6": "int", "FUNC8": "ossl_aria_encrypt", "TYPE9": "undefined4", "FUNC9": "EVP_CIPHER_CTX_get_num", "TYPE8": "undefined8", "VAR7": "local_50", "VAR8": "local_58", "VAR9": "local_5c", "TYPE1": "EVP_CIPHER_CTX *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x38\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x28],RAX\nXOR EAX,EAX\nCMP RCX,0x7ffffff\nMOV EBX,0x8000000\nCMOVBE RBX,RCX\nTEST RCX,RCX\nJZ 0x0018d2af\nMOV R12,RDI\nMOV R13,RSI\nMOV R14,RDX\nMOV RBP,RCX\nLEA RAX,[RSP + 0x24]\nMOV qword ptr [RSP + 0x18],RAX\nCMP RCX,RBX\nJC 0x0018d2af\nMOV RDI,R12\nCALL 0x00088f8f\nMOV dword ptr [RSP + 0x24],EAX\nMOV RDI,R12\nCALL 0x000886b6\nMOV dword ptr [RSP + 0xc],EAX\nLEA R15,[R12 + 0x28]\nMOV RDI,R12\nCALL 0x000886c9\nMOV qword ptr [RSP + 0x10],RAX\nMOV ESI,0x2000\nMOV RDI,R12\nCALL 0x00089fec\nLEA RDX,[RBX*0x8]\nTEST EAX,EAX\nCMOVNZ RDX,RBX\nPUSH qword ptr [0x00568fd0]\nMOV ESI,dword ptr [RSP + 0x14]\nPUSH RSI\nMOV R9,qword ptr [RSP + 0x28]\nMOV R8,R15\nMOV RCX,qword ptr [RSP + 0x20]\nMOV RSI,R13\nMOV RDI,R14\nCALL 0x001ab770\nMOV ESI,dword ptr [RSP + 0x34]\nMOV RDI,R12\nCALL 0x0008909d\nSUB RBP,RBX\nADD R14,RBX\nADD R13,RBX\nADD RSP,0x10\nCMP RBX,RBP\nCMOVA RBX,RBP\nTEST RBP,RBP\nJZ 0x0018d2af\nCMP RBP,RBX\nJNC 0x0018d219\nMOV EAX,0x1\nMOV RCX,qword ptr [RSP + 0x28]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0018d2d3\nADD RSP,0x38\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nCALL 0x00062640\n"}, "206": {"funcbody": "void [FUNC1] ([TYPE17] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,...)\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_RCX;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  [TYPE15] [VAR15] ;\n  undefined8 [VAR14] ;\n  undefined8 [VAR13] ;\n  undefined8 [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  if (in_AL != '\\0') {\n    [VAR11] ._0_4_ = in_XMM0_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR17] [0].gp_offset = 0x18;\n  [VAR17] [0].fp_offset = 0x30;\n  [VAR17] [0].overflow_arg_area = &stack0x00000008;\n  [VAR17] [0].reg_save_area = &[VAR15] ;\n  [VAR14] = in_RCX;\n  [VAR13] = in_R8;\n  [VAR12] = in_R9;\n  [FUNC3] ([VAR1] ,[VAR2] ,1,[VAR3] ,[VAR17] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"TYPE17": "va_list", "VAR1": "r", "VAR2": "offset", "VAR3": "format", "VAR4": "local_18", "VAR5": "local_28", "VAR6": "local_38", "FUNC2": "__stack_chk_fail", "FUNC3": "pcp_msg", "FUNC1": "pcp_warn", "TYPE3": "char *", "VAR14": "local_a0", "TYPE2": "off_t", "VAR15": "local_b8", "TYPE5": "undefined1[16]", "VAR12": "local_90", "TYPE4": "undefined1[16]", "VAR13": "local_98", "TYPE7": "undefined1[16]", "TYPE6": "undefined1[16]", "TYPE9": "undefined1[16]", "VAR16": "local_c0", "TYPE8": "undefined1[16]", "VAR17": "args", "VAR7": "local_48", "TYPE11": "undefined1[16]", "VAR8": "local_58", "TYPE12": "undefined8", "VAR9": "local_68", "TYPE10": "undefined1[16]", "VAR10": "local_78", "TYPE15": "undefined1", "VAR11": "local_88", "TYPE16": "undefined8", "TYPE1": "pcp_reader *", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "SUB RSP,0xd8\nMOV qword ptr [RSP + 0x38],RCX\nMOV qword ptr [RSP + 0x40],R8\nMOV qword ptr [RSP + 0x48],R9\nTEST AL,AL\nJZ 0x00051189\nMOVAPS xmmword ptr [RSP + 0x50],XMM0\nMOVAPS xmmword ptr [RSP + 0x60],XMM1\nMOVAPS xmmword ptr [RSP + 0x70],XMM2\nMOVAPS xmmword ptr [RSP + 0x80],XMM3\nMOVAPS xmmword ptr [RSP + 0x90],XMM4\nMOVAPS xmmword ptr [RSP + 0xa0],XMM5\nMOVAPS xmmword ptr [RSP + 0xb0],XMM6\nMOVAPS xmmword ptr [RSP + 0xc0],XMM7\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0x18\nMOV dword ptr [RSP + 0x4],0x30\nLEA RAX,[RSP + 0xe0]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nMOV R8,RSP\nMOV RCX,RDX\nMOV EDX,0x1\nCALL 0x00050def\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x000511e7\nADD RSP,0xd8\nRET\nCALL 0x00032060\n"}, "207": {"funcbody": "void [FUNC1] (void)\n{\n  object *pplVar1;\n  fixnum fVar2;\n  fixnum fVar3;\n  fixnum fVar4;\n  long i;\n  [TYPE2] [VAR2] ;\n  [TYPE3] [VAR3] ;\n  [TYPE4] [VAR4] ;\n  [TYPE1] [VAR1] ;\n  \n  pplVar1 = vs_base;\n  fVar2 = [FUNC2] (vs_base[2]);\n  fVar3 = [FUNC2] (vs_base[1]);\n  fVar4 = [FUNC2] (*vs_base);\n  i = [FUNC3] (fVar4,fVar3,fVar2);\n  vs_top = pplVar1 + 1;\n  vs_base = pplVar1;\n  if ((i + 0x2000000000000000U & 0xc000000000000000) == 0) {\n    [VAR4] = ([TYPE4] (i + -0x6000000000000000);\n  }\n  else {\n    [VAR4] = [FUNC4] (i);\n  }\n  *vs_base = [VAR4] ;\n  return;\n}", "answer": {"VAR1": "old_base", "VAR2": "x", "VAR3": "_q1", "VAR4": "_q4", "FUNC2": "object_to_fixnum", "FUNC3": "XFetchName", "FUNC1": "L164", "TYPE3": "fixnum", "TYPE2": "fixnum", "FUNC4": "make_fixnum1", "TYPE4": "object", "TYPE1": "object *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,qword ptr [0x00971288]\nMOV RDI,qword ptr [RBX + 0x10]\nCALL 0x0018c8b8\nMOV R12,RAX\nMOV RAX,qword ptr [0x00971288]\nMOV RDI,qword ptr [RAX + 0x8]\nCALL 0x0018c8b8\nMOV RBP,RAX\nMOV RAX,qword ptr [0x00971288]\nMOV RDI,qword ptr [RAX]\nCALL 0x0018c8b8\nMOV RDX,R12\nMOV RSI,RBP\nMOV RDI,RAX\nCALL 0x0010bfc0\nMOV qword ptr [0x00971288],RBX\nADD RBX,0x8\nMOV qword ptr [0x00a86200],RBX\nMOV RDX,0x2000000000000000\nADD RDX,RAX\nMOV RCX,-0x4000000000000000\nTEST RDX,RCX\nJNZ 0x00293eb7\nMOV RDI,-0x6000000000000000\nADD RAX,RDI\nMOV RDX,qword ptr [0x00971288]\nMOV qword ptr [RDX],RAX\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,RAX\nCALL 0x0013926f\nJMP 0x00293ea8\n"}, "208": {"funcbody": "_Bool [FUNC1] (TYPE14 [VAR1] ,[TYPE2] [VAR2] ,TYPE33 [VAR3] ,\n           [TYPE4] [VAR4] )\n{\n  [TYPE5] [VAR5] ;\n  _Bool _Var1;\n  \n  if (((char)[VAR2] ->field_0x49 < '\\0') || (([VAR2] ->link).next != (bfd *)0x0)) {\n    [FUNC3] (\"linker.c\",0x1d5);\n  }\n  [VAR1] ->undefs = (bfd_link_hash_entry *)0x0;\n  [VAR1] ->undefs_tail = (bfd_link_hash_entry *)0x0;\n  [VAR1] ->type = bfd_link_generic_hash_table;\n  _Var1 = [FUNC2] (&[VAR1] ->table,[VAR3] ,[VAR4] );\n  if (_Var1) {\n    [VAR1] ->hash_table_free = [FUNC4] ;\n    ([VAR2] ->link).next = (bfd *)[VAR1] ;\n    [VAR2] ->field_0x49 = [VAR2] ->field_0x49 | 0x80;\n  }\n  return _Var1;\n}", "answer": {"VAR1": "table", "VAR2": "abfd", "VAR3": "newfunc", "VAR4": "entsize", "VAR5": "ret", "FUNC2": "bfd_hash_table_init", "FUNC3": "bfd_assert", "FUNC1": "_bfd_link_hash_table_init", "TYPE3": "_func_bfd_hash_entry_ptr_bfd_hash_entry_ptr_bfd_hash_table_ptr_char_ptr *", "TYPE2": "bfd *", "FUNC4": "_bfd_generic_link_hash_table_free", "TYPE5": "_Bool", "TYPE4": "uint", "TYPE1": "bfd_link_hash_table *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RSI\nMOV R12,RDX\nMOV R13D,ECX\nCMP byte ptr [RSI + 0x49],0x0\nJS 0x00123e25\nCMP qword ptr [RSI + 0x108],0x0\nJZ 0x00123e36\nMOV ESI,0x1d5\nLEA RDI,[0x1735ee]\nCALL 0x00090d4a\nMOV qword ptr [RBX + 0x28],0x0\nMOV qword ptr [RBX + 0x30],0x0\nMOV dword ptr [RBX + 0x40],0x0\nMOV EDX,R13D\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x00095190\nTEST AL,AL\nJZ 0x00123e75\nLEA RCX,[0x123a80]\nMOV qword ptr [RBX + 0x38],RCX\nMOV qword ptr [RBP + 0x108],RBX\nOR byte ptr [RBP + 0x49],0x80\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\n"}, "209": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  long *plVar2;\n  [TYPE4] [VAR4] ;\n  undefined8 uVar3;\n  [TYPE5] [VAR5] ;\n  char *pcVar4;\n  undefined4 in_register_00000014;\n  [TYPE6] [VAR6] ;\n  \n  plVar2 = (long *)[FUNC2] ([VAR1] ,[VAR2] ,CONCAT44(in_register_00000014,[VAR3] ));\n  if (plVar2 == (long *)0x0) {\n    return (char *)0x0;\n  }\n  uVar3 = [FUNC5] ([VAR1] ,&DAT_00d2d315);\n  [FUNC8] (plVar2,uVar3);\n  (*xmlFree)(uVar3);\n  [VAR6] = [VAR1] ;\n  if (*plVar2 != 0) {\n    iVar1 = [FUNC4] ([VAR1] ,\"file:///\",8);\n    if (iVar1 == 0) {\n      [VAR6] = [VAR1] + 7;\n    }\n    else {\n      iVar1 = [FUNC4] ([VAR1] ,\"file://localhost/\",0x11);\n      if (iVar1 != 0) goto LAB_00333f3c;\n      [VAR6] = [VAR1] + 0x10;\n    }\n  }\n  pcVar4 = [FUNC3] ([VAR6] ,[VAR2] );\n  [VAR1] = [VAR2] ;\n  if ((pcVar4 == (char *)0x0) && (pcVar4 = [FUNC6] ([VAR6] ,[VAR2] ), pcVar4 == (char *)0x0)) {\n    [FUNC7] (plVar2);\n    return (char *)0x0;\n  }\nLAB_00333f3c:\n  [FUNC7] (plVar2);\n  return [VAR1] ;\n}", "answer": {"VAR1": "source", "VAR2": "resolved_path", "VAR3": "resolved_path_len", "VAR4": "uri", "VAR5": "escsource", "VAR6": "file_dest", "FUNC2": "xmlCreateURI", "FUNC3": "tsrm_realpath", "FUNC1": "_xmlreader_get_valid_file_path", "FUNC6": "expand_filepath", "TYPE3": "int", "FUNC7": "xmlFreeURI", "TYPE2": "char *", "FUNC4": "strncasecmp", "TYPE5": "xmlChar *", "FUNC5": "xmlURIEscapeStr", "TYPE4": "xmlURI *", "TYPE6": "char *", "FUNC8": "xmlParseURIReference", "TYPE1": "char *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV R12,RSI\nCALL 0x000ecdb0\nTEST RAX,RAX\nJZ 0x00333f95\nMOV RBP,RAX\nLEA RSI,[0xd2d315]\nMOV RDI,RBX\nCALL 0x000ebf10\nMOV R13,RAX\nMOV RSI,RAX\nMOV RDI,RBP\nCALL 0x000ebc10\nMOV RDI,R13\nCALL qword ptr [0x012020e8]\nCMP qword ptr [RBP],0x0\nJZ 0x00333f2c\nMOV EDX,0x8\nLEA RSI,[0x523e6b]\nMOV RDI,RBX\nCALL 0x000eca90\nTEST EAX,EAX\nJNZ 0x00333f55\nADD RBX,0x7\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x00437f24\nTEST RAX,RAX\nJZ 0x00333f73\nMOV RDI,RBP\nCALL 0x000ec6f0\nMOV RBX,R12\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV EDX,0x11\nLEA RSI,[0x523e74]\nMOV RDI,RBX\nCALL 0x000eca90\nTEST EAX,EAX\nJNZ 0x00333f90\nADD RBX,0x10\nJMP 0x00333f2c\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x0033ecfb\nMOV RBX,RAX\nTEST RAX,RAX\nJNZ 0x00333f3c\nMOV RDI,RBP\nCALL 0x000ec6f0\nJMP 0x00333f47\nMOV R12,RBX\nJMP 0x00333f3c\nMOV EBX,0x0\nJMP 0x00333f47\n"}, "210": {"funcbody": "int [FUNC1] (TYPE15 [VAR1] ,TYPE25 [VAR2] )\n{\n  long lVar1;\n  uchar *puVar2;\n  int iVar3;\n  uchar *_data;\n  long in_FS_OFFSET;\n  TYPE41 [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR1] ->type = 2;\n  puVar2 = [VAR4] + 7;\n  do {\n    _data = puVar2;\n    *_data = (uchar)[VAR2] ;\n    [VAR2] = [VAR2] >> 8;\n    puVar2 = _data + -1;\n  } while ([VAR2] != 0);\n  iVar3 = [FUNC2] ([VAR1] ,_data,8 - ((int)_data - (int)[VAR4] ));\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar3;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "a", "VAR2": "r", "VAR3": "local_10", "VAR4": "tbuf", "FUNC2": "ASN1_STRING_set", "FUNC3": "__stack_chk_fail", "FUNC1": "ASN1_INTEGER_set_uint64", "TYPE3": "undefined8", "TYPE2": "uint64_t", "TYPE4": "uchar[8]", "TYPE1": "ASN1_INTEGER *"}, "assembly": "SUB RSP,0x18\nMOV RDX,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV dword ptr [RDI + 0x4],0x2\nLEA RAX,[RSP + 0x7]\nMOV R8,RSP\nMOV RCX,RAX\nSUB RCX,R8\nMOV RSI,RAX\nMOV byte ptr [RAX],DL\nSHR RDX,0x8\nSUB RAX,0x1\nTEST RDX,RDX\nJNZ 0x00127906\nMOV EDX,0x8\nSUB EDX,ECX\nCALL 0x0006c59d\nMOV RDI,qword ptr [RSP + 0x8]\nXOR RDI,qword ptr FS:[0x28]\nJNZ 0x0012793f\nADD RSP,0x18\nRET\nCALL 0x000626a0\n"}, "211": {"funcbody": "void [FUNC1] (TYPE15 [VAR1] )\n{\n  long lVar1;\n  int iVar2;\n  OSSL_LIB_CTX *ctx;\n  [TYPE2] [VAR2] ;\n  long in_FS_OFFSET;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR4] [0].key = (char *)0x0;\n  [VAR4] [0].data_type = 0;\n  [VAR4] [0]._12_4_ = 0;\n  [VAR4] [0].data = (void *)0x0;\n  [VAR4] [0].data_size = 0;\n  [VAR4] [0].return_size = 0;\n  [VAR4] [1].key = (char *)0x0;\n  [VAR4] [1].data_type = 0;\n  [VAR4] [1]._12_4_ = 0;\n  [VAR4] [1].data = (void *)0x0;\n  [VAR4] [1].data_size = 0;\n  [VAR4] [1].return_size = 0;\n  ctx = [FUNC6] ((PROV_CTX *)[VAR1] ->provctx);\n  [FUNC4] (\"digest\",\"SHA1\",0);\n  iVar2 = [FUNC5] (&[VAR1] ->digest,[VAR4] ,ctx);\n  if (iVar2 == 0) {\n    [FUNC3] (&[VAR1] ->digest);\n  }\n  [VAR1] ->iter = 0x800;\n  [VAR1] ->lower_bound_checks = ossl_kdf_pbkdf2_default_checks;\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "ctx", "VAR2": "provctx", "VAR3": "local_20", "VAR4": "params", "VAR5": "local_88", "VAR6": "local_90", "FUNC2": "__stack_chk_fail", "FUNC3": "ossl_prov_digest_reset", "FUNC1": "kdf_pbkdf2_init", "FUNC6": "ossl_prov_ctx_get0_libctx", "TYPE3": "undefined8", "TYPE2": "OSSL_LIB_CTX *", "FUNC4": "OSSL_PARAM_construct_utf8_string", "TYPE5": "undefined8", "FUNC5": "ossl_prov_digest_load_from_params", "TYPE4": "OSSL_PARAM[2]", "TYPE7": "undefined8", "TYPE6": "undefined8", "TYPE9": "undefined8", "TYPE8": "undefined8", "VAR7": "local_98", "VAR8": "local_a0", "VAR9": "local_a8", "TYPE1": "KDF_PBKDF2 *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x90\nMOV RBX,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x88],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP + 0x30],0x0\nMOV qword ptr [RSP + 0x38],0x0\nMOV qword ptr [RSP + 0x40],0x0\nMOV qword ptr [RSP + 0x48],0x0\nMOV qword ptr [RSP + 0x50],0x0\nMOV qword ptr [RSP + 0x58],0x0\nMOV qword ptr [RSP + 0x60],0x0\nMOV qword ptr [RSP + 0x68],0x0\nMOV qword ptr [RSP + 0x70],0x0\nMOV qword ptr [RSP + 0x78],0x0\nMOV RDI,qword ptr [RDI]\nCALL 0x00105de2\nMOV R12,RAX\nMOV RDI,RSP\nMOV ECX,0x0\nLEA RDX,[0x261956]\nLEA RSI,[0x2969c5]\nCALL 0x0009c961\nMOV RAX,qword ptr [RSP]\nMOV RDX,qword ptr [RSP + 0x8]\nMOV qword ptr [RSP + 0x30],RAX\nMOV qword ptr [RSP + 0x38],RDX\nMOV RAX,qword ptr [RSP + 0x10]\nMOV RDX,qword ptr [RSP + 0x18]\nMOV qword ptr [RSP + 0x40],RAX\nMOV qword ptr [RSP + 0x48],RDX\nMOV RAX,qword ptr [RSP + 0x20]\nMOV qword ptr [RSP + 0x50],RAX\nLEA RBP,[RBX + 0x30]\nLEA RSI,[RSP + 0x30]\nMOV RDX,R12\nMOV RDI,RBP\nCALL 0x000c471a\nTEST EAX,EAX\nJZ 0x000ebcce\nMOV qword ptr [RBX + 0x28],0x800\nLEA RAX,[0x27646c]\nMOV EAX,dword ptr [RAX]\nMOV dword ptr [RBX + 0x48],EAX\nMOV RAX,qword ptr [RSP + 0x88]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x000ebcd8\nADD RSP,0x90\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,RBP\nCALL 0x000c464a\nJMP 0x000ebc9b\nCALL 0x00062660\n"}, "212": {"funcbody": "/* Local variable gctx:rsa_gen_ctx *[RDI:8] conflicts with parameter, skipped. */\nint [FUNC1] ([TYPE1] [VAR1] ,TYPE25 [VAR2] )\n{\n  int iVar1;\n  uint uVar2;\n  OSSL_PARAM *pOVar3;\n  [TYPE3] [VAR3] ;\n  \n  if ([VAR2] == (TYPE25)0x0) {\n    return 1;\n  }\n  pOVar3 = [FUNC4] ([VAR2] ,\"bits\");\n  if (pOVar3 != (OSSL_PARAM *)0x0) {\n    iVar1 = [FUNC5] (pOVar3,(size_t *)((long)[VAR1] + 0x18));\n    if (iVar1 == 0) {\n      return 0;\n    }\n    if (*(ulong *)((long)[VAR1] + 0x18) < 0x200) {\n      [FUNC2] ();\n      [FUNC8] (\"providers/implementations/keymgmt/rsa_kmgmt.c\",0x203,\"rsa_gen_set_params\");\n      [FUNC6] (0x39,0xab,(char *)0x0);\n      return 0;\n    }\n  }\n  pOVar3 = [FUNC4] ([VAR2] ,\"primes\");\n  if ((pOVar3 != (OSSL_PARAM *)0x0) &&\n     (iVar1 = [FUNC5] (pOVar3,(size_t *)((long)[VAR1] + 0x28)), iVar1 == 0)) {\n    return 0;\n  }\n  pOVar3 = [FUNC4] ([VAR2] ,\"e\");\n  if ((pOVar3 != (OSSL_PARAM *)0x0) &&\n     (iVar1 = [FUNC3] (pOVar3,(BIGNUM **)((long)[VAR1] + 0x20)), iVar1 == 0)) {\n    return 0;\n  }\n  uVar2 = 1;\n  if (*(int *)((long)[VAR1] + 0x10) == 0x1000) {\n    iVar1 = [FUNC7] ((RSA_PSS_PARAMS_30 *)((long)[VAR1] + 0x30),(int *)((long)[VAR1] + 0x44),[VAR2] ,*[VAR1] );\n    uVar2 = (uint)(iVar1 != 0);\n  }\n  return uVar2;\n}", "answer": {"VAR1": "genctx", "VAR2": "params", "VAR3": "p", "FUNC2": "ERR_new", "FUNC3": "OSSL_PARAM_get_BN", "FUNC1": "rsa_gen_set_params", "FUNC6": "ERR_set_error", "TYPE3": "OSSL_PARAM *", "FUNC7": "ossl_rsa_pss_params_30_fromdata", "TYPE2": "OSSL_PARAM *", "FUNC4": "OSSL_PARAM_locate_const", "FUNC5": "OSSL_PARAM_get_size_t", "FUNC8": "ERR_set_debug", "TYPE1": "void *"}, "assembly": "MOV EAX,0x1\nTEST RSI,RSI\nJZ 0x0011d724\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV RBX,RDI\nLEA RSI,[0x2874b1]\nMOV RDI,RBP\nCALL 0x000b3eb1\nTEST RAX,RAX\nJZ 0x0011d66d\nLEA RSI,[RBX + 0x18]\nMOV RDI,RAX\nCALL 0x000b4baa\nTEST EAX,EAX\nJZ 0x0011d6c3\nCMP qword ptr [RBX + 0x18],0x1ff\nJBE 0x0011d6ca\nLEA RSI,[0x281de6]\nMOV RDI,RBP\nCALL 0x000b3eb1\nTEST RAX,RAX\nJZ 0x0011d691\nLEA RSI,[RBX + 0x28]\nMOV RDI,RAX\nCALL 0x000b4baa\nTEST EAX,EAX\nJZ 0x0011d6c3\nLEA RSI,[0x279c6a]\nMOV RDI,RBP\nCALL 0x000b3eb1\nTEST RAX,RAX\nJZ 0x0011d6b5\nLEA RSI,[RBX + 0x20]\nMOV RDI,RAX\nCALL 0x000b4c26\nTEST EAX,EAX\nJZ 0x0011d6c3\nMOV EAX,0x1\nCMP dword ptr [RBX + 0x10],0x1000\nJZ 0x0011d707\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x00090d64\nLEA RDX,[0x28b5f0]\nMOV ESI,0x203\nLEA RDI,[0x28b5c0]\nCALL 0x00090e71\nMOV EDX,0x0\nMOV ESI,0xab\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00091188\nMOV EAX,0x0\nJMP 0x0011d6c3\nLEA RSI,[RBX + 0x44]\nLEA RDI,[RBX + 0x30]\nMOV RCX,qword ptr [RBX]\nMOV RDX,RBP\nCALL 0x000c265b\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x0011d6c3\nRET\n"}, "213": {"funcbody": "int [FUNC1] (TYPE13 [VAR1] )\n{\n  uint16_t uVar1;\n  int bits;\n  [TYPE2] [VAR2] ;\n  int iVar2;\n  int iVar3;\n  \n  bits = [FUNC2] ((BIGNUM *)[VAR1] ->n);\n  if ([VAR1] ->version == 1) {\n    iVar2 = [FUNC5] ((OPENSSL_STACK *)[VAR1] ->prime_infos);\n    if (iVar2 < 1) {\n      return 0;\n    }\n    iVar3 = [FUNC3] (bits);\n    if (iVar3 < iVar2 + 2) {\n      return 0;\n    }\n  }\n  uVar1 = [FUNC4] (bits);\n  return (uint)uVar1;\n}", "answer": {"VAR1": "rsa", "VAR2": "bits", "FUNC2": "BN_num_bits", "FUNC3": "ossl_rsa_multip_cap", "FUNC1": "RSA_security_bits", "TYPE2": "int", "FUNC4": "ossl_ifc_ffc_compute_security_bits", "FUNC5": "OPENSSL_sk_num", "TYPE1": "RSA *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RDI,qword ptr [RDI + 0x28]\nCALL 0x0008c767\nMOV EBP,EAX\nCMP dword ptr [RBX + 0x10],0x1\nJZ 0x000e2093\nMOV EDI,EBP\nCALL 0x000e1e9d\nMOVZX EAX,AX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RDI,qword ptr [RBX + 0x88]\nCALL 0x000eb826\nMOV EBX,EAX\nMOV EAX,0x0\nTEST EBX,EBX\nJLE 0x000e208c\nMOV EDI,EBP\nCALL 0x000e364a\nMOV EDX,EAX\nADD EBX,0x2\nMOV EAX,0x0\nCMP EBX,EDX\nJLE 0x000e2082\nJMP 0x000e208c\n"}, "214": {"funcbody": "grub_script_function_t [FUNC1] ([TYPE1] [VAR1] )\n{\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  grub_size_t gVar4;\n  char *pcVar5;\n  char *pcVar6;\n  [TYPE3] [VAR3] ;\n  char *pcVar7;\n  [TYPE2] [VAR2] ;\n  grub_script_function *pgVar8;\n  uint uVar9;\n  long in_FS_OFFSET;\n  code *pcStack_40;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  long [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  [VAR5] = *(long *)(in_FS_OFFSET + 0x28);\n  pgVar8 = grub_script_function_list;\n  if (grub_script_function_list != (grub_script_function_t)0x0) {\n    do {\n      pcStack_40 = (code *)0x4f74;\n      iVar2 = [FUNC5] ([VAR1] ,pgVar8->name);\n      if (iVar2 == 0) {\n        if (pgVar8 != (grub_script_function_t)0x0) goto LAB_00005057;\n        goto LAB_00004f8a;\n      }\n      pgVar8 = pgVar8->next;\n    } while (pgVar8 != (grub_script_function *)0x0);\n  }\n  pgVar8 = (grub_script_function_t)0x0;\nLAB_00004f8a:\n  lVar3 = 0;\n  do {\n    cVar1 = [VAR1] [lVar3];\n    [VAR6] [lVar3] = cVar1;\n    if (cVar1 == '\\0') break;\n    lVar3 = lVar3 + 1;\n  } while (lVar3 != 0x14);\n  [VAR6] [20] = '\\0';\n  pcStack_40 = (code *)0x4fb5;\n  gVar4 = [FUNC3] ([VAR6] );\n  pcVar5 = [VAR6] + gVar4;\n  pcVar7 = [VAR6] + (gVar4 - 1);\n  if (pcVar7 < [VAR6] ) {\n    pcVar6 = (char *)0x0;\n  }\n  else {\n    if (((int)[VAR6] [gVar4 - 1] & 0xc0U) == 0x80) {\n      do {\n        pcVar7 = pcVar7 + -1;\n        if (pcVar7 == &[VAR7] ) {\n          pcVar6 = (char *)0x0;\n          goto LAB_00005076;\n        }\n      } while (((int)*pcVar7 & 0xc0U) == 0x80);\n    }\n    pcVar6 = pcVar7 + (0x21 - (long)&[VAR4] );\n    if (*pcVar7 < '\\0') {\n      uVar9 = (uint)*pcVar7;\n      if (((uVar9 & 0xe0) == 0xc0) && (pcVar7 + 2 <= pcVar5)) {\n        pcVar6 = pcVar7 + 2 + -(long)[VAR6] ;\n      }\n      else if (((uVar9 & 0xf0) == 0xe0) && (pcVar7 + 3 <= pcVar5)) {\n        pcVar6 = pcVar7 + 3 + -(long)[VAR6] ;\n      }\n      else if (((uVar9 & 0xf8) == 0xf0) && (pcVar7 + 4 <= pcVar5)) {\n        pcVar6 = pcVar7 + 4 + -(long)[VAR6] ;\n      }\n      else {\n        pcVar6 = pcVar7 + -(long)[VAR6] ;\n      }\n    }\n  }\nLAB_00005076:\n  [VAR6] [(long)pcVar6] = '\\0';\n  pcStack_40 = (code *)0x5093;\n  [FUNC2] (GRUB_ERR_UNKNOWN_COMMAND,\"can\\'t find command `%s\\'\",[VAR6] );\nLAB_00005057:\n  if ([VAR5] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pgVar8;\n  }\n  pcStack_40 = grub_script_lexer_ref;\n  [FUNC4] ();\n}", "answer": {"VAR1": "functionname", "VAR2": "func", "VAR3": "ptr", "VAR4": "local_18", "VAR5": "local_20", "VAR6": "tmp", "FUNC2": "grub_error", "FUNC3": "grub_strlen", "FUNC1": "grub_script_function_find", "TYPE3": "char *", "TYPE2": "grub_script_function_t", "FUNC4": "__stack_chk_fail", "TYPE5": "undefined8", "FUNC5": "grub_strcmp", "TYPE4": "undefined1", "TYPE7": "undefined1", "TYPE6": "char[21]", "VAR7": "local_39", "TYPE1": "char *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV RBP,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV RBX,qword ptr [0x00240ab8]\nTEST RBX,RBX\nJZ 0x00004f85\nMOV RSI,qword ptr [RBX]\nMOV RDI,RBP\nCALL 0x00008a2a\nTEST EAX,EAX\nJZ 0x0000504e\nMOV RBX,qword ptr [RBX + 0x10]\nTEST RBX,RBX\nJNZ 0x00004f69\nMOV EBX,0x0\nMOV EAX,0x0\nMOVZX EDX,byte ptr [RBP + RAX*0x1]\nMOV byte ptr [RSP + RAX*0x1],DL\nTEST DL,DL\nJZ 0x00004fa5\nADD RAX,0x1\nCMP RAX,0x14\nJNZ 0x00004f8f\nMOV byte ptr [RSP + 0x14],0x0\nMOV RBP,RSP\nMOV RDI,RBP\nCALL 0x00008cf0\nADD RAX,RBP\nLEA RDX,[RAX + -0x1]\nCMP RDX,RBP\nJC 0x000050c8\nMOVSX ECX,byte ptr [RAX + -0x1]\nAND ECX,0xc0\nCMP ECX,0x80\nJNZ 0x00004ffa\nLEA RSI,[RSP + -0x1]\nSUB RDX,0x1\nCMP RDX,RSI\nJZ 0x00005071\nMOVSX ECX,byte ptr [RDX]\nAND ECX,0xc0\nCMP ECX,0x80\nJZ 0x00004fdc\nMOVZX ESI,byte ptr [RDX]\nMOV RCX,RDX\nLEA RDI,[RSP + 0x20]\nSUB RCX,RDI\nLEA RCX,[RCX + 0x21]\nTEST SIL,SIL\nJNS 0x00005076\nMOVSX ESI,SIL\nMOV ECX,ESI\nAND ECX,0xe0\nCMP ECX,0xc0\nJZ 0x00005095\nMOV ECX,ESI\nAND ECX,0xf0\nCMP ECX,0xe0\nJZ 0x000050a6\nAND ESI,0xf8\nCMP ESI,0xf0\nJZ 0x000050b7\nMOV RAX,RSP\nMOV RCX,RDX\nSUB RCX,RAX\nJMP 0x00005076\nTEST RBX,RBX\nJZ 0x00004f8a\nMOV RAX,RBX\nMOV RDI,qword ptr [RSP + 0x18]\nXOR RDI,qword ptr FS:[0x28]\nJNZ 0x000050cf\nADD RSP,0x28\nPOP RBX\nPOP RBP\nRET\nMOV ECX,0x0\nMOV byte ptr [RSP + RCX*0x1],0x0\nMOV RDX,RSP\nLEA RSI,[0x235d6]\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x000086e9\nJMP 0x00005057\nLEA RCX,[RDX + 0x2]\nCMP RAX,RCX\nJC 0x00005025\nMOV RAX,RSP\nSUB RCX,RAX\nJMP 0x00005076\nLEA RCX,[RDX + 0x3]\nCMP RAX,RCX\nJC 0x00005035\nMOV RAX,RSP\nSUB RCX,RAX\nJMP 0x00005076\nLEA RCX,[RDX + 0x4]\nCMP RAX,RCX\nJC 0x00005043\nMOV RAX,RSP\nSUB RCX,RAX\nJMP 0x00005076\nMOV ECX,0x0\nJMP 0x00005076\nCALL 0x000033c0\n"}, "215": {"funcbody": "adns_status\n[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n     [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  [TYPE7] [VAR7] ;\n  adns_status aVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  [TYPE15] [VAR15] ;\n  [TYPE14] [VAR14] ;\n  [TYPE13] [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  long [VAR8] ;\n  \n  [VAR8] = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC2] (&[VAR10] ,[VAR1] ,-1,(adns_query)0x0,[VAR5] ,[VAR6] ,[VAR6] ,0xc,(int *)0x0);\n  iVar2 = 0;\n  while( true ) {\n    aVar1 = [FUNC4] (&[VAR10] ,&[VAR11] ,&[VAR12] );\n    if (aVar1 != adns_s_ok) {\n      [FUNC5] (\"!st\",\"../src/query.c\",0x8f,\"check_domain_name\");\n    }\n    if ([VAR11] < 0) break;\n    aVar1 = (*[VAR4] ->checklabel)([VAR1] ,[VAR2] ,&[VAR9] ,[VAR3] ,iVar2,(char *)[VAR5] ,[VAR12] ,[VAR11] );\n    if ((aVar1 != adns_s_ok) || (iVar2 = iVar2 + 1, [VAR11] == 0)) {\n      if ([VAR8] != *(long *)(in_FS_OFFSET + 0x28)) {\n        [FUNC3] ();\n      }\n      return aVar1;\n    }\n  }\n  [FUNC5] (\"lablen >= 0\",\"../src/query.c\",0x8f,\"check_domain_name\");\n}", "answer": {"TYPE17": "undefined8", "VAR1": "ads", "VAR2": "flags", "VAR3": "ctx", "VAR4": "typei", "VAR5": "dgram", "VAR6": "dglen", "FUNC2": "adns__findlabel_start", "FUNC3": "__stack_chk_fail", "FUNC1": "check_domain_name", "TYPE3": "qcontext *", "VAR14": "local_108", "TYPE2": "adns_queryflags", "VAR15": "local_110", "FUNC4": "adns__findlabel_next", "TYPE5": "byte *", "VAR12": "labstart", "FUNC5": "__assert_fail", "TYPE4": "typeinfo *", "VAR13": "local_100", "TYPE7": "adns_status", "TYPE6": "int", "TYPE9": "checklabel_state", "VAR16": "local_114", "TYPE8": "undefined8", "VAR17": "local_120", "VAR7": "st", "TYPE11": "int", "VAR8": "local_40", "TYPE12": "int", "VAR9": "cls", "TYPE10": "findlabel_state", "VAR10": "fls", "TYPE15": "undefined8", "VAR11": "lablen", "TYPE16": "undefined4", "TYPE1": "adns_state", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0xf8\nMOV RAX,RDI\nMOV qword ptr [RSP + 0x8],RDI\nMOV dword ptr [RSP + 0x14],ESI\nMOV qword ptr [RSP + 0x18],RDX\nMOV R15,RCX\nMOV qword ptr [RSP + 0x20],R8\nMOV RCX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0xe8],RCX\nXOR ECX,ECX\nLEA RDI,[RSP + 0x40]\nSUB RSP,0x8\nPUSH 0x0\nPUSH 0xc\nPUSH R9\nMOV EDX,0xffffffff\nMOV RSI,RAX\nCALL 0x00012a0b\nADD RSP,0x20\nMOV EBX,0x0\nLEA R14,[RSP + 0x38]\nLEA R13,[RSP + 0x3c]\nLEA R12,[RSP + 0x40]\nLEA RAX,[RSP + 0x80]\nMOV qword ptr [RSP + 0x28],RAX\nJMP 0x0000c96c\nMOV EBX,EBP\nMOV RDX,R14\nMOV RSI,R13\nMOV RDI,R12\nCALL 0x00012a3c\nTEST EAX,EAX\nJNZ 0x0000c9e2\nMOV EAX,dword ptr [RSP + 0x3c]\nTEST EAX,EAX\nJS 0x0000ca01\nLEA EBP,[RBX + 0x1]\nPUSH RAX\nMOV EAX,dword ptr [RSP + 0x40]\nPUSH RAX\nMOV R9,qword ptr [RSP + 0x30]\nMOV R8D,EBX\nMOV RCX,qword ptr [RSP + 0x28]\nMOV RDX,qword ptr [RSP + 0x38]\nMOV ESI,dword ptr [RSP + 0x24]\nMOV RDI,qword ptr [RSP + 0x18]\nCALL qword ptr [R15 + 0x40]\nADD RSP,0x10\nTEST EAX,EAX\nJNZ 0x0000c9bd\nCMP dword ptr [RSP + 0x3c],0x0\nJNZ 0x0000c96a\nMOV RCX,qword ptr [RSP + 0xe8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0000ca20\nADD RSP,0xf8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nLEA RCX,[0x17250]\nMOV EDX,0x8f\nLEA RSI,[0x170a1]\nLEA RDI,[0x170b0]\nCALL 0x00002e30\nLEA RCX,[0x17250]\nMOV EDX,0x8f\nLEA RSI,[0x170a1]\nLEA RDI,[0x170b4]\nCALL 0x00002e30\nCALL 0x00002de0\n"}, "216": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] )\n{\n  long lVar1;\n  int iVar2;\n  \n  lVar1 = *(long *)[VAR1] ;\n  if (*(code **)(lVar1 + 0xa0) == (code *)0x0) {\n    [FUNC2] ();\n    [FUNC4] (\"crypto/ec/ec_lib.c\",0x3ad,\"EC_POINT_add\");\n    [FUNC3] (0x10,0xc0101,(char *)0x0);\n    return 0;\n  }\n  if (lVar1 == *(long *)[VAR2] ) {\n    iVar2 = *(int *)([VAR1] + 0x20);\n    if (iVar2 == 0) {\n      if ((lVar1 == *(long *)[VAR3] ) && (lVar1 == *(long *)[VAR4] )) goto LAB_0008b39f;\n    }\n    else if (((iVar2 == *(int *)([VAR2] + 8)) || (*(int *)([VAR2] + 8) == 0)) &&\n            ((lVar1 == *(long *)[VAR3] &&\n             ((((iVar2 == *(int *)([VAR3] + 8) || (*(int *)([VAR3] + 8) == 0)) &&\n               (lVar1 == *(long *)[VAR4] )) &&\n              ((iVar2 == *(int *)([VAR4] + 8) || (*(int *)([VAR4] + 8) == 0)))))))) {\nLAB_0008b39f:\n      iVar2 = (**(code **)(lVar1 + 0xa0))();\n      return iVar2;\n    }\n  }\n  [FUNC2] ();\n  [FUNC4] (\"crypto/ec/ec_lib.c\",0x3b2,\"EC_POINT_add\");\n  [FUNC3] (0x10,0x65,(char *)0x0);\n  return 0;\n}", "answer": {"VAR1": "group", "VAR2": "r", "VAR3": "a", "VAR4": "b", "VAR5": "ctx", "FUNC2": "ERR_new", "FUNC3": "ERR_set_error", "FUNC1": "EC_POINT_add", "TYPE3": "EC_POINT *", "TYPE2": "EC_POINT *", "FUNC4": "ERR_set_debug", "TYPE5": "BN_CTX *", "TYPE4": "EC_POINT *", "TYPE1": "EC_GROUP *"}, "assembly": "SUB RSP,0x8\nMOV RAX,qword ptr [RDI]\nMOV R9,qword ptr [RAX + 0xa0]\nTEST R9,R9\nJZ 0x0008b318\nCMP RAX,qword ptr [RSI]\nJNZ 0x0008b35a\nMOV R10D,dword ptr [RDI + 0x20]\nTEST R10D,R10D\nJZ 0x0008b355\nMOV R11D,dword ptr [RSI + 0x8]\nCMP R10D,R11D\nJZ 0x0008b2ea\nTEST R11D,R11D\nJNZ 0x0008b35a\nCMP RAX,qword ptr [RDX]\nJNZ 0x0008b35a\nMOV R11D,dword ptr [RDX + 0x8]\nCMP R10D,R11D\nJZ 0x0008b2fd\nTEST R11D,R11D\nJNZ 0x0008b35a\nCMP RAX,qword ptr [RCX]\nJNZ 0x0008b35a\nMOV EAX,dword ptr [RCX + 0x8]\nCMP R10D,EAX\nJZ 0x0008b39f\nTEST EAX,EAX\nJZ 0x0008b39f\nJMP 0x0008b35a\nCALL 0x0009b61b\nLEA RDX,[0x265b50]\nMOV ESI,0x3ad\nLEA RDI,[0x26595b]\nCALL 0x0009b728\nMOV EDX,0x0\nMOV ESI,0xc0101\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x0009ba3f\nMOV EAX,0x0\nJMP 0x0008b395\nCMP RAX,qword ptr [RDX]\nJZ 0x0008b39a\nCALL 0x0009b61b\nLEA RDX,[0x265b50]\nMOV ESI,0x3b2\nLEA RDI,[0x26595b]\nCALL 0x0009b728\nMOV EDX,0x0\nMOV ESI,0x65\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x0009ba3f\nMOV EAX,0x0\nADD RSP,0x8\nRET\nCMP RAX,qword ptr [RCX]\nJNZ 0x0008b35a\nCALL R9\nJMP 0x0008b395\n"}, "217": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  uint uVar1;\n  int iVar2;\n  heapNode *phVar3;\n  [TYPE3] [VAR3] ;\n  [TYPE4] [VAR4] ;\n  int *piVar4;\n  [TYPE5] [VAR5] ;\n  uint uVar5;\n  \n  [VAR5] = [VAR1] ->count;\n  if ([VAR5] == [VAR1] ->size) {\n    piVar4 = [FUNC2] ();\n    *piVar4 = 0x1c;\n    [VAR2] = (void *)0x0;\n  }\n  else {\n    phVar3 = (heapNode *)[FUNC3] (8);\n    if (phVar3 == (heapNode *)0x0) {\n      piVar4 = [FUNC2] ();\n      *piVar4 = 0xc;\n      [VAR2] = (void *)0x0;\n    }\n    else {\n      phVar3->data = [VAR2] ;\n      if ([VAR2] != (TYPE20x0) {\n        if ([VAR5] == 0) {\n          *[VAR1] ->heaparray = phVar3;\n          [VAR1] ->count = [VAR1] ->count + 1;\n        }\n        else {\n          do {\n            uVar1 = [VAR5] - 1;\n            uVar5 = uVar1 >> 1;\n            iVar2 = (*[VAR1] ->fCmp)([VAR2] ,[VAR1] ->heaparray[uVar5]->data);\n            if (iVar2 < 1) break;\n            [VAR1] ->heaparray[VAR5] = [VAR1] ->heaparray[uVar5];\n            [VAR5] = uVar5;\n          } while (uVar1 >> 1 != 0);\n          [VAR1] ->heaparray[VAR5] = phVar3;\n          [VAR1] ->count = [VAR1] ->count + 1;\n        }\n      }\n    }\n  }\n  return [VAR2] ;\n}", "answer": {"VAR1": "h", "VAR2": "x", "VAR3": "p_1", "VAR4": "p", "VAR5": "index", "FUNC2": "__errno_location", "FUNC3": "malloc", "FUNC1": "heap_insert", "TYPE3": "heapNode *", "TYPE2": "void *", "TYPE5": "uint", "TYPE4": "heapNode *", "TYPE1": "Heap"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV EBX,dword ptr [RDI + 0x18]\nCMP EBX,dword ptr [RDI]\nJZ 0x00012872\nMOV R12,RDI\nMOV R13,RSI\nMOV EDI,0x8\nCALL 0x00003fb0\nMOV R14,RAX\nTEST RAX,RAX\nJZ 0x00012884\nMOV qword ptr [RAX],R13\nTEST R13,R13\nJZ 0x000128a9\nTEST EBX,EBX\nJZ 0x00012896\nLEA EBP,[RBX + -0x1]\nSHR EBP,0x1\nMOV R15D,EBP\nMOV RAX,qword ptr [R12 + 0x20]\nMOV RAX,qword ptr [RAX + R15*0x8]\nMOV RSI,qword ptr [RAX]\nMOV RDI,R13\nCALL qword ptr [R12 + 0x8]\nTEST EAX,EAX\nJLE 0x0001284f\nMOV RAX,qword ptr [R12 + 0x20]\nMOV RDX,qword ptr [RAX + R15*0x8]\nMOV EBX,EBX\nMOV qword ptr [RAX + RBX*0x8],RDX\nMOV EBX,EBP\nTEST EBP,EBP\nJNZ 0x0001281a\nMOV EBX,EBX\nMOV RAX,qword ptr [R12 + 0x20]\nMOV qword ptr [RAX + RBX*0x8],R14\nADD dword ptr [R12 + 0x18],0x1\nMOV RAX,R13\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nCALL 0x00003b70\nMOV dword ptr [RAX],0x1c\nMOV EAX,0x0\nJMP 0x00012863\nCALL 0x00003b70\nMOV dword ptr [RAX],0xc\nMOV EAX,0x0\nJMP 0x00012863\nMOV RAX,qword ptr [R12 + 0x20]\nMOV qword ptr [RAX],R14\nADD dword ptr [R12 + 0x18],0x1\nMOV RAX,R13\nJMP 0x00012863\nMOV RAX,R13\nJMP 0x00012863\n"}, "218": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  zend_result zVar1;\n  int rc;\n  [TYPE3] [VAR3] ;\n  char *pcVar2;\n  long in_FS_OFFSET;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  long [VAR4] ;\n  \n  [VAR4] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR6] = ([TYPE6] )0x0;\n  zVar1 = [FUNC2] (([VAR1] ->This).u2.next,\"s\",&[VAR6] ,&[VAR5] );\n  if (zVar1 != FAILURE) {\n    rc = [FUNC6] ([VAR6] );\n    if (rc == 0) {\n      ([VAR2] ->u1).type_info = 3;\n    }\n    else {\n      pcVar2 = [FUNC4] (rc);\n      [FUNC3] ((char *)0x0,2,\"cli_set_process_title had an error: %s\",pcVar2);\n      ([VAR2] ->u1).type_info = 2;\n    }\n  }\n  if ([VAR4] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC5] ();\n}", "answer": {"VAR1": "execute_data", "VAR2": "return_value", "VAR3": "rc", "VAR4": "local_10", "VAR5": "title_len", "VAR6": "title", "FUNC2": "zend_parse_parameters", "FUNC3": "php_error_docref", "FUNC1": "zif_cli_set_process_title", "FUNC6": "set_ps_title", "TYPE3": "int", "TYPE2": "zval *", "FUNC4": "ps_title_errno", "TYPE5": "size_t", "FUNC5": "__stack_chk_fail", "TYPE4": "undefined8", "TYPE6": "char *", "TYPE1": "zend_execute_data *"}, "assembly": "PUSH RBX\nSUB RSP,0x20\nMOV RBX,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP + 0x8],0x0\nLEA RCX,[RSP + 0x10]\nLEA RDX,[RSP + 0x8]\nMOV EDI,dword ptr [RDI + 0x2c]\nLEA RSI,[0xd1497f]\nCALL 0x003c15e1\nCMP EAX,-0x1\nJNZ 0x004b272d\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x004b2772\nADD RSP,0x20\nPOP RBX\nRET\nMOV RDI,qword ptr [RSP + 0x8]\nCALL 0x004b258f\nTEST EAX,EAX\nJNZ 0x004b2744\nMOV dword ptr [RBX + 0x8],0x3\nJMP 0x004b2717\nMOV EDI,EAX\nCALL 0x004b2550\nMOV RCX,RAX\nLEA RDX,[0xd48538]\nMOV ESI,0x2\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x003466a7\nMOV dword ptr [RBX + 0x8],0x2\nJMP 0x004b2717\nCALL 0x000fa8a0\n"}, "219": {"funcbody": "OSSL_PARAM * [FUNC1] (TYPE14 [VAR1] )\n{\n  EVP_PKEY_CTX *pEVar1;\n  code *pcVar2;\n  EVP_MD *md;\n  [TYPE2] [VAR2] ;\n  OSSL_PARAM *pOVar3;\n  OSSL_PROVIDER *prov;\n  void *pvVar4;\n  [TYPE3] [VAR3] ;\n  \n  if ([VAR1] == (TYPE14)0x0) {\n    return (OSSL_PARAM *)0x0;\n  }\n  pEVar1 = [VAR1] ->pctx;\n  if ((((pEVar1 != (EVP_PKEY_CTX *)0x0) && ((pEVar1->operation - 0x80U & 0xffffff7f) == 0)) &&\n      ((pEVar1->op).kex.algctx != (void *)0x0)) &&\n     (pcVar2 = (code *)((pEVar1->op).sig.signature)->settable_ctx_md_params, pcVar2 != (code *)0x0))\n  {\n    pOVar3 = (OSSL_PARAM *)(*pcVar2)();\n    return pOVar3;\n  }\n  md = [VAR1] ->digest;\n  if (md == (EVP_MD *)0x0) {\n    pOVar3 = (OSSL_PARAM *)0x0;\n  }\n  else if (md->settable_ctx_params == (undefined1 *)0x0) {\n    pOVar3 = (OSSL_PARAM *)0x0;\n  }\n  else {\n    prov = [FUNC2] (md);\n    pvVar4 = [FUNC3] (prov);\n    pOVar3 = (OSSL_PARAM *)(*(code *)[VAR1] ->digest->settable_ctx_params)([VAR1] ->algctx,pvVar4);\n  }\n  return pOVar3;\n}", "answer": {"VAR1": "ctx", "VAR2": "pctx", "VAR3": "alg", "FUNC2": "EVP_MD_get0_provider", "FUNC3": "ossl_provider_ctx", "FUNC1": "EVP_MD_CTX_settable_params", "TYPE3": "void *", "TYPE2": "EVP_PKEY_CTX *", "TYPE1": "EVP_MD_CTX *"}, "assembly": "TEST RDI,RDI\nJZ 0x000826a4\nPUSH RBX\nMOV RBX,RDI\nMOV RAX,qword ptr [RDI + 0x28]\nTEST RAX,RAX\nJZ 0x00082671\nMOV ECX,dword ptr [RAX]\nLEA EDX,[RCX + -0x80]\nTEST EDX,0xffffff7f\nJNZ 0x00082671\nMOV RDI,qword ptr [RAX + 0x30]\nTEST RDI,RDI\nJZ 0x00082671\nMOV RAX,qword ptr [RAX + 0x28]\nMOV RAX,qword ptr [RAX + 0xf0]\nTEST RAX,RAX\nJZ 0x00082671\nCALL RAX\nJMP 0x000826a2\nMOV RDI,qword ptr [RBX + 0x8]\nTEST RDI,RDI\nJZ 0x000826aa\nCMP qword ptr [RDI + 0xe0],0x0\nJZ 0x000826b1\nCALL 0x0008db77\nMOV RDI,RAX\nCALL 0x000a305a\nMOV RDI,qword ptr [RBX + 0x38]\nMOV RDX,qword ptr [RBX + 0x8]\nMOV RSI,RAX\nCALL qword ptr [RDX + 0xe0]\nPOP RBX\nRET\nMOV EAX,0x0\nRET\nMOV EAX,0x0\nJMP 0x000826a2\nMOV EAX,0x0\nJMP 0x000826a2\n"}, "220": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,TYPE27 [VAR2] )\n{\n  int iVar1;\n  [TYPE3] [VAR3] ;\n  BIGNUM **ppBVar2;\n  long lVar3;\n  \n  iVar1 = [FUNC2] ([VAR1] );\n  if (iVar1 != 0) {\n    if (iVar1 < 1) {\n      iVar1 = 1;\n    }\n    else {\n      lVar3 = 0;\n      do {\n        ppBVar2 = (BIGNUM **)[FUNC3] ((OPENSSL_STACK *)[VAR1] ->prime_infos,(int)lVar3);\n        [VAR2] [lVar3] = *ppBVar2;\n        lVar3 = lVar3 + 1;\n      } while (lVar3 != (ulong)(iVar1 - 1) + 1);\n      iVar1 = 1;\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "r", "VAR2": "primes", "VAR3": "pnum", "FUNC2": "RSA_get_multi_prime_extra_count", "FUNC3": "OPENSSL_sk_value", "FUNC1": "RSA_get0_multi_prime_factors", "TYPE3": "int", "TYPE2": "BIGNUM * *", "TYPE1": "RSA *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV R12,RSI\nCALL 0x000b483f\nTEST EAX,EAX\nJZ 0x000b48ab\nTEST EAX,EAX\nJLE 0x000b48b6\nLEA R13D,[RAX + -0x1]\nADD R13,0x1\nMOV EBX,0x0\nMOV RDI,qword ptr [RBP + 0x88]\nMOV ESI,EBX\nCALL 0x000bc9c7\nMOV RAX,qword ptr [RAX]\nMOV qword ptr [R12 + RBX*0x8],RAX\nADD RBX,0x1\nCMP RBX,R13\nJNZ 0x000b4888\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV EAX,0x1\nJMP 0x000b48ab\n"}, "221": {"funcbody": "OSSL_PROPERTY_LIST ** [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  OSSL_PROPERTY_LIST **ppOVar2;\n  \n  if (([VAR2] != 0) && (iVar1 = [FUNC3] (0x40,(OPENSSL_INIT_SETTINGS *)0x0), iVar1 == 0)) {\n    return (OSSL_PROPERTY_LIST **)0x0;\n  }\n  ppOVar2 = (OSSL_PROPERTY_LIST **)[FUNC2] ([VAR1] ,0xe,&ossl_ctx_global_properties_method);\n  return ppOVar2;\n}", "answer": {"VAR1": "libctx", "VAR2": "loadconfig", "FUNC2": "ossl_lib_ctx_get_data", "FUNC3": "OPENSSL_init_crypto", "FUNC1": "ossl_ctx_global_properties", "TYPE2": "int", "TYPE1": "OSSL_LIB_CTX *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nTEST ESI,ESI\nJZ 0x000ab072\nMOV ESI,0x0\nMOV EDI,0x40\nCALL 0x0009fb94\nTEST EAX,EAX\nJZ 0x000ab088\nLEA RDX,[0x5343a0]\nMOV ESI,0xe\nMOV RDI,RBX\nCALL 0x0009d62c\nPOP RBX\nRET\nMOV EAX,0x0\nJMP 0x000ab086\n"}, "222": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  [TYPE4] [VAR4] ;\n  int iVar1;\n  bool bVar2;\n  \n  if ((([VAR1] != ([TYPE1] )0x0) && ([VAR1] ->data != (uchar *)0x0)) && (0 < [VAR1] ->length)) {\n    iVar1 = 0;\n    do {\n      [VAR4] = 0xff;\n      if (iVar1 < [VAR3] ) {\n        [VAR4] = ~[VAR2] [iVar1];\n      }\n      bVar2 = ([VAR1] ->data[iVar1] & [VAR4] ) == 0;\n      iVar1 = iVar1 + 1;\n    } while ((iVar1 < [VAR1] ->length) && (bVar2));\n    return (int)bVar2;\n  }\n  return 1;\n}", "answer": {"VAR1": "a", "VAR2": "flags", "VAR3": "flags_len", "VAR4": "mask", "FUNC1": "ASN1_BIT_STRING_check", "TYPE3": "int", "TYPE2": "uchar *", "TYPE4": "uchar", "TYPE1": "ASN1_BIT_STRING *"}, "assembly": "MOV EAX,0x1\nTEST RDI,RDI\nJZ 0x001457c4\nMOV R8,qword ptr [RDI + 0x8]\nTEST R8,R8\nJZ 0x001457c4\nMOV R9D,dword ptr [RDI]\nTEST R9D,R9D\nJLE 0x001457bf\nMOV ECX,0x0\nMOV R10D,0xffffffff\nJMP 0x001457a9\nMOVSXD RDI,ECX\nTEST byte ptr [R8 + RDI*0x1],AL\nSETZ AL\nADD ECX,0x1\nCMP ECX,R9D\nJGE 0x001457bb\nTEST AL,AL\nJZ 0x001457bb\nMOV EAX,R10D\nCMP EDX,ECX\nJLE 0x00145793\nMOVSXD RAX,ECX\nMOVZX EAX,byte ptr [RSI + RAX*0x1]\nNOT EAX\nJMP 0x00145793\nMOVZX EAX,AL\nRET\nMOV EAX,0x1\nRET\n"}, "223": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  bfd_vma bVar1;\n  TYPE49 [VAR4] ;\n  [TYPE5] [VAR5] ;\n  \n  bVar1 = (*[VAR1] ->xvec->bfd_h_getx16)((void *)((long)[VAR2] + 4));\n  *(short *)((long)[VAR3] + 0x90) = (short)bVar1;\n  bVar1 = (*[VAR1] ->xvec->bfd_h_getx16)((void *)((long)[VAR2] + 6));\n  *(int *)((long)[VAR3] + 0x94) = (int)bVar1;\n  bVar1 = (*[VAR1] ->xvec->bfd_h_getx32)((void *)((long)[VAR2] + 8));\n  *(bfd_vma *)((long)[VAR3] + 0x98) = bVar1;\n  bVar1 = (*[VAR1] ->xvec->bfd_h_getx32)((void *)((long)[VAR2] + 0x10));\n  *(bfd_vma *)((long)[VAR3] + 0xa8) = bVar1;\n  bVar1 = (*[VAR1] ->xvec->bfd_h_getx16)((void *)((long)[VAR2] + 0x16));\n  *(short *)((long)[VAR3] + 0xb2) = (short)bVar1;\n  bVar1 = (*[VAR1] ->xvec->bfd_h_getx32)((void *)((long)[VAR2] + 0xc));\n  *(bfd_vma *)((long)[VAR3] + 0xa0) = bVar1;\n  if ((*(long *)((long)[VAR3] + 0xa8) != 0) && (bVar1 == 0)) {\n    *(undefined8 *)((long)[VAR3] + 0xa8) = 0;\n    *(ushort *)((long)[VAR3] + 0xb2) = *(ushort *)((long)[VAR3] + 0xb2) | 8;\n  }\n  bVar1 = (*[VAR1] ->xvec->bfd_h_getx16)((void *)((long)[VAR2] + 0x14));\n  *(short *)((long)[VAR3] + 0xb0) = (short)bVar1;\n  return;\n}", "answer": {"VAR1": "abfd", "VAR2": "src", "VAR3": "dst", "VAR4": "filehdr_dst", "VAR5": "filehdr_src", "FUNC1": "coff_swap_filehdr_in", "TYPE3": "void *", "TYPE2": "void *", "TYPE5": "external_PEI_IMAGE_hdr *", "TYPE4": "internal_filehdr *", "TYPE1": "bfd *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV R12,RDI\nMOV RBX,RSI\nMOV RBP,RDX\nLEA RDI,[RSI + 0x4]\nMOV RAX,qword ptr [R12 + 0x8]\nCALL qword ptr [RAX + 0xa0]\nMOV word ptr [RBP + 0x90],AX\nLEA RDI,[RBX + 0x6]\nMOV RAX,qword ptr [R12 + 0x8]\nCALL qword ptr [RAX + 0xa0]\nMOV dword ptr [RBP + 0x94],EAX\nLEA RDI,[RBX + 0x8]\nMOV RAX,qword ptr [R12 + 0x8]\nCALL qword ptr [RAX + 0x88]\nMOV qword ptr [RBP + 0x98],RAX\nLEA RDI,[RBX + 0x10]\nMOV RAX,qword ptr [R12 + 0x8]\nCALL qword ptr [RAX + 0x88]\nMOV qword ptr [RBP + 0xa8],RAX\nLEA RDI,[RBX + 0x16]\nMOV RAX,qword ptr [R12 + 0x8]\nCALL qword ptr [RAX + 0xa0]\nMOV word ptr [RBP + 0xb2],AX\nLEA RDI,[RBX + 0xc]\nMOV RAX,qword ptr [R12 + 0x8]\nCALL qword ptr [RAX + 0x88]\nMOV qword ptr [RBP + 0xa0],RAX\nCMP qword ptr [RBP + 0xa8],0x0\nJZ 0x000b4aad\nTEST RAX,RAX\nJZ 0x000b4ac8\nLEA RDI,[RBX + 0x14]\nMOV RAX,qword ptr [R12 + 0x8]\nCALL qword ptr [RAX + 0xa0]\nMOV word ptr [RBP + 0xb0],AX\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV qword ptr [RBP + 0xa8],0x0\nOR word ptr [RBP + 0xb2],0x8\nJMP 0x000b4aad\n"}, "224": {"funcbody": "int [FUNC1] (TYPE12 [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  X509_CINF *pXVar2;\n  \n  if ([VAR1] == (TYPE12)0x0) {\n    return 0;\n  }\n  if ([VAR2] == 0) {\n    [FUNC4] ((ASN1_INTEGER *)[VAR1] ->cert_info);\n    [VAR1] ->cert_info = (X509_CINF *)0x0;\n    iVar1 = 1;\n  }\n  else {\n    if ([VAR1] ->cert_info == (X509_CINF *)0x0) {\n      pXVar2 = (X509_CINF *)[FUNC2] ();\n      [VAR1] ->cert_info = pXVar2;\n      if (pXVar2 == (X509_CINF *)0x0) {\n        return 0;\n      }\n    }\n    iVar1 = [FUNC3] ((ASN1_INTEGER *)[VAR1] ->cert_info,[VAR2] );\n  }\n  return iVar1;\n}", "answer": {"VAR1": "x", "VAR2": "version", "FUNC2": "ASN1_INTEGER_new", "FUNC3": "ASN1_INTEGER_set", "FUNC1": "X509_set_version", "TYPE2": "long", "FUNC4": "ASN1_INTEGER_free", "TYPE1": "X509 *"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x000b5fe8\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV RBX,RDI\nTEST RSI,RSI\nJZ 0x000b5fbb\nCMP qword ptr [RDI],0x0\nJZ 0x000b5fd1\nMOV RSI,RBP\nMOV RDI,qword ptr [RBX]\nCALL 0x00120f84\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RDI,qword ptr [RDI]\nCALL 0x000708f3\nMOV qword ptr [RBX],0x0\nMOV EAX,0x1\nJMP 0x000b5fb4\nCALL 0x000708e0\nMOV RDX,RAX\nMOV qword ptr [RBX],RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJNZ 0x000b5fa9\nJMP 0x000b5fb4\nRET\n"}, "225": {"funcbody": "int [FUNC1] (TYPE14 [VAR1] )\n{\n  int iVar1;\n  uint uVar2;\n  EC_POINT *generator;\n  TYPE21 [VAR2] ;\n  \n  generator = (EC_POINT *)[FUNC3] ((EC_GROUP *)[VAR1] );\n  if ((generator != (EC_POINT *)0x0) && (iVar1 = [FUNC2] (generator), iVar1 != 0)) {\n    return 1;\n  }\n  uVar2 = 0;\n  if ([VAR1] ->pre_comp_type == _ISpunct) {\n    uVar2 = (uint)(([VAR1] ->pre_comp).nistp224 != (NISTP224_PRE_COMP *)0x0);\n  }\n  return uVar2;\n}", "answer": {"VAR1": "group", "VAR2": "generator", "FUNC2": "ecp_nistz256_is_affine_G", "FUNC3": "EC_GROUP_get0_generator", "FUNC1": "ecp_nistz256_window_have_precompute_mult", "TYPE2": "EC_POINT *", "TYPE1": "EC_GROUP *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCALL 0x00181e7e\nTEST RAX,RAX\nJZ 0x0018ba83\nMOV RDI,RAX\nCALL 0x0018b961\nMOV EDX,EAX\nMOV EAX,0x1\nTEST EDX,EDX\nJNZ 0x0018ba91\nMOV EAX,0x0\nCMP dword ptr [RBX + 0x98],0x4\nJZ 0x0018ba93\nPOP RBX\nRET\nCMP qword ptr [RBX + 0xa0],0x0\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x0018ba91\n"}, "226": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE21 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,TYPE65 [VAR6] ,[TYPE7] [VAR7] )\n{\n  int iVar1;\n  \n  if ([VAR4] == ([TYPE4] )0x0) {\n    if (([VAR5] & 1U) == 0) {\n      [FUNC6] ();\n      [FUNC5] (\"providers/implementations/encode_decode/encode_key2any.c\",0x549,\n            \"rsapss_to_EncryptedPrivateKeyInfo_der_encode\");\n      [FUNC2] (0x39,0x80106,(char *)0x0);\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = [FUNC7] ((key2any_ctx_st *)[VAR1] ,[VAR2] ,[VAR3] ,0x390,\"RSA-PSS PRIVATE KEY\",[FUNC9] ,[FUNC3] ,[VAR6] ,\n                    [VAR7] ,[FUNC4] ,(i2d_of_void *)PTR_[FUNC8] _00569f78);\n    }\n  }\n  else {\n    [FUNC6] ();\n    [FUNC5] (\"providers/implementations/encode_decode/encode_key2any.c\",0x549,\n          \"rsapss_to_EncryptedPrivateKeyInfo_der_encode\");\n    [FUNC2] (0x39,0x80106,(char *)0x0);\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "cout", "VAR3": "key", "VAR4": "key_abstract", "VAR5": "selection", "VAR6": "cb", "FUNC2": "ERR_set_error", "FUNC3": "key_to_epki_der_priv_bio", "FUNC1": "rsapss_to_EncryptedPrivateKeyInfo_der_encode", "FUNC6": "ERR_new", "TYPE3": "void *", "FUNC7": "key2any_encode", "TYPE2": "OSSL_CORE_BIO *", "FUNC4": "prepare_rsa_params", "TYPE5": "int", "FUNC5": "ERR_set_debug", "TYPE4": "OSSL_PARAM *", "TYPE7": "void *", "TYPE6": "OSSL_PASSPHRASE_CALLBACK *", "FUNC8": "i2d_RSAPrivateKey", "FUNC9": "rsa_check_key_type", "VAR7": "cbarg", "TYPE1": "void *"}, "assembly": "PUSH RBX\nTEST RCX,RCX\nJNZ 0x0010c92a\nMOV EBX,R8D\nAND EBX,0x1\nJNZ 0x0010c969\nCALL 0x000a22fd\nLEA RDX,[0x27ee40]\nMOV ESI,0x549\nLEA RDI,[0x27dad0]\nCALL 0x000a240a\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x000a2721\nJMP 0x0010c965\nCALL 0x000a22fd\nLEA RDX,[0x27ee40]\nMOV ESI,0x549\nLEA RDI,[0x27dad0]\nCALL 0x000a240a\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x000a2721\nMOV EBX,0x0\nMOV EAX,EBX\nPOP RBX\nRET\nSUB RSP,0x8\nPUSH qword ptr [0x00569f78]\nLEA RAX,[0x10b47c]\nPUSH RAX\nPUSH qword ptr [RSP + 0x28]\nPUSH R9\nLEA RAX,[0x1128f4]\nPUSH RAX\nLEA R9,[0x10b444]\nLEA R8,[0x27db28]\nMOV ECX,0x390\nCALL 0x0010b6e9\nMOV EBX,EAX\nADD RSP,0x30\nJMP 0x0010c965\n"}, "227": {"funcbody": "OSSL_PARAM * [FUNC1] (TYPE10 [VAR1] )\n{\n  OSSL_PROVIDER *prov;\n  void *pvVar1;\n  [TYPE2] [VAR2] ;\n  OSSL_PARAM *pOVar2;\n  \n  if ([VAR1] == (TYPE10)0x0) {\n    return (OSSL_PARAM *)0x0;\n  }\n  if ([VAR1] ->gettable_ctx_params != (undefined1 *)0x0) {\n    prov = [FUNC3] ([VAR1] );\n    pvVar1 = [FUNC2] (prov);\n    pOVar2 = (OSSL_PARAM *)(*(code *)[VAR1] ->gettable_ctx_params)(0,pvVar1);\n    return pOVar2;\n  }\n  return (OSSL_PARAM *)0x0;\n}", "answer": {"VAR1": "sig", "VAR2": "provctx", "FUNC2": "ossl_provider_ctx", "FUNC3": "EVP_SIGNATURE_get0_provider", "FUNC1": "EVP_SIGNATURE_gettable_ctx_params", "TYPE2": "void *", "TYPE1": "EVP_SIGNATURE *"}, "assembly": "TEST RDI,RDI\nJZ 0x000a538d\nCMP qword ptr [RDI + 0xc0],0x0\nJZ 0x000a5393\nPUSH RBX\nMOV RBX,RDI\nCALL 0x000a4bf0\nMOV RDI,RAX\nCALL 0x000af1e3\nMOV RSI,RAX\nMOV EDI,0x0\nCALL qword ptr [RBX + 0xc0]\nPOP RBX\nRET\nMOV EAX,0x0\nRET\nMOV EAX,0x0\nRET\n"}, "228": {"funcbody": "PROV_CIPHER_HW * [FUNC1] ([TYPE1] [VAR1] )\n{\n  PROV_CIPHER_HW *pPVar1;\n  \n  pPVar1 = &aesni_cfb1;\n  if (((uint)DAT_0057b45c & 0x2000000) == 0) {\n    pPVar1 = &aes_cfb1;\n  }\n  return pPVar1;\n}", "answer": {"VAR1": "keybits", "FUNC1": "ossl_prov_cipher_hw_aes_cfb1", "TYPE1": "size_t"}, "assembly": "LEA RAX,[0x57b458]\nMOV EAX,dword ptr [RAX + 0x4]\nAND EAX,0x2000000\nLEA RAX,[0x55eab0]\nLEA RDX,[0x55ead0]\nCMOVZ RAX,RDX\nRET\n"}, "229": {"funcbody": "size_t [FUNC1] ([TYPE1] [VAR1] )\n{\n  char cVar1;\n  ulong uVar2;\n  [TYPE2] [VAR2] ;\n  ulong uVar3;\n  [TYPE1] pcVar4;\n  \n  uVar3 = 0xffffffffffffffff;\n  pcVar4 = [VAR1] ;\n  do {\n    if (uVar3 == 0) break;\n    uVar3 = uVar3 - 1;\n    cVar1 = *pcVar4;\n    pcVar4 = pcVar4 + 1;\n  } while (cVar1 != '\\0');\n  uVar3 = ~uVar3;\n  uVar2 = uVar3 - 1;\n  if (1 < uVar2) {\n    cVar1 = [VAR1] [uVar3 - 2];\n    uVar3 = uVar3 - 2;\n    while (cVar1 == '/') {\n      if (uVar3 == 1) {\n        return 1;\n      }\n      cVar1 = [VAR1] [uVar3 - 1];\n      uVar2 = uVar3;\n      uVar3 = uVar3 - 1;\n    }\n  }\n  return uVar2;\n}", "answer": {"VAR1": "name", "VAR2": "len", "FUNC1": "base_len", "TYPE2": "size_t", "TYPE1": "char *"}, "assembly": "MOV RDX,RDI\nMOV RCX,-0x1\nMOV EAX,0x0\nSCASB.REPNE RDI\nMOV RAX,RCX\nNOT RAX\nSUB RAX,0x1\nCMP RAX,0x1\nJBE 0x0000deeb\nLEA RCX,[RAX + -0x1]\nCMP byte ptr [RDX + RAX*0x1 + -0x1],0x2f\nJZ 0x0000def0\nRET\nMOV RCX,RAX\nCMP RCX,0x1\nJZ 0x0000df06\nLEA RAX,[RCX + -0x1]\nCMP byte ptr [RDX + RCX*0x1 + -0x1],0x2f\nJZ 0x0000deed\nMOV RAX,RCX\nJMP 0x0000deeb\nMOV RAX,RCX\nRET\n"}, "230": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,[TYPE5] [VAR5] ,\n          [TYPE6] [VAR6] )\n{\n  if ([VAR2] == ([TYPE2] )0x0) {\n    [FUNC3] ([VAR1] ,1,\"%s %s\\n\",[VAR3] ,[VAR4] );\n  }\n  else {\n    [FUNC3] ([VAR1] ,1,\"%s (%s) %s\\n\",[VAR2] ,[VAR3] ,[VAR4] );\n  }\n  [FUNC3] ([VAR1] ,1,\"Copyright %s %d Free Software Foundation, Inc.\",&DAT_0000b01f,0x7e6);\n  [FUNC2] (10,(FILE *)[VAR1] );\n  [FUNC3] ([VAR1] ,1,\n        \"License GPLv3+: GNU GPL version 3 or later <%s>.\\nThis is free software: you are free to change and redistribute it.\\nThere is NO WARRANTY, to the extent permitted by law.\\n\"\n        ,\"https://gnu.org/licenses/gpl.html\");\n  [FUNC2] (10,(FILE *)[VAR1] );\n  switch([VAR6] ) {\n  case 0:\n    break;\n  case 1:\n    [FUNC3] ([VAR1] ,1,\"Written by %s.\\n\",*[VAR5] );\n    break;\n  case 2:\n    [FUNC3] ([VAR1] ,1,\"Written by %s and %s.\\n\",*[VAR5] ,[VAR5] [1]);\n    break;\n  case 3:\n    [FUNC3] ([VAR1] ,1,\"Written by %s, %s, and %s.\\n\",*[VAR5] ,[VAR5] [1],[VAR5] [2]);\n    break;\n  case 4:\n    [FUNC3] ([VAR1] ,1,\"Written by %s, %s, %s,\\nand %s.\\n\",*[VAR5] ,[VAR5] [1],[VAR5] [2],[VAR5] [3]);\n    break;\n  case 5:\n    [FUNC3] ([VAR1] ,1,\"Written by %s, %s, %s,\\n%s, and %s.\\n\",*[VAR5] ,[VAR5] [1],[VAR5] [2],[VAR5] [3],[VAR5] [4]);\n    break;\n  case 6:\n    [FUNC3] ([VAR1] ,1,\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\",*[VAR5] ,[VAR5] [1],[VAR5] [2],[VAR5] [3],[VAR5] [4],\n          [VAR5] [5]);\n    break;\n  case 7:\n    [FUNC3] ([VAR1] ,1,\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\",*[VAR5] ,[VAR5] [1],[VAR5] [2],[VAR5] [3],\n          [VAR5] [4],[VAR5] [5],[VAR5] [6]);\n    break;\n  case 8:\n    [FUNC3] ([VAR1] ,1,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\",*[VAR5] ,[VAR5] [1],[VAR5] [2],[VAR5] [3],\n          [VAR5] [4],[VAR5] [5],[VAR5] [6],[VAR5] [7]);\n    break;\n  case 9:\n    [FUNC3] ([VAR1] ,1,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\",*[VAR5] ,[VAR5] [1],[VAR5] [2],\n          [VAR5] [3],[VAR5] [4],[VAR5] [5],[VAR5] [6],[VAR5] [7],[VAR5] [8]);\n    break;\n  default:\n    [FUNC3] ([VAR1] ,1,\"Written by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\",*[VAR5] ,[VAR5] [1],\n          [VAR5] [2],[VAR5] [3],[VAR5] [4],[VAR5] [5],[VAR5] [6],[VAR5] [7],[VAR5] [8]);\n  }\n  return;\n}", "answer": {"VAR1": "stream", "VAR2": "command_name", "VAR3": "package", "VAR4": "version", "VAR5": "authors", "VAR6": "n_authors", "FUNC2": "fputc", "FUNC3": "__fprintf_chk", "FUNC1": "version_etc_arn", "TYPE3": "char *", "TYPE2": "char *", "TYPE5": "char * *", "TYPE4": "char *", "TYPE6": "size_t", "TYPE1": "FILE *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV RBP,R8\nMOV R12,R9\nTEST RSI,RSI\nJZ 0x00005ad7\nMOV R9,RCX\nMOV R8,RDX\nMOV RCX,RSI\nLEA RDX,[0xb00c]\nMOV ESI,0x1\nMOV EAX,0x0\nCALL 0x000021e0\nMOV R8D,0x7e6\nLEA RCX,[0xb01f]\nLEA RDX,[0xb360]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nMOV RSI,RBX\nMOV EDI,0xa\nCALL 0x00001fc0\nLEA RCX,[0xb0c8]\nLEA RDX,[0xb0f0]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nMOV RSI,RBX\nMOV EDI,0xa\nCALL 0x00001fc0\nCMP R12,0x9\nJA 0x00005cc3\nLEA RDX,[0xb338]\nMOVSXD RAX,dword ptr [RDX + R12*0x4]\nADD RAX,RDX\nJMP RAX\nMOV R8,RCX\nMOV RCX,RDX\nLEA RDX,[0xb018]\nMOV ESI,0x1\nMOV EAX,0x0\nCALL 0x000021e0\nJMP 0x00005a5d\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0xb023]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV R8,qword ptr [RBP + 0x8]\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0xb033]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nJMP 0x00005b15\nMOV R9,qword ptr [RBP + 0x10]\nMOV R8,qword ptr [RBP + 0x8]\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0xb04a]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nJMP 0x00005b15\nSUB RSP,0x8\nPUSH qword ptr [RBP + 0x18]\nMOV R9,qword ptr [RBP + 0x10]\nMOV R8,qword ptr [RBP + 0x8]\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0xb1a0]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nADD RSP,0x10\nJMP 0x00005b15\nPUSH qword ptr [RBP + 0x20]\nPUSH qword ptr [RBP + 0x18]\nMOV R9,qword ptr [RBP + 0x10]\nMOV R8,qword ptr [RBP + 0x8]\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0xb1c0]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nADD RSP,0x10\nJMP 0x00005b15\nSUB RSP,0x8\nPUSH qword ptr [RBP + 0x28]\nPUSH qword ptr [RBP + 0x20]\nPUSH qword ptr [RBP + 0x18]\nMOV R9,qword ptr [RBP + 0x10]\nMOV R8,qword ptr [RBP + 0x8]\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0xb1e8]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nADD RSP,0x20\nJMP 0x00005b15\nPUSH qword ptr [RBP + 0x30]\nPUSH qword ptr [RBP + 0x28]\nPUSH qword ptr [RBP + 0x20]\nPUSH qword ptr [RBP + 0x18]\nMOV R9,qword ptr [RBP + 0x10]\nMOV R8,qword ptr [RBP + 0x8]\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0xb210]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nADD RSP,0x20\nJMP 0x00005b15\nSUB RSP,0x8\nPUSH qword ptr [RBP + 0x38]\nPUSH qword ptr [RBP + 0x30]\nPUSH qword ptr [RBP + 0x28]\nPUSH qword ptr [RBP + 0x20]\nPUSH qword ptr [RBP + 0x18]\nMOV R9,qword ptr [RBP + 0x10]\nMOV R8,qword ptr [RBP + 0x8]\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0xb240]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nADD RSP,0x30\nJMP 0x00005b15\nPUSH qword ptr [RBP + 0x40]\nPUSH qword ptr [RBP + 0x38]\nPUSH qword ptr [RBP + 0x30]\nPUSH qword ptr [RBP + 0x28]\nPUSH qword ptr [RBP + 0x20]\nPUSH qword ptr [RBP + 0x18]\nMOV R9,qword ptr [RBP + 0x10]\nMOV R8,qword ptr [RBP + 0x8]\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0xb270]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nADD RSP,0x30\nJMP 0x00005b15\nPUSH qword ptr [RBP + 0x40]\nPUSH qword ptr [RBP + 0x38]\nPUSH qword ptr [RBP + 0x30]\nPUSH qword ptr [RBP + 0x28]\nPUSH qword ptr [RBP + 0x20]\nPUSH qword ptr [RBP + 0x18]\nMOV R9,qword ptr [RBP + 0x10]\nMOV R8,qword ptr [RBP + 0x8]\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0xb2a8]\nMOV ESI,0x1\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000021e0\nADD RSP,0x30\nJMP 0x00005b15\n"}, "231": {"funcbody": "void [FUNC1] (void)\n{\n  ENGINE *e;\n  TYPE19 [VAR1] ;\n  \n  for (e = [FUNC2] (); e != (ENGINE *)0x0; e = [FUNC3] (e)) {\n    [FUNC4] (e);\n  }\n  return;\n}", "answer": {"VAR1": "e", "FUNC2": "ENGINE_get_first", "FUNC3": "ENGINE_get_next", "FUNC1": "ENGINE_register_all_DH", "FUNC4": "ENGINE_register_DH", "TYPE1": "ENGINE *"}, "assembly": "PUSH RBX\nCALL 0x0017ac85\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x0017cbd2\nMOV RDI,RBX\nCALL 0x0017cb6c\nMOV RDI,RBX\nCALL 0x0017adcb\nMOV RBX,RAX\nTEST RAX,RAX\nJNZ 0x0017cbba\nPOP RBX\nRET\n"}, "232": {"funcbody": "int [FUNC1] (TYPE12 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  BIO *in;\n  [TYPE4] [VAR4] ;\n  size_t sVar2;\n  \n  if ((([VAR2] == ([TYPE2] )0x0) || ([VAR3] == ([TYPE3] )0x0)) ||\n     (*[VAR2] == (uchar *)0x0)) {\n    [FUNC6] ();\n    [FUNC5] (\"crypto/encode_decode/decoder_lib.c\",0x97,\"OSSL_DECODER_from_data\");\n    [FUNC8] (0x3c,0xc0102,(char *)0x0);\n    iVar1 = 0;\n  }\n  else {\n    in = (BIO *)[FUNC3] (*[VAR2] ,*(int *)[VAR3] );\n    iVar1 = [FUNC2] ([VAR1] ,in);\n    if (iVar1 != 0) {\n      sVar2 = [FUNC7] ((BIO *)in,3,0,[VAR2] );\n      *[VAR3] = sVar2;\n      iVar1 = 1;\n    }\n    [FUNC4] ((BIO *)in);\n  }\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "pdata", "VAR3": "pdata_len", "VAR4": "membio", "FUNC2": "OSSL_DECODER_from_bio", "FUNC3": "BIO_new_mem_buf", "FUNC1": "OSSL_DECODER_from_data", "FUNC6": "ERR_new", "TYPE3": "size_t *", "FUNC7": "BIO_ctrl", "TYPE2": "uchar * *", "FUNC4": "BIO_free", "FUNC5": "ERR_set_debug", "TYPE4": "BIO *", "FUNC8": "ERR_set_error", "TYPE1": "OSSL_DECODER_CTX *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nTEST RSI,RSI\nJZ 0x00105ad8\nMOV RBP,RDI\nMOV RBX,RSI\nMOV R12,RDX\nMOV RDI,qword ptr [RSI]\nTEST RDX,RDX\nJZ 0x00105ad8\nTEST RDI,RDI\nJZ 0x00105ad8\nMOV ESI,dword ptr [RDX]\nCALL 0x000d8cc0\nMOV R13,RAX\nMOV RSI,RAX\nMOV RDI,RBP\nCALL 0x001056ed\nMOV EBP,EAX\nTEST EAX,EAX\nJNZ 0x00105b20\nMOV RDI,R13\nCALL 0x000d3780\nJMP 0x00105b13\nCALL 0x0010b20b\nLEA RDX,[0x2dcf00]\nMOV ESI,0x97\nLEA RDI,[0x2dcb88]\nCALL 0x0010b318\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0x3c\nMOV EAX,0x0\nCALL 0x0010b62f\nMOV EBP,0x0\nMOV EAX,EBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV RCX,RBX\nMOV EDX,0x0\nMOV ESI,0x3\nMOV RDI,R13\nCALL 0x000d3e48\nMOV qword ptr [R12],RAX\nMOV EBP,0x1\nJMP 0x00105ace\n"}, "233": {"funcbody": "void [FUNC1] (TYPE18 [VAR1] ,TYPE27 [VAR2] )\n{\n  void **ppvVar1;\n  void **ppvVar2;\n  TYPE31 [VAR3] ;\n  [TYPE4] [VAR4] ;\n  int iVar3;\n  long lVar4;\n  \n  if ([VAR1] == (TYPE18)0x0) {\n    return;\n  }\n  iVar3 = [VAR1] ->num_nodes - 1;\n  if (-1 < iVar3) {\n    lVar4 = (long)iVar3 << 3;\n    do {\n      ppvVar2 = *(void ***)((long)[VAR1] ->b + lVar4);\n      while (ppvVar2 != (void **)0x0) {\n        ppvVar1 = (void **)ppvVar2[1];\n        (*[VAR2] )(*ppvVar2);\n        ppvVar2 = ppvVar1;\n      }\n      lVar4 = lVar4 + -8;\n      iVar3 = iVar3 + -1;\n    } while (-1 < iVar3);\n  }\n  return;\n}", "answer": {"VAR1": "lh", "VAR2": "func", "VAR3": "a", "VAR4": "n", "FUNC1": "OPENSSL_LH_doall", "TYPE3": "OPENSSL_LH_NODE *", "TYPE2": "OPENSSL_LH_DOALL_FUNC", "TYPE4": "OPENSSL_LH_NODE *", "TYPE1": "OPENSSL_LHASH *"}, "assembly": "TEST RDI,RDI\nJZ 0x00098aff\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R12D,dword ptr [RDI + 0x18]\nSUB R12D,0x1\nJS 0x00098af6\nMOV RBP,RSI\nMOV R14,RDI\nMOVSXD R13,R12D\nSHL R13,0x3\nMOV RAX,qword ptr [R14]\nMOV RAX,qword ptr [RAX + R13*0x1]\nTEST RAX,RAX\nJZ 0x00098aec\nMOV RBX,qword ptr [RAX + 0x8]\nMOV RDI,qword ptr [RAX]\nCALL RBP\nMOV RAX,RBX\nTEST RBX,RBX\nJNZ 0x00098adb\nSUB R13,0x8\nSUB R12D,0x1\nJNS 0x00098acf\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nRET\n"}, "234": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  char cVar1;\n  char *__s;\n  int iVar2;\n  OSSL_NAMEMAP *namemap;\n  [TYPE6] [VAR6] ;\n  char *pcVar3;\n  [TYPE8] [VAR8] ;\n  void *pvVar4;\n  ulong uVar5;\n  TYPE45 [VAR4] ;\n  [TYPE9] [VAR9] ;\n  [TYPE5] [VAR5] ;\n  [TYPE7] [VAR7] ;\n  long in_FS_OFFSET;\n  byte bVar6;\n  [TYPE11] [VAR11] ;\n  long [VAR10] ;\n  \n  bVar6 = 0;\n  [VAR10] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR11] = ([TYPE11] )0x0;\n  iVar2 = *(int *)((long)[VAR3] + 8);\n  if (iVar2 == 0) {\n    pvVar4 = (void *)0x0;\n    if (*(long *)((long)[VAR3] + 0x10) == 0) goto LAB_00184f6e;\n    namemap = [FUNC5] (*[VAR3] );\n    __s = *(char **)((long)[VAR3] + 0x10);\n    pcVar3 = [FUNC7] (__s,0x3a);\n    [VAR9] = (long)pcVar3 - (long)__s;\n    if (pcVar3 == (char *)0x0) {\n      uVar5 = 0xffffffffffffffff;\n      pcVar3 = __s;\n      do {\n        if (uVar5 == 0) break;\n        uVar5 = uVar5 - 1;\n        cVar1 = *pcVar3;\n        pcVar3 = pcVar3 + (ulong)bVar6 * -2 + 1;\n      } while (cVar1 != '\\0');\n      [VAR9] = ~uVar5 - 1;\n    }\n    if (namemap == (OSSL_NAMEMAP *)0x0) {\n      pvVar4 = (void *)0x0;\n      goto LAB_00184f6e;\n    }\n    iVar2 = [FUNC6] (namemap,__s,[VAR9] );\n    if (iVar2 == 0) {\n      pvVar4 = (void *)0x0;\n      goto LAB_00184f6e;\n    }\n  }\n  if (([VAR1] == ([TYPE1] )0x0) &&\n     ([VAR1] = [FUNC3] (*[VAR3] ), (OSSL_METHOD_STORE *)[VAR1] == (OSSL_METHOD_STORE *)0x0)) {\n    pvVar4 = (void *)0x0;\n  }\n  else {\n    iVar2 = [FUNC4] ((OSSL_METHOD_STORE *)[VAR1] ,iVar2,*(char **)((long)[VAR3] + 0x18),[VAR2] ,&[VAR11] );\n    pvVar4 = [VAR11] ;\n    if (iVar2 == 0) {\n      pvVar4 = (void *)0x0;\n    }\n  }\nLAB_00184f6e:\n  if ([VAR10] != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC2] ();\n  }\n  return pvVar4;\n}", "answer": {"VAR1": "store", "VAR2": "prov", "VAR3": "data", "VAR4": "methdata", "VAR5": "id", "VAR6": "namemap", "FUNC2": "__stack_chk_fail", "FUNC3": "get_encoder_store", "FUNC1": "get_encoder_from_store", "FUNC6": "ossl_namemap_name2num_n", "TYPE3": "void *", "FUNC7": "strchr", "TYPE2": "OSSL_PROVIDER * *", "FUNC4": "ossl_method_store_fetch", "TYPE5": "int", "FUNC5": "ossl_namemap_stored", "TYPE4": "encoder_data_st *", "TYPE7": "char *", "TYPE6": "OSSL_NAMEMAP *", "TYPE9": "size_t", "TYPE8": "char *", "VAR7": "names", "TYPE11": "void *", "VAR8": "q", "VAR9": "l", "TYPE10": "undefined8", "VAR10": "local_30", "VAR11": "method", "TYPE1": "void *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x10\nMOV R12,RDI\nMOV R13,RSI\nMOV RBX,RDX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],0x0\nMOV EBP,dword ptr [RDX + 0x8]\nTEST EBP,EBP\nJNZ 0x00184f4d\nCMP qword ptr [RDX + 0x10],0x0\nJZ 0x00184f6e\nMOV RDI,qword ptr [RDX]\nCALL 0x000994bb\nMOV R14,RAX\nMOV RBP,qword ptr [RBX + 0x10]\nMOV ESI,0x3a\nMOV RDI,RBP\nCALL 0x00062640\nMOV RDX,RAX\nSUB RDX,RBP\nTEST RAX,RAX\nJZ 0x00184f8b\nTEST R14,R14\nJZ 0x00184fb2\nMOV RSI,RBP\nMOV RDI,R14\nCALL 0x00099669\nMOV EBP,EAX\nTEST EAX,EAX\nJZ 0x00184fb9\nTEST R12,R12\nJZ 0x00184fa0\nMOV RDX,qword ptr [RBX + 0x18]\nMOV R8,RSP\nMOV RCX,R13\nMOV ESI,EBP\nMOV RDI,R12\nCALL 0x000ae4d3\nTEST EAX,EAX\nJZ 0x00184fc0\nMOV RAX,qword ptr [RSP]\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00184fc7\nADD RSP,0x10\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV RCX,-0x1\nMOV RDI,RBP\nSCASB.REPNE RDI\nNOT RCX\nLEA RDX,[RCX + -0x1]\nJMP 0x00184f37\nMOV RDI,qword ptr [RBX]\nCALL 0x00184ad0\nMOV R12,RAX\nTEST RAX,RAX\nJNZ 0x00184f52\nJMP 0x00184f6e\nMOV EAX,0x0\nJMP 0x00184f6e\nMOV EAX,0x0\nJMP 0x00184f6e\nMOV EAX,0x0\nJMP 0x00184f6e\nCALL 0x000626d0\n"}, "235": {"funcbody": "_Bool [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  _Bool _Var1;\n  \n  if ([VAR2] ->sh_type != 0x70000001) {\n    return false;\n  }\n  _Var1 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,[VAR4] );\n  return _Var1;\n}", "answer": {"VAR1": "abfd", "VAR2": "hdr", "VAR3": "name", "VAR4": "shindex", "FUNC2": "_bfd_elf_make_section_from_shdr", "FUNC1": "elf_x86_64_section_from_shdr", "TYPE3": "char *", "TYPE2": "Elf_Internal_Shdr *", "TYPE4": "int", "TYPE1": "bfd *"}, "assembly": "MOV EAX,0x0\nCMP dword ptr [RSI + 0x4],0x70000001\nJZ 0x00046cc0\nRET\nSUB RSP,0x8\nCALL 0x0005b00f\nADD RSP,0x8\nRET\n"}, "236": {"funcbody": "void [FUNC1] (undefined [VAR1] ,undefined [VAR2] ,undefined [VAR3] ,undefined [VAR4] ,undefined [VAR5] ,\n          [TYPE6] [VAR6] ,[TYPE7] [VAR7] ,int [VAR8] )\n{\n  void *pvVar1;\n  undefined7 in_register_00000009;\n  undefined7 in_register_00000011;\n  void *__src;\n  undefined7 in_register_00000031;\n  undefined7 in_register_00000039;\n  int3 in_register_00000081;\n  int iVar2;\n  \n  pvVar1 = (void *)CONCAT71(in_register_00000039,[VAR1] );\n  __src = (void *)CONCAT71(in_register_00000011,[VAR3] );\n  if (CONCAT31(in_register_00000081,[VAR5] ) != 0 && -1 < in_register_00000081) {\n    iVar2 = 0;\n    do {\n      pvVar1 = [FUNC2] (pvVar1,__src,(long)[VAR8] * 2);\n      iVar2 = iVar2 + 1;\n      __src = (void *)((long)__src + (CONCAT71(in_register_00000009,[VAR4] ) & 0xfffffffffffffffe));\n      pvVar1 = (void *)((long)pvVar1 + (CONCAT71(in_register_00000031,[VAR2] ) & 0xfffffffffffffffe));\n    } while (CONCAT31(in_register_00000081,[VAR5] ) != iVar2);\n    return;\n  }\n  return;\n}", "answer": {"VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "VAR5": "param_5", "VAR6": "param_6", "FUNC2": "memcpy", "FUNC1": "FUN_007b7b40", "TYPE3": "undefined", "TYPE2": "undefined", "TYPE5": "undefined", "TYPE4": "undefined", "TYPE7": "undefined", "TYPE6": "undefined", "TYPE8": "undefined4", "VAR7": "param_7", "VAR8": "param_8", "TYPE1": "undefined"}, "assembly": "TEST R8D,R8D\nJLE 0x007b7bb0\nPUSH R15\nPUSH R14\nAND RCX,-0x2\nPUSH R13\nPUSH R12\nAND RSI,-0x2\nPUSH RBP\nPUSH RBX\nMOV R9,RDI\nMOV RBX,RDX\nMOV R14D,R8D\nMOV R12,RCX\nSUB RSP,0x8\nMOV RBP,RSI\nXOR R15D,R15D\nMOVSXD R13,dword ptr [RSP + 0x48]\nADD R13,R13\nNOP dword ptr [RAX]\nMOV RSI,RBX\nMOV RDI,R9\nMOV RDX,R13\nCALL 0x0010e180\nADD R15D,0x1\nMOV R9,RAX\nADD RBX,R12\nADD R9,RBP\nCMP R14D,R15D\nJNZ 0x007b7b78\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nRET\n"}, "237": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE21 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,TYPE66 [VAR6] ,[TYPE7] [VAR7] )\n{\n  int iVar1;\n  \n  if ([VAR4] == ([TYPE4] )0x0) {\n    iVar1 = [FUNC3] ([VAR1] ,[VAR3] ,[VAR5] ,[VAR2] ,[FUNC4] ,[VAR6] ,[VAR7] );\n  }\n  else {\n    [FUNC2] ();\n    [FUNC5] (\"providers/implementations/encode_decode/encode_key2ms.c\",0xe9,\"rsa2pvk_encode\");\n    [FUNC6] (0x39,0x80106,(char *)0x0);\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "vctx", "VAR2": "cout", "VAR3": "key", "VAR4": "key_abstract", "VAR5": "selection", "VAR6": "cb", "FUNC2": "ERR_new", "FUNC3": "key2pvk_encode", "FUNC1": "rsa2pvk_encode", "FUNC6": "ERR_set_error", "TYPE3": "void *", "TYPE2": "OSSL_CORE_BIO *", "FUNC4": "EVP_PKEY_set1_RSA", "TYPE5": "int", "FUNC5": "ERR_set_debug", "TYPE4": "OSSL_PARAM *", "TYPE7": "void *", "TYPE6": "OSSL_PASSPHRASE_CALLBACK *", "VAR7": "cbarg", "TYPE1": "void *"}, "assembly": "SUB RSP,0x8\nTEST RCX,RCX\nJZ 0x000e4562\nCALL 0x00080b6e\nLEA RDX,[0x275ab8]\nMOV ESI,0xe9\nLEA RDI,[0x275a50]\nCALL 0x00080c7b\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00080f92\nMOV EAX,0x0\nADD RSP,0x8\nRET\nMOV RAX,RDX\nMOV EDX,R8D\nSUB RSP,0x8\nPUSH qword ptr [RSP + 0x18]\nLEA R8,[0x19b1ef]\nMOV RCX,RSI\nMOV RSI,RAX\nCALL 0x000e43d1\nADD RSP,0x10\nJMP 0x000e455d\n"}, "238": {"funcbody": "ssize_t [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  long lVar1;\n  size_t sVar2;\n  uint uVar3;\n  char *pcVar4;\n  [TYPE4] [VAR4] ;\n  [TYPE7] [VAR7] ;\n  int *piVar5;\n  [TYPE5] [VAR5] ;\n  [TYPE8] [VAR8] ;\n  [TYPE6] [VAR6] ;\n  long lVar6;\n  [TYPE9] [VAR9] ;\n  char *[VAR13] ;\n  size_t [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  \n  *[VAR3] = (char *)0x0;\n  pcVar4 = (char *)[FUNC7] (100);\n  if (pcVar4 == (char *)0x0) {\n    [FUNC2] (\"read_until: out of memory\");\n  }\n  else {\n    [VAR12] = 100;\n    lVar6 = 0;\n    do {\n      do {\n        [VAR13] = pcVar4;\n        uVar3 = [FUNC8] ([VAR1] ,3);\n        [FUNC8] ([VAR1] ,4,(long)(int)(uVar3 & 0xfffff7ff));\n        do {\n          [VAR8] = [FUNC5] ([VAR1] ,[VAR13] + lVar6,1);\n          if ([VAR8] == 0) {\nLAB_000050e0:\n            [FUNC8] ([VAR1] ,4,(long)(int)uVar3);\n            [FUNC4] ([VAR13] );\n            if ([VAR8] != 0) {\n              piVar5 = [FUNC3] ();\n              pcVar4 = [FUNC6] (*piVar5);\n              [FUNC2] (\"read_until: read error: %s\",pcVar4);\n              return [VAR8] ;\n            }\n            [FUNC2] (\"read_until: closed\");\n            return 0;\n          }\n          if ([VAR8] == -1) {\n            piVar5 = [FUNC3] ();\n            if (*piVar5 != 0xb) goto LAB_000050e0;\n            [VAR8] = 0;\n          }\n        } while ([VAR8] == 0);\n        [FUNC8] ([VAR1] ,4,(long)(int)uVar3);\n        lVar1 = lVar6 + 1;\n        if ([VAR13] [lVar6] == [VAR2] ) {\n          pcVar4 = (char *)[FUNC9] ([VAR13] ,lVar6 + 2);\n          if (pcVar4 == (char *)0x0) {\n            [FUNC2] (\"read_until: realloc: shrink failed\");\n            pcVar4 = [VAR13] ;\n          }\n          *[VAR3] = pcVar4;\n          return lVar1;\n        }\n        sVar2 = lVar6 + 2;\n        lVar6 = lVar1;\n        pcVar4 = [VAR13] ;\n      } while ([VAR12] != sVar2);\n      [VAR12] = [VAR12] << 1;\n      pcVar4 = (char *)[FUNC9] ([VAR13] ,[VAR12] );\n    } while (pcVar4 != (char *)0x0);\n    [FUNC2] (\"read_until: realloc failed\");\n    [FUNC4] ([VAR13] );\n  }\n  return -1;\n}", "answer": {"VAR1": "fd", "VAR2": "ch", "VAR3": "data", "VAR4": "buf", "VAR5": "len", "VAR6": "rbuf", "FUNC2": "log_error", "FUNC3": "__errno_location", "FUNC1": "read_until", "FUNC6": "strerror", "TYPE3": "char * *", "FUNC7": "malloc", "TYPE2": "int", "FUNC4": "free", "TYPE5": "ssize_t", "VAR12": "local_50", "FUNC5": "read", "TYPE4": "char *", "VAR13": "local_58", "TYPE7": "char *", "TYPE6": "char *", "FUNC8": "fcntl", "TYPE9": "long", "FUNC9": "realloc", "TYPE8": "ssize_t", "VAR7": "buf2", "TYPE11": "undefined4", "VAR8": "n", "TYPE12": "undefined8", "VAR9": "flags", "TYPE10": "undefined8", "VAR10": "local_40", "VAR11": "local_44", "TYPE1": "int", "TYPE13": "undefined8"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV EBP,EDI\nMOV dword ptr [RSP + 0x14],ESI\nMOV qword ptr [RSP + 0x18],RDX\nMOV qword ptr [RDX],0x0\nMOV EDI,0x64\nCALL 0x00001680\nMOV qword ptr [RSP],RAX\nTEST RAX,RAX\nJZ 0x00004f8b\nMOV qword ptr [RSP + 0x8],0x64\nMOV R13D,0x0\nMOV R14D,0x0\nJMP 0x000050a8\nLEA RDI,[0x7ca4]\nCALL 0x00002899\nMOV RBX,-0x1\nJMP 0x0000504f\nSHL qword ptr [RSP + 0x8],0x1\nMOV RAX,qword ptr [RSP + 0x8]\nMOV RSI,RAX\nMOV RDI,qword ptr [RSP]\nCALL 0x000016c0\nTEST RAX,RAX\nJZ 0x00004fc7\nMOV qword ptr [RSP],RAX\nJMP 0x000050a5\nLEA RDI,[0x7cbe]\nCALL 0x00002899\nMOV RDI,qword ptr [RSP]\nCALL 0x000014a0\nMOV RBX,-0x1\nJMP 0x0000504f\nTEST RBX,RBX\nJNZ 0x00005073\nMOV EDX,0x1\nMOV RSI,R12\nMOV EDI,EBP\nCALL 0x000015c0\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000050e0\nCMP RAX,-0x1\nJNZ 0x00004fe5\nCALL 0x000014c0\nCMP dword ptr [RAX],0xb\nJNZ 0x000050e0\nMOV RBX,R14\nJMP 0x00004fe5\nLEA RDI,[0x7cd9]\nMOV EAX,0x0\nCALL 0x00002899\nJMP 0x0000504f\nLEA RSI,[R13 + 0x2]\nMOV RDI,qword ptr [RSP]\nCALL 0x000016c0\nTEST RAX,RAX\nJZ 0x00005061\nMOV RCX,qword ptr [RSP + 0x18]\nMOV qword ptr [RCX],RAX\nMOV RAX,RBX\nADD RSP,0x28\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nLEA RDI,[0x7e00]\nCALL 0x00002899\nMOV RAX,qword ptr [RSP]\nJMP 0x00005047\nMOV RDX,R15\nMOV ESI,0x4\nMOV EDI,EBP\nMOV EAX,0x0\nCALL 0x000014f0\nLEA RBX,[R13 + 0x1]\nMOVSX EAX,byte ptr [R12]\nCMP EAX,dword ptr [RSP + 0x14]\nJZ 0x00005035\nLEA RAX,[RBX + 0x1]\nCMP qword ptr [RSP + 0x8],RAX\nJZ 0x00004fa3\nMOV R13,RBX\nMOV RAX,qword ptr [RSP]\nLEA R12,[RAX + R13*0x1]\nMOV ESI,0x3\nMOV EDI,EBP\nMOV EAX,0x0\nCALL 0x000014f0\nMOVSXD R15,EAX\nAND AH,0xf7\nMOVSXD RDX,EAX\nMOV ESI,0x4\nMOV EDI,EBP\nMOV EAX,0x0\nCALL 0x000014f0\nJMP 0x00004fee\nMOV RDX,R15\nMOV ESI,0x4\nMOV EDI,EBP\nMOV EAX,0x0\nCALL 0x000014f0\nMOV RDI,qword ptr [RSP]\nCALL 0x000014a0\nTEST RBX,RBX\nJZ 0x00005022\nCALL 0x000014c0\nMOV EDI,dword ptr [RAX]\nCALL 0x000017e0\nMOV RSI,RAX\nLEA RDI,[0x7cec]\nMOV EAX,0x0\nCALL 0x00002899\nJMP 0x0000504f\n"}, "239": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  long lVar1;\n  grub_disk_dev_t pgVar2;\n  int iVar3;\n  [TYPE3] [VAR3] ;\n  grub_disk_pull_t gVar4;\n  long in_FS_OFFSET;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR5] .ents = (part_ent *)0x0;\n  gVar4 = GRUB_DISK_PULL_NONE;\n  pgVar2 = grub_disk_dev_list;\n  [VAR5] .hook = [VAR1] ;\n  [VAR5] .hook_data = [VAR2] ;\n  do {\n    while (pgVar2 == (grub_disk_dev_t)0x0) {\n      gVar4 = gVar4 + GRUB_DISK_PULL_REMOVABLE;\n      pgVar2 = grub_disk_dev_list;\n      if (GRUB_DISK_PULL_RESCAN < gVar4) {\n        iVar3 = 0;\nLAB_000136f7:\n        if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n          return iVar3;\n        }\n        [FUNC3] ();\n      }\n    }\n    if ((pgVar2->disk_iterate !=\n         (_func_int_grub_disk_dev_iterate_hook_t_void_ptr_grub_disk_pull_t *)0x0) &&\n       (iVar3 = (*pgVar2->disk_iterate)([FUNC2] ,&[VAR5] ,gVar4), iVar3 != 0)) {\n      iVar3 = 1;\n      goto LAB_000136f7;\n    }\n    pgVar2 = pgVar2->next;\n  } while( true );\n}", "answer": {"VAR1": "hook", "VAR2": "hook_data", "VAR3": "p", "VAR4": "local_20", "VAR5": "ctx", "FUNC2": "iterate_disk", "FUNC3": "__stack_chk_fail", "FUNC1": "grub_device_iterate", "TYPE3": "grub_disk_dev_t", "TYPE2": "void *", "TYPE5": "grub_device_iterate_ctx", "TYPE4": "undefined8", "TYPE1": "grub_device_iterate_hook_t"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x20\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],RDI\nMOV qword ptr [RSP + 0x8],RSI\nMOV qword ptr [RSP + 0x10],0x0\nMOV EBP,0x0\nMOV R12,RSP\nMOV RBX,qword ptr [0x00242d20]\nTEST RBX,RBX\nJZ 0x000136e3\nMOV RAX,qword ptr [RBX + 0x10]\nTEST RAX,RAX\nJZ 0x000136da\nMOV EDX,EBP\nMOV RSI,R12\nLEA RDI,[0x135b3]\nCALL RAX\nTEST EAX,EAX\nJNZ 0x000136f2\nMOV RBX,qword ptr [RBX + 0x48]\nTEST RBX,RBX\nJNZ 0x000136bf\nADD EBP,0x1\nCMP EBP,0x2\nJBE 0x000136b3\nMOV EAX,0x0\nJMP 0x000136f7\nMOV EAX,0x1\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00013710\nADD RSP,0x20\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x00003b70\n"}, "240": {"funcbody": "void [FUNC1] (ushort *param_1,ulong param_2,int param_3,int param_4,int param_5,int param_6)\n{\n  byte bVar1;\n  uint uVar2;\n  int iVar3;\n  \n  bVar1 = (byte)param_4;\n  param_6 = param_6 << (bVar1 + 4 & 0x1f);\n  if (param_4 != 0) {\n    param_6 = param_6 + (1 << (bVar1 - 1 & 0x1f));\n  }\n  if (param_3 < 1) {\n    return;\n  }\n  iVar3 = 0;\n  do {\n    uVar2 = (int)((uint)*param_1 * param_5 + param_6) >> (bVar1 & 0x1f);\n    if ((uVar2 & 0xfffff000) != 0) {\n      uVar2 = (int)~uVar2 >> 0x1f & 0xfff;\n    }\n    *param_1 = (ushort)uVar2;\n    uVar2 = (int)((uint)param_1[1] * param_5 + param_6) >> (bVar1 & 0x1f);\n    if ((uVar2 & 0xfffff000) != 0) {\n      uVar2 = (int)~uVar2 >> 0x1f & 0xfff;\n    }\n    param_1[1] = (ushort)uVar2;\n    uVar2 = (int)((uint)param_1[2] * param_5 + param_6) >> (bVar1 & 0x1f);\n    if ((uVar2 & 0xfffff000) != 0) {\n      uVar2 = (int)~uVar2 >> 0x1f & 0xfff;\n    }\n    param_1[2] = (ushort)uVar2;\n    uVar2 = (int)((uint)param_1[3] * param_5 + param_6) >> (bVar1 & 0x1f);\n    if ((uVar2 & 0xfffff000) != 0) {\n      uVar2 = (int)~uVar2 >> 0x1f & 0xfff;\n    }\n    param_1[3] = (ushort)uVar2;\n    uVar2 = (int)((uint)param_1[4] * param_5 + param_6) >> (bVar1 & 0x1f);\n    if ((uVar2 & 0xfffff000) != 0) {\n      uVar2 = (int)~uVar2 >> 0x1f & 0xfff;\n    }\n    param_1[4] = (ushort)uVar2;\n    uVar2 = (int)((uint)param_1[5] * param_5 + param_6) >> (bVar1 & 0x1f);\n    if ((uVar2 & 0xfffff000) != 0) {\n      uVar2 = (int)~uVar2 >> 0x1f & 0xfff;\n    }\n    param_1[5] = (ushort)uVar2;\n    uVar2 = (int)((uint)param_1[6] * param_5 + param_6) >> (bVar1 & 0x1f);\n    if ((uVar2 & 0xfffff000) != 0) {\n      uVar2 = (int)~uVar2 >> 0x1f & 0xfff;\n    }\n    param_1[6] = (ushort)uVar2;\n    uVar2 = (int)((uint)param_1[7] * param_5 + param_6) >> (bVar1 & 0x1f);\n    if ((uVar2 & 0xfffff000) != 0) {\n      uVar2 = (int)~uVar2 >> 0x1f & 0xfff;\n    }\n    iVar3 = iVar3 + 1;\n    param_1[7] = (ushort)uVar2;\n    param_1 = (ushort *)((long)param_1 + (param_2 & 0xfffffffffffffffe));\n  } while (param_3 != iVar3);\n  return;\n}", "answer": {"FUNC1": "FUN_00da7f50"}, "assembly": "MOV EAX,ECX\nLEA ECX,[RCX + 0x4]\nSHL R9D,CL\nTEST EAX,EAX\nJZ 0x00da7f6b\nLEA ECX,[RAX + -0x1]\nMOV R10D,0x1\nSHL R10D,CL\nADD R9D,R10D\nTEST EDX,EDX\nJG 0x00da7f78\nRET\nAND RSI,-0x2\nXOR R11D,R11D\nMOVZX R10D,word ptr [RDI]\nMOV ECX,EAX\nIMUL R10D,R8D\nADD R10D,R9D\nSAR R10D,CL\nTEST R10D,0xfffff000\nMOV ECX,R10D\nJZ 0x00da7fa6\nNOT ECX\nSAR ECX,0x1f\nAND ECX,0xfff\nMOVZX R10D,word ptr [RDI + 0x2]\nMOV word ptr [RDI],CX\nMOV ECX,EAX\nIMUL R10D,R8D\nADD R10D,R9D\nSAR R10D,CL\nTEST R10D,0xfffff000\nMOV ECX,R10D\nJZ 0x00da7fd1\nNOT ECX\nSAR ECX,0x1f\nAND ECX,0xfff\nMOVZX R10D,word ptr [RDI + 0x4]\nMOV word ptr [RDI + 0x2],CX\nMOV ECX,EAX\nIMUL R10D,R8D\nADD R10D,R9D\nSAR R10D,CL\nTEST R10D,0xfffff000\nMOV ECX,R10D\nJZ 0x00da7ffd\nNOT ECX\nSAR ECX,0x1f\nAND ECX,0xfff\nMOVZX R10D,word ptr [RDI + 0x6]\nMOV word ptr [RDI + 0x4],CX\nMOV ECX,EAX\nIMUL R10D,R8D\nADD R10D,R9D\nSAR R10D,CL\nTEST R10D,0xfffff000\nMOV ECX,R10D\nJZ 0x00da8029\nNOT ECX\nSAR ECX,0x1f\nAND ECX,0xfff\nMOVZX R10D,word ptr [RDI + 0x8]\nMOV word ptr [RDI + 0x6],CX\nMOV ECX,EAX\nIMUL R10D,R8D\nADD R10D,R9D\nSAR R10D,CL\nTEST R10D,0xfffff000\nMOV ECX,R10D\nJZ 0x00da8055\nNOT ECX\nSAR ECX,0x1f\nAND ECX,0xfff\nMOVZX R10D,word ptr [RDI + 0xa]\nMOV word ptr [RDI + 0x8],CX\nMOV ECX,EAX\nIMUL R10D,R8D\nADD R10D,R9D\nSAR R10D,CL\nTEST R10D,0xfffff000\nMOV ECX,R10D\nJZ 0x00da8081\nNOT ECX\nSAR ECX,0x1f\nAND ECX,0xfff\nMOVZX R10D,word ptr [RDI + 0xc]\nMOV word ptr [RDI + 0xa],CX\nMOV ECX,EAX\nIMUL R10D,R8D\nADD R10D,R9D\nSAR R10D,CL\nTEST R10D,0xfffff000\nMOV ECX,R10D\nJZ 0x00da80ad\nNOT ECX\nSAR ECX,0x1f\nAND ECX,0xfff\nMOV word ptr [RDI + 0xc],CX\nMOVZX ECX,word ptr [RDI + 0xe]\nIMUL ECX,R8D\nLEA R10D,[RCX + R9*0x1]\nMOV ECX,EAX\nSAR R10D,CL\nTEST R10D,0xfffff000\nMOV ECX,R10D\nJZ 0x00da80d9\nNOT ECX\nSAR ECX,0x1f\nAND ECX,0xfff\nADD R11D,0x1\nMOV word ptr [RDI + 0xe],CX\nADD RDI,RSI\nCMP EDX,R11D\nJNZ 0x00da7f7f\nRET\n"}, "241": {"funcbody": "int [FUNC1] (TYPE10 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  OSSL_LIB_CTX *libctx;\n  [TYPE5] [VAR5] ;\n  OSSL_NAMEMAP *namemap;\n  [TYPE6] [VAR6] ;\n  \n  libctx = [FUNC3] ([VAR1] );\n  namemap = [FUNC2] (libctx);\n  if ([VAR1] == (TYPE10)0x0) {\n    [VAR2] = [FUNC4] (namemap,[VAR3] );\n  }\n  iVar1 = [FUNC4] (namemap,[VAR4] );\n  return (int)(iVar1 == [VAR2] );\n}", "answer": {"VAR1": "prov", "VAR2": "number", "VAR3": "legacy_name", "VAR4": "name", "VAR5": "libctx", "VAR6": "namemap", "FUNC2": "ossl_namemap_stored", "FUNC3": "ossl_provider_libctx", "FUNC1": "evp_is_a", "TYPE3": "char *", "TYPE2": "int", "FUNC4": "ossl_namemap_name2num", "TYPE5": "OSSL_LIB_CTX *", "TYPE4": "char *", "TYPE6": "OSSL_NAMEMAP *", "TYPE1": "OSSL_PROVIDER *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV EBP,ESI\nMOV R14,RDX\nMOV R13,RCX\nCALL 0x0009ee5e\nMOV RDI,RAX\nCALL 0x0009705a\nMOV R12,RAX\nTEST RBX,RBX\nJZ 0x00088015\nMOV RSI,R13\nMOV RDI,R12\nCALL 0x00097270\nCMP EAX,EBP\nSETZ AL\nMOVZX EAX,AL\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV RSI,R14\nMOV RDI,RAX\nCALL 0x00097270\nMOV EBP,EAX\nJMP 0x00087ff9\n"}, "242": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  if ([VAR5] <= [VAR6] ) {\n    return 1;\n  }\n  [FUNC2] ((char *)0x0,[VAR1] ,[VAR2] ,\"unsigned int\",[VAR3] ,[VAR4] ,\"<=\",\"[%u] compared to [%u]\",(ulong)[VAR5] ,\n        (ulong)[VAR6] );\n  return 0;\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "s1", "VAR4": "s2", "VAR5": "t1", "VAR6": "t2", "FUNC2": "test_fail_message", "FUNC1": "test_uint_le", "TYPE3": "char *", "TYPE2": "int", "TYPE5": "uint", "TYPE4": "char *", "TYPE6": "uint", "TYPE1": "char *"}, "assembly": "MOV EAX,0x1\nCMP R8D,R9D\nJA 0x00004792\nRET\nSUB RSP,0x8\nMOV R10D,R9D\nMOV EAX,R8D\nMOV R9,RCX\nMOV R8,RDX\nMOV EDX,ESI\nPUSH R10\nPUSH RAX\nLEA RAX,[0xa250]\nPUSH RAX\nLEA RAX,[0xa23d]\nPUSH RAX\nLEA RCX,[0xa243]\nMOV RSI,RDI\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x00003d49\nMOV EAX,0x0\nADD RSP,0x28\nRET\n"}, "243": {"funcbody": "EVP_CIPHER * [FUNC1] (void)\n{\n  EVP_CIPHER *pEVar1;\n  \n  pEVar1 = &aesni_256_ofb;\n  if (((uint)DAT_00590494 & 0x2000000) == 0) {\n    pEVar1 = &aes_256_ofb;\n  }\n  return (EVP_CIPHER *)pEVar1;\n}", "answer": {"FUNC1": "EVP_aes_256_ofb"}, "assembly": "LEA RAX,[0x590490]\nMOV EAX,dword ptr [RAX + 0x4]\nAND EAX,0x2000000\nLEA RAX,[0x558fc0]\nLEA RDX,[0x558ec0]\nCMOVZ RAX,RDX\nRET\n"}, "244": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC3] (stdscr,[VAR1] ,[VAR2] );\n  if (iVar1 != -1) {\n    iVar1 = [FUNC2] (stdscr,[VAR3] ,-1);\n  }\n  return iVar1;\n}", "answer": {"VAR1": "a1", "VAR2": "a2", "VAR3": "z", "FUNC2": "winnstr", "FUNC3": "wmove", "FUNC1": "mvinstr", "TYPE3": "char *", "TYPE2": "int", "TYPE1": "int"}, "assembly": "PUSH RBX\nMOV RBX,RDX\nMOV EDX,ESI\nMOV ESI,EDI\nMOV RDI,qword ptr [0x0023b8b0]\nCALL 0x0000cee4\nCMP EAX,-0x1\nJZ 0x00009fd4\nMOV EDX,0xffffffff\nMOV RSI,RBX\nMOV RDI,qword ptr [0x0023b8b0]\nCALL 0x0000bdcf\nPOP RBX\nRET\n"}, "245": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  uint uVar2;\n  OSSL_PARAM *pOVar3;\n  TYPE44 [VAR4] ;\n  size_t val;\n  EVP_MD *md;\n  [TYPE5] [VAR5] ;\n  TYPE34 [VAR3] ;\n  \n  pOVar3 = [FUNC7] ([VAR2] ,\"size\");\n  if (pOVar3 != (OSSL_PARAM *)0x0) {\n    val = [FUNC3] (*(HMAC_CTX **)((long)[VAR1] + 8));\n    iVar1 = [FUNC6] (pOVar3,val);\n    if (iVar1 == 0) {\n      return 0;\n    }\n  }\n  pOVar3 = [FUNC7] ([VAR2] ,\"block-size\");\n  uVar2 = 1;\n  if (pOVar3 != (OSSL_PARAM *)0x0) {\n    md = [FUNC5] ((PROV_DIGEST *)((long)[VAR1] + 0x10));\n    iVar1 = 0;\n    if (md != (EVP_MD *)0x0) {\n      iVar1 = [FUNC2] (md);\n    }\n    iVar1 = [FUNC4] (pOVar3,iVar1);\n    uVar2 = (uint)(iVar1 != 0);\n  }\n  return uVar2;\n}", "answer": {"VAR1": "vmacctx", "VAR2": "params", "VAR3": "macctx", "VAR4": "p", "VAR5": "md", "FUNC2": "EVP_MD_get_block_size", "FUNC3": "HMAC_size", "FUNC1": "hmac_get_ctx_params", "FUNC6": "OSSL_PARAM_set_size_t", "TYPE3": "hmac_data_st *", "FUNC7": "OSSL_PARAM_locate", "TYPE2": "OSSL_PARAM *", "FUNC4": "OSSL_PARAM_set_int", "TYPE5": "EVP_MD *", "FUNC5": "ossl_prov_digest_md", "TYPE4": "OSSL_PARAM *", "TYPE1": "void *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV R12,RSI\nLEA RSI,[0x2cf47f]\nMOV RDI,R12\nCALL 0x00130c88\nTEST RAX,RAX\nJZ 0x001aef22\nMOV RBP,RAX\nMOV RDI,qword ptr [RBX + 0x8]\nCALL 0x00128a0e\nMOV RSI,RAX\nMOV RDI,RBP\nCALL 0x001319ea\nTEST EAX,EAX\nJZ 0x001aef6b\nLEA RSI,[0x2df134]\nMOV RDI,R12\nCALL 0x00130c88\nMOV RBP,RAX\nMOV EAX,0x1\nTEST RBP,RBP\nJZ 0x001aef6b\nLEA RDI,[RBX + 0x10]\nCALL 0x0017aec7\nMOV ESI,0x0\nTEST RAX,RAX\nJZ 0x001aef5b\nMOV RDI,RAX\nCALL 0x0011600d\nMOV ESI,EAX\nMOV RDI,RBP\nCALL 0x0013105c\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "246": {"funcbody": "object [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  object *pplVar1;\n  object *pplVar2;\n  [TYPE6] [VAR6] ;\n  object plVar3;\n  [TYPE3] [VAR3] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  pplVar2 = vs_top;\n  pplVar1 = vs_top + 4;\n  if (vs_limit <= pplVar1) {\n    vs_top = pplVar1;\n    [FUNC3] ();\n  }\n  if ((long)[VAR1] < 0) {\nLAB_0025ac6e:\n    plVar3 = (object)&frame_stack[0xf63].frs_bds_top;\n  }\n  else {\n    if (((*(byte *)[VAR1] & 1) == 0) || ([VAR1] ->fw < 0)) {\n      if ([VAR1] != ([TYPE1] )&frame_stack[0xf63].frs_bds_top) goto LAB_0025ac6e;\n    }\n    else if ((*(byte *)((long)&([VAR1] ->c).c_cdr + 1) & 0x1f) != 0x10) goto LAB_0025ac6e;\n    *pplVar2 = [VAR1] ;\n    pplVar2[1] = [VAR2] ;\n    pplVar2[2] = (object)VVi[30];\n    pplVar2[3] = *(object *)((long)VVi[50] + 0x28);\n    vs_base = pplVar2;\n    vs_top = pplVar1;\n    [FUNC2] ();\n    plVar3 = *vs_base;\n  }\n  vs_top = pplVar2;\n  return plVar3;\n}", "answer": {"VAR1": "V150", "VAR2": "V151", "VAR3": "base", "VAR4": "sup", "VAR5": "_z", "VAR6": "V153", "FUNC2": "Lmember", "FUNC3": "vs_overflow", "FUNC1": "LI17", "TYPE3": "object *", "TYPE2": "object", "TYPE5": "object", "TYPE4": "object *", "TYPE6": "object", "TYPE1": "object"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV R13,RSI\nMOV RBX,qword ptr [0x00a86200]\nLEA R12,[RBX + 0x20]\nMOV qword ptr [0x00a86200],R12\nCMP qword ptr [0x0072c3d0],R12\nJBE 0x0025ac5e\nTEST RBP,RBP\nJS 0x0025ac6e\nTEST byte ptr [RBP],0x1\nJZ 0x0025ac65\nCMP qword ptr [RBP],0x0\nJS 0x0025ac65\nMOVZX EAX,byte ptr [RBP + 0x1]\nAND EAX,0x1f\nCMP AL,0x10\nJNZ 0x0025ac6e\nMOV qword ptr [RBX],RBP\nMOV qword ptr [RBX + 0x8],R13\nMOV RAX,qword ptr [0x00735330]\nMOV qword ptr [RBX + 0x10],RAX\nMOV RAX,qword ptr [0x007353d0]\nMOV RAX,qword ptr [RAX + 0x28]\nMOV qword ptr [RBX + 0x18],RAX\nMOV qword ptr [0x00971288],RBX\nMOV qword ptr [0x00a86200],R12\nMOV EAX,0x0\nCALL 0x0012aa15\nMOV qword ptr [0x00a86200],R12\nMOV RAX,qword ptr [0x00971288]\nMOV RAX,qword ptr [RAX]\nMOV qword ptr [0x00a86200],RBX\nJMP 0x0025ac7a\nCALL 0x0011206a\nJMP 0x0025abee\nCMP RBP,0xb6e040\nJZ 0x0025ac0b\nMOV qword ptr [0x00a86200],RBX\nMOV EAX,0xb6e040\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\n"}, "247": {"funcbody": "void [FUNC1] (undefined [VAR1] ,undefined [VAR2] ,undefined [VAR3] ,undefined [VAR4] ,undefined [VAR5] ,undefined [VAR6] \n          ,int [VAR7] ,int [VAR8] )\n{\n  int iVar1;\n  long lVar2;\n  long lVar3;\n  long lVar4;\n  int iVar5;\n  undefined7 in_register_00000009;\n  undefined7 in_register_00000011;\n  int *piVar6;\n  long lVar7;\n  int iVar8;\n  undefined7 in_register_00000031;\n  long lVar9;\n  undefined7 in_register_00000039;\n  long lVar10;\n  undefined7 in_register_00000081;\n  undefined7 in_register_00000089;\n  long lVar11;\n  long lVar12;\n  int iVar13;\n  long lVar14;\n  [TYPE14] [VAR14] ;\n  [TYPE13] [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  \n  lVar2 = (long)[VAR7] ;\n  lVar3 = lVar2 * 0x3ea94d00 + 0x20000000 >> 0x1e;\n  if (0 < [VAR8] ) {\n    lVar7 = (long)(int)(lVar2 * 0x53625b00 + 0x20000000 >> 0x1e);\n    lVar2 = (long)(int)(lVar2 * 0x4848af00 + 0x20000000 >> 0x1e);\n    lVar11 = 0;\n    piVar6 = (int *)(CONCAT71(in_register_00000011,[VAR3] ) + 0x10);\n    do {\n      lVar14 = (long)*(int *)(CONCAT71(in_register_00000081,[VAR5] ) + 4);\n      lVar10 = (long)*(int *)(CONCAT71(in_register_00000031,[VAR2] ) + 4 + lVar11 * 8);\n      lVar12 = (long)*(int *)(CONCAT71(in_register_00000031,[VAR2] ) + lVar11 * 8);\n      lVar4 = (long)*(int *)CONCAT71(in_register_00000009,[VAR4] );\n      lVar9 = (long)((int *)CONCAT71(in_register_00000009,[VAR4] ))[1];\n      iVar5 = (int)((lVar12 * lVar4 - lVar10 * lVar9) + 0x20000000 >> 0x1e);\n      iVar1 = (int)(((long)*piVar6 * (long)*(int *)CONCAT71(in_register_00000081,[VAR5] ) -\n                    piVar6[1] * lVar14) + 0x20000000 >> 0x1e) -\n              (int)(iVar5 * lVar7 + 0x40000000 >> 0x1f);\n      iVar8 = (int)(lVar9 * lVar12 + 0x20000000 + lVar4 * lVar10 >> 0x1e);\n      iVar13 = (int)(*piVar6 * lVar14 + 0x20000000 +\n                     (long)*(int *)CONCAT71(in_register_00000081,[VAR5] ) * (long)piVar6[1] >> 0x1e) -\n               (int)(iVar8 * lVar7 + 0x40000000 >> 0x1f);\n      piVar6[6] = iVar5 + (int)(iVar1 * lVar7 + 0x40000000 >> 0x1f);\n      piVar6[7] = iVar8 + (int)(iVar13 * lVar7 + 0x40000000 >> 0x1f);\n      lVar9 = (long)*(int *)(CONCAT71(in_register_00000081,[VAR5] ) + 0xc);\n      lVar4 = (long)*(int *)(CONCAT71(in_register_00000081,[VAR5] ) + 8);\n      iVar5 = (int)((piVar6[0x48] * lVar4 - piVar6[0x49] * lVar9) + 0x20000000 >> 0x1e) -\n              (int)(iVar1 * lVar2 + 0x40000000 >> 0x1f);\n      iVar8 = (int)(piVar6[0x48] * lVar9 + 0x20000000 + lVar4 * piVar6[0x49] >> 0x1e) -\n              (int)(iVar13 * lVar2 + 0x40000000 >> 0x1f);\n      piVar6[0x50] = iVar1 + (int)(iVar5 * lVar2 + 0x40000000 >> 0x1f);\n      piVar6[0x51] = iVar13 + (int)(iVar8 * lVar2 + 0x40000000 >> 0x1f);\n      lVar9 = (long)*(int *)(CONCAT71(in_register_00000081,[VAR5] ) + 0x10);\n      lVar10 = (long)*(int *)(CONCAT71(in_register_00000081,[VAR5] ) + 0x14);\n      lVar4 = (long)((int)((piVar6[0x90] * lVar9 - piVar6[0x91] * lVar10) + 0x20000000 >> 0x1e) -\n                    (int)(iVar5 * lVar3 + 0x40000000 >> 0x1f));\n      piVar6[0x9a] = iVar5 + (int)(lVar3 * lVar4 + 0x40000000 >> 0x1f);\n      lVar9 = (long)((int)(piVar6[0x90] * lVar10 + 0x20000000 + lVar9 * piVar6[0x91] >> 0x1e) -\n                    (int)(iVar8 * lVar3 + 0x40000000 >> 0x1f));\n      piVar6[0x9b] = iVar8 + (int)(lVar3 * lVar9 + 0x40000000 >> 0x1f);\n      *(int *)(CONCAT71(in_register_00000039,[VAR1] ) + lVar11 * 8) =\n           (int)((ulong)(lVar4 * *(int *)(CONCAT71(in_register_00000089,[VAR6] ) + lVar11 * 4) + 0x8000\n                        ) >> 0x10);\n      *(int *)(CONCAT71(in_register_00000039,[VAR1] ) + 4 + lVar11 * 8) =\n           (int)((ulong)(*(int *)(CONCAT71(in_register_00000089,[VAR6] ) + lVar11 * 4) * lVar9 + 0x8000\n                        ) >> 0x10);\n      lVar11 = lVar11 + 1;\n      piVar6 = piVar6 + 2;\n    } while ((ulong)([VAR8] - 1) + 1 != lVar11);\n  }\n  return;\n}", "answer": {"VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "VAR5": "param_5", "VAR6": "param_6", "FUNC1": "FUN_00eea610", "TYPE3": "undefined", "VAR14": "local_60", "TYPE2": "undefined", "TYPE5": "undefined", "VAR12": "local_50", "TYPE4": "undefined", "VAR13": "local_58", "TYPE7": "undefined4", "TYPE6": "undefined", "TYPE9": "undefined8", "TYPE8": "undefined4", "VAR7": "param_7", "TYPE11": "undefined8", "VAR8": "param_8", "TYPE12": "undefined8", "VAR9": "local_38", "TYPE10": "undefined8", "VAR10": "local_40", "VAR11": "local_48", "TYPE1": "undefined", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOVSXD RAX,dword ptr [RSP + 0x38]\nMOV qword ptr [RSP + -0x18],RCX\nMOV ECX,dword ptr [RSP + 0x40]\nMOV qword ptr [RSP + -0x28],RDI\nMOV qword ptr [RSP + -0x20],RSI\nMOV qword ptr [RSP + -0x10],R9\nIMUL RBP,RAX,0x53625b00\nIMUL RBX,RAX,0x4848af00\nIMUL RAX,RAX,0x3ea94d00\nADD RBP,0x20000000\nADD RBX,0x20000000\nSAR RBP,0x1e\nADD RAX,0x20000000\nSAR RBX,0x1e\nSAR RAX,0x1e\nTEST ECX,ECX\nMOV qword ptr [RSP + -0x30],RAX\nJLE 0x00eea912\nLEA EAX,[RCX + -0x1]\nMOVSXD RBP,EBP\nMOVSXD RBX,EBX\nADD RDX,0x10\nXOR R9D,R9D\nADD RAX,0x1\nMOV qword ptr [RSP + -0x8],RAX\nNOP word ptr [RAX + RAX*0x1]\nMOV RCX,qword ptr [RSP + -0x20]\nMOV RSI,qword ptr [RSP + -0x18]\nMOVSXD R12,dword ptr [RDX + 0x4]\nMOVSXD R13,dword ptr [R8 + 0x4]\nMOVSXD RDI,dword ptr [RCX + R9*0x8 + 0x4]\nMOVSXD R10,dword ptr [RCX + R9*0x8]\nMOVSXD RAX,dword ptr [RSI]\nMOVSXD RSI,dword ptr [RSI + 0x4]\nMOV RCX,R10\nMOV R11,RDI\nIMUL R11,RSI\nIMUL RCX,RAX\nIMUL RSI,R10\nSUB RCX,R11\nMOVSXD R11,dword ptr [RDX]\nIMUL RAX,RDI\nMOVSXD RDI,dword ptr [R8]\nADD RCX,0x20000000\nSAR RCX,0x1e\nLEA R10,[RSI + RAX*0x1 + 0x20000000]\nMOV RAX,R11\nMOV RSI,R12\nIMUL RSI,R13\nIMUL RAX,RDI\nSAR R10,0x1e\nIMUL RDI,R12\nMOVSXD R12,dword ptr [RDX + 0x120]\nSUB RAX,RSI\nMOVSXD RSI,ECX\nIMUL RSI,RBP\nADD RAX,0x20000000\nSAR RAX,0x1e\nIMUL R11,R13\nMOVSXD R13,dword ptr [RDX + 0x124]\nADD RSI,0x40000000\nSAR RSI,0x1f\nSUB EAX,ESI\nMOVSXD RSI,R10D\nLEA R11,[R11 + RDI*0x1 + 0x20000000]\nIMUL RSI,RBP\nMOV R15,R13\nSAR R11,0x1e\nADD RSI,0x40000000\nSAR RSI,0x1f\nSUB R11D,ESI\nMOVSXD RSI,EAX\nMOV RDI,RSI\nIMUL RDI,RBP\nADD RDI,0x40000000\nSAR RDI,0x1f\nADD ECX,EDI\nMOVSXD RDI,R11D\nMOV dword ptr [RDX + 0x18],ECX\nMOV RCX,RDI\nIMUL RCX,RBP\nADD RCX,0x40000000\nSAR RCX,0x1f\nADD R10D,ECX\nMOV RCX,R12\nMOV dword ptr [RDX + 0x1c],R10D\nMOVSXD R14,dword ptr [R8 + 0xc]\nMOVSXD R10,dword ptr [R8 + 0x8]\nIMUL RCX,R10\nIMUL R15,R14\nIMUL RSI,RBX\nSUB RCX,R15\nIMUL R12,R14\nADD RCX,0x20000000\nADD RSI,0x40000000\nIMUL R10,R13\nSAR RSI,0x1f\nSAR RCX,0x1e\nIMUL RDI,RBX\nSUB ECX,ESI\nMOVSXD R13,dword ptr [RDX + 0x244]\nLEA RSI,[R12 + R10*0x1 + 0x20000000]\nMOVSXD R10,ECX\nMOVSXD R12,dword ptr [RDX + 0x240]\nADD RDI,0x40000000\nMOV R15,R13\nSAR RDI,0x1f\nSAR RSI,0x1e\nSUB ESI,EDI\nMOV RDI,R10\nIMUL RDI,RBX\nADD RDI,0x40000000\nSAR RDI,0x1f\nADD EAX,EDI\nMOVSXD RDI,ESI\nMOV dword ptr [RDX + 0x140],EAX\nMOV RAX,RDI\nIMUL RAX,RBX\nADD RAX,0x40000000\nSAR RAX,0x1f\nADD R11D,EAX\nMOV RAX,R12\nMOV dword ptr [RDX + 0x144],R11D\nMOVSXD R11,dword ptr [R8 + 0x10]\nMOVSXD R14,dword ptr [R8 + 0x14]\nIMUL RAX,R11\nIMUL R15,R14\nSUB RAX,R15\nMOV R15,qword ptr [RSP + -0x30]\nADD RAX,0x20000000\nSAR RAX,0x1e\nIMUL R10,R15\nADD R10,0x40000000\nSAR R10,0x1f\nSUB EAX,R10D\nMOV R10,R15\nADD RDX,0x8\nCDQE\nIMUL R10,RAX\nIMUL R12,R14\nIMUL R11,R13\nADD R10,0x40000000\nSAR R10,0x1f\nIMUL RDI,R15\nADD ECX,R10D\nMOV dword ptr [RDX + 0x260],ECX\nLEA RCX,[R12 + R11*0x1 + 0x20000000]\nSAR RCX,0x1e\nADD RDI,0x40000000\nSAR RDI,0x1f\nSUB ECX,EDI\nMOVSXD RCX,ECX\nIMUL R15,RCX\nMOV RDI,R15\nADD RDI,0x40000000\nSAR RDI,0x1f\nADD ESI,EDI\nMOV RDI,qword ptr [RSP + -0x10]\nMOV dword ptr [RDX + 0x264],ESI\nMOVSXD RSI,dword ptr [RDI + R9*0x4]\nIMUL RAX,RSI\nMOV RSI,qword ptr [RSP + -0x28]\nADD RAX,0x8000\nSAR RAX,0x10\nMOV dword ptr [RSI + R9*0x8],EAX\nMOVSXD RAX,dword ptr [RDI + R9*0x4]\nIMUL RAX,RCX\nADD RAX,0x8000\nSAR RAX,0x10\nMOV dword ptr [RSI + R9*0x8 + 0x4],EAX\nADD R9,0x1\nCMP qword ptr [RSP + -0x8],R9\nJNZ 0x00eea698\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "248": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  int iVar2;\n  int *p;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  iVar1 = [FUNC2] ((BIGNUM *)[VAR3] );\n  iVar1 = iVar1 + 1;\n  p = (int *)[FUNC6] ((int)((long)iVar1 << 2),\"crypto/bn/bn_gf2m.c\",0x3d5);\n  if (p == (int *)0x0) {\n    [FUNC4] ();\n    [FUNC9] (\"crypto/bn/bn_gf2m.c\",0x3d7,\"BN_GF2m_mod_sqrt\");\n    [FUNC5] (3,0xc0100,(char *)0x0);\n    iVar2 = 0;\n  }\n  else {\n    iVar2 = [FUNC3] ([VAR3] ,p,iVar1);\n    if ((iVar2 == 0) || (iVar1 < iVar2)) {\n      [FUNC4] ();\n      [FUNC9] (\"crypto/bn/bn_gf2m.c\",0x3dc,\"BN_GF2m_mod_sqrt\");\n      [FUNC5] (3,0x6a,(char *)0x0);\n    }\n    else {\n      iVar2 = [FUNC8] ([VAR1] ,[VAR2] ,p,[VAR4] );\n    }\n    [FUNC7] (p);\n  }\n  return iVar2;\n}", "answer": {"VAR1": "r", "VAR2": "a", "VAR3": "p", "VAR4": "ctx", "VAR5": "max", "VAR6": "arr", "FUNC2": "BN_num_bits", "FUNC3": "BN_GF2m_poly2arr", "FUNC1": "BN_GF2m_mod_sqrt", "FUNC6": "FUNC1", "TYPE3": "BIGNUM *", "FUNC7": "FUNC1", "TYPE2": "BIGNUM *", "FUNC4": "ERR_new", "TYPE5": "int", "FUNC5": "ERR_set_error", "TYPE4": "BN_CTX *", "TYPE6": "int *", "FUNC8": "BN_GF2m_mod_sqrt_arr", "FUNC9": "ERR_set_debug", "TYPE1": "BIGNUM *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R12,RDI\nMOV R13,RSI\nMOV RBP,RDX\nMOV R14,RCX\nMOV RDI,RDX\nCALL 0x0007de2b\nLEA EBX,[RAX + 0x1]\nMOVSXD RDI,EBX\nSHL RDI,0x2\nMOV EDX,0x3d5\nLEA RSI,[0x2bbdc1]\nCALL 0x000b1a8a\nTEST RAX,RAX\nJZ 0x0026a832\nMOV R15,RAX\nMOV EDX,EBX\nMOV RSI,RAX\nMOV RDI,RBP\nCALL 0x00269e05\nMOV EBP,EAX\nTEST EAX,EAX\nJZ 0x0026a86f\nCMP EBX,EAX\nJL 0x0026a86f\nMOV RCX,R14\nMOV RDX,R15\nMOV RSI,R13\nMOV RDI,R12\nCALL 0x00269972\nMOV EBP,EAX\nJMP 0x0026a8a5\nCALL 0x00090d64\nLEA RDX,[0x2bbe20]\nMOV ESI,0x3d7\nLEA RDI,[0x2bbdc1]\nCALL 0x00090e71\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0x3\nMOV EAX,0x0\nCALL 0x00091188\nMOV EBP,0x0\nJMP 0x0026a8b9\nCALL 0x00090d64\nLEA RDX,[0x2bbe20]\nMOV ESI,0x3dc\nLEA RDI,[0x2bbdc1]\nCALL 0x00090e71\nMOV EDX,0x0\nMOV ESI,0x6a\nMOV EDI,0x3\nMOV EAX,0x0\nCALL 0x00091188\nMOV EDX,0x3e2\nLEA RSI,[0x2bbdc1]\nMOV RDI,R15\nCALL 0x000b1acb\nMOV EAX,EBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "249": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  char *__dest;\n  [TYPE3] [VAR3] ;\n  \n  if ([VAR2] == 0xffffffffffffffff) {\n    [FUNC5] (1,\"Possible integer overflow in memory allocation (1 * %zu + 1)\",0xffffffffffffffff);\n  }\n  __dest = (char *)[FUNC3] ([VAR2] + 1);\n  if (__dest != (char *)0x0) {\n    if ([VAR2] != 0) {\n      [FUNC2] (__dest,[VAR1] ,[VAR2] );\n    }\n    __dest[VAR2] = '\\0';\n    return __dest;\n  }\n  [FUNC4] ();\n}", "answer": {"VAR1": "s", "VAR2": "length", "VAR3": "p", "FUNC2": "memcpy", "FUNC3": "malloc", "FUNC1": "zend_strndup", "TYPE3": "char *", "TYPE2": "size_t", "FUNC4": "zend_out_of_memory", "FUNC5": "zend_error_noreturn", "TYPE1": "char *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nCMP RSI,-0x1\nJZ 0x0038d4d2\nMOV R12,RDI\nMOV RBX,RSI\nLEA RDI,[RSI + 0x1]\nCALL 0x000facc0\nMOV RBP,RAX\nTEST RAX,RAX\nJZ 0x0038d4ef\nTEST RBX,RBX\nJZ 0x0038d4c5\nMOV RDX,RBX\nMOV RSI,R12\nMOV RDI,RAX\nCALL 0x000fa320\nMOV byte ptr [RBP + RBX*0x1],0x0\nMOV RAX,RBP\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDX,-0x1\nLEA RSI,[0xd29a60]\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x003b6cd3\nCALL 0x0038892f\n"}, "250": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC3] ((BIGNUM *)[VAR5] ,(BIGNUM *)[VAR6] );\n  if (iVar1 >= 0) {\n    [FUNC2] ((char *)0x0,[VAR1] ,[VAR2] ,\"BIGNUM\",[VAR3] ,[VAR4] ,\"<\",[VAR5] ,[VAR6] );\n  }\n  return (uint)(iVar1 < 0);\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "s1", "VAR4": "s2", "VAR5": "t1", "VAR6": "t2", "FUNC2": "test_fail_bignum_message", "FUNC3": "BN_cmp", "FUNC1": "test_BN_lt", "TYPE3": "char *", "TYPE2": "int", "TYPE5": "BIGNUM *", "TYPE4": "char *", "TYPE6": "BIGNUM *", "TYPE1": "char *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R12,RDI\nMOV R13D,ESI\nMOV R14,RDX\nMOV R15,RCX\nMOV RBX,R8\nMOV RBP,R9\nMOV RSI,R9\nMOV RDI,R8\nCALL 0x0007a6ed\nMOV EDX,0x1\nTEST EAX,EAX\nJS 0x00069bcd\nSUB RSP,0x8\nPUSH RBP\nPUSH RBX\nLEA RAX,[0x2614d9]\nPUSH RAX\nMOV R9,R15\nMOV R8,R14\nLEA RCX,[0x282c28]\nMOV EDX,R13D\nMOV RSI,R12\nMOV EDI,0x0\nCALL 0x0006d6d7\nADD RSP,0x20\nMOV EDX,0x0\nMOV EAX,EDX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "251": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  char *pcVar2;\n  char *pcVar3;\n  size_t sVar4;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  *[VAR3] = (char *)0x0;\n  *[VAR4] = (char *)0x0;\n  pcVar2 = [FUNC6] ([VAR2] ,(int)*[VAR1] );\n  if ((pcVar2 != (char *)0x0) && (pcVar2 = [VAR1] + 1, *pcVar2 != '\\0')) {\n    pcVar3 = [FUNC6] (pcVar2,0x2f);\n    if (pcVar3 == (char *)0x0) {\n      sVar4 = [FUNC3] (pcVar2);\n      iVar1 = (int)sVar4;\n    }\n    else {\n      iVar1 = (int)pcVar3 - (int)pcVar2;\n    }\n    [VAR6] = iVar1 + 1;\n    if ([VAR6] == 1) {\n      *[VAR3] = (char *)0x0;\n    }\n    else {\n      pcVar3 = (char *)[FUNC4] (1,(long)[VAR6] );\n      *[VAR3] = pcVar3;\n      if (*[VAR3] == (char *)0x0) {\n        return 0xc;\n      }\n      [FUNC5] (*[VAR3] ,pcVar2,(long)[VAR6] );\n      (*[VAR3] )[(long)[VAR6] + -1] = '\\0';\n    }\n    [VAR7] = pcVar2 + (long)[VAR6] + -1;\n    if (*[VAR7] == '/') {\n      [VAR7] = [VAR7] + 1;\n    }\n    if (*[VAR7] != '\\0') {\n      pcVar2 = [FUNC2] ([VAR7] );\n      *[VAR4] = pcVar2;\n      if (*[VAR4] == (char *)0x0) {\n        [FUNC7] (*[VAR3] );\n        return 0xc;\n      }\n    }\n  }\n  return 0;\n}", "answer": {"VAR1": "file", "VAR2": "pfx", "VAR3": "user", "VAR4": "rest", "VAR5": "p", "VAR6": "len", "FUNC2": "strdup", "FUNC3": "strlen", "FUNC1": "split_shortcut", "FUNC6": "strchr", "TYPE3": "char * *", "FUNC7": "free", "TYPE2": "char *", "FUNC4": "calloc", "TYPE5": "char *", "FUNC5": "memcpy", "TYPE4": "char * *", "TYPE7": "char *", "TYPE6": "int", "TYPE9": "char * *", "TYPE8": "char *", "VAR7": "file-local", "VAR8": "pfx-local", "VAR9": "user-local", "TYPE10": "char * *", "VAR10": "rest-local", "TYPE1": "char *"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nSUB RSP,0x30\nMOV qword ptr [RBP + -0x18],RDI\nMOV qword ptr [RBP + -0x20],RSI\nMOV qword ptr [RBP + -0x28],RDX\nMOV qword ptr [RBP + -0x30],RCX\nMOV RAX,qword ptr [RBP + -0x28]\nMOV qword ptr [RAX],0x0\nMOV RAX,qword ptr [RBP + -0x30]\nMOV qword ptr [RAX],0x0\nMOV RAX,qword ptr [RBP + -0x18]\nMOVZX EAX,byte ptr [RAX]\nMOVSX EDX,AL\nMOV RAX,qword ptr [RBP + -0x20]\nMOV ESI,EDX\nMOV RDI,RAX\nCALL 0x000238f0\nTEST RAX,RAX\nJNZ 0x0006f6f8\nMOV EAX,0x0\nJMP 0x0006f833\nADD qword ptr [RBP + -0x18],0x1\nMOV RAX,qword ptr [RBP + -0x18]\nMOVZX EAX,byte ptr [RAX]\nTEST AL,AL\nJNZ 0x0006f712\nMOV EAX,0x0\nJMP 0x0006f833\nMOV RAX,qword ptr [RBP + -0x18]\nMOV ESI,0x2f\nMOV RDI,RAX\nCALL 0x000238f0\nMOV qword ptr [RBP + -0x8],RAX\nCMP qword ptr [RBP + -0x8],0x0\nJZ 0x0006f744\nMOV RDX,qword ptr [RBP + -0x8]\nMOV RAX,qword ptr [RBP + -0x18]\nSUB RDX,RAX\nMOV RAX,RDX\nADD EAX,0x1\nMOV dword ptr [RBP + -0xc],EAX\nJMP 0x0006f756\nMOV RAX,qword ptr [RBP + -0x18]\nMOV RDI,RAX\nCALL 0x00023640\nADD EAX,0x1\nMOV dword ptr [RBP + -0xc],EAX\nCMP dword ptr [RBP + -0xc],0x1\nJNZ 0x0006f769\nMOV RAX,qword ptr [RBP + -0x28]\nMOV qword ptr [RAX],0x0\nJMP 0x0006f7ce\nMOV EAX,dword ptr [RBP + -0xc]\nCDQE\nMOV RSI,RAX\nMOV EDI,0x1\nCALL 0x00024390\nMOV RDX,RAX\nMOV RAX,qword ptr [RBP + -0x28]\nMOV qword ptr [RAX],RDX\nMOV RAX,qword ptr [RBP + -0x28]\nMOV RAX,qword ptr [RAX]\nTEST RAX,RAX\nJNZ 0x0006f79b\nMOV EAX,0xc\nJMP 0x0006f833\nMOV EAX,dword ptr [RBP + -0xc]\nMOVSXD RDX,EAX\nMOV RAX,qword ptr [RBP + -0x28]\nMOV RAX,qword ptr [RAX]\nMOV RCX,qword ptr [RBP + -0x18]\nMOV RSI,RCX\nMOV RDI,RAX\nCALL 0x000247e0\nMOV RAX,qword ptr [RBP + -0x28]\nMOV RAX,qword ptr [RAX]\nMOV EDX,dword ptr [RBP + -0xc]\nMOVSXD RDX,EDX\nSUB RDX,0x1\nADD RAX,RDX\nMOV byte ptr [RAX],0x0\nMOV EAX,dword ptr [RBP + -0xc]\nCDQE\nSUB RAX,0x1\nADD qword ptr [RBP + -0x18],RAX\nMOV RAX,qword ptr [RBP + -0x18]\nMOVZX EAX,byte ptr [RAX]\nCMP AL,0x2f\nJNZ 0x0006f7eb\nADD qword ptr [RBP + -0x18],0x1\nMOV RAX,qword ptr [RBP + -0x18]\nMOVZX EAX,byte ptr [RAX]\nTEST AL,AL\nJZ 0x0006f82e\nMOV RAX,qword ptr [RBP + -0x18]\nMOV RDI,RAX\nCALL 0x000262d0\nMOV RDX,RAX\nMOV RAX,qword ptr [RBP + -0x30]\nMOV qword ptr [RAX],RDX\nMOV RAX,qword ptr [RBP + -0x30]\nMOV RAX,qword ptr [RAX]\nTEST RAX,RAX\nJNZ 0x0006f82e\nMOV RAX,qword ptr [RBP + -0x28]\nMOV RAX,qword ptr [RAX]\nMOV RDI,RAX\nCALL 0x000228f0\nMOV EAX,0xc\nJMP 0x0006f833\nMOV EAX,0x0\nLEAVE\nRET\n"}, "252": {"funcbody": "/* remote_target::trace_stop() */\nvoid remote_target::[FUNC1] (void)\n{\n  byte *pbVar1;\n  byte **ppbVar2;\n  char *pcVar3;\n  undefined in_CL;\n  long lVar4;\n  undefined extraout_DL;\n  undefined extraout_DL_00;\n  undefined uVar5;\n  byte *pbVar6;\n  remote_target *in_RDI;\n  byte *pbVar7;\n  undefined in_R8B;\n  undefined in_R9B;\n  bool bVar8;\n  bool bVar9;\n  byte bVar10;\n  \n  bVar10 = 0;\n  ppbVar2 = (byte **)[FUNC5] ();\n  uVar5 = 0xc9;\n  [FUNC2] (in_RDI,\"QTStop\");\n  [FUNC6] ();\n  pbVar1 = *ppbVar2;\n  bVar8 = false;\n  bVar9 = *pbVar1 == 0;\n  if (bVar9) {\n    pcVar3 = (char *)[FUNC4] (\"Target does not support this command.\");\n    [FUNC3] (pcVar3,uVar5,extraout_DL,in_CL,in_R8B,in_R9B);\n  }\n  lVar4 = 3;\n  pbVar6 = pbVar1;\n  pbVar7 = (byte *)0x794f2c;\n  do {\n    if (lVar4 == 0) break;\n    lVar4 = lVar4 + -1;\n    bVar8 = *pbVar6 < *pbVar7;\n    bVar9 = *pbVar6 == *pbVar7;\n    pbVar6 = pbVar6 + (ulong)bVar10 * -2 + 1;\n    pbVar7 = pbVar7 + (ulong)bVar10 * -2 + 1;\n  } while (bVar9);\n  uVar5 = (undefined)lVar4;\n  if ((!bVar8 && !bVar9) == bVar8) {\n    return;\n  }\n  pcVar3 = (char *)[FUNC4] (\"Bogus reply from target: %s\");\n  [FUNC3] (pcVar3,(char)pbVar1,extraout_DL_00,uVar5,in_R8B,in_R9B);\n}", "answer": {"FUNC2": "putpkt", "FUNC3": "error", "FUNC1": "trace_stop", "FUNC6": "remote_get_noisy_reply", "FUNC4": "gettext", "FUNC5": "get_remote_state"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nCALL 0x00491a2e\nMOV RBP,RAX\nLEA RSI,[0x7b65c9]\nMOV RDI,RBX\nCALL 0x004947a6\nMOV RDI,RBX\nCALL 0x00494c34\nMOV RBX,qword ptr [RBP]\nCMP byte ptr [RBX],0x0\nJZ 0x00497aae\nMOV ECX,0x3\nLEA RDI,[0x794f2c]\nMOV RSI,RBX\nCMPSB.REPE RDI,RSI\nSETA AL\nSBB AL,0x0\nTEST AL,AL\nJNZ 0x00497ac7\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nLEA RDI,[0x7b8a68]\nCALL 0x000d0680\nMOV RDI,RAX\nMOV EAX,0x0\nCALL 0x006ddb33\nLEA RDI,[0x7b65ad]\nCALL 0x000d0680\nMOV RSI,RBX\nMOV RDI,RAX\nMOV EAX,0x0\nCALL 0x006ddb33\n"}, "253": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] )\n{\n  uint uVar1;\n  [TYPE2] [VAR2] ;\n  \n  uVar1 = [FUNC2] ([VAR1] );\n  if (uVar1 != 0) {\n    if (uVar1 == 5) {\n      uVar1 = [VAR1] ->ex_nscert >> 2 & 1;\n    }\n    else {\n      uVar1 = 1;\n    }\n  }\n  return uVar1;\n}", "answer": {"VAR1": "x", "VAR2": "ca_ret", "FUNC2": "check_ca", "FUNC1": "check_ssl_ca", "TYPE2": "int", "TYPE1": "X509 *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCALL 0x001029a6\nTEST EAX,EAX\nJZ 0x00102a2a\nCMP EAX,0x5\nJZ 0x00102a2c\nMOV EAX,0x1\nPOP RBX\nRET\nMOV EAX,dword ptr [RBX + 0xf4]\nSHR EAX,0x2\nAND EAX,0x1\nJMP 0x00102a2a\n"}, "254": {"funcbody": "SCM [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  [TYPE5] [VAR5] ;\n  [TYPE1] *pTVar1;\n  \n  pTVar1 = ([TYPE1] *)[FUNC2] (0x20);\n  pTVar1[1] = [VAR2] ;\n  pTVar1[2] = [VAR3] ;\n  pTVar1[3] = [VAR4] ;\n  *pTVar1 = [VAR1] ;\n  return (SCM)pTVar1;\n}", "answer": {"VAR1": "car", "VAR2": "cbr", "VAR3": "ccr", "VAR4": "cdr", "VAR5": "z", "FUNC2": "GC_malloc", "FUNC1": "scm_double_cell", "TYPE3": "scm_t_bits", "TYPE2": "scm_t_bits", "TYPE5": "SCM", "TYPE4": "scm_t_bits", "TYPE1": "scm_t_bits"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV R13,RSI\nMOV R12,RDX\nMOV RBP,RCX\nMOV EDI,0x20\nCALL 0x00032c58\nMOV qword ptr [RAX + 0x8],R13\nMOV qword ptr [RAX + 0x10],R12\nMOV qword ptr [RAX + 0x18],RBP\nMOV qword ptr [RAX],RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\n"}, "255": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  uint uVar1;\n  int iVar2;\n  BIGNUM *b;\n  \n  uVar1 = [FUNC2] ([VAR1] );\n  if (uVar1 != 0) {\n    b = [FUNC4] ();\n    iVar2 = [FUNC3] ((BIGNUM *)[VAR1] ,b);\n    uVar1 = (uint)(0 < iVar2);\n  }\n  return uVar1;\n}", "answer": {"VAR1": "e", "FUNC2": "BN_is_odd", "FUNC3": "BN_cmp", "FUNC1": "ossl_rsa_check_public_exponent", "FUNC4": "BN_value_one", "TYPE1": "BIGNUM *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCALL 0x0007a8b8\nTEST EAX,EAX\nJNZ 0x001cd23f\nPOP RBX\nRET\nCALL 0x0007a184\nMOV RSI,RAX\nMOV RDI,RBX\nCALL 0x0007a402\nTEST EAX,EAX\nSETG AL\nMOVZX EAX,AL\nJMP 0x001cd23d\n"}, "256": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  bfd *pbVar1;\n  \n  if (bfd_last_cache == (bfd *)0x0) {\n    [VAR1] ->lru_next = [VAR1] ;\n    [VAR1] ->lru_prev = [VAR1] ;\n  }\n  else {\n    [VAR1] ->lru_next = bfd_last_cache;\n    pbVar1 = bfd_last_cache->lru_prev;\n    [VAR1] ->lru_prev = pbVar1;\n    pbVar1->lru_next = [VAR1] ;\n    [VAR1] ->lru_next->lru_prev = [VAR1] ;\n  }\n  bfd_last_cache = [VAR1] ;\n  return;\n}", "answer": {"VAR1": "abfd", "FUNC1": "insert", "TYPE1": "bfd *"}, "assembly": "MOV RAX,qword ptr [0x00343fb0]\nTEST RAX,RAX\nJZ 0x000c65c7\nMOV qword ptr [RDI + 0x28],RAX\nMOV RAX,qword ptr [RAX + 0x20]\nMOV qword ptr [RDI + 0x20],RAX\nMOV qword ptr [RAX + 0x28],RDI\nMOV RAX,qword ptr [RDI + 0x28]\nMOV qword ptr [RAX + 0x20],RDI\nMOV qword ptr [0x00343fb0],RDI\nRET\nMOV qword ptr [RDI + 0x28],RDI\nMOV qword ptr [RDI + 0x20],RDI\nJMP 0x000c65bf\n"}, "257": {"funcbody": "/* remote_target::upload_tracepoints(uploaded_tp**) */\nundefined8 __thiscall remote_target::[FUNC1] (remote_target *this,TYPE13 [VAR1] )\n{\n  char cVar1;\n  char *pcVar2;\n  char **ppcVar3;\n  \n  ppcVar3 = (char **)[FUNC5] ();\n  [FUNC4] (this,\"qTfP\");\n  [FUNC3] (this,(vector *)ppcVar3,false,(bool *)0x0);\n  pcVar2 = *ppcVar3;\n  cVar1 = *pcVar2;\n  while ((cVar1 != '\\0' && (cVar1 != 'l'))) {\n    [FUNC2] (pcVar2,[VAR1] );\n    [FUNC4] (this,\"qTsP\");\n    [FUNC3] (this,(vector *)ppcVar3,false,(bool *)0x0);\n    pcVar2 = *ppcVar3;\n    cVar1 = *pcVar2;\n  }\n  return 0;\n}", "answer": {"VAR1": "param_1", "FUNC2": "parse_tracepoint_definition", "FUNC3": "getpkt", "FUNC1": "upload_tracepoints", "FUNC4": "putpkt", "FUNC5": "get_remote_state", "TYPE1": "uploaded_tp * *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV R13,RSI\nCALL 0x00491a2e\nMOV RBP,RAX\nLEA RSI,[0x7b65d0]\nMOV RDI,RBX\nCALL 0x004947a6\nMOV ECX,0x0\nMOV EDX,0x0\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x00494854\nMOV RDI,qword ptr [RBP]\nMOVZX EAX,byte ptr [RDI]\nTEST AL,AL\nJZ 0x0049804c\nMOV R12,RBP\nCMP AL,0x6c\nJZ 0x0049804c\nLEA R14,[0x7b65d5]\nMOV RSI,R13\nCALL 0x0055dc80\nMOV RSI,R14\nMOV RDI,RBX\nCALL 0x004947a6\nMOV ECX,0x0\nMOV EDX,0x0\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x00494854\nMOV RDI,qword ptr [RBP]\nMOVZX EAX,byte ptr [RDI]\nTEST AL,AL\nJZ 0x0049804c\nCMP AL,0x6c\nJNZ 0x00498015\nMOV EAX,0x0\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\n"}, "258": {"funcbody": "_Bool [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  undefined8 uVar2;\n  [TYPE2] [VAR2] ;\n  long in_FS_OFFSET;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  long [VAR3] ;\n  \n  [VAR3] = *(long *)(in_FS_OFFSET + 0x28);\n  uVar2 = [FUNC3] (&[VAR5] ,&[VAR4] );\n  iVar1 = [FUNC2] ([VAR1] ,1,recfix_external,uVar2);\n  [FUNC4] (uVar2);\n  [FUNC5] (stderr,\"%s\",[VAR5] );\n  if ([VAR3] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1 == 0;\n  }\n  [FUNC6] ();\n}", "answer": {"VAR1": "db", "VAR2": "buf", "VAR3": "local_20", "VAR4": "errors_size", "VAR5": "errors", "FUNC2": "rec_int_check_db", "FUNC3": "rec_buf_new", "FUNC1": "recfix_check_database", "FUNC6": "__stack_chk_fail", "TYPE3": "undefined8", "TYPE2": "rec_buf_t", "FUNC4": "rec_buf_close", "TYPE5": "char *", "FUNC5": "rpl_fprintf", "TYPE4": "size_t", "TYPE1": "rec_db_t"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV RBP,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nLEA RSI,[RSP + 0x10]\nLEA RDI,[RSP + 0x8]\nCALL 0x00003f80\nMOV RBX,RAX\nMOVZX EDX,byte ptr [0x00220010]\nMOV RCX,RAX\nMOV ESI,0x1\nMOV RDI,RBP\nCALL 0x00004090\nMOV EBP,EAX\nMOV RDI,RBX\nCALL 0x00003f00\nMOV RDX,qword ptr [RSP + 0x8]\nLEA RSI,[0x1b198]\nMOV RDI,qword ptr [0x002200a0]\nMOV EAX,0x0\nCALL 0x00016d7f\nTEST EBP,EBP\nSETZ AL\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0000521c\nADD RSP,0x28\nPOP RBX\nPOP RBP\nRET\nCALL 0x00003eb0\n"}, "259": {"funcbody": "void [FUNC1] (long param_1)\n{\n  long lVar1;\n  ulong uVar2;\n  undefined8 *puVar3;\n  \n  lVar1 = *(long *)(param_1 + 0x20);\n  *(undefined8 *)(lVar1 + 0x4a0) = 0;\n  *(undefined8 *)(\"_ITM_deregisterTMCloneTable\" + lVar1 + 0xd) = 0;\n  puVar3 = (undefined8 *)(lVar1 + 0x4a8U & 0xfffffffffffffff8);\n  uVar2 = (ulong)(((int)lVar1 - (int)puVar3) + 0x24a0U >> 3);\n  for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  *(undefined8 *)((long)&__DT_RELA[0x91].r_addend + lVar1) = 0;\n  *(undefined8 *)((long)&__DT_RELA[0x151].r_info + lVar1) = 0;\n  puVar3 = (undefined8 *)(lVar1 + 0x48c8U & 0xfffffffffffffff8);\n  uVar2 = (ulong)(((int)lVar1 - (int)puVar3) + 0x5ac0U >> 3);\n  for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + 1;\n  }\n  *(undefined4 *)(lVar1 + 0x440) = 0;\n  *(undefined4 *)((long)&__DT_RELA[0x2e7].r_offset + lVar1 + 4) = 0;\n  return;\n}", "answer": {"FUNC1": "FUN_00894530"}, "assembly": "MOV RDX,qword ptr [RDI + 0x20]\nXOR EAX,EAX\nLEA RDI,[RDX + 0x4a8]\nMOV ECX,EDX\nMOV qword ptr [RDX + 0x4a0],0x0\nMOV qword ptr [RDX + 0x2498],0x0\nAND RDI,-0x8\nSUB ECX,EDI\nADD ECX,0x24a0\nSHR ECX,0x3\nSTOSQ.REP RDI\nLEA RDI,[RDX + 0x48c8]\nMOV ECX,EDX\nMOV qword ptr [RDX + 0x48c0],0x0\nMOV qword ptr [RDX + 0x5ab8],0x0\nAND RDI,-0x8\nSUB ECX,EDI\nADD ECX,0x5ac0\nSHR ECX,0x3\nSTOSQ.REP RDI\nMOV dword ptr [RDX + 0x440],0x0\nMOV dword ptr [RDX + 0x80c4],0x0\nRET\n"}, "260": {"funcbody": "/* Local variable data:collected_names_st *[RSI:8] conflicts with parameter, skipped. */\nvoid [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  \n  if ((*(byte *)((long)[VAR2] + 8) & 1) != 0) {\n    return;\n  }\n  *(byte *)((long)[VAR2] + 8) = *(byte *)((long)[VAR2] + 8) | 1;\n  iVar1 = [FUNC2] (*[VAR2] ,[VAR1] );\n  if (0 < iVar1) {\n    *(byte *)((long)[VAR2] + 8) = *(byte *)((long)[VAR2] + 8) & 0xfe;\n  }\n  return;\n}", "answer": {"VAR1": "name", "VAR2": "arg", "FUNC2": "OPENSSL_sk_push", "FUNC1": "collect_name", "TYPE2": "void *", "TYPE1": "char *"}, "assembly": "TEST byte ptr [RSI + 0x8],0x1\nJZ 0x001a7077\nRET\nPUSH RBX\nMOV RBX,RSI\nMOV RSI,RDI\nOR byte ptr [RBX + 0x8],0x1\nMOV RDI,qword ptr [RBX]\nCALL 0x000cdaae\nTEST EAX,EAX\nJLE 0x001a7092\nAND byte ptr [RBX + 0x8],0xfe\nPOP RBX\nRET\n"}, "261": {"funcbody": "char * [FUNC1] (char *param_1)\n{\n  int iVar1;\n  long lVar2;\n  char *pcVar3;\n  \n  lVar2 = [FUNC3] (0x1000);\n  if (lVar2 != 0) {\n    iVar1 = [FUNC2] (lVar2,0x1000);\n    if (((iVar1 == 1) && (pcVar3 = (char *)[FUNC5] (param_1,lVar2), pcVar3 != (char *)0x0)) &&\n       (*pcVar3 != '\\0')) {\n      param_1 = pcVar3;\n    }\n    [FUNC4] (lVar2);\n  }\n  return param_1;\n}", "answer": {"FUNC2": "FUN_00165836", "FUNC3": "FUN_00046958", "FUNC1": "FUN_000d631f", "FUNC4": "FUN_00046a85", "FUNC5": "FUN_000d62af"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV EDI,0x1000\nCALL 0x00046958\nMOV RBX,RAX\nMOV RAX,RBP\nTEST RBX,RBX\nJZ 0x000d635a\nMOV ESI,0x1000\nMOV RDI,RBX\nCALL 0x00165836\nCMP EAX,0x1\nJZ 0x000d6361\nMOV RDI,RBX\nCALL 0x00046a85\nMOV RAX,RBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RSI,RBX\nMOV RDI,RBP\nCALL 0x000d62af\nTEST RAX,RAX\nJZ 0x000d634f\nCMP byte ptr [RAX],0x0\nCMOVNZ RBP,RAX\nJMP 0x000d634f\n"}, "262": {"funcbody": "EVP_CIPHER * [FUNC1] (void)\n{\n  EVP_CIPHER *ptr;\n  TYPE17 [VAR1] ;\n  CRYPTO_RWLOCK *pCVar1;\n  \n  ptr = (EVP_CIPHER *)[FUNC2] (0x100,\"crypto/evp/evp_enc.c\",0x59c);\n  if (ptr != (EVP_CIPHER *)0x0) {\n    pCVar1 = [FUNC3] ();\n    ptr->lock = pCVar1;\n    if (pCVar1 == (CRYPTO_RWLOCK *)0x0) {\n      [FUNC4] (ptr);\n      ptr = (EVP_CIPHER *)0x0;\n    }\n    else {\n      ptr->refcnt = 1;\n    }\n  }\n  return ptr;\n}", "answer": {"VAR1": "cipher", "FUNC2": "CRYPTO_zalloc", "FUNC3": "CRYPTO_THREAD_lock_new", "FUNC1": "evp_cipher_new", "FUNC4": "CRYPTO_free", "TYPE1": "EVP_CIPHER *"}, "assembly": "PUSH RBX\nMOV EDX,0x59c\nLEA RSI,[0x26dfc2]\nMOV EDI,0x100\nCALL 0x000a97d6\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x0009232e\nCALL 0x000b0519\nMOV qword ptr [RBX + 0x88],RAX\nTEST RAX,RAX\nJZ 0x00092333\nMOV dword ptr [RBX + 0x80],0x1\nMFENCE\nMOV RAX,RBX\nPOP RBX\nRET\nMOV EDX,0x5a1\nLEA RSI,[0x26dfc2]\nMOV RDI,RBX\nCALL 0x000a96fe\nMOV EBX,0x0\nJMP 0x0009232e\n"}, "263": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  if ([VAR6] < [VAR5] ) {\n    return 1;\n  }\n  [FUNC2] ((char *)0x0,[VAR1] ,[VAR2] ,\"int\",[VAR3] ,[VAR4] ,\">\",\"[%d] compared to [%d]\",(ulong)(uint)[VAR5] ,\n        (ulong)(uint)[VAR6] );\n  return 0;\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "s1", "VAR4": "s2", "VAR5": "t1", "VAR6": "t2", "FUNC2": "test_fail_message", "FUNC1": "test_int_gt", "TYPE3": "char *", "TYPE2": "int", "TYPE5": "int", "TYPE4": "char *", "TYPE6": "int", "TYPE1": "char *"}, "assembly": "MOV EAX,0x1\nCMP R8D,R9D\nJLE 0x00077965\nRET\nSUB RSP,0x8\nMOV R10D,R9D\nMOV EAX,R8D\nMOV R9,RCX\nMOV R8,RDX\nMOV EDX,ESI\nPUSH R10\nPUSH RAX\nLEA RAX,[0x2785a0]\nPUSH RAX\nLEA RAX,[0x29e12b]\nPUSH RAX\nLEA RCX,[0x2785ca]\nMOV RSI,RDI\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x000770bc\nMOV EAX,0x0\nADD RSP,0x28\nRET\n"}, "264": {"funcbody": "int [FUNC1] (TYPE15 [VAR1] )\n{\n  if ([VAR1] != (TYPE15)0x0) {\n    [VAR1] ->data = (lhash_st_CONF_VALUE *)0x0;\n    [VAR1] ->flag_dollarid = 0;\n    [VAR1] ->flag_abspath = 0;\n    [VAR1] ->includedir = (char *)0x0;\n    [VAR1] ->libctx = (OSSL_LIB_CTX *)0x0;\n    [VAR1] ->meth = &default_method;\n    [VAR1] ->meth_data = CONF_type_default;\n  }\n  return (uint)([VAR1] != (TYPE15)0x0);\n}", "answer": {"VAR1": "conf", "FUNC1": "def_init_default", "TYPE1": "CONF *"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x0022ada5\nMOV qword ptr [RDI + 0x10],0x0\nMOV qword ptr [RDI + 0x18],0x0\nMOV qword ptr [RDI + 0x20],0x0\nMOV qword ptr [RDI + 0x28],0x0\nLEA RAX,[0x5842e0]\nMOV qword ptr [RDI],RAX\nLEA RAX,[0x2b8a20]\nMOV qword ptr [RDI + 0x8],RAX\nMOV EAX,0x1\nRET\n"}, "265": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  \n  if ([VAR3] != (TYPE30x0) {\n    iVar1 = [FUNC3] ([VAR1] ,[VAR3] ,1,[FUNC2] );\n    return iVar1;\n  }\n  return -1;\n}", "answer": {"VAR1": "sp", "VAR2": "name", "VAR3": "string", "FUNC2": "_nc_outch_sp", "FUNC3": "tputs_sp", "FUNC1": "_nc_putp_sp", "TYPE3": "char *", "TYPE2": "char *", "TYPE1": "SCREEN *"}, "assembly": "TEST RDX,RDX\nJZ 0x0001f1d0\nSUB RSP,0x8\nMOV RSI,RDX\nLEA RCX,[0x1ed49]\nMOV EDX,0x1\nCALL 0x0001ee82\nADD RSP,0x8\nRET\nMOV EAX,0xffffffff\nRET\n"}, "266": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  gchar *pgVar1;\n  \n  [FUNC2] ([VAR1] ->color_expiry);\n  pgVar1 = (gchar *)[FUNC5] ([VAR2] );\n  [VAR1] ->color_expiry = pgVar1;\n  if ([VAR3] != 0) {\n    [FUNC4] ([VAR1] );\n    [FUNC3] ([VAR1] );\n  }\n  return;\n}", "answer": {"VAR1": "ig", "VAR2": "color", "VAR3": "redraw", "FUNC2": "g_free", "FUNC3": "app_window_redraw_category_list", "FUNC1": "app_window_update_expiry_color", "TYPE3": "gboolean", "TYPE2": "GdkColor *", "FUNC4": "app_window_redraw_card_list", "FUNC5": "gdk_color_to_string", "TYPE1": "Ignuit *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV R12,RSI\nMOV EBP,EDX\nMOV RDI,qword ptr [RDI + 0x170]\nCALL 0x000089e8\nMOV RDI,R12\nCALL 0x00008100\nMOV qword ptr [RBX + 0x170],RAX\nTEST EBP,EBP\nJNZ 0x0000c73b\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,RBX\nCALL 0x0000b2ad\nMOV RDI,RBX\nCALL 0x0000a9c7\nJMP 0x0000c736\n"}, "267": {"funcbody": "_Bool [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  _Bool _Var1;\n  long lVar2;\n  TYPE49 [VAR4] ;\n  void *pvVar3;\n  TYPE38 [VAR3] ;\n  \n  if (*(long *)&[VAR2] ->field_0xd0 == 0) {\n    pvVar3 = [FUNC3] ([VAR1] ,0xe8);\n    if (pvVar3 == (void *)0x0) {\n      return false;\n    }\n    *(void **)&[VAR2] ->field_0xd0 = pvVar3;\n  }\n  pvVar3 = [VAR1] ->xvec->backend_data;\n  [VAR2] ->field_0x29 = [VAR2] ->field_0x29 & 0xfb | *(byte *)((long)pvVar3 + 1000) >> 2 & 4;\n  lVar2 = (**(code **)((long)pvVar3 + 0xa8))([VAR1] ,[VAR2] );\n  if (lVar2 != 0) {\n    *(undefined4 *)(*(long *)&[VAR2] ->field_0xd0 + 4) = *(undefined4 *)(lVar2 + 0x10);\n    *(undefined8 *)(*(long *)&[VAR2] ->field_0xd0 + 8) = *(undefined8 *)(lVar2 + 0x18);\n  }\n  _Var1 = [FUNC2] ([VAR1] ,[VAR2] );\n  return _Var1;\n}", "answer": {"VAR1": "abfd", "VAR2": "sec", "VAR3": "bed", "VAR4": "ssect", "FUNC2": "_bfd_generic_new_section_hook", "FUNC3": "bfd_zalloc", "FUNC1": "_bfd_elf_new_section_hook", "TYPE3": "elf_backend_data *", "TYPE2": "asection *", "TYPE4": "bfd_elf_special_section *", "TYPE1": "bfd *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV RBX,RSI\nCMP qword ptr [RSI + 0xd0],0x0\nJZ 0x000ea750\nMOV RAX,qword ptr [RBP + 0x8]\nMOV RCX,qword ptr [RAX + 0x378]\nMOVZX EAX,byte ptr [RCX + 0x3e8]\nSHR AL,0x2\nAND EAX,0x4\nMOV EDX,EAX\nMOVZX EAX,byte ptr [RBX + 0x29]\nAND EAX,0xfffffffb\nOR EAX,EDX\nMOV byte ptr [RBX + 0x29],AL\nMOV RSI,RBX\nMOV RDI,RBP\nCALL qword ptr [RCX + 0xa8]\nTEST RAX,RAX\nJZ 0x000ea73e\nMOV RDX,qword ptr [RBX + 0xd0]\nMOV ECX,dword ptr [RAX + 0x10]\nMOV dword ptr [RDX + 0x4],ECX\nMOV RDX,qword ptr [RBX + 0xd0]\nMOV RAX,qword ptr [RAX + 0x18]\nMOV qword ptr [RDX + 0x8],RAX\nMOV RSI,RBX\nMOV RDI,RBP\nCALL 0x000cc84d\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV ESI,0xe8\nCALL 0x000cbaf0\nMOV RDX,RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x000ea749\nMOV qword ptr [RBX + 0xd0],RDX\nJMP 0x000ea6eb\n"}, "268": {"funcbody": "void [FUNC1] (undefined [VAR1] ,undefined [VAR2] ,undefined [VAR3] ,undefined [VAR4] ,[TYPE5] [VAR5] ,\n          undefined [VAR6] ,int [VAR7] ,int [VAR8] ,int [VAR9] ,uint [VAR10] )\n{\n  long lVar1;\n  byte bVar2;\n  long lVar3;\n  long lVar4;\n  long lVar5;\n  long lVar6;\n  long lVar7;\n  long lVar8;\n  long lVar9;\n  undefined *puVar10;\n  int iVar11;\n  int iVar12;\n  int iVar13;\n  undefined7 in_register_00000009;\n  undefined7 in_register_00000011;\n  long lVar14;\n  long lVar15;\n  undefined7 in_register_00000031;\n  long lVar16;\n  undefined7 in_register_00000039;\n  ulong uVar17;\n  long lVar18;\n  undefined7 in_register_00000089;\n  ulong uVar19;\n  long lVar20;\n  [TYPE18] [VAR18] ;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  [TYPE15] [VAR15] ;\n  [TYPE14] [VAR14] ;\n  [TYPE13] [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  \n  puVar10 = PTR_DAT_01757fd0;\n  lVar3 = *(long *)CONCAT71(in_register_00000011,[VAR3] );\n  lVar4 = *(long *)CONCAT71(in_register_00000031,[VAR2] );\n  lVar5 = ((long *)CONCAT71(in_register_00000031,[VAR2] ))[1];\n  lVar6 = ((long *)CONCAT71(in_register_00000011,[VAR3] ))[1];\n  lVar7 = *(long *)CONCAT71(in_register_00000009,[VAR4] );\n  lVar8 = ((long *)CONCAT71(in_register_00000009,[VAR4] ))[1];\n  iVar11 = [VAR7] + 1 >> 1;\n  if (0 < iVar11) {\n    lVar14 = (ulong)([VAR10] & 7) * 8;\n    lVar15 = 0;\n    do {\n      iVar13 = *(short *)(lVar5 + lVar15 * 2) * [VAR8] +\n               (int)*(short *)(lVar4 + lVar15 * 2) * (0x1000 - [VAR8] ) >> 0x13;\n      iVar12 = *(short *)(lVar5 + 2 + lVar15 * 2) * [VAR8] +\n               (int)*(short *)(lVar4 + 2 + lVar15 * 2) * (0x1000 - [VAR8] ) >> 0x13;\n      lVar16 = (long)((*(short *)(lVar8 + lVar15) * [VAR9] +\n                       (int)*(short *)(lVar7 + lVar15) * (0x1000 - [VAR9] ) >> 0x13) + 0x200);\n      lVar9 = *(long *)(CONCAT71(in_register_00000039,[VAR1] ) + 0x2230 + lVar16 * 8);\n      uVar19 = (ulong)((uint)lVar15 & 7);\n      lVar1 = CONCAT71(in_register_00000039,[VAR1] ) +\n              (long)((int)*(short *)(lVar3 + lVar15) * (0x1000 - [VAR9] ) +\n                     *(short *)(lVar6 + lVar15) * [VAR9] >> 0x13) * 8;\n      lVar20 = (long)*(int *)(CONCAT71(in_register_00000039,[VAR1] ) + 0xe30 + lVar16 * 4) +\n               *(long *)((long)&__DT_RELA[0x106].r_offset + lVar1);\n      lVar1 = *(long *)((long)&__DT_RELA[0x2b0].r_addend + lVar1);\n      uVar17 = (ulong)((uint)lVar15 + 1 & 7);\n      bVar2 = (&DAT_012f7040)[uVar17 + lVar14];\n      lVar16 = (long)(int)((uint)(byte)puVar10[uVar17 + lVar14] + iVar12);\n      lVar18 = (long)(int)((uint)(byte)puVar10[uVar19 + lVar14] + iVar13);\n      *(char *)(CONCAT71(in_register_00000089,[VAR6] ) + lVar15) =\n           *(char *)(lVar20 + (int)(iVar13 + (uint)(byte)(&DAT_012f7040)[uVar19 + lVar14])) +\n           *(char *)(lVar1 + lVar18) + *(char *)(lVar9 + lVar18);\n      *(char *)(CONCAT71(in_register_00000089,[VAR6] ) + 1 + lVar15) =\n           *(char *)(lVar9 + lVar16) + *(char *)(lVar20 + (int)(iVar12 + (uint)bVar2)) +\n           *(char *)(lVar1 + lVar16);\n      lVar15 = lVar15 + 2;\n    } while ((ulong)(iVar11 - 1) * 2 + 2 != lVar15);\n  }\n  return;\n}", "answer": {"TYPE17": "undefined8", "TYPE18": "undefined4", "VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "VAR5": "param_5", "VAR6": "param_6", "FUNC1": "FUN_00f58960", "TYPE3": "undefined", "VAR14": "local_48", "TYPE2": "undefined", "VAR15": "local_50", "TYPE5": "undefined", "VAR12": "local_3c", "TYPE4": "undefined", "VAR13": "local_40", "TYPE7": "undefined4", "VAR18": "local_64", "TYPE6": "undefined", "TYPE9": "undefined4", "VAR16": "local_58", "TYPE8": "undefined4", "VAR17": "local_60", "VAR7": "param_7", "TYPE11": "undefined8", "VAR8": "param_8", "TYPE12": "undefined4", "VAR9": "param_9", "TYPE10": "undefined4", "VAR10": "param_10", "TYPE15": "undefined8", "VAR11": "local_38", "TYPE16": "undefined8", "TYPE1": "undefined", "TYPE13": "undefined4", "TYPE14": "undefined8"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV RAX,qword ptr [RDX]\nMOV R13,qword ptr [RSI]\nMOV R14,qword ptr [RSI + 0x8]\nMOV qword ptr [RSP + -0x30],RAX\nMOV RAX,qword ptr [RDX + 0x8]\nMOV qword ptr [RSP + -0x28],RAX\nMOV RAX,qword ptr [RCX]\nMOV qword ptr [RSP + -0x20],RAX\nMOV RAX,qword ptr [RCX + 0x8]\nMOV qword ptr [RSP + -0x18],RAX\nMOV EAX,0x1000\nMOV EDX,EAX\nSUB EAX,dword ptr [RSP + 0x48]\nSUB EDX,dword ptr [RSP + 0x40]\nMOV dword ptr [RSP + -0xc],EAX\nMOV EAX,dword ptr [RSP + 0x38]\nMOV dword ptr [RSP + -0x10],EDX\nADD EAX,0x1\nSAR EAX,0x1\nTEST EAX,EAX\nJLE 0x00f58b13\nMOV EDX,dword ptr [RSP + 0x50]\nLEA R15,[0x12f7040]\nSUB EAX,0x1\nLEA RAX,[RAX + RAX*0x1 + 0x2]\nAND EDX,0x7\nMOV qword ptr [RSP + -0x8],RAX\nSHL RDX,0x3\nADD R15,RDX\nADD RDX,qword ptr [0x01757fd0]\nMOV R12,RDX\nXOR EDX,EDX\nNOP dword ptr [RAX]\nMOVSX EAX,word ptr [R13 + RDX*0x2]\nMOVSX ECX,word ptr [R14 + RDX*0x2]\nMOV EBX,dword ptr [RSP + -0x10]\nMOVSX ESI,word ptr [R13 + RDX*0x2 + 0x2]\nIMUL ECX,dword ptr [RSP + 0x40]\nMOV R11,qword ptr [RSP + -0x30]\nIMUL EAX,EBX\nIMUL ESI,EBX\nMOV RBX,qword ptr [RSP + -0x20]\nADD ECX,EAX\nMOVSX EAX,word ptr [R14 + RDX*0x2 + 0x2]\nIMUL EAX,dword ptr [RSP + 0x40]\nMOVSX R8D,word ptr [RBX + RDX*0x1]\nMOV EBX,dword ptr [RSP + -0xc]\nSAR ECX,0x13\nIMUL R8D,EBX\nADD EAX,ESI\nMOV RSI,qword ptr [RSP + -0x18]\nSAR EAX,0x13\nMOVSX ESI,word ptr [RSI + RDX*0x1]\nIMUL ESI,dword ptr [RSP + 0x48]\nADD ESI,R8D\nMOVSX R8D,word ptr [R11 + RDX*0x1]\nSAR ESI,0x13\nADD ESI,0x200\nMOVSXD RSI,ESI\nIMUL R8D,EBX\nMOV RBX,qword ptr [RSP + -0x28]\nMOVSXD R11,dword ptr [RDI + RSI*0x4 + 0xe30]\nMOV RBP,qword ptr [RDI + RSI*0x8 + 0x2230]\nMOVSX R10D,word ptr [RBX + RDX*0x1]\nIMUL R10D,dword ptr [RSP + 0x48]\nADD R8D,R10D\nMOV R10,RDX\nSAR R8D,0x13\nAND R10D,0x7\nMOVSXD R8,R8D\nLEA R8,[RDI + R8*0x8]\nADD R11,qword ptr [R8 + 0x5a30]\nMOV RBX,qword ptr [R8 + 0x8230]\nLEA R8D,[RDX + 0x1]\nAND R8D,0x7\nMOVZX ESI,byte ptr [R12 + R8*0x1]\nMOVZX R8D,byte ptr [R15 + R8*0x1]\nMOV dword ptr [RSP + -0x34],R8D\nMOVZX R8D,byte ptr [R12 + R10*0x1]\nADD ESI,EAX\nMOVZX R10D,byte ptr [R15 + R10*0x1]\nADD EAX,dword ptr [RSP + -0x34]\nMOVSXD RSI,ESI\nADD R8D,ECX\nMOVSXD R8,R8D\nADD ECX,R10D\nCDQE\nMOVZX R10D,byte ptr [RBX + R8*0x1]\nMOVSXD RCX,ECX\nADD R10B,byte ptr [RBP + R8*0x1]\nMOVZX R8D,byte ptr [R11 + RCX*0x1]\nADD R8D,R10D\nMOV byte ptr [R9 + RDX*0x1],R8B\nMOVZX ECX,byte ptr [RBP + RSI*0x1]\nADD CL,byte ptr [R11 + RAX*0x1]\nADD CL,byte ptr [RBX + RSI*0x1]\nMOV byte ptr [R9 + RDX*0x1 + 0x1],CL\nADD RDX,0x2\nCMP qword ptr [RSP + -0x8],RDX\nJNZ 0x00f589f0\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "269": {"funcbody": "EUint32 [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n             [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  long lVar1;\n  char *pcVar2;\n  [TYPE7] [VAR7] ;\n  char *pcVar3;\n  [TYPE8] [VAR8] ;\n  char *pcVar4;\n  [TYPE9] [VAR9] ;\n  [TYPE10] [VAR10] ;\n  long in_FS_OFFSET;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ([VAR1] == ([TYPE1] )0x0) {\n    [FUNC4] (\"%s\",\"[edma_get_ini_string] Invalid file handler\");\n    [VAR7] = ([TYPE7] )0xffffffffffffffff;\n  }\n  else if ([VAR2] == ([TYPE2] )0x0) {\n    [FUNC4] (\"%s\",\"[edma_get_ini_string] Invalid Section\");\n    [VAR7] = ([TYPE7] )0xffffffffffffffff;\n  }\n  else if ([VAR3] == ([TYPE3] )0x0) {\n    [FUNC4] (\"%s\",\"[edma_get_ini_string] Invalid Field\");\n    [VAR7] = ([TYPE7] )0xffffffffffffffff;\n  }\n  else if ([VAR5] == (TYPE50x0) {\n    [FUNC4] (\"%s\",\"[edma_get_ini_string] Invalid Target buffer\");\n    [VAR7] = ([TYPE7] )0xffffffffffffffff;\n  }\n  else {\n    [FUNC8] ([VAR5] ,0,[VAR6] );\n    [FUNC7] ([VAR12] ,0x50,1,0x50,&DAT_000291bf,[VAR2] );\n    pcVar2 = [FUNC9] ([VAR1] ->p,[VAR12] );\n    [VAR7] = ([TYPE7] )0x0;\n    if (pcVar2 != (char *)0x0) {\n      pcVar3 = [FUNC6] (pcVar2 + 1,0x5b);\n      if (pcVar3 != (char *)0x0) {\n        *pcVar3 = '\\0';\n      }\n      pcVar2 = [FUNC9] (pcVar2 + 1,[VAR3] );\n      if (pcVar2 == (char *)0x0) {\n        *pcVar3 = '[';\n        [VAR7] = ([TYPE7] )0x0;\n      }\n      else {\n        pcVar2 = [FUNC6] (pcVar2,0x3d);\n        pcVar4 = [FUNC6] (pcVar2,0xd);\n        if (pcVar4 == (char *)0x0) {\n          pcVar4 = [FUNC6] (pcVar2,10);\n          if (pcVar4 == (char *)0x0) {\n            [FUNC2] (1,\"%s\",\"[edma_get_ini_string] Can\\'t locate end of line\");\n            [VAR7] = ([TYPE7] )0x0;\n            goto LAB_00015dcf;\n          }\n        }\n        [FUNC10] ([VAR5] ,pcVar2 + 1,(size_t)(pcVar4 + (-1 - (long)pcVar2)));\n        [VAR5] [(long)(pcVar4 + (-1 - (long)pcVar2))] = '\\0';\n        *pcVar3 = '[';\n        [VAR7] = ([TYPE7] )[FUNC5] ([VAR5] );\n      }\n    }\n  }\nLAB_00015dcf:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return (EUint32)[VAR7] ;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "pini", "VAR2": "Section", "VAR3": "Val", "VAR4": "def", "FUNC10": "strncpy", "VAR5": "Buffer", "VAR6": "size", "FUNC2": "__printf_chk", "FUNC3": "__stack_chk_fail", "FUNC1": "edma_get_ini_string", "FUNC6": "strchr", "TYPE3": "EPChar", "FUNC7": "__snprintf_chk", "TYPE2": "EPChar", "FUNC4": "edma_printf_err", "TYPE5": "EPChar", "VAR12": "sec", "FUNC5": "strlen", "TYPE4": "EPChar", "TYPE7": "EPChar", "TYPE6": "EUint32", "FUNC8": "memset", "TYPE9": "EPChar", "FUNC9": "strstr", "TYPE8": "EPChar", "VAR7": "pi", "TYPE11": "undefined8", "VAR8": "pe", "TYPE12": "EChar[80]", "VAR9": "pe1", "TYPE10": "EUint32", "VAR10": "n", "VAR11": "local_30", "TYPE1": "PINIFILE.conflict"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x60\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x58],RAX\nXOR EAX,EAX\nTEST RDI,RDI\nJZ 0x00015e58\nTEST RSI,RSI\nMOV R12,RSI\nJZ 0x00015e80\nTEST RDX,RDX\nMOV R13,RDX\nJZ 0x00015ea8\nTEST R8,R8\nMOV RBX,R8\nJZ 0x00015e30\nMOV RBP,RDI\nMOV RDX,R9\nXOR ESI,ESI\nMOV RDI,R8\nMOV R14,RSP\nCALL 0x000095a0\nLEA R8,[0x291bf]\nMOV R9,R12\nMOV ECX,0x50\nMOV EDX,0x1\nMOV ESI,0x50\nMOV RDI,R14\nXOR EAX,EAX\nCALL 0x00009020\nMOV RDI,qword ptr [RBP + 0x8]\nMOV RSI,R14\nCALL 0x0000a0f0\nMOV RBP,RAX\nXOR EAX,EAX\nTEST RBP,RBP\nJZ 0x00015dcf\nADD RBP,0x1\nMOV ESI,0x5b\nMOV RDI,RBP\nCALL 0x000094e0\nTEST RAX,RAX\nMOV R12,RAX\nJZ 0x00015d71\nMOV byte ptr [RAX],0x0\nMOV RSI,R13\nMOV RDI,RBP\nCALL 0x0000a0f0\nTEST RAX,RAX\nJZ 0x00015e20\nMOV ESI,0x3d\nMOV RDI,RAX\nCALL 0x000094e0\nMOV ESI,0xd\nMOV RDI,RAX\nMOV R13,RAX\nCALL 0x000094e0\nTEST RAX,RAX\nJZ 0x00015df0\nSUB RAX,R13\nLEA RSI,[R13 + 0x1]\nMOV RDI,RBX\nLEA RDX,[RAX + -0x1]\nMOV RBP,RAX\nCALL 0x000090f0\nMOV byte ptr [RBX + RBP*0x1 + -0x1],0x0\nMOV RDI,RBX\nMOV byte ptr [R12],0x5b\nCALL 0x00009410\nMOV RCX,qword ptr [RSP + 0x58]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00015ec9\nADD RSP,0x60\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV ESI,0xa\nMOV RDI,R13\nCALL 0x000094e0\nTEST RAX,RAX\nJNZ 0x00015da7\nLEA RDX,[0x29130]\nLEA RSI,[0x2c80f]\nMOV EDI,0x1\nCALL 0x00009bf0\nXOR EAX,EAX\nJMP 0x00015dcf\nMOV byte ptr [R12],0x5b\nJMP 0x00015dcf\nLEA RSI,[0x29100]\nLEA RDI,[0x2c80f]\nXOR EAX,EAX\nCALL 0x00009ff0\nMOV RAX,-0x1\nJMP 0x00015dcf\nLEA RSI,[0x29080]\nLEA RDI,[0x2c80f]\nCALL 0x00009ff0\nMOV RAX,-0x1\nJMP 0x00015dcf\nLEA RSI,[0x290b0]\nLEA RDI,[0x2c80f]\nXOR EAX,EAX\nCALL 0x00009ff0\nMOV RAX,-0x1\nJMP 0x00015dcf\nLEA RSI,[0x290d8]\nLEA RDI,[0x2c80f]\nXOR EAX,EAX\nCALL 0x00009ff0\nMOV RAX,-0x1\nJMP 0x00015dcf\nCALL 0x00009460\n"}, "270": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] )\n{\n  uint uVar1;\n  char *pcVar2;\n  [TYPE9] [VAR9] ;\n  [TYPE10] [VAR10] ;\n  int iVar3;\n  [TYPE8] [VAR8] ;\n  [TYPE5] [VAR12] ;\n  int [VAR11] ;\n  \n  if ([VAR1] == ([TYPE1] )0x0) {\n    [VAR11] = -1;\n  }\n  else if (([VAR2] != [VAR4] ) || ([VAR11] = 0, [VAR3] != [VAR5] )) {\n    iVar3 = (int)[VAR1] ->_columns;\n    [VAR12] = [VAR5] ;\n    if (iVar3 <= [VAR5] ) {\n      [VAR12] = [VAR5] % iVar3;\n      [VAR4] = [VAR4] + [VAR5] / iVar3;\n    }\n    uVar1 = *[VAR1] ->_current_attr;\n    if (((uVar1 & 0x400000) != 0) ||\n       (((uVar1 & 0xffffff00) != 0 && ((cur_term->type).Booleans[0xe] == '\\0')))) {\n      [FUNC4] ([VAR1] ,0,[VAR6] );\n    }\n    if ([VAR1] ->_columns <= [VAR3] ) {\n      [VAR11] = ([VAR3] + 1) / (int)[VAR1] ->_columns;\n      [VAR2] = [VAR2] + [VAR11] ;\n      if ([VAR1] ->_lines <= [VAR2] ) {\n        [VAR11] = ([VAR1] ->_lines - [VAR2] ) + 1 + [VAR11] ;\n      }\n      if (0 < [VAR11] ) {\n        pcVar2 = (cur_term->type).Strings[2];\n        [VAR3] = [VAR11] ;\n        if (pcVar2 == (char *)0x0) {\n          (*[VAR6] )([VAR1] ,0xd);\n        }\n        else {\n          [FUNC2] ([VAR1] ,\"carriage_return\",pcVar2);\n        }\n        do {\n          pcVar2 = (cur_term->type).Strings[0x67];\n          if (pcVar2 == (char *)0x0) {\n            (*[VAR6] )([VAR1] ,10);\n          }\n          else {\n            [FUNC2] ([VAR1] ,\"newline\",pcVar2);\n          }\n          [VAR3] = [VAR3] + -1;\n        } while ([VAR3] != 0);\n      }\n    }\n    iVar3 = [VAR1] ->_lines + -1;\n    if (iVar3 <= [VAR4] ) {\n      [VAR4] = iVar3;\n    }\n    if ([VAR2] < iVar3) {\n      iVar3 = [VAR2] ;\n    }\n    [VAR11] = [FUNC3] ([VAR1] ,iVar3,[VAR3] ,[VAR4] ,[VAR12] ,[VAR7] ,[VAR6] );\n    if (((uVar1 ^ *[VAR1] ->_current_attr) & 0xffffff00) != 0) {\n      [FUNC4] ([VAR1] ,uVar1 & 0xffffff00,[VAR6] );\n    }\n  }\n  return [VAR11] ;\n}", "answer": {"VAR1": "sp", "VAR2": "yold", "VAR3": "xold", "VAR4": "ynew", "VAR5": "xnew", "VAR6": "myOutCh", "FUNC2": "_nc_putp_sp", "FUNC3": "onscreen_mvcur", "FUNC1": "_nc_real_mvcur", "TYPE3": "int", "TYPE2": "int", "FUNC4": "vidputs_sp", "TYPE5": "int", "VAR12": "local_40", "TYPE4": "int", "TYPE7": "int", "TYPE6": "NCURSES_OUTC_sp", "TYPE9": "int", "TYPE8": "chtype", "VAR7": "ovw", "TYPE11": "undefined4", "VAR8": "oldattr", "TYPE12": "undefined4", "VAR9": "l", "TYPE10": "int", "VAR10": "code", "VAR11": "local_3c", "TYPE1": "SCREEN *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV dword ptr [RSP + 0x8],R8D\nTEST RDI,RDI\nJZ 0x0000bb0d\nMOV RBX,RDI\nMOV R13D,ESI\nMOV EBP,EDX\nMOV R12D,ECX\nMOV R14,R9\nCMP ESI,ECX\nJNZ 0x0000b9b0\nMOV dword ptr [RSP + 0xc],0x0\nCMP EDX,R8D\nJNZ 0x0000b9b0\nMOV EAX,dword ptr [RSP + 0xc]\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOVSX ECX,word ptr [RBX + 0x76]\nMOV EAX,dword ptr [RSP + 0x8]\nCMP ECX,EAX\nJG 0x0000b9c6\nCDQ\nIDIV ECX\nADD R12D,EAX\nMOV dword ptr [RSP + 0x8],EDX\nMOV RAX,qword ptr [RBX + 0x2e0]\nMOV R15D,dword ptr [RAX]\nTEST R15D,0x400000\nJNZ 0x0000b9f3\nTEST R15D,0xffffff00\nJZ 0x0000ba03\nMOV RAX,qword ptr [0x0023b888]\nMOV RAX,qword ptr [RAX + 0x10]\nCMP byte ptr [RAX + 0xe],0x0\nJNZ 0x0000ba03\nMOV RDX,R14\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x0000f7c3\nMOVSX ECX,word ptr [RBX + 0x76]\nCMP ECX,EBP\nJG 0x0000baa5\nLEA EAX,[RBP + 0x1]\nCDQ\nIDIV ECX\nMOV dword ptr [RSP + 0xc],EAX\nADD R13D,EAX\nMOVSX EDX,word ptr [RBX + 0x74]\nCMP EDX,R13D\nJG 0x0000ba30\nSUB EDX,R13D\nLEA EAX,[RDX + RAX*0x1 + 0x1]\nMOV dword ptr [RSP + 0xc],EAX\nCMP dword ptr [RSP + 0xc],0x0\nJLE 0x0000baa5\nMOV RAX,qword ptr [0x0023b888]\nMOV RAX,qword ptr [RAX + 0x20]\nMOV RDX,qword ptr [RAX + 0x10]\nTEST RDX,RDX\nJNZ 0x0000ba5c\nMOV ESI,0xd\nMOV RDI,RBX\nCALL R14\nMOV EBP,dword ptr [RSP + 0xc]\nJMP 0x0000ba81\nLEA RSI,[0x29ebe]\nMOV RDI,RBX\nCALL 0x0001df64\nJMP 0x0000ba56\nLEA RSI,[0x29eac]\nMOV RDI,RBX\nCALL 0x0001df64\nSUB EBP,0x1\nJZ 0x0000baa5\nMOV RAX,qword ptr [0x0023b888]\nMOV RAX,qword ptr [RAX + 0x20]\nMOV RDX,qword ptr [RAX + 0x338]\nTEST RDX,RDX\nJNZ 0x0000ba6d\nMOV ESI,0xa\nMOV RDI,RBX\nCALL R14\nJMP 0x0000ba7c\nMOVSX ESI,word ptr [RBX + 0x74]\nSUB ESI,0x1\nCMP ESI,R12D\nMOV ECX,R12D\nCMOVLE ECX,ESI\nCMP ESI,R13D\nCMOVG ESI,R13D\nSUB RSP,0x8\nPUSH R14\nMOV R9D,dword ptr [RSP + 0x60]\nMOV R8D,dword ptr [RSP + 0x18]\nMOV EDX,EBP\nMOV RDI,RBX\nCALL 0x0000b401\nMOV dword ptr [RSP + 0x1c],EAX\nMOV RAX,qword ptr [RBX + 0x2e0]\nMOV EDI,R15D\nXOR EDI,dword ptr [RAX]\nMOV EAX,EDI\nADD RSP,0x10\nTEST EAX,0xffffff00\nJZ 0x0000b99d\nMOV ESI,R15D\nMOV SIL,0x0\nMOV RDX,R14\nMOV RDI,RBX\nCALL 0x0000f7c3\nJMP 0x0000b99d\nMOV dword ptr [RSP + 0xc],0xffffffff\nJMP 0x0000b99d\n"}, "271": {"funcbody": "int [FUNC1] (TYPE15 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  EVP_CIPHER *pEVar1;\n  IDEA_KEY_SCHEDULE *ks;\n  [TYPE3] in;\n  ulong uVar2;\n  [TYPE5] [VAR5] ;\n  \n  pEVar1 = [FUNC3] ([VAR1] );\n  uVar2 = (ulong)pEVar1->block_size;\n  if (uVar2 <= [VAR4] ) {\n    in = [VAR3] ;\n    do {\n      ks = (IDEA_KEY_SCHEDULE *)[FUNC4] ([VAR1] );\n      [FUNC2] (in,[VAR2] ,ks);\n      in = in + uVar2;\n      [VAR2] = [VAR2] + uVar2;\n    } while ((ulong)((long)in - (long)[VAR3] ) <= [VAR4] - uVar2);\n  }\n  return 1;\n}", "answer": {"VAR1": "ctx", "VAR2": "out", "VAR3": "in", "VAR4": "inl", "VAR5": "bl", "FUNC2": "IDEA_ecb_encrypt", "FUNC3": "EVP_CIPHER_CTX_get0_cipher", "FUNC1": "idea_ecb_cipher", "TYPE3": "uchar *", "TYPE2": "uchar *", "FUNC4": "EVP_CIPHER_CTX_get_cipher_data", "TYPE5": "size_t", "TYPE4": "size_t", "TYPE1": "EVP_CIPHER_CTX *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R14,RDI\nMOV RBP,RSI\nMOV RBX,RDX\nMOV R13,RCX\nCALL 0x0008867f\nMOVSXD R12,dword ptr [RAX + 0x4]\nCMP R12,R13\nJA 0x00190bea\nSUB R13,R12\nMOV R15,RBX\nMOV RDI,R14\nCALL 0x000886c9\nMOV RDX,RAX\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x001a4049\nADD RBX,R12\nADD RBP,R12\nMOV RAX,RBX\nSUB RAX,R15\nCMP R13,RAX\nJNC 0x00190bc3\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "272": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,TYPE75 [VAR7] ,[TYPE8] [VAR8] ,\n         [TYPE9] [VAR9] )\n{\n  int iVar1;\n  [TYPE10] [VAR10] ;\n  \n  if ([VAR2] < 0x304) {\n    if ([VAR2] < 0x302) {\n      if ([VAR2] == 0x300) {\n        iVar1 = [FUNC2] ([VAR4] ,*[VAR4] ,[VAR3] ,[VAR6] ,[VAR7] ,[VAR5] ,[VAR8] ,[VAR1] );\n        return iVar1;\n      }\n      if (0x300 < [VAR2] ) goto LAB_00139d9d;\n      if ([VAR2] != 0x100) {\n        return 0;\n      }\n    }\n  }\n  else if (([VAR2] != 0xfefd) && ([VAR2] != 0xfeff)) {\n    return 0;\n  }\n  [VAR3] = [VAR3] + [VAR5] ;\n  *[VAR4] = *[VAR4] - [VAR5] ;\nLAB_00139d9d:\n  iVar1 = [FUNC3] ([VAR4] ,*[VAR4] ,[VAR3] ,[VAR6] ,[VAR7] ,[VAR5] ,[VAR8] ,[VAR9] ,[VAR1] );\n  return iVar1;\n}", "answer": {"VAR1": "libctx", "VAR2": "tlsversion", "VAR3": "buf", "VAR4": "buflen", "VAR5": "blocksize", "VAR6": "mac", "FUNC2": "ssl3_cbc_remove_padding_and_mac", "FUNC3": "tls1_cbc_remove_padding_and_mac", "FUNC1": "ossl_cipher_tlsunpadblock", "TYPE3": "uchar *", "TYPE2": "uint", "TYPE5": "size_t", "TYPE4": "size_t *", "TYPE7": "int *", "TYPE6": "uchar * *", "TYPE9": "int", "TYPE8": "size_t", "VAR7": "alloced", "VAR8": "macsize", "VAR9": "aead", "TYPE10": "int", "VAR10": "ret", "TYPE1": "OSSL_LIB_CTX *"}, "assembly": "SUB RSP,0x8\nMOV RAX,RCX\nMOV RCX,R9\nCMP ESI,0x303\nJA 0x00139dd6\nCMP ESI,0x302\nJNC 0x00139de6\nCMP ESI,0x300\nJZ 0x00139dee\nCMP ESI,0x300\nJBE 0x00139dc7\nSUB RSP,0x8\nPUSH RDI\nMOV ESI,dword ptr [RSP + 0x30]\nPUSH RSI\nPUSH qword ptr [RSP + 0x30]\nMOV R9,R8\nMOV R8,qword ptr [RSP + 0x30]\nMOV RSI,qword ptr [RAX]\nMOV RDI,RAX\nCALL 0x0013cb4d\nADD RSP,0x20\nADD RSP,0x8\nRET\nCMP ESI,0x100\nJZ 0x00139de6\nMOV EAX,0x0\nJMP 0x00139dc2\nCMP ESI,0xfefd\nJZ 0x00139de6\nCMP ESI,0xfeff\nJNZ 0x00139dcf\nADD RDX,R8\nSUB qword ptr [RAX],R8\nJMP 0x00139d9d\nPUSH RDI\nPUSH qword ptr [RSP + 0x20]\nMOV R9,R8\nMOV R8,qword ptr [RSP + 0x20]\nMOV RSI,qword ptr [RAX]\nMOV RDI,RAX\nCALL 0x0013cacf\nADD RSP,0x10\nJMP 0x00139dc2\n"}, "273": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  \n  iVar1 = 0;\n  if ([VAR1] <= g_taruib_gst_lenM) {\n    iVar1 = g_taruib_gst_lenM - [VAR1] ;\n  }\n  g_taruib_gst_lenM = iVar1;\n  return;\n}", "answer": {"VAR1": "n", "FUNC1": "taruib_unread", "TYPE1": "int"}, "assembly": "MOV EDX,dword ptr [0x002adb00]\nMOV ECX,EDX\nSUB ECX,EDI\nCMP EDX,EDI\nMOV EAX,0x0\nCMOVGE EAX,ECX\nMOV dword ptr [0x002adb00],EAX\nRET\n"}, "274": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] ,TYPE25 [VAR2] ,TYPE37 [VAR3] )\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = [FUNC3] ((EVP_PKEY *)[VAR3] ->p2);\n  iVar2 = 0;\n  if (iVar1 == 6) {\n    iVar2 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,5);\n  }\n  return iVar2;\n}", "answer": {"VAR1": "state", "VAR2": "translation", "VAR3": "ctx", "FUNC2": "get_rsa_payload_coefficient", "FUNC3": "EVP_PKEY_get_base_id", "FUNC1": "get_rsa_payload_c6", "TYPE3": "translation_ctx_st *", "TYPE2": "translation_st *", "TYPE1": "state"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV EBP,EDI\nMOV R12,RSI\nMOV RBX,RDX\nMOV RDI,qword ptr [RDX + 0x20]\nCALL 0x000a1a22\nMOV EDX,0x0\nCMP EAX,0x6\nJZ 0x001aaee8\nMOV EAX,EDX\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV ECX,0x5\nMOV RDX,RBX\nMOV RSI,R12\nMOV EDI,EBP\nCALL 0x001aad56\nMOV EDX,EAX\nJMP 0x001aaee1\n"}, "275": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  int *piVar2;\n  [TYPE3] [VAR3] ;\n  \n  [VAR3] = cur_term;\n  if (([VAR1] != ([TYPE1] )0x0) && ([VAR3] = [VAR1] ->_term, [VAR3] == ([TYPE3] )0x0)) {\n    [VAR3] = cur_term;\n  }\n  if (([VAR2] != ([TYPE2] )0x0) && ([VAR3] != ([TYPE3] )0x0)) {\n    do {\n      iVar1 = [FUNC2] ((int)[VAR3] ->Filedes,(termios *)[VAR2] );\n      if (iVar1 == 0) {\n        return 0;\n      }\n      piVar2 = [FUNC3] ();\n    } while (*piVar2 == 4);\n  }\n  if ([VAR2] != ([TYPE2] )0x0) {\n    [VAR2] ->c_iflag = 0;\n    [VAR2] ->c_oflag = 0;\n    [VAR2] ->c_cflag = 0;\n    [VAR2] ->c_lflag = 0;\n    [VAR2] ->c_line = '\\0';\n    [VAR2] ->c_cc[0] = '\\0';\n    [VAR2] ->c_cc[1] = '\\0';\n    [VAR2] ->c_cc[2] = '\\0';\n    [VAR2] ->c_cc[3] = '\\0';\n    [VAR2] ->c_cc[4] = '\\0';\n    [VAR2] ->c_cc[5] = '\\0';\n    [VAR2] ->c_cc[6] = '\\0';\n    *(undefined8 *)([VAR2] ->c_cc + 7) = 0;\n    *(undefined8 *)([VAR2] ->c_cc + 0xf) = 0;\n    *(undefined8 *)([VAR2] ->c_cc + 0x17) = 0;\n    *(undefined8 *)([VAR2] ->c_cc + 0x1f) = 0;\n    [VAR2] ->c_ospeed = 0;\n  }\n  return -1;\n}", "answer": {"VAR1": "sp", "VAR2": "buf", "VAR3": "termp", "FUNC2": "tcgetattr", "FUNC3": "__errno_location", "FUNC1": "_nc_get_tty_mode_sp", "TYPE3": "TERMINAL.conflict *", "TYPE2": "termios *", "TYPE1": "SCREEN *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RSI\nTEST RDI,RDI\nJZ 0x000184ce\nMOV RBP,qword ptr [RDI + 0x30]\nTEST RBP,RBP\nCMOVZ RBP,qword ptr [0x0023b888]\nTEST RBX,RBX\nJZ 0x0001847f\nTEST RBP,RBP\nJZ 0x0001847f\nMOVSX EDI,word ptr [RBP + 0x48]\nMOV RSI,RBX\nCALL 0x00007a00\nTEST EAX,EAX\nJZ 0x000184c7\nCALL 0x000076f0\nCMP dword ptr [RAX],0x4\nJZ 0x00018465\nMOV EAX,0xffffffff\nTEST RBX,RBX\nJZ 0x000184c7\nMOV qword ptr [RBX],0x0\nMOV qword ptr [RBX + 0x8],0x0\nMOV qword ptr [RBX + 0x10],0x0\nMOV qword ptr [RBX + 0x18],0x0\nMOV qword ptr [RBX + 0x20],0x0\nMOV qword ptr [RBX + 0x28],0x0\nMOV qword ptr [RBX + 0x30],0x0\nMOV dword ptr [RBX + 0x38],0x0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RBP,qword ptr [0x0023b888]\nJMP 0x0001845b\n"}, "276": {"funcbody": "void [FUNC1] (undefined8 param_1,long param_2)\n{\n  int iVar1;\n  long lVar2;\n  \n  iVar1 = [FUNC3] ();\n  if ((iVar1 != 0) && (iVar1 = [FUNC2] (param_1,0), iVar1 == 0)) {\n    return;\n  }\n  lVar2 = [FUNC4] (param_1);\n  *(ulong *)(param_2 + 8) = (ulong)(lVar2 != 0);\n  return;\n}", "answer": {"FUNC2": "FUN_0021f6d8", "FUNC3": "FUN_0025e8af", "FUNC1": "FUN_0009aeaa", "FUNC4": "FUN_0009ad1a"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RSI\nCALL 0x0025e8af\nTEST EAX,EAX\nJZ 0x0009aed0\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x0021f6d8\nTEST EAX,EAX\nJZ 0x0009aee5\nMOV RDI,RBX\nCALL 0x0009ad1a\nTEST RAX,RAX\nSETNZ AL\nMOVZX EAX,AL\nMOV qword ptr [RBP + 0x8],RAX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "277": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  [TYPE3] [VAR3] ;\n  long lVar1;\n  \n  if ([VAR1] ->ssl == (SSL *)0x0) {\n    lVar1 = [FUNC2] ((SSL_CTX *)[VAR1] ->ctx,0x5c,0,[VAR2] );\n    [VAR3] = ([TYPE3] )lVar1;\n  }\n  else {\n    lVar1 = [FUNC3] ((SSL *)[VAR1] ->ssl,0x5c,0,[VAR2] );\n    [VAR3] = ([TYPE3] )lVar1;\n  }\n  return (int)(0 < [VAR3] );\n}", "answer": {"VAR1": "cctx", "VAR2": "value", "VAR3": "rv", "FUNC2": "SSL_CTX_ctrl", "FUNC3": "SSL_ctrl", "FUNC1": "cmd_Groups", "TYPE3": "int", "TYPE2": "char *", "TYPE1": "SSL_CONF_CTX *"}, "assembly": "SUB RSP,0x8\nMOV RAX,qword ptr [RDI + 0x20]\nTEST RAX,RAX\nJZ 0x000bc0cb\nMOV RCX,RSI\nMOV EDX,0x0\nMOV ESI,0x5c\nMOV RDI,RAX\nCALL 0x00079bc3\nTEST EAX,EAX\nSETG AL\nMOVZX EAX,AL\nADD RSP,0x8\nRET\nMOV RDI,qword ptr [RDI + 0x18]\nMOV RCX,RSI\nMOV EDX,0x0\nMOV ESI,0x5c\nCALL 0x0007a09e\nJMP 0x000bc0be\n"}, "278": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] )\n{\n  grub_size_t len;\n  grub_err_t gVar1;\n  [TYPE3] [VAR3] ;\n  char *buf;\n  [TYPE2] [VAR2] ;\n  \n  len = ([VAR1] ->ino).field_8.field_0.size;\n  buf = (char *)[FUNC3] (len + 1);\n  if (buf != (char *)0x0) {\n    gVar1 = [FUNC2] ([VAR1] ->disk,[VAR1] ->sb,&[VAR1] ->ino,0,buf,len,(grub_disk_read_hook_t)0x0,(void *)0x0);\n    if (gVar1 == GRUB_ERR_NONE) {\n      buf[len] = '\\0';\n    }\n    else {\n      [FUNC4] (buf);\n      buf = (char *)0x0;\n    }\n  }\n  return buf;\n}", "answer": {"VAR1": "node", "VAR2": "symsize", "VAR3": "err", "FUNC2": "read_bfs_file", "FUNC3": "grub_malloc", "FUNC1": "read_symlink", "TYPE3": "grub_err_t", "TYPE2": "grub_size_t", "FUNC4": "grub_free", "TYPE1": "grub_fshelp_node_t.conflict"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,RDI\nMOV R12,qword ptr [RDI + 0xe4]\nLEA RDI,[R12 + 0x1]\nCALL 0x0008dcf1\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000335ea\nLEA RDX,[RBP + 0x10]\nMOV RSI,qword ptr [RBP + 0x8]\nPUSH 0x0\nPUSH 0x0\nMOV R9,R12\nMOV R8,RAX\nMOV ECX,0x0\nMOV RDI,qword ptr [RBP]\nCALL 0x00032e97\nADD RSP,0x10\nTEST EAX,EAX\nJNZ 0x000335f2\nMOV byte ptr [RBX + R12*0x1],0x0\nMOV RAX,RBX\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,RBX\nCALL 0x0008dd4c\nMOV EBX,0x0\nJMP 0x000335ea\n"}, "279": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,TYPE23 [VAR2] )\n{\n  int iVar1;\n  \n  if ([VAR1] != (TYPE19)0x0) {\n    iVar1 = [FUNC2] ([VAR2] );\n    if (iVar1 != 0) {\n      [FUNC3] ([VAR1] );\n      [VAR1] ->type = X509_LU_CRL;\n      ([VAR1] ->data).x509 = (X509 *)[VAR2] ;\n      iVar1 = 1;\n    }\n    return iVar1;\n  }\n  return 0;\n}", "answer": {"VAR1": "a", "VAR2": "obj", "FUNC2": "X509_CRL_up_ref", "FUNC3": "x509_object_free_internal", "FUNC1": "X509_OBJECT_set1_X509_CRL", "TYPE2": "X509_CRL *", "TYPE1": "X509_OBJECT *"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x00204e46\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV RBX,RDI\nMOV RDI,RSI\nCALL 0x000bd85e\nTEST EAX,EAX\nJNZ 0x00204e2d\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RDI,RBX\nCALL 0x0020458e\nMOV dword ptr [RBX],0x2\nMOV qword ptr [RBX + 0x8],RBP\nMOV EAX,0x1\nJMP 0x00204e26\nRET\n"}, "280": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  iVar1 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,(timeval *)0x0,[VAR4] );\n  return iVar1;\n}", "answer": {"VAR1": "stream", "VAR2": "pbuf", "VAR3": "psize", "VAR4": "pread", "VAR5": "stream-local", "VAR6": "pbuf-local", "FUNC2": "mu_stream_timed_getline", "FUNC1": "mu_stream_getline", "TYPE3": "size_t *", "TYPE2": "char * *", "TYPE5": "mu_stream_t", "TYPE4": "size_t *", "TYPE7": "size_t *", "TYPE6": "char * *", "TYPE8": "size_t *", "VAR7": "psize-local", "VAR8": "pread-local", "TYPE1": "mu_stream_t"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nSUB RSP,0x20\nMOV qword ptr [RBP + -0x8],RDI\nMOV qword ptr [RBP + -0x10],RSI\nMOV qword ptr [RBP + -0x18],RDX\nMOV qword ptr [RBP + -0x20],RCX\nMOV RCX,qword ptr [RBP + -0x20]\nMOV RDX,qword ptr [RBP + -0x18]\nMOV RSI,qword ptr [RBP + -0x10]\nMOV RAX,qword ptr [RBP + -0x8]\nMOV R8,RCX\nMOV ECX,0x0\nMOV RDI,RAX\nCALL 0x00012080\nLEAVE\nRET\n"}, "281": {"funcbody": "int [FUNC1] (TYPE18 [VAR1] )\n{\n  int iVar1;\n  long lVar2;\n  int iVar3;\n  \n  iVar1 = [FUNC2] ((EC_GROUP *)[VAR1] );\n  iVar3 = 0;\n  if ((iVar1 == 0x197) && (*(int *)([VAR1] + 0x48) != 0)) {\n    lVar2 = 1;\n    do {\n      iVar1 = (int)lVar2;\n      if (*(int *)([VAR1] + lVar2 * 4 + 0x48) == 0) break;\n      iVar1 = iVar1 + 1;\n      lVar2 = lVar2 + 1;\n    } while (lVar2 != 6);\n    iVar3 = 0x2ab;\n    if ((iVar1 != 4) && (iVar3 = 0x2aa, iVar1 != 2)) {\n      iVar3 = 0;\n    }\n  }\n  return iVar3;\n}", "answer": {"VAR1": "param_1", "FUNC2": "EC_GROUP_get_field_type", "FUNC1": "EC_GROUP_get_basis_type", "TYPE1": "EC_GROUP *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCALL 0x00161e6c\nMOV EDX,0x0\nCMP EAX,0x197\nJZ 0x00163f2a\nMOV EAX,EDX\nPOP RBX\nRET\nCMP dword ptr [RBX + 0x48],0x0\nJZ 0x00163f26\nMOV EAX,0x1\nMOV ECX,EAX\nCMP dword ptr [RBX + RAX*0x4 + 0x48],0x0\nJNZ 0x00163f5a\nMOV EDX,0x2ab\nCMP ECX,0x4\nJZ 0x00163f26\nCMP ECX,0x2\nMOV EDX,0x2aa\nMOV EAX,0x0\nCMOVNZ EDX,EAX\nJMP 0x00163f26\nLEA ECX,[RAX + 0x1]\nADD RAX,0x1\nCMP RAX,0x6\nJZ 0x00163f3e\nJMP 0x00163f35\n"}, "282": {"funcbody": "char * [FUNC1] (void)\n{\n  time_t tVar1;\n  tm *__tp;\n  long in_FS_OFFSET;\n  [TYPE2] [VAR2] ;\n  long [VAR1] ;\n  \n  [VAR1] = *(long *)(in_FS_OFFSET + 0x28);\n  tVar1 = [FUNC6] (&[VAR2] );\n  if (tVar1 == -1) {\n    [FUNC5] (\"cannot get current time.\");\n  }\n  __tp = [FUNC3] (&[VAR2] );\n  [FUNC2] (now::buf,0x80,\"%a %b %d %H:%M:%S %Z %Y\",__tp);\n  if ([VAR1] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return now::buf;\n  }\n  [FUNC4] ();\n}", "answer": {"VAR1": "local_10", "VAR2": "tval", "FUNC2": "strftime", "FUNC3": "localtime", "FUNC1": "now", "FUNC6": "time", "TYPE2": "time_t", "FUNC4": "__stack_chk_fail", "FUNC5": "die", "TYPE1": "undefined8"}, "assembly": "SUB RSP,0x18\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV RDI,RSP\nCALL 0x0000bd50\nCMP RAX,-0x1\nJZ 0x0002c5f2\nMOV RDI,RSP\nCALL 0x0000b9d0\nMOV RCX,RAX\nLEA RDX,[0x47579]\nMOV ESI,0x80\nLEA RDI,[0x263fe0]\nCALL 0x0000be50\nLEA RAX,[0x263fe0]\nMOV RDX,qword ptr [RSP + 0x8]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x0002c603\nADD RSP,0x18\nRET\nLEA RDI,[0x47560]\nMOV EAX,0x0\nCALL 0x00025cf9\nCALL 0x0000bad0\n"}, "283": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  void *vctx;\n  TYPE24 [VAR2] ;\n  PROV_CIPHER_HW *hw;\n  \n  iVar1 = [FUNC4] ();\n  if (iVar1 == 0) {\n    vctx = (void *)0x0;\n  }\n  else {\n    vctx = [FUNC2] (0x140,\"providers/implementations/ciphers/cipher_sm4.c\",0x34);\n    if (vctx != (void *)0x0) {\n      hw = [FUNC3] (0x80);\n      [FUNC5] (vctx,0x80,8,0x80,4,0,hw,[VAR1] );\n    }\n  }\n  return vctx;\n}", "answer": {"VAR1": "provctx", "VAR2": "ctx", "FUNC2": "CRYPTO_zalloc", "FUNC3": "ossl_prov_cipher_hw_sm4_ofb128", "FUNC1": "sm4_128_ofb128_newctx", "TYPE2": "PROV_SM4_CTX *", "FUNC4": "ossl_prov_is_running", "FUNC5": "ossl_cipher_generic_initkey", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nCALL 0x000c44ef\nTEST EAX,EAX\nJZ 0x000d3cd1\nMOV EDX,0x34\nLEA RSI,[0x274c58]\nMOV EDI,0x140\nCALL 0x00099c80\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000d3cc7\nMOV EDI,0x80\nCALL 0x000d3dcb\nPUSH RBP\nPUSH RAX\nMOV R9D,0x0\nMOV R8D,0x4\nMOV ECX,0x80\nMOV EDX,0x8\nMOV ESI,0x80\nMOV RDI,RBX\nCALL 0x00108031\nADD RSP,0x10\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV EBX,0x0\nJMP 0x000d3cc7\n"}, "284": {"funcbody": "int [FUNC1] (TYPE15 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int enc;\n  void *key;\n  ulong len;\n  long in_FS_OFFSET;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  long [VAR5] ;\n  \n  [VAR5] = *(long *)(in_FS_OFFSET + 0x28);\n  len = 0x40000000;\n  if ([VAR4] < 0x40000000) {\n    len = [VAR4] ;\n  }\n  if (([VAR4] != 0) && (len <= [VAR4] )) {\n    do {\n      [VAR6] = [FUNC2] ([VAR1] );\n      enc = [FUNC4] ([VAR1] );\n      key = [FUNC3] ([VAR1] );\n      [FUNC6] ([VAR3] ,[VAR2] ,len,key,[VAR1] ->iv,&[VAR6] ,enc,(block128_f)PTR_[FUNC8] _00568fd0);\n      [FUNC7] ([VAR1] ,[VAR6] );\n      [VAR4] = [VAR4] - len;\n      [VAR3] = [VAR3] + len;\n      [VAR2] = [VAR2] + len;\n      if ([VAR4] < len) {\n        len = [VAR4] ;\n      }\n    } while (([VAR4] != 0) && (len <= [VAR4] ));\n  }\n  if ([VAR5] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 1;\n  }\n  [FUNC5] ();\n}", "answer": {"VAR1": "ctx", "VAR2": "out", "VAR3": "in", "VAR4": "inl", "VAR5": "local_40", "VAR6": "num", "FUNC2": "EVP_CIPHER_CTX_get_num", "FUNC3": "EVP_CIPHER_CTX_get_cipher_data", "FUNC1": "aria_128_cfb128_cipher", "FUNC6": "CRYPTO_cfb128_encrypt", "TYPE3": "uchar *", "FUNC7": "EVP_CIPHER_CTX_set_num", "TYPE2": "uchar *", "FUNC4": "EVP_CIPHER_CTX_is_encrypting", "TYPE5": "undefined8", "FUNC5": "__stack_chk_fail", "TYPE4": "size_t", "TYPE7": "undefined8", "TYPE6": "int", "FUNC8": "ossl_aria_encrypt", "VAR7": "local_50", "TYPE1": "EVP_CIPHER_CTX *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nCMP RCX,0x3fffffff\nMOV EBX,0x40000000\nCMOVBE RBX,RCX\nTEST RCX,RCX\nJZ 0x0018c5ec\nMOV R12,RDI\nMOV R13,RSI\nMOV R14,RDX\nMOV RBP,RCX\nLEA RAX,[RSP + 0x14]\nMOV qword ptr [RSP + 0x8],RAX\nCMP RCX,RBX\nJC 0x0018c5ec\nMOV RDI,R12\nCALL 0x000893cf\nMOV dword ptr [RSP + 0x14],EAX\nMOV RDI,R12\nCALL 0x00088af6\nMOV R15D,EAX\nMOV RDI,R12\nCALL 0x00088b09\nPUSH qword ptr [0x00568fd0]\nPUSH R15\nMOV R9,qword ptr [RSP + 0x18]\nLEA R8,[R12 + 0x28]\nMOV RCX,RAX\nMOV RDX,RBX\nMOV RSI,R13\nMOV RDI,R14\nCALL 0x001ac643\nMOV ESI,dword ptr [RSP + 0x24]\nMOV RDI,R12\nCALL 0x000894dd\nSUB RBP,RBX\nADD R14,RBX\nADD R13,RBX\nADD RSP,0x10\nCMP RBX,RBP\nCMOVA RBX,RBP\nTEST RBP,RBP\nJZ 0x0018c5ec\nCMP RBP,RBX\nJNC 0x0018c580\nMOV EAX,0x1\nMOV RDX,qword ptr [RSP + 0x18]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x0018c610\nADD RSP,0x28\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nCALL 0x00062640\n"}, "285": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,TYPE30 [VAR3] ,[TYPE4] [VAR4] ,\n          TYPE54 [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] ,[TYPE8] [VAR8] )\n{\n  int iVar1;\n  uint uVar2;\n  [TYPE9] [VAR9] ;\n  int iVar3;\n  uint uVar4;\n  [TYPE10] [VAR10] ;\n  int iVar5;\n  double dVar6;\n  double dVar7;\n  float fVar8;\n  [TYPE14] [VAR14] ;\n  [TYPE13] [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  \n  iVar3 = [VAR3] ->x;\n  iVar1 = [VAR3] ->y;\n  uVar2 = [FUNC2] ([VAR1] ->dir);\n  dVar6 = [FUNC5] ((double)[VAR2] ->xx * (double)[VAR2] ->xx + (double)[VAR2] ->xy * (double)[VAR2] ->xy);\n  [VAR5] ->x = dVar6;\n  dVar6 = [FUNC5] ((double)[VAR2] ->yx * (double)[VAR2] ->yx + (double)[VAR2] ->yy * (double)[VAR2] ->yy);\n  [VAR5] ->y = dVar6;\n  if (((_DAT_00413408 < [VAR5] ->x) || ([VAR10] = 1, _DAT_00413408 < dVar6)) && ([VAR10] = 1, [VAR4] == 0)) {\n    uVar4 = [FUNC4] ([VAR1] ->dir);\n    [VAR10] = (uVar4 ^ 1) & 1;\n  }\n  *[VAR8] = [VAR10] ;\n  if (uVar2 == 0) {\n    [VAR13] ._0_1_ = (byte)iVar3;\n    iVar5 = 1 << ((byte)[VAR13] & 0x1f);\n    [VAR11] ._0_1_ = (byte)iVar1;\n    iVar3 = 1 << ((byte)[VAR11] & 0x1f);\n    fVar8 = (float)iVar5;\n    dVar7 = (double)([VAR2] ->tx / fVar8);\n    dVar6 = [FUNC3] (dVar7);\n    [VAR6] ->x = (double)((float)((dVar7 - dVar6) * (double)iVar5) / fVar8);\n    fVar8 = (float)iVar3;\n    dVar7 = (double)([VAR2] ->ty / fVar8);\n    dVar6 = [FUNC3] (dVar7);\n    dVar6 = (double)((float)((dVar7 - dVar6) * (double)iVar3) / fVar8);\n  }\n  else {\n    [VAR6] ->x = 0.0;\n    dVar6 = 0.0;\n  }\n  [VAR6] ->y = dVar6;\n  if ([VAR10] == 0) {\n    [VAR7] ->xx = (float)((double)[VAR2] ->xx / [VAR5] ->x);\n    [VAR7] ->xy = (float)((double)[VAR2] ->xy / [VAR5] ->x);\n    [VAR7] ->yx = (float)((double)[VAR2] ->yx / [VAR5] ->y);\n    fVar8 = [VAR2] ->yy;\n    dVar6 = [VAR5] ->y;\n  }\n  else {\n    [VAR7] ->xx = [VAR2] ->xx;\n    [VAR7] ->xy = [VAR2] ->xy;\n    [VAR7] ->yx = [VAR2] ->yx;\n    fVar8 = [VAR2] ->yy;\n    dVar6 = DAT_0040ef58;\n  }\n  [VAR7] ->yy = (float)((double)fVar8 / dVar6);\n  [VAR7] ->tx = (float)((double)[VAR2] ->tx - [VAR6] ->x);\n  [VAR7] ->ty = (float)((double)[VAR2] ->ty - [VAR6] ->y);\n  return;\n}", "answer": {"VAR1": "pfont", "VAR2": "char_tm", "VAR3": "log2_scale", "VAR4": "design_grid", "VAR5": "char_size", "VAR6": "subpix_origin", "FUNC2": "gs_currentaligntopixels", "FUNC3": "floor", "FUNC1": "decompose_matrix", "TYPE3": "gs_log2_scale_point *", "VAR14": "local_4c", "TYPE2": "gs_matrix *", "FUNC4": "gs_currentgridfittt", "TYPE5": "gs_point *", "VAR12": "local_40", "FUNC5": "sqrt", "TYPE4": "bool", "VAR13": "local_48", "TYPE7": "gs_matrix *", "TYPE6": "gs_point *", "TYPE9": "bool", "TYPE8": "bool *", "VAR7": "post_transform", "TYPE11": "undefined4", "VAR8": "dg", "TYPE12": "undefined4", "VAR9": "atp", "TYPE10": "bool", "VAR10": "design_grid1", "VAR11": "local_3c", "TYPE1": "gs_font_type42 *", "TYPE13": "undefined8", "TYPE14": "undefined4"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV R15,RDI\nMOV RBX,RSI\nMOV dword ptr [RSP + 0x18],ECX\nMOV R12,R8\nMOV R13,R9\nMOV RBP,qword ptr [RSP + 0x60]\nMOV EAX,dword ptr [RDX]\nMOV dword ptr [RSP + 0x10],EAX\nMOV EAX,dword ptr [RDX + 0x4]\nMOV dword ptr [RSP + 0x1c],EAX\nMOV RDI,qword ptr [RDI + 0x18]\nCALL 0x0038ca24\nMOV dword ptr [RSP + 0xc],EAX\nPXOR XMM0,XMM0\nCVTSS2SD XMM0,dword ptr [RBX]\nPXOR XMM1,XMM1\nCVTSS2SD XMM1,dword ptr [RBX + 0x4]\nMULSD XMM0,XMM0\nMULSD XMM1,XMM1\nADDSD XMM0,XMM1\nCALL 0x000f1b80\nMOVSD qword ptr [R12],XMM0\nPXOR XMM0,XMM0\nCVTSS2SD XMM0,dword ptr [RBX + 0x8]\nPXOR XMM1,XMM1\nCVTSS2SD XMM1,dword ptr [RBX + 0xc]\nMULSD XMM0,XMM0\nMULSD XMM1,XMM1\nADDSD XMM0,XMM1\nCALL 0x000f1b80\nMOVSD qword ptr [R12 + 0x8],XMM0\nMOVSD XMM1,qword ptr [0x00413408]\nUCOMISD XMM1,qword ptr [R12]\nJC 0x00127d78\nMOV R14D,0x1\nUCOMISD XMM1,XMM0\nJNC 0x00127d89\nMOV R14D,0x1\nCMP dword ptr [RSP + 0x18],0x0\nJZ 0x00127f3a\nMOV RAX,qword ptr [RSP + 0x68]\nMOV dword ptr [RAX],R14D\nCMP dword ptr [RSP + 0xc],0x0\nJNZ 0x00127f52\nMOV EAX,0x1\nMOV R15D,EAX\nMOVZX ECX,byte ptr [RSP + 0x10]\nSHL R15D,CL\nMOVZX ECX,byte ptr [RSP + 0x1c]\nSHL EAX,CL\nMOV dword ptr [RSP + 0xc],EAX\nPXOR XMM7,XMM7\nCVTSI2SS XMM7,R15D\nMOVSS XMM0,dword ptr [RBX + 0x10]\nMOVSS dword ptr [RSP + 0x18],XMM7\nDIVSS XMM0,XMM7\nPXOR XMM2,XMM2\nCVTSS2SD XMM2,XMM0\nMOVSD qword ptr [RSP + 0x10],XMM2\nMOVAPD XMM0,XMM2\nCALL 0x000f1a50\nMOVSD XMM2,qword ptr [RSP + 0x10]\nSUBSD XMM2,XMM0\nMOVAPD XMM0,XMM2\nPXOR XMM1,XMM1\nCVTSI2SD XMM1,R15D\nMULSD XMM0,XMM1\nCVTSD2SS XMM0,XMM0\nDIVSS XMM0,dword ptr [RSP + 0x18]\nCVTSS2SD XMM0,XMM0\nMOVSD qword ptr [R13],XMM0\nPXOR XMM4,XMM4\nCVTSI2SS XMM4,dword ptr [RSP + 0xc]\nMOVSS XMM0,dword ptr [RBX + 0x14]\nMOVSS dword ptr [RSP + 0x18],XMM4\nDIVSS XMM0,XMM4\nPXOR XMM3,XMM3\nCVTSS2SD XMM3,XMM0\nMOVSD qword ptr [RSP + 0x10],XMM3\nMOVAPD XMM0,XMM3\nCALL 0x000f1a50\nMOVSD XMM3,qword ptr [RSP + 0x10]\nSUBSD XMM3,XMM0\nMOVAPD XMM0,XMM3\nPXOR XMM1,XMM1\nCVTSI2SD XMM1,dword ptr [RSP + 0xc]\nMULSD XMM0,XMM1\nCVTSD2SS XMM0,XMM0\nDIVSS XMM0,dword ptr [RSP + 0x18]\nCVTSS2SD XMM0,XMM0\nMOVSD qword ptr [R13 + 0x8],XMM0\nMOVSS XMM0,dword ptr [RBX]\nTEST R14D,R14D\nJNZ 0x00127f63\nCVTSS2SD XMM0,XMM0\nDIVSD XMM0,qword ptr [R12]\nPXOR XMM5,XMM5\nCVTSD2SS XMM5,XMM0\nMOVSS dword ptr [RBP],XMM5\nPXOR XMM0,XMM0\nCVTSS2SD XMM0,dword ptr [RBX + 0x4]\nDIVSD XMM0,qword ptr [R12]\nPXOR XMM6,XMM6\nCVTSD2SS XMM6,XMM0\nMOVSS dword ptr [RBP + 0x4],XMM6\nPXOR XMM0,XMM0\nCVTSS2SD XMM0,dword ptr [RBX + 0x8]\nDIVSD XMM0,qword ptr [R12 + 0x8]\nPXOR XMM5,XMM5\nCVTSD2SS XMM5,XMM0\nMOVSS dword ptr [RBP + 0x8],XMM5\nPXOR XMM0,XMM0\nCVTSS2SD XMM0,dword ptr [RBX + 0xc]\nMOVSD XMM1,qword ptr [R12 + 0x8]\nDIVSD XMM0,XMM1\nPXOR XMM4,XMM4\nCVTSD2SS XMM4,XMM0\nMOVSS dword ptr [RBP + 0xc],XMM4\nPXOR XMM0,XMM0\nCVTSS2SD XMM0,dword ptr [RBX + 0x10]\nSUBSD XMM0,qword ptr [R13]\nPXOR XMM5,XMM5\nCVTSD2SS XMM5,XMM0\nMOVSS dword ptr [RBP + 0x10],XMM5\nPXOR XMM0,XMM0\nCVTSS2SD XMM0,dword ptr [RBX + 0x14]\nSUBSD XMM0,qword ptr [R13 + 0x8]\nPXOR XMM6,XMM6\nCVTSD2SS XMM6,XMM0\nMOVSS dword ptr [RBP + 0x14],XMM6\nADD RSP,0x28\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV RDI,qword ptr [R15 + 0x18]\nCALL 0x0038ca2b\nXOR EAX,0x1\nMOV R14D,EAX\nAND R14D,0x1\nJMP 0x00127d89\nMOV qword ptr [R13],0x0\nPXOR XMM0,XMM0\nJMP 0x00127e6f\nMOVSS dword ptr [RBP],XMM0\nMOVSS XMM0,dword ptr [RBX + 0x4]\nMOVSS dword ptr [RBP + 0x4],XMM0\nMOVSS XMM0,dword ptr [RBX + 0x8]\nMOVSS dword ptr [RBP + 0x8],XMM0\nPXOR XMM0,XMM0\nCVTSS2SD XMM0,dword ptr [RBX + 0xc]\nMOVSD XMM1,qword ptr [0x0040ef58]\nJMP 0x00127ee2\n"}, "286": {"funcbody": "void [FUNC1] (TYPE14 [VAR1] )\n{\n  mem_node *pmVar1;\n  mem_node *pmVar2;\n  mem_node *pmVar3;\n  TYPE26 [VAR2] ;\n  \n  pmVar1 = [VAR1] ->right;\n  [VAR1] ->right = pmVar1->left;\n  if (pmVar1->left != &mem_z) {\n    pmVar1->left->parent = [VAR1] ;\n  }\n  if (pmVar1 != &mem_z) {\n    pmVar1->parent = [VAR1] ->parent;\n  }\n  pmVar2 = [VAR1] ->parent;\n  pmVar3 = pmVar1;\n  if (pmVar2 != (mem_node *)0x0) {\n    if (pmVar2->left == [VAR1] ) {\n      pmVar2->left = pmVar1;\n      pmVar3 = mem_root;\n    }\n    else {\n      pmVar2->right = pmVar1;\n      pmVar3 = mem_root;\n    }\n  }\n  mem_root = pmVar3;\n  pmVar1->left = [VAR1] ;\n  if ([VAR1] != &mem_z) {\n    [VAR1] ->parent = pmVar1;\n  }\n  return;\n}", "answer": {"VAR1": "x", "VAR2": "y", "FUNC1": "mem_rotate_left", "TYPE2": "mem_node *", "TYPE1": "mem_node *"}, "assembly": "MOV RAX,qword ptr [RDI + 0x8]\nMOV RDX,qword ptr [RAX]\nMOV qword ptr [RDI + 0x8],RDX\nMOV RDX,qword ptr [RAX]\nLEA RCX,[0x9a3d80]\nCMP RDX,RCX\nJZ 0x001c0746\nMOV qword ptr [RDX + 0x10],RDI\nLEA RDX,[0x9a3d80]\nCMP RAX,RDX\nJZ 0x001c075a\nMOV RDX,qword ptr [RDI + 0x10]\nMOV qword ptr [RAX + 0x10],RDX\nMOV RDX,qword ptr [RDI + 0x10]\nTEST RDX,RDX\nJZ 0x001c0786\nCMP qword ptr [RDX],RDI\nJZ 0x001c0781\nMOV qword ptr [RDX + 0x8],RAX\nMOV qword ptr [RAX],RDI\nLEA RDX,[0x9a3d80]\nCMP RDI,RDX\nJZ 0x001c077f\nMOV qword ptr [RDI + 0x10],RAX\nRET\nMOV qword ptr [RDX],RAX\nJMP 0x001c076c\nMOV qword ptr [0x009a3dc0],RAX\nJMP 0x001c076c\n"}, "287": {"funcbody": "int [FUNC1] (TYPE13 [VAR1] ,TYPE21 [VAR2] )\n{\n  DSA *key;\n  TYPE34 [VAR3] ;\n  \n  key = [FUNC2] ([VAR2] ,(OSSL_LIB_CTX *)0x0,(char *)0x0);\n  if (key != (DSA *)0x0) {\n    [FUNC3] ((EVP_PKEY *)[VAR1] ,0x74,key);\n  }\n  return (uint)(key != (DSA *)0x0);\n}", "answer": {"VAR1": "pkey", "VAR2": "p8", "VAR3": "dsa", "FUNC2": "ossl_dsa_key_from_pkcs8", "FUNC3": "EVP_PKEY_assign", "FUNC1": "dsa_priv_decode", "TYPE3": "DSA *", "TYPE2": "PKCS8_PRIV_KEY_INFO *", "TYPE1": "EVP_PKEY *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nMOV RDI,RSI\nMOV EDX,0x0\nMOV ESI,0x0\nCALL 0x00177997\nMOV ECX,0x0\nTEST RAX,RAX\nJZ 0x001771af\nMOV RDX,RAX\nMOV ESI,0x74\nMOV RDI,RBX\nCALL 0x000a33f2\nMOV ECX,0x1\nMOV EAX,ECX\nPOP RBX\nRET\n"}, "288": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  int iVar1;\n  [TYPE7] [VAR7] ;\n  \n  iVar1 = [FUNC2] ((BIGNUM *)[VAR5] ,(BIGNUM *)[VAR6] );\n  if (iVar1 == 0) {\n    [FUNC3] ((char *)0x0,[VAR1] ,[VAR2] ,\"BIGNUM\",[VAR3] ,[VAR4] ,\"!=\",[VAR5] ,[VAR6] );\n  }\n  return (uint)(iVar1 != 0);\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "s1", "VAR4": "s2", "VAR5": "t1", "VAR6": "t2", "FUNC2": "BN_cmp", "FUNC3": "test_fail_bignum_message", "FUNC1": "test_BN_ne", "TYPE3": "char *", "TYPE2": "int", "TYPE5": "BIGNUM *", "TYPE4": "char *", "TYPE7": "undefined8", "TYPE6": "BIGNUM *", "VAR7": "local_40", "TYPE1": "char *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV qword ptr [RSP + 0x8],RDI\nMOV R13D,ESI\nMOV R14,RDX\nMOV R15,RCX\nMOV RBP,R8\nMOV R12,R9\nMOV RSI,R9\nMOV RDI,R8\nCALL 0x000022a0\nMOV EBX,0x1\nTEST EAX,EAX\nJZ 0x00005eba\nMOV EAX,EBX\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV EBX,EAX\nSUB RSP,0x8\nPUSH R12\nPUSH RBP\nLEA RAX,[0xa4c8]\nPUSH RAX\nMOV R9,R15\nMOV R8,R14\nLEA RCX,[0xa5d6]\nMOV EDX,R13D\nMOV RSI,qword ptr [RSP + 0x28]\nMOV EDI,0x0\nCALL 0x00009cbd\nADD RSP,0x20\nJMP 0x00005ea9\n"}, "289": {"funcbody": "OSSL_PROPERTY_IDX [FUNC1] (TYPE12 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  CRYPTO_RWLOCK **ppCVar1;\n  TYPE41 [VAR4] ;\n  CRYPTO_RWLOCK **pidx;\n  \n  ppCVar1 = (CRYPTO_RWLOCK **)[FUNC3] ([VAR1] ,3,&property_string_data_method);\n  [VAR4] ._0_4_ = 0;\n  if (ppCVar1 != (CRYPTO_RWLOCK **)0x0) {\n    pidx = ppCVar1 + 3;\n    if ([VAR3] == 0) {\n      pidx = (CRYPTO_RWLOCK **)0x0;\n    }\n    [VAR4] ._0_4_ = [FUNC2] (*ppCVar1,(PROP_TABLE *)ppCVar1[1],(OSSL_PROPERTY_IDX *)pidx,[VAR2] );\n  }\n  return (OSSL_PROPERTY_IDX)[VAR4] ;\n}", "answer": {"VAR1": "ctx", "VAR2": "s", "VAR3": "create", "VAR4": "propdata", "FUNC2": "ossl_property_string", "FUNC3": "ossl_lib_ctx_get_data", "FUNC1": "ossl_property_name", "TYPE3": "int", "TYPE2": "char *", "TYPE4": "PROPERTY_STRING_DATA *", "TYPE1": "OSSL_LIB_CTX *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV EBX,EDX\nLEA RDX,[0x5dfdf0]\nMOV ESI,0x3\nCALL 0x001edaac\nMOV RDI,RAX\nMOV EAX,0x0\nTEST RDI,RDI\nJZ 0x00226270\nLEA RDX,[RDI + 0x18]\nTEST EBX,EBX\nMOV EAX,0x0\nCMOVZ RDX,RAX\nMOV RSI,qword ptr [RDI + 0x8]\nMOV RCX,RBP\nMOV RDI,qword ptr [RDI]\nCALL 0x00225e1d\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "290": {"funcbody": "int [FUNC1] (TYPE13 [VAR1] ,[TYPE2] [VAR2] ,TYPE32 [VAR3] )\n{\n  int iVar1;\n  [TYPE4] [VAR4] ;\n  uint uVar2;\n  BIO *in;\n  ulong uVar3;\n  \n  in = (BIO *)[FUNC8] ([VAR2] ,\"rb\");\n  if (in == (BIO *)0x0) {\n    uVar3 = [FUNC7] ();\n    uVar2 = (uint)uVar3 & 0x7fffff;\n    if ((uVar3 & 0x80000000) != 0) {\n      uVar2 = (uint)uVar3 & 0x7fffffff;\n    }\n    if (uVar2 == 0x80) {\n      [FUNC4] ();\n      [FUNC6] (\"crypto/conf/conf_def.c\",0xb3,\"def_load\");\n      [FUNC2] (0xe,0x72,(char *)0x0);\n      iVar1 = 0;\n    }\n    else {\n      [FUNC4] ();\n      [FUNC6] (\"crypto/conf/conf_def.c\",0xb5,\"def_load\");\n      [FUNC2] (0xe,0x80002,(char *)0x0);\n      iVar1 = 0;\n    }\n  }\n  else {\n    iVar1 = [FUNC3] ([VAR1] ,in,[VAR3] );\n    [FUNC5] ((BIO *)in);\n  }\n  return iVar1;\n}", "answer": {"VAR1": "conf", "VAR2": "name", "VAR3": "line", "VAR4": "ret", "FUNC2": "ERR_set_error", "FUNC3": "def_load_bio", "FUNC1": "def_load", "FUNC6": "ERR_set_debug", "TYPE3": "long *", "FUNC7": "ERR_peek_last_error", "TYPE2": "char *", "FUNC4": "ERR_new", "FUNC5": "BIO_free", "TYPE4": "int", "FUNC8": "BIO_new_file", "TYPE1": "CONF *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,RDI\nMOV RDI,RSI\nMOV R12,RDX\nLEA RSI,[0x277ef7]\nCALL 0x0007719c\nTEST RAX,RAX\nJZ 0x00217cf3\nMOV RBX,RAX\nMOV RDX,R12\nMOV RSI,RAX\nMOV RDI,RBP\nCALL 0x0021683d\nMOV EBP,EAX\nMOV RDI,RBX\nCALL 0x00072501\nMOV EAX,EBP\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x000807f8\nMOV RCX,RAX\nAND ECX,0x80000000\nMOV EDX,EAX\nAND EDX,0x7fffffff\nAND EAX,0x7fffff\nTEST RCX,RCX\nCMOVNZ EAX,EDX\nCMP EAX,0x80\nJZ 0x00217d58\nCALL 0x00080fae\nLEA RDX,[0x2a6a30]\nMOV ESI,0xb5\nLEA RDI,[0x2a6957]\nCALL 0x000810bb\nMOV EDX,0x0\nMOV ESI,0x80002\nMOV EDI,0xe\nMOV EAX,0x0\nCALL 0x000813d2\nMOV EBP,0x0\nJMP 0x00217cec\nCALL 0x00080fae\nLEA RDX,[0x2a6a30]\nMOV ESI,0xb3\nLEA RDI,[0x2a6957]\nCALL 0x000810bb\nMOV EDX,0x0\nMOV ESI,0x72\nMOV EDI,0xe\nMOV EAX,0x0\nCALL 0x000813d2\nMOV EBP,0x0\nJMP 0x00217cec\n"}, "291": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  uint uVar1;\n  [TYPE5] [VAR5] ;\n  int iVar2;\n  OSSL_LIB_CTX *ctx;\n  BN_CTX *ctx_00;\n  EC_GROUP *group;\n  EC_GROUP *group_00;\n  TYPE44 [VAR4] ;\n  \n  uVar1 = [FUNC4] ();\n  if ((uVar1 != 0) && (uVar1 = 1, ([VAR2] & 0x87U) != 0)) {\n    ctx = [FUNC6] ((EC_KEY *)[VAR1] );\n    ctx_00 = [FUNC11] (ctx);\n    uVar1 = 0;\n    if (ctx_00 != (BN_CTX *)0x0) {\n      uVar1 = 1;\n      if (([VAR2] & 4U) != 0) {\n        uVar1 = [FUNC2] ((EC_KEY *)[VAR1] );\n        if ((uVar1 & 0x2000) == 0) {\n          group_00 = [FUNC5] ((EC_KEY *)[VAR1] );\n          iVar2 = [FUNC3] (group_00,(BN_CTX *)ctx_00);\n          uVar1 = (uint)(iVar2 != 0);\n        }\n        else {\n          group = (EC_GROUP *)[FUNC5] ((EC_KEY *)[VAR1] );\n          iVar2 = [FUNC10] (group,uVar1 >> 0xe & 1,ctx_00);\n          uVar1 = (uint)(iVar2 != 0);\n        }\n      }\n      if (([VAR2] & 2U) != 0) {\n        if ([VAR3] == 1) {\n          if (uVar1 != 0) {\n            iVar2 = [FUNC13] ((EC_KEY *)[VAR1] ,ctx_00);\n            uVar1 = (uint)(iVar2 != 0);\n          }\n        }\n        else if (uVar1 != 0) {\n          iVar2 = [FUNC9] ((EC_KEY *)[VAR1] ,ctx_00);\n          uVar1 = (uint)(iVar2 != 0);\n        }\n      }\n      if ((([VAR2] & 1U) != 0) && (uVar1 != 0)) {\n        iVar2 = [FUNC12] ((EC_KEY *)[VAR1] );\n        uVar1 = (uint)(iVar2 != 0);\n      }\n      if ((([VAR2] & 3U) == 3) && (uVar1 != 0)) {\n        iVar2 = [FUNC7] ((EC_KEY *)[VAR1] ,ctx_00);\n        uVar1 = (uint)(iVar2 != 0);\n      }\n      [FUNC8] ((BN_CTX *)ctx_00);\n    }\n  }\n  return uVar1;\n}", "answer": {"FUNC12": "ossl_ec_key_private_check", "FUNC11": "BN_CTX_new_ex", "VAR1": "keydata", "FUNC13": "ossl_ec_key_public_check_quick", "VAR2": "selection", "VAR3": "checktype", "VAR4": "eck", "FUNC10": "EC_GROUP_check_named_curve", "VAR5": "flags", "FUNC2": "EC_KEY_get_flags", "FUNC3": "EC_GROUP_check", "FUNC1": "ec_validate", "FUNC6": "ossl_ec_key_get_libctx", "TYPE3": "int", "FUNC7": "ossl_ec_key_pairwise_check", "TYPE2": "int", "FUNC4": "ossl_prov_is_running", "TYPE5": "int", "FUNC5": "EC_KEY_get0_group", "TYPE4": "EC_KEY *", "FUNC8": "BN_CTX_free", "FUNC9": "ossl_ec_key_public_check", "TYPE1": "void *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R12,RDI\nMOV EBP,ESI\nMOV R13D,EDX\nCALL 0x000f1526\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x001208e0\nMOV EBX,0x1\nTEST BPL,0x87\nJNZ 0x001208eb\nMOV EAX,EBX\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV RDI,R12\nCALL 0x001932ac\nMOV RDI,RAX\nCALL 0x00160f58\nMOV R14,RAX\nMOV EBX,0x0\nTEST RAX,RAX\nJZ 0x001208e0\nMOV EBX,0x1\nTEST BPL,0x4\nJNZ 0x0012094f\nTEST BPL,0x2\nJZ 0x0012092b\nCMP R13D,0x1\nJZ 0x001209a3\nTEST EBX,EBX\nJNZ 0x001209bf\nTEST BPL,0x1\nJZ 0x00120939\nTEST EBX,EBX\nJNZ 0x001209d7\nAND EBP,0x3\nCMP EBP,0x3\nJZ 0x001209ec\nMOV RDI,R14\nCALL 0x00161040\nJMP 0x001208e0\nMOV RDI,R12\nCALL 0x0019364c\nMOV EBX,EAX\nTEST AH,0x20\nJZ 0x00120983\nMOV RDI,R12\nCALL 0x001932bb\nMOV ESI,EBX\nSHR ESI,0xe\nAND ESI,0x1\nMOV RDX,R14\nMOV RDI,RAX\nCALL 0x00191699\nTEST EAX,EAX\nSETNZ BL\nMOVZX EBX,BL\nJMP 0x00120913\nMOV RDI,R12\nCALL 0x001932bb\nMOV RSI,R14\nMOV RDI,RAX\nCALL 0x0019177f\nTEST EAX,EAX\nSETNZ BL\nMOVZX EBX,BL\nJMP 0x00120913\nTEST EBX,EBX\nJZ 0x0012092b\nMOV RSI,R14\nMOV RDI,R12\nCALL 0x00192c4b\nTEST EAX,EAX\nSETNZ BL\nMOVZX EBX,BL\nJMP 0x0012092b\nMOV RSI,R14\nMOV RDI,R12\nCALL 0x00192ea0\nTEST EAX,EAX\nSETNZ BL\nMOVZX EBX,BL\nJMP 0x0012092b\nMOV RDI,R12\nCALL 0x00192fe4\nTEST EAX,EAX\nSETNZ BL\nMOVZX EBX,BL\nJMP 0x00120939\nTEST EBX,EBX\nJZ 0x00120945\nMOV RSI,R14\nMOV RDI,R12\nCALL 0x001930a6\nTEST EAX,EAX\nSETNZ BL\nMOVZX EBX,BL\nJMP 0x00120945\n"}, "292": {"funcbody": "/* partial_symtab::end() */\nvoid partial_symtab::[FUNC1] (void)\n{\n  long lVar1;\n  long lVar2;\n  ulong uVar3;\n  _Iter_comp_iter in_ECX;\n  _Iter_comp_iter extraout_EDX;\n  long lVar4;\n  long lVar5;\n  __normal_iterator _Var6;\n  long in_RDI;\n  undefined in_R8B;\n  undefined in_R9B;\n  \n  std::vector<partial_symbol*,std::allocator<partial_symbol*>>::[FUNC5] ();\n  std::vector<partial_symbol*,std::allocator<partial_symbol*>>::[FUNC5] ();\n  lVar1 = *(long *)(in_RDI + 0x58);\n  lVar2 = *(long *)(in_RDI + 0x50);\n  if (lVar1 != lVar2) {\n    uVar3 = lVar1 - lVar2 >> 3;\n    lVar4 = 0x3f;\n    if (uVar3 != 0) {\n      for (; uVar3 >> lVar4 == 0; lVar4 = lVar4 + -1) {\n      }\n    }\n    _Var6 = (__normal_iterator)lVar2;\n    std::[FUNC4] (_Var6,(__normal_iterator)lVar1,(0x3f - (long)(int)((uint)lVar4 ^ 0x3f)) * 2,in_ECX,\n               in_R8B,in_R9B,0);\n    if (lVar1 - lVar2 < 0x81) {\n      std::[FUNC3] (_Var6,(__normal_iterator)lVar1,extraout_EDX);\n    }\n    else {\n      lVar4 = lVar2 + 0x80;\n      lVar5 = lVar4;\n      std::[FUNC3] (_Var6,(__normal_iterator)lVar4,extraout_EDX);\n      if (lVar1 != lVar4) {\n        do {\n          std::[FUNC2] ((__normal_iterator)lVar4,(_Val_comp_iter)lVar5);\n          lVar4 = lVar4 + 8;\n        } while (lVar4 != lVar2 + 0x88 + (lVar1 - (lVar2 + 0x88) & 0xfffffffffffffff8U));\n      }\n    }\n  }\n  return;\n}", "answer": {"FUNC2": "__unguarded_linear_insert<__gnu_cxx::__normal_iterator<partial_symbol**,std::vector<partial_symbol*,std::allocator<partial_symbol*>>>,__gnu_cxx::__ops::_Val_comp_iter<partial_symtab::end()::{lambda(partial_symbol*,partial_symbol*)#1}>>", "FUNC3": "__insertion_sort<__gnu_cxx::__normal_iterator<partial_symbol**,std::vector<partial_symbol*,std::allocator<partial_symbol*>>>,__gnu_cxx::__ops::_Iter_comp_iter<partial_symtab::end()::{lambda(partial_symbol*,partial_symbol*)#1}>>", "FUNC1": "end", "FUNC4": "FUNC1", "FUNC5": "_M_shrink_to_fit"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nLEA RDI,[RDI + 0x50]\nCALL 0x0046a60a\nLEA RDI,[RBX + 0x68]\nCALL 0x0046a60a\nMOV RBP,qword ptr [RBX + 0x58]\nMOV R12,qword ptr [RBX + 0x50]\nCMP RBP,R12\nJZ 0x004698d1\nMOV RBX,RBP\nSUB RBX,R12\nMOV RAX,RBX\nSAR RAX,0x3\nBSR RAX,RAX\nXOR RAX,0x3f\nCDQE\nMOV EDX,0x3f\nSUB RDX,RAX\nADD RDX,RDX\nSUB RSP,0x8\nPUSH 0x0\nMOV RSI,RBP\nMOV RDI,R12\nCALL 0x0046727c\nADD RSP,0x10\nCMP RBX,0x80\nJLE 0x004698bc\nLEA RBX,[R12 + 0x80]\nSUB RSP,0x8\nPUSH 0x0\nMOV RSI,RBX\nMOV RDI,R12\nCALL 0x00467873\nADD RSP,0x10\nCMP RBP,RBX\nJZ 0x004698d1\nADD R12,0x88\nSUB RBP,R12\nAND RBP,-0x8\nADD R12,RBP\nSUB RSP,0x8\nPUSH 0x0\nMOV RDI,RBX\nCALL 0x004670c4\nADD RBX,0x8\nADD RSP,0x10\nCMP RBX,R12\nJNZ 0x0046989f\nJMP 0x004698d1\nSUB RSP,0x8\nPUSH 0x0\nMOV RSI,RBP\nMOV RDI,R12\nCALL 0x00467873\nADD RSP,0x10\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "293": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  WINDOW *pWVar1;\n  chtype *__ptr;\n  [TYPE3] [VAR3] ;\n  SCREEN *pSVar2;\n  [TYPE2] [VAR2] ;\n  _win_list *p_Var3;\n  _win_list *__ptr_00;\n  int iVar4;\n  \n  if ([VAR1] == ([TYPE1] )0x0) {\n    return -1;\n  }\n  if (_nc_globals._nc_windowlist == (_win_list *)0x0) {\n    return -1;\n  }\n  __ptr_00 = _nc_globals._nc_windowlist;\n  if ([VAR1] == &(_nc_globals._nc_windowlist)->win) {\n    if (_nc_screen_chain != (SCREEN *)0x0) {\n      p_Var3 = (_win_list *)0x0;\nLAB_0000c370:\n      pSVar2 = _nc_screen_chain;\n      if ([VAR1] == _nc_screen_chain->_curscr) {\nLAB_0000c3d7:\n        pSVar2->_curscr = (WINDOW *)0x0;\n        if ([VAR1] == curscr) {\n          curscr = (WINDOW *)0x0;\n        }\n      }\n      else if ([VAR1] == _nc_screen_chain->_stdscr) {\nLAB_0000c41b:\n        pSVar2->_stdscr = (WINDOW *)0x0;\n        if ([VAR1] == stdscr) {\n          stdscr = (WINDOW *)0x0;\n        }\n      }\n      else {\n        pWVar1 = _nc_screen_chain->_newscr;\n        while ([VAR1] != pWVar1) {\n          pSVar2 = pSVar2->_next_screen;\n          if (pSVar2 == (SCREEN *)0x0) goto LAB_0000c3eb;\n          if ([VAR1] == pSVar2->_curscr) goto LAB_0000c3d7;\n          if ([VAR1] == pSVar2->_stdscr) goto LAB_0000c41b;\n          pWVar1 = pSVar2->_newscr;\n        }\n        pSVar2->_newscr = (WINDOW *)0x0;\n        if ([VAR1] == newscr) {\n          newscr = (WINDOW *)0x0;\n        }\n      }\n      goto LAB_0000c3eb;\n    }\n  }\n  else {\n    do {\n      p_Var3 = __ptr_00;\n      __ptr_00 = p_Var3->next;\n      if (__ptr_00 == (_win_list *)0x0) {\n        return -1;\n      }\n    } while (&__ptr_00->win != [VAR1] );\n    if (_nc_screen_chain != (SCREEN *)0x0) goto LAB_0000c370;\nLAB_0000c3eb:\n    if (p_Var3 != (_win_list *)0x0) {\n      p_Var3->next = __ptr_00->next;\n      goto LAB_0000c3f6;\n    }\n  }\n  _nc_globals._nc_windowlist = __ptr_00->next;\nLAB_0000c3f6:\n  if (((*(byte *)&[VAR1] ->_flags & 1) == 0) && (-1 < [VAR1] ->_maxy)) {\n    iVar4 = 0;\n    do {\n      __ptr = [VAR1] ->_line[iVar4].text;\n      if (__ptr != (chtype *)0x0) {\n        [FUNC2] (__ptr);\n      }\n      iVar4 = iVar4 + 1;\n    } while (iVar4 <= [VAR1] ->_maxy);\n  }\n  [FUNC2] ([VAR1] ->_line);\n  [FUNC2] (__ptr_00);\n  return 0;\n}", "answer": {"VAR1": "win", "VAR2": "p", "VAR3": "sp", "FUNC2": "free", "FUNC1": "_nc_freewin", "TYPE3": "SCREEN *", "TYPE2": "_win_list *", "TYPE1": "WINDOW *"}, "assembly": "TEST RDI,RDI\nJZ 0x0000c491\nMOV RDX,qword ptr [0x0023b470]\nMOV EAX,0xffffffff\nTEST RDX,RDX\nJZ 0x0000c4b3\nPUSH R12\nPUSH RBP\nPUSH RBX\nLEA RAX,[RDX + 0x10]\nCMP RDI,RAX\nJZ 0x0000c497\nMOV RBX,qword ptr [RDX]\nTEST RBX,RBX\nJZ 0x0000c48a\nLEA RAX,[RBX + 0x10]\nCMP RAX,RDI\nJZ 0x0000c364\nMOV RDX,RBX\nJMP 0x0000c34a\nMOV RAX,qword ptr [0x0023b898]\nTEST RAX,RAX\nJZ 0x0000c3eb\nCMP RDI,qword ptr [RAX + 0x80]\nJZ 0x0000c3d7\nCMP RDI,qword ptr [RAX + 0x90]\nJZ 0x0000c41b\nCMP RDI,qword ptr [RAX + 0x88]\nJZ 0x0000c3b6\nMOV RAX,qword ptr [RAX + 0x510]\nTEST RAX,RAX\nJZ 0x0000c3eb\nCMP RDI,qword ptr [RAX + 0x80]\nJZ 0x0000c3d7\nCMP RDI,qword ptr [RAX + 0x90]\nJZ 0x0000c41b\nCMP RDI,qword ptr [RAX + 0x88]\nJNZ 0x0000c38f\nMOV qword ptr [RAX + 0x88],0x0\nCMP RDI,qword ptr [0x0023b8a0]\nJNZ 0x0000c3eb\nMOV qword ptr [0x0023b8a0],0x0\nJMP 0x0000c3eb\nMOV qword ptr [RAX + 0x80],0x0\nCMP RDI,qword ptr [0x0023b8a8]\nJZ 0x0000c40e\nTEST RDX,RDX\nJZ 0x0000c43c\nMOV RAX,qword ptr [RBX]\nMOV qword ptr [RDX],RAX\nMOV RBP,RDI\nTEST byte ptr [RDI + 0xc],0x1\nJNZ 0x0000c46f\nCMP word ptr [RDI + 0x4],0x0\nJS 0x0000c46f\nMOV R12D,0x0\nJMP 0x0000c455\nMOV qword ptr [0x0023b8a8],0x0\nJMP 0x0000c3eb\nMOV qword ptr [RAX + 0x90],0x0\nCMP RDI,qword ptr [0x0023b8b0]\nJNZ 0x0000c3eb\nMOV qword ptr [0x0023b8b0],0x0\nJMP 0x0000c3eb\nMOV RAX,qword ptr [RBX]\nMOV qword ptr [0x0023b470],RAX\nJMP 0x0000c3f6\nADD R12D,0x1\nMOVSX EAX,word ptr [RBP + 0x4]\nCMP EAX,R12D\nJL 0x0000c46f\nMOVSXD RAX,R12D\nSHL RAX,0x4\nADD RAX,qword ptr [RBP + 0x28]\nMOV RDI,qword ptr [RAX]\nTEST RDI,RDI\nJZ 0x0000c448\nCALL 0x00007400\nJMP 0x0000c448\nMOV RDI,qword ptr [RBP + 0x28]\nCALL 0x00007400\nMOV RDI,RBX\nCALL 0x00007400\nMOV EAX,0x0\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV EAX,0xffffffff\nJMP 0x0000c485\nMOV EAX,0xffffffff\nRET\nMOV RAX,qword ptr [0x0023b898]\nMOV RBX,RDX\nTEST RAX,RAX\nJZ 0x0000c43c\nMOV RBX,RDX\nMOV EDX,0x0\nJMP 0x0000c370\nRET\n"}, "294": {"funcbody": "c448_error_t\n[FUNC1] ([TYPE1] [VAR1] ,TYPE25 [VAR2] ,TYPE31 [VAR3] ,TYPE45 [VAR4] ,\n     [TYPE5] [VAR5] ,TYPE69 [VAR6] ,TYPE75 [VAR7] ,TYPE89 [VAR8] ,\n     [TYPE9] [VAR9] )\n{\n  byte bVar1;\n  byte bVar2;\n  long lVar3;\n  int iVar4;\n  c448_error_t cVar5;\n  [TYPE10] [VAR10] ;\n  long lVar6;\n  c448_bool_t cVar7;\n  EVP_MD_CTX *hashctx;\n  long in_FS_OFFSET;\n  [TYPE20] [VAR20] ;\n  [TYPE19] [VAR19] ;\n  [TYPE18] [VAR18] ;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  [TYPE15] [VAR15] ;\n  [TYPE14] [VAR14] ;\n  [TYPE13] [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  \n  lVar3 = *(long *)(in_FS_OFFSET + 0x28);\n  if ([VAR2] [0x71] == '\\0') {\n    lVar6 = 0x37;\n    do {\n      bVar1 = [VAR2] [lVar6 + 0x39];\n      bVar2 = ossl_c448_ed448_verify::order[lVar6];\n      if (bVar1 >= bVar2 && bVar1 != bVar2) {\n        cVar5 = C448_FAILURE;\n        goto LAB_001794b6;\n      }\n      if (bVar1 < bVar2) {\n        cVar5 = [FUNC12] ([VAR14] ,[VAR3] );\n        if (cVar5 != C448_SUCCESS) goto LAB_001794b6;\n        cVar5 = [FUNC12] ([VAR13] ,[VAR2] );\n        if (cVar5 != C448_SUCCESS) goto LAB_001794b6;\n        hashctx = [FUNC11] ();\n        if (hashctx != (EVP_MD_CTX *)0x0) {\n          cVar5 = [FUNC5] ([VAR1] ,hashctx,[VAR6] ,'\\0',[VAR7] ,(ulong)[VAR8] ,[VAR9] );\n          if (cVar5 != C448_FAILURE) {\n            iVar4 = [FUNC9] ((EVP_MD_CTX *)hashctx,[VAR2] ,0x39);\n            if (iVar4 != 0) {\n              iVar4 = [FUNC9] ((EVP_MD_CTX *)hashctx,[VAR3] ,0x39);\n              if (iVar4 != 0) {\n                iVar4 = [FUNC9] ((EVP_MD_CTX *)hashctx,[VAR4] ,[VAR5] );\n                if (iVar4 != 0) {\n                  iVar4 = [FUNC3] (hashctx,[VAR12] ,0x72);\n                  if (iVar4 != 0) {\n                    [FUNC4] (hashctx);\n                    [FUNC6] ([VAR16] ,[VAR12] ,0x72);\n                    [FUNC13] ([VAR12] ,0x72);\n                    [FUNC2] ([VAR16] ,ossl_curve448_scalar_zero,[VAR16] );\n                    [FUNC6] ([VAR15] ,[VAR2] + 0x39,0x39);\n                    [FUNC8] ([VAR14] ,[VAR15] ,[VAR14] ,[VAR16] );\n                    cVar7 = [FUNC7] ([VAR14] ,[VAR13] );\n                    cVar5 = (c448_error_t)cVar7;\n                    goto LAB_001794b6;\n                  }\n                }\n              }\n            }\n          }\n        }\n        [FUNC4] (hashctx);\n        cVar5 = C448_FAILURE;\n        goto LAB_001794b6;\n      }\n      lVar6 = lVar6 + -1;\n    } while (lVar6 != -1);\n    cVar5 = C448_FAILURE;\n  }\n  else {\n    cVar5 = C448_FAILURE;\n  }\nLAB_001794b6:\n  if (lVar3 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return cVar5;\n  }\n  [FUNC10] ();\n}", "answer": {"TYPE19": "undefined8", "TYPE17": "EVP_MD_CTX *", "TYPE18": "undefined4", "TYPE20": "undefined8", "FUNC12": "ossl_curve448_point_decode_like_eddsa_and_mul_by_ratio", "FUNC11": "EVP_MD_CTX_new", "VAR1": "ctx", "FUNC13": "OPENSSL_cleanse", "VAR2": "signature", "VAR3": "pubkey", "VAR4": "message", "FUNC10": "__stack_chk_fail", "VAR5": "message_len", "VAR6": "prehashed", "VAR14": "pk_point", "VAR15": "response_scalar", "VAR12": "challenge", "VAR13": "r_point", "VAR18": "local_344", "VAR19": "local_350", "VAR16": "challenge_scalar", "VAR17": "hashctx", "VAR7": "context", "TYPE11": "undefined8", "VAR8": "context_len", "TYPE12": "uint8_t[114]", "VAR9": "propq", "TYPE10": "c448_error_t", "VAR10": "error", "TYPE15": "curve448_scalar_t", "VAR11": "local_40", "TYPE16": "curve448_scalar_t", "TYPE13": "curve448_point_t", "TYPE14": "curve448_point_t", "VAR20": "local_358", "FUNC2": "ossl_curve448_scalar_sub", "FUNC3": "EVP_DigestFinalXOF", "FUNC1": "ossl_c448_ed448_verify", "TYPE3": "uint8_t *", "FUNC6": "ossl_curve448_scalar_decode_long", "TYPE2": "uint8_t *", "FUNC7": "ossl_curve448_point_eq", "TYPE5": "size_t", "FUNC4": "EVP_MD_CTX_free", "TYPE4": "uint8_t *", "FUNC5": "hash_init_with_dom", "TYPE7": "uint8_t *", "TYPE6": "uint8_t", "TYPE9": "char *", "FUNC8": "ossl_curve448_base_double_scalarmul_non_secret", "TYPE8": "uint8_t", "FUNC9": "EVP_DigestUpdate", "TYPE1": "OSSL_LIB_CTX *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x328\nMOV qword ptr [RSP],RDI\nMOV qword ptr [RSP + 0x8],RCX\nMOV dword ptr [RSP + 0x14],R9D\nMOV R13,qword ptr [RSP + 0x360]\nMOV R15,qword ptr [RSP + 0x370]\nMOVZX R14D,byte ptr [RSP + 0x368]\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x318],RAX\nXOR EAX,EAX\nCMP byte ptr [RSI + 0x71],0x0\nJNZ 0x001794aa\nMOV RBX,RSI\nMOV RBP,RDX\nMOV R12,R8\nMOV EAX,0x37\nLEA RSI,[0x2957c0]\nMOVZX ECX,byte ptr [RBX + RAX*0x1 + 0x39]\nMOVZX EDX,byte ptr [RSI + RAX*0x1]\nCMP CL,DL\nJA 0x001794b1\nJC 0x001794df\nSUB RAX,0x1\nCMP RAX,-0x1\nJNZ 0x0017938b\nMOV EAX,0x0\nJMP 0x001794b6\nMOV EDX,0x39\nMOV RSI,RBX\nMOV RDI,qword ptr [RSP + 0x18]\nCALL 0x0009217f\nTEST EAX,EAX\nJZ 0x00179548\nMOV EDX,0x39\nMOV RSI,RBP\nMOV RDI,qword ptr [RSP + 0x18]\nCALL 0x0009217f\nTEST EAX,EAX\nJZ 0x00179548\nMOV RDX,R12\nMOV RSI,qword ptr [RSP + 0x8]\nMOV RDI,qword ptr [RSP + 0x18]\nCALL 0x0009217f\nTEST EAX,EAX\nJZ 0x00179548\nLEA RSI,[RSP + 0x2a0]\nMOV EDX,0x72\nMOV RDI,qword ptr [RSP + 0x18]\nCALL 0x00092512\nTEST EAX,EAX\nJZ 0x00179548\nMOV RDI,qword ptr [RSP + 0x18]\nCALL 0x00092db1\nLEA R12,[RSP + 0x2a0]\nLEA RBP,[RSP + 0x20]\nMOV EDX,0x72\nMOV RSI,R12\nMOV RDI,RBP\nCALL 0x0017a55b\nMOV ESI,0x72\nMOV RDI,R12\nCALL 0x000b8670\nMOV RDX,RBP\nLEA RSI,[0x295880]\nMOV RDI,RBP\nCALL 0x0017a3d1\nLEA RSI,[RBX + 0x39]\nLEA R12,[RSP + 0x60]\nMOV EDX,0x39\nMOV RDI,R12\nCALL 0x0017a55b\nLEA RBX,[RSP + 0xa0]\nMOV RCX,RBP\nMOV RDX,RBX\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x0017866a\nLEA RSI,[RSP + 0x1a0]\nMOV RDI,RBX\nCALL 0x00176e5c\nJMP 0x001794b6\nMOV EAX,0x0\nJMP 0x001794b6\nMOV EAX,0x0\nMOV RDI,qword ptr [RSP + 0x318]\nXOR RDI,qword ptr FS:[0x28]\nJNZ 0x0017955c\nADD RSP,0x328\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nLEA RDI,[RSP + 0xa0]\nMOV RSI,RBP\nCALL 0x00177292\nCMP EAX,-0x1\nJNZ 0x001794b6\nLEA RDI,[RSP + 0x1a0]\nMOV RSI,RBX\nCALL 0x00177292\nCMP EAX,-0x1\nJNZ 0x001794b6\nCALL 0x00092160\nMOV RSI,RAX\nMOV qword ptr [RSP + 0x18],RAX\nTEST RAX,RAX\nJZ 0x00179548\nMOVZX EDX,byte ptr [RSP + 0x14]\nSUB RSP,0x8\nPUSH R15\nMOVZX R9D,R14B\nMOV R8,R13\nMOV ECX,0x0\nMOV RDI,qword ptr [RSP + 0x10]\nCALL 0x00178cee\nADD RSP,0x10\nTEST EAX,EAX\nJNZ 0x001793b6\nMOV RDI,qword ptr [RSP + 0x18]\nCALL 0x00092db1\nMOV EAX,0x0\nJMP 0x001794b6\nCALL 0x000656c0\n"}, "295": {"funcbody": "/* Local variable cp:char * *[RDI:8] conflicts with parameter, skipped. */\nint [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  TYPE50 [VAR5] ;\n  int iVar1;\n  uint uVar2;\n  \n  uVar2 = *(uint *)*[VAR1] ;\n  if ((([VAR4] ->size & 1U) != 0) && (uVar2 == 0)) {\n    return -1;\n  }\n  iVar1 = 0;\n  if ((([VAR4] ->size & 2U) != 0) && ((int)uVar2 < 0)) {\n    uVar2 = -uVar2;\n    iVar1 = 1;\n  }\n  iVar1 = [FUNC2] ([VAR2] ,(ulong)uVar2,iVar1);\n  return iVar1;\n}", "answer": {"VAR1": "pval", "VAR2": "cont", "VAR3": "putype", "VAR4": "it", "VAR5": "utmp", "FUNC2": "ossl_i2c_uint64_int", "FUNC1": "uint32_i2c", "TYPE3": "int *", "TYPE2": "uchar *", "TYPE5": "uint32_t", "TYPE4": "ASN1_ITEM *", "TYPE1": "ASN1_VALUE * *"}, "assembly": "MOV RAX,qword ptr [RDI]\nMOV EAX,dword ptr [RAX]\nMOV RCX,qword ptr [RCX + 0x28]\nTEST CL,0x1\nJZ 0x0013f657\nTEST EAX,EAX\nJZ 0x0013f681\nSUB RSP,0x8\nMOV EDX,0x0\nTEST CL,0x2\nJZ 0x0013f669\nTEST EAX,EAX\nJS 0x0013f678\nMOV RDI,RSI\nMOV ESI,EAX\nCALL 0x001380e4\nADD RSP,0x8\nRET\nNEG EAX\nMOV EDX,0x1\nJMP 0x0013f669\nMOV EAX,0xffffffff\nRET\n"}, "296": {"funcbody": "int [FUNC1] (TYPE10 [VAR1] ,TYPE25 [VAR2] )\n{\n  int iVar1;\n  \n  if (*(code **)(*(long *)[VAR1] + 0x48) == (code *)0x0) {\n    [FUNC3] ();\n    [FUNC4] (\"crypto/ec/ec_lib.c\",0x267,\"EC_GROUP_check_discriminant\");\n    [FUNC2] (0x10,0xc0101,(char *)0x0);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = (**(code **)(*(long *)[VAR1] + 0x48))();\n  }\n  return iVar1;\n}", "answer": {"VAR1": "group", "VAR2": "ctx", "FUNC2": "ERR_set_error", "FUNC3": "ERR_new", "FUNC1": "EC_GROUP_check_discriminant", "TYPE2": "BN_CTX *", "FUNC4": "ERR_set_debug", "TYPE1": "EC_GROUP *"}, "assembly": "SUB RSP,0x8\nMOV RAX,qword ptr [RDI]\nMOV RAX,qword ptr [RAX + 0x48]\nTEST RAX,RAX\nJZ 0x00163379\nCALL RAX\nADD RSP,0x8\nRET\nCALL 0x00082e6e\nLEA RDX,[0x291870]\nMOV ESI,0x267\nLEA RDI,[0x2915db]\nCALL 0x00082f7b\nMOV EDX,0x0\nMOV ESI,0xc0101\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x00083292\nMOV EAX,0x0\nJMP 0x00163374\n"}, "297": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] )\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar2 = 0x1005;\n  if ([VAR2] - 2U < 2) {\n    [VAR8] [0] = *[VAR3] ;\n    [VAR7] [0] = 'z';\n    [VAR7] [1] = '\\0';\n    [VAR8] [1] = [VAR7] ;\n    [VAR8] [2] = [VAR3] [1];\n    if (2 < [VAR2] ) {\n      [VAR8] [3] = [VAR3] [2];\n    }\n    iVar2 = [FUNC3] ([VAR1] ,[VAR2] + 1,[VAR8] ,[VAR4] ,[VAR5] );\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "pglobal", "VAR2": "argc", "VAR3": "argv", "VAR4": "pvar", "VAR5": "pinfo", "VAR6": "local_10", "FUNC2": "__stack_chk_fail", "FUNC3": "iitimegrade", "FUNC1": "iitime", "TYPE3": "char * *", "TYPE2": "int", "TYPE5": "pointer", "TYPE4": "pointer", "TYPE7": "char[2]", "TYPE6": "undefined8", "TYPE8": "char *[4]", "VAR7": "ab", "VAR8": "aznew", "TYPE1": "pointer"}, "assembly": "SUB RSP,0x38\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x28],RAX\nXOR EAX,EAX\nLEA R9D,[RSI + -0x2]\nMOV EAX,0x1005\nCMP R9D,0x1\nJA 0x00010375\nMOV RAX,qword ptr [RDX]\nMOV qword ptr [RSP],RAX\nMOV byte ptr [RSP + 0x26],0x7a\nMOV byte ptr [RSP + 0x27],0x0\nLEA RAX,[RSP + 0x26]\nMOV qword ptr [RSP + 0x8],RAX\nMOV RAX,qword ptr [RDX + 0x8]\nMOV qword ptr [RSP + 0x10],RAX\nCMP ESI,0x2\nJLE 0x0001036a\nMOV RAX,qword ptr [RDX + 0x10]\nMOV qword ptr [RSP + 0x18],RAX\nMOV RDX,RSP\nADD ESI,0x1\nCALL 0x0001022e\nMOV RCX,qword ptr [RSP + 0x28]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0001038a\nADD RSP,0x38\nRET\nCALL 0x000036d0\n"}, "298": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  uint uVar1;\n  int iVar2;\n  ASN1_OBJECT *pAVar3;\n  ASN1_TYPE *a;\n  \n  if (([VAR2] != ([TYPE2] )0x0) && ([VAR1] != ([TYPE1] )0x0)) {\n    if ((ASN1_OBJECT *)[VAR1] ->algorithm != (ASN1_OBJECT *)0x0) {\n      [FUNC5] ((ASN1_OBJECT *)[VAR1] ->algorithm);\n    }\n    [VAR1] ->algorithm = (ASN1_OBJECT *)0x0;\n    if ((ASN1_TYPE *)[VAR1] ->parameter != (ASN1_TYPE *)0x0) {\n      [FUNC4] ((ASN1_TYPE *)[VAR1] ->parameter);\n    }\n    [VAR1] ->parameter = (ASN1_TYPE *)0x0;\n    if ((ASN1_OBJECT *)[VAR2] ->algorithm != (ASN1_OBJECT *)0x0) {\n      pAVar3 = [FUNC6] ((ASN1_OBJECT *)[VAR2] ->algorithm);\n      [VAR1] ->algorithm = (ASN1_OBJECT *)pAVar3;\n      if (pAVar3 == (ASN1_OBJECT *)0x0) {\n        return 0;\n      }\n    }\n    uVar1 = 1;\n    if ([VAR2] ->parameter != (ASN1_TYPE *)0x0) {\n      a = [FUNC2] ();\n      [VAR1] ->parameter = (ASN1_TYPE *)a;\n      uVar1 = 0;\n      if (a != (ASN1_TYPE *)0x0) {\n        iVar2 = [FUNC3] (a,[VAR2] ->parameter->type,([VAR2] ->parameter->value).ptr);\n        uVar1 = (uint)(iVar2 != 0);\n      }\n    }\n    return uVar1;\n  }\n  return 0;\n}", "answer": {"VAR1": "dest", "VAR2": "src", "FUNC2": "ASN1_TYPE_new", "FUNC3": "ASN1_TYPE_set1", "FUNC1": "X509_ALGOR_copy", "FUNC6": "OBJ_dup", "TYPE2": "X509_ALGOR *", "FUNC4": "ASN1_TYPE_free", "FUNC5": "ASN1_OBJECT_free", "TYPE1": "X509_ALGOR *"}, "assembly": "TEST RSI,RSI\nJZ 0x00083677\nTEST RDI,RDI\nJZ 0x00083677\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV RBX,RDI\nMOV RDI,qword ptr [RDI]\nTEST RDI,RDI\nJZ 0x000835fc\nCALL 0x0015e21d\nMOV qword ptr [RBX],0x0\nMOV RDI,qword ptr [RBX + 0x8]\nTEST RDI,RDI\nJZ 0x00083611\nCALL 0x00082c87\nMOV qword ptr [RBX + 0x8],0x0\nMOV RDI,qword ptr [RBP]\nTEST RDI,RDI\nJZ 0x00083637\nCALL 0x000db300\nMOV RDX,RAX\nMOV qword ptr [RBX],RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x00083670\nMOV EAX,0x1\nCMP qword ptr [RBP + 0x8],0x0\nJZ 0x00083670\nCALL 0x00082c71\nMOV RDI,RAX\nMOV qword ptr [RBX + 0x8],RAX\nMOV EAX,0x0\nTEST RDI,RDI\nJZ 0x00083670\nMOV RAX,qword ptr [RBP + 0x8]\nMOV RDX,qword ptr [RAX + 0x8]\nMOV ESI,dword ptr [RAX]\nCALL 0x00160af7\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV EAX,0x0\nRET\n"}, "299": {"funcbody": "int [FUNC1] (TYPE12 [VAR1] ,TYPE23 [VAR2] )\n{\n  [TYPE9] [VAR9] ;\n  char *pcVar2;\n  [TYPE3] [VAR3] ;\n  OPENSSL_STACK *st;\n  TYPE40 [VAR4] ;\n  int iVar1;\n  void *pvVar3;\n  TYPE104 [VAR10] ;\n  char *pcVar4;\n  [TYPE5] [VAR5] ;\n  char *__s;\n  [TYPE6] [VAR6] ;\n  char *pcVar5;\n  [TYPE7] [VAR7] ;\n  int iVar6;\n  [TYPE8] [VAR8] ;\n  char *pcVar7;\n  size_t __n;\n  char *[VAR11] ;\n  \n  pcVar2 = [FUNC10] ((CONF_IMODULE *)[VAR1] );\n  st = (OPENSSL_STACK *)[FUNC12] ((CONF *)[VAR2] ,pcVar2);\n  iVar6 = 0;\n  if (st == (OPENSSL_STACK *)0x0) {\n    [FUNC13] ();\n    [FUNC9] (\"crypto/asn1/asn_moid.c\",0x20,\"oid_module_init\");\n    [FUNC2] (0xd,0xac,(char *)0x0);\n    iVar6 = 0;\n  }\n  else {\n    for (; iVar1 = [FUNC3] (st), iVar6 < iVar1; iVar6 = iVar6 + 1) {\n      pvVar3 = [FUNC8] (st,iVar6);\n      pcVar2 = *(char **)((long)pvVar3 + 8);\n      __s = *(char **)((long)pvVar3 + 0x10);\n      pcVar4 = [FUNC5] (__s,0x2c);\n      if (pcVar4 == (char *)0x0) {\n        [VAR11] = (char *)0x0;\n        pcVar4 = pcVar2;\n      }\n      else {\n        pcVar5 = pcVar4;\n        if (pcVar4[1] == '\\0') goto LAB_00257203;\n        do {\n          pcVar5 = pcVar5 + 1;\n          iVar1 = [FUNC7] ((int)*pcVar5,8);\n        } while (iVar1 != 0);\n        while (iVar1 = [FUNC7] ((int)*__s,8), iVar1 != 0) {\n          __s = __s + 1;\n        }\n        while( true ) {\n          pcVar7 = pcVar4 + -1;\n          iVar1 = [FUNC7] ((int)*pcVar7,8);\n          if (iVar1 == 0) break;\n          pcVar4 = pcVar7;\n          if (__s == pcVar7) goto LAB_00257203;\n        }\n        __n = (long)pcVar4 - (long)__s;\n        [VAR11] = (char *)[FUNC11] ((int)__n + 1,\"crypto/asn1/asn_moid.c\",0x56);\n        if ([VAR11] == (char *)0x0) {\n          [FUNC13] ();\n          [FUNC9] (\"crypto/asn1/asn_moid.c\",0x57,\"do_create\");\n          [FUNC2] (0xd,0xc0100,(char *)0x0);\n          goto LAB_00257203;\n        }\n        [FUNC6] ([VAR11] ,__s,__n);\n        [VAR11] [__n] = '\\0';\n        __s = pcVar5;\n        pcVar4 = [VAR11] ;\n      }\n      iVar1 = [FUNC14] (__s,pcVar2,pcVar4);\n      [FUNC4] ([VAR11] );\n      if (iVar1 == 0) {\nLAB_00257203:\n        [FUNC13] ();\n        [FUNC9] (\"crypto/asn1/asn_moid.c\",0x26,\"oid_module_init\");\n        [FUNC2] (0xd,0xab,(char *)0x0);\n        return 0;\n      }\n    }\n    iVar6 = 1;\n  }\n  return iVar6;\n}", "answer": {"FUNC12": "NCONF_get_section", "FUNC11": "FUNC1", "FUNC14": "OBJ_create", "VAR1": "md", "FUNC13": "ERR_new", "VAR2": "cnf", "VAR3": "oid_section", "VAR4": "sktmp", "FUNC10": "CONF_imodule_get_value", "VAR5": "ln", "VAR6": "ostr", "FUNC2": "ERR_set_error", "FUNC3": "OPENSSL_sk_num", "FUNC1": "oid_module_init", "FUNC6": "memcpy", "TYPE3": "char *", "FUNC7": "ossl_ctype_check", "TYPE2": "CONF *", "FUNC4": "FUNC1", "TYPE5": "char *", "FUNC5": "strrchr", "TYPE4": "stack_st_CONF_VALUE *", "TYPE7": "int", "TYPE6": "char *", "FUNC8": "OPENSSL_sk_value", "TYPE9": "int", "FUNC9": "ERR_set_debug", "TYPE8": "char *", "VAR7": "i", "TYPE11": "undefined8", "VAR8": "p", "VAR9": "nid", "TYPE10": "CONF_VALUE *", "VAR10": "oval", "VAR11": "local_40", "TYPE1": "CONF_IMODULE *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBX,RSI\nCALL 0x0014bd81\nMOV RSI,RAX\nMOV RDI,RBX\nCALL 0x0014ab95\nMOV R13,RAX\nMOV R12D,0x0\nTEST RAX,RAX\nJNZ 0x0025727d\nCALL 0x00085359\nLEA RDX,[0x2aa930]\nMOV ESI,0x20\nLEA RDI,[0x2aa8f2]\nCALL 0x00085466\nMOV EDX,0x0\nMOV ESI,0xac\nMOV EDI,0xd\nMOV EAX,0x0\nCALL 0x0008577d\nMOV EAX,0x0\nJMP 0x002572ca\nADD RBP,0x1\nMOVSX EDI,byte ptr [RBP]\nMOV ESI,0x8\nCALL 0x0009ff86\nTEST EAX,EAX\nJNZ 0x0025712b\nJMP 0x00257147\nADD RBX,0x1\nMOVSX EDI,byte ptr [RBX]\nMOV ESI,0x8\nCALL 0x0009ff86\nTEST EAX,EAX\nJNZ 0x00257143\nSUB R15,0x1\nMOVSX EDI,byte ptr [R15]\nMOV ESI,0x8\nCALL 0x0009ff86\nTEST EAX,EAX\nJZ 0x0025717d\nCMP RBX,R15\nJZ 0x00257203\nSUB R15,0x1\nJMP 0x0025715c\nADD R15,0x1\nSUB R15,RBX\nMOV qword ptr [RSP + 0x8],R15\nLEA RDI,[R15 + 0x1]\nMOV EDX,0x56\nLEA RSI,[0x2aa8f2]\nCALL 0x000a1afc\nMOV R15,RAX\nTEST RAX,RAX\nJZ 0x002571cd\nMOV RDX,qword ptr [RSP + 0x8]\nMOV RSI,RBX\nMOV RDI,RAX\nCALL 0x00062840\nMOV RAX,qword ptr [RSP + 0x8]\nMOV byte ptr [R15 + RAX*0x1],0x0\nMOV qword ptr [RSP + 0x8],R15\nMOV RBX,RBP\nJMP 0x0025724f\nCALL 0x00085359\nLEA RDX,[0x2aa920]\nMOV ESI,0x57\nLEA RDI,[0x2aa8f2]\nCALL 0x00085466\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0xd\nMOV EAX,0x0\nCALL 0x0008577d\nCALL 0x00085359\nLEA RDX,[0x2aa930]\nMOV ESI,0x26\nLEA RDI,[0x2aa8f2]\nCALL 0x00085466\nMOV EDX,0x0\nMOV ESI,0xab\nMOV EDI,0xd\nMOV EAX,0x0\nCALL 0x0008577d\nMOV EAX,0x0\nJMP 0x002572ca\nMOV R15,R14\nMOV qword ptr [RSP + 0x8],0x0\nMOV RDX,R15\nMOV RSI,R14\nMOV RDI,RBX\nCALL 0x000ab743\nMOV EBX,EAX\nMOV EDX,0x61\nLEA RSI,[0x2aa8f2]\nMOV RDI,qword ptr [RSP + 0x8]\nCALL 0x000a1b3d\nTEST EBX,EBX\nJZ 0x00257203\nADD R12D,0x1\nMOV RDI,R13\nCALL 0x000baa80\nCMP EAX,R12D\nJLE 0x002572c5\nMOV ESI,R12D\nMOV RDI,R13\nCALL 0x000baa8e\nMOV R14,qword ptr [RAX + 0x8]\nMOV RBX,qword ptr [RAX + 0x10]\nMOV ESI,0x2c\nMOV RDI,RBX\nCALL 0x00062450\nMOV R15,RAX\nTEST RAX,RAX\nJZ 0x00257243\nCMP byte ptr [RAX + 0x1],0x0\nJZ 0x00257203\nLEA RBP,[RAX + 0x1]\nJMP 0x0025712f\nMOV EAX,0x1\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "300": {"funcbody": "void [FUNC1] (long param_1,long param_2,long param_3)\n{\n  long in_FS_OFFSET;\n  undefined auStack_188 [8];\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  long [VAR1] ;\n  \n  [VAR1] = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC3] (auStack_188,0x10,param_2 + param_3 * -2,param_3,0x15,0x80);\n  [FUNC3] (&[VAR4] ,0x10,param_2 + param_3 * -2 + 8,param_3,0x15,0x80);\n  [FUNC4] (param_1,param_3,&[VAR3] ,0x10,0x10,0);\n  [FUNC4] (param_1 + 8,param_3,&[VAR2] ,0x10,0x10,0);\n  if ([VAR1] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "local_30", "VAR2": "local_160", "VAR3": "local_168", "VAR4": "local_180", "FUNC2": "__stack_chk_fail", "FUNC3": "FUN_00ece580", "FUNC1": "FUN_00be98c0", "TYPE3": "undefined1", "TYPE2": "undefined1", "FUNC4": "FUN_00ece6f0", "TYPE4": "undefined1", "TYPE1": "undefined8"}, "assembly": "PUSH R14\nPUSH R13\nLEA R14,[RDX + RDX*0x1]\nPUSH R12\nPUSH RBP\nMOV R13,RSI\nPUSH RBX\nMOV RBP,RDX\nMOV RDX,RSI\nMOV R12,RDI\nSUB RDX,R14\nMOV R9D,0x80\nSUB RSP,0x160\nMOV R8D,0x15\nMOV RCX,RBP\nMOV RBX,RSP\nMOV ESI,0x10\nSUB R13,R14\nMOV RDI,RBX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x158],RAX\nXOR EAX,EAX\nCALL 0x00ece580\nLEA RDX,[R13 + 0x8]\nLEA RDI,[RBX + 0x8]\nMOV R9D,0x80\nMOV R8D,0x15\nMOV RCX,RBP\nMOV ESI,0x10\nCALL 0x00ece580\nLEA RDX,[RBX + 0x20]\nXOR R9D,R9D\nMOV R8D,0x10\nMOV ECX,0x10\nMOV RSI,RBP\nMOV RDI,R12\nCALL 0x00ece6f0\nLEA RDX,[RBX + 0x28]\nLEA RDI,[R12 + 0x8]\nXOR R9D,R9D\nMOV R8D,0x10\nMOV ECX,0x10\nMOV RSI,RBP\nCALL 0x00ece6f0\nMOV RAX,qword ptr [RSP + 0x158]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x00be9997\nADD RSP,0x160\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nCALL 0x0010cf30\n"}, "301": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  void *vctx;\n  TYPE20 [VAR2] ;\n  PROV_CIPHER_HW *hw;\n  \n  iVar1 = [FUNC2] ();\n  if (iVar1 == 0) {\n    vctx = (void *)0x0;\n  }\n  else {\n    vctx = [FUNC4] (0x1d8,\"providers/implementations/ciphers/cipher_aria.c\",0x4e);\n    if (vctx != (void *)0x0) {\n      hw = [FUNC5] (0xc0);\n      [FUNC3] (vctx,0xc0,8,0x80,3,0,hw,[VAR1] );\n    }\n  }\n  return vctx;\n}", "answer": {"VAR1": "provctx", "VAR2": "ctx", "FUNC2": "ossl_prov_is_running", "FUNC3": "ossl_cipher_generic_initkey", "FUNC1": "aria_192_cfb8_newctx", "TYPE2": "PROV_ARIA_CTX *", "FUNC4": "CRYPTO_zalloc", "FUNC5": "ossl_prov_cipher_hw_aria_cfb8", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nCALL 0x000ea026\nTEST EAX,EAX\nJZ 0x000f5945\nMOV EDX,0x4e\nLEA RSI,[0x287fd0]\nMOV EDI,0x1d8\nCALL 0x000b1ba3\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000f593b\nMOV EDI,0xc0\nCALL 0x000f5f15\nPUSH RBP\nPUSH RAX\nMOV R9D,0x0\nMOV R8D,0x3\nMOV ECX,0x80\nMOV EDX,0x8\nMOV ESI,0xc0\nMOV RDI,RBX\nCALL 0x0012db68\nADD RSP,0x10\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV EBX,0x0\nJMP 0x000f593b\n"}, "302": {"funcbody": "/* DWARF original prototype: void visit(TestAbsTermVisitor * this, Azimuth * param_1) */\nvoid __thiscall TestAbsTermVisitor::[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  double dVar1;\n  double dVar2;\n  \n  dVar1 = ([VAR1] ->b->super_VecBase<double,_int,_GNU_gama::Exception::matvec>).\n          super_MatVecBase<double,_int,_GNU_gama::Exception::matvec>.\n          super_MemRep<double,_int,_GNU_gama::Exception::matvec>.rep[[VAR1] ->indm + -1];\n  dVar2 = (double)((ulong)((dVar1 * [VAR1] ->d0) / DAT_00071bf8) & DAT_0005bfb0);\n  if (dVar2 < [VAR1] ->tol_abs_ || dVar2 == [VAR1] ->tol_abs_) {\n    [VAR1] ->val = 0.0;\n    return;\n  }\n  [VAR1] ->val = dVar1;\n  return;\n}", "answer": {"VAR1": "this", "VAR2": "param_2", "FUNC1": "visit", "TYPE2": "Azimuth *", "TYPE1": "TestAbsTermVisitor *"}, "assembly": "MOV RDX,qword ptr [RDI + 0x88]\nMOV EAX,dword ptr [RDI + 0x70]\nSUB EAX,0x1\nCDQE\nMOV RDX,qword ptr [RDX]\nMOVSD XMM1,qword ptr [RDX + RAX*0x8]\nMOVAPD XMM0,XMM1\nMULSD XMM0,qword ptr [RDI + 0xa0]\nDIVSD XMM0,qword ptr [0x00071bf8]\nANDPD XMM0,xmmword ptr [0x0005bfb0]\nUCOMISD XMM0,qword ptr [RDI + 0x90]\nJA 0x00034a55\nMOV qword ptr [RDI + 0x98],0x0\nRET\nMOVSD qword ptr [RDI + 0x98],XMM1\nRET\n"}, "303": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  \n  if ([VAR1] == (TYPE10x0) {\n    [FUNC3] (\"a != NULL\",\"src/math/ltm_desc.c\",0x107);\n  }\n  if ([VAR2] != (TYPE20x0) {\n    iVar1 = [FUNC2] ();\n    iVar1 = [FUNC4] (iVar1);\n    return iVar1;\n  }\n  [FUNC3] (\"b != NULL\",\"src/math/ltm_desc.c\",0x108);\n}", "answer": {"VAR1": "a", "VAR2": "b", "VAR3": "c", "VAR4": "d", "FUNC2": "mp_div", "FUNC3": "crypt_argchk", "FUNC1": "divide", "TYPE3": "void *", "TYPE2": "void *", "FUNC4": "mpi_to_ltc_error", "TYPE4": "void *", "TYPE1": "void *"}, "assembly": "SUB RSP,0x8\nTEST RDI,RDI\nJZ 0x00063aee\nTEST RSI,RSI\nJZ 0x00063b06\nCALL 0x00013d30\nMOV EDI,EAX\nCALL 0x000633a8\nADD RSP,0x8\nRET\nMOV EDX,0x107\nLEA RSI,[0xc0a81]\nLEA RDI,[0xad68e]\nCALL 0x00014260\nMOV EDX,0x108\nLEA RSI,[0xc0a81]\nLEA RDI,[0xc36ee]\nCALL 0x00014260\n"}, "304": {"funcbody": "undefined8 [FUNC1] (long param_1,int param_2)\n{\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  undefined8 uStack_18;\n  \n  iVar1 = [FUNC2] ();\n  if (iVar1 == 0) {\n    if (param_2 == 1) {\n      lVar2 = 0;\n      do {\n        *(byte *)(param_1 + lVar2) =\n             (byte)((int)lVar2 >> 1) & 3 | (byte)lVar2 & 0x38 | (byte)lVar2 * '\\x04' & 4;\n        lVar2 = lVar2 + 1;\n      } while (lVar2 != 0x40);\n    }\n    else if (param_2 == 0) {\n      lVar2 = 0;\n      do {\n        *(char *)(param_1 + lVar2) = (char)lVar2;\n        lVar2 = lVar2 + 1;\n      } while (lVar2 != 0x40);\n    }\n    else if (param_2 == 3) {\n      lVar2 = 0;\n      do {\n        *(byte *)(param_1 + lVar2) = (char)lVar2 * '\\b' & 0x38U | (byte)((int)lVar2 >> 3);\n        lVar2 = lVar2 + 1;\n      } while (lVar2 != 0x40);\n    }\n    else {\n      if (param_2 != 4) {\n        uVar3 = [FUNC3] (0,0x10,\"Internal error, IDCT permutation not set\\n\",uStack_18);\n        return uVar3;\n      }\n      lVar2 = 0;\n      do {\n        *(byte *)(param_1 + lVar2) =\n             (byte)((int)lVar2 >> 3) & 3 | (byte)lVar2 & 0x24 | (byte)lVar2 * '\\b' & 0x18;\n        lVar2 = lVar2 + 1;\n      } while (lVar2 != 0x40);\n    }\n  }\n  return uStack_18;\n}", "answer": {"FUNC2": "FUN_0017272d", "FUNC3": "FUN_00fb6de0", "FUNC1": "FUN_001475a1"}, "assembly": "PUSH RBP\nPUSH RBX\nMOV EBP,ESI\nMOV RBX,RDI\nSUB RSP,0x8\nCALL 0x0017272d\nTEST EAX,EAX\nJNZ 0x00147671\nCMP EBP,0x1\nJZ 0x001475e5\nJC 0x001475d2\nCMP EBP,0x3\nJZ 0x0014760f\nCMP EBP,0x4\nJNZ 0x00147659\nXOR EAX,EAX\nJMP 0x00147630\nXOR EAX,EAX\nMOV byte ptr [RBX + RAX*0x1],AL\nINC RAX\nCMP RAX,0x40\nJNZ 0x001475d4\nJMP 0x00147671\nXOR EAX,EAX\nMOV EDX,EAX\nMOV CL,AL\nSAR EDX,0x1\nAND ECX,0x38\nAND EDX,0x3\nOR EDX,ECX\nLEA ECX,[RAX*0x4]\nAND ECX,0x4\nOR EDX,ECX\nMOV byte ptr [RBX + RAX*0x1],DL\nINC RAX\nCMP RAX,0x40\nJNZ 0x001475e7\nJMP 0x00147671\nXOR EAX,EAX\nLEA EDX,[RAX*0x8]\nMOV ECX,EAX\nSAR ECX,0x3\nAND EDX,0x38\nOR EDX,ECX\nMOV byte ptr [RBX + RAX*0x1],DL\nINC RAX\nCMP RAX,0x40\nJNZ 0x00147611\nJMP 0x00147671\nMOV EDX,EAX\nMOV CL,AL\nSAR EDX,0x3\nAND ECX,0x24\nAND EDX,0x3\nOR EDX,ECX\nLEA ECX,[RAX*0x8]\nAND ECX,0x18\nOR EDX,ECX\nMOV byte ptr [RBX + RAX*0x1],DL\nINC RAX\nCMP RAX,0x40\nJNZ 0x00147630\nJMP 0x00147671\nPOP RCX\nPOP RBX\nPOP RBP\nLEA RDX,[0x113f5b0]\nMOV ESI,0x10\nXOR EDI,EDI\nXOR EAX,EAX\nJMP 0x00fb6de0\nPOP RAX\nPOP RBX\nPOP RBP\nRET\n"}, "305": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  void *vctx;\n  TYPE28 [VAR2] ;\n  PROV_CIPHER_HW *hw;\n  \n  iVar1 = [FUNC5] ();\n  if (iVar1 == 0) {\n    vctx = (void *)0x0;\n  }\n  else {\n    vctx = [FUNC2] (0x1c0,\"providers/implementations/ciphers/cipher_aes.c\",0x4f);\n    if (vctx != (void *)0x0) {\n      hw = [FUNC4] (0xc0);\n      [FUNC3] (vctx,0xc0,8,0x80,3,0,hw,[VAR1] );\n    }\n  }\n  return vctx;\n}", "answer": {"VAR1": "provctx", "VAR2": "ctx", "FUNC2": "CRYPTO_zalloc", "FUNC3": "ossl_cipher_generic_initkey", "FUNC1": "aes_192_cfb1_newctx", "TYPE2": "PROV_AES_CTX *", "FUNC4": "ossl_prov_cipher_hw_aes_cfb1", "FUNC5": "ossl_prov_is_running", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nCALL 0x000de31c\nTEST EAX,EAX\nJZ 0x000e123c\nMOV EDX,0x4f\nLEA RSI,[0x282f78]\nMOV EDI,0x1c0\nCALL 0x000a8716\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000e1232\nMOV EDI,0xc0\nCALL 0x000e62e3\nPUSH RBP\nPUSH RAX\nMOV R9D,0x0\nMOV R8D,0x3\nMOV ECX,0x80\nMOV EDX,0x8\nMOV ESI,0xc0\nMOV RDI,RBX\nCALL 0x00121e5e\nADD RSP,0x10\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV EBX,0x0\nJMP 0x000e1232\n"}, "306": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,...)\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  char *path;\n  [TYPE4] [VAR4] ;\n  int *piVar3;\n  undefined8 in_RCX;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  [TYPE18] [VAR18] ;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  undefined8 [VAR15] ;\n  undefined8 [VAR14] ;\n  undefined8 [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  if (in_AL != '\\0') {\n    [VAR12] ._0_4_ = in_XMM0_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR18] [0].gp_offset = 0x18;\n  [VAR18] [0].fp_offset = 0x30;\n  [VAR18] [0].overflow_arg_area = &stack0x00000008;\n  [VAR18] [0].reg_save_area = &[VAR16] ;\n  [VAR15] = in_RCX;\n  [VAR14] = in_R8;\n  [VAR13] = in_R9;\n  path = [FUNC4] ([VAR1] ,[VAR3] ,[VAR18] );\n  if (path == (char *)0x0) {\n    piVar3 = [FUNC3] ();\n    iVar2 = -*piVar3;\n  }\n  else {\n    iVar2 = [FUNC2] ([VAR1] ,[VAR2] ,path);\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC5] ();\n}", "answer": {"TYPE17": "undefined8", "TYPE18": "va_list", "VAR1": "pc", "VAR2": "res", "VAR3": "path", "VAR4": "p", "VAR5": "local_28", "VAR6": "local_38", "FUNC2": "ul_path_read_majmin", "FUNC3": "__errno_location", "FUNC1": "ul_path_readf_majmin", "TYPE3": "char *", "VAR14": "local_a8", "TYPE2": "dev_t *", "VAR15": "local_b0", "FUNC4": "ul_path_mkpath", "TYPE5": "undefined1[16]", "VAR12": "local_98", "FUNC5": "__stack_chk_fail", "TYPE4": "char *", "VAR13": "local_a0", "TYPE7": "undefined1[16]", "VAR18": "ap", "TYPE6": "undefined1[16]", "TYPE9": "undefined1[16]", "VAR16": "local_c8", "TYPE8": "undefined1[16]", "VAR17": "local_d0", "VAR7": "local_48", "TYPE11": "undefined1[16]", "VAR8": "local_58", "TYPE12": "undefined1[16]", "VAR9": "local_68", "TYPE10": "undefined1[16]", "VAR10": "local_78", "TYPE15": "undefined8", "VAR11": "local_88", "TYPE16": "undefined1", "TYPE1": "path_cxt *", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0xd8\nMOV RBX,RDI\nMOV RBP,RSI\nMOV RSI,RDX\nMOV qword ptr [RSP + 0x38],RCX\nMOV qword ptr [RSP + 0x40],R8\nMOV qword ptr [RSP + 0x48],R9\nTEST AL,AL\nJZ 0x0000ec84\nMOVAPS xmmword ptr [RSP + 0x50],XMM0\nMOVAPS xmmword ptr [RSP + 0x60],XMM1\nMOVAPS xmmword ptr [RSP + 0x70],XMM2\nMOVAPS xmmword ptr [RSP + 0x80],XMM3\nMOVAPS xmmword ptr [RSP + 0x90],XMM4\nMOVAPS xmmword ptr [RSP + 0xa0],XMM5\nMOVAPS xmmword ptr [RSP + 0xb0],XMM6\nMOVAPS xmmword ptr [RSP + 0xc0],XMM7\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0x18\nMOV dword ptr [RSP + 0x4],0x30\nLEA RAX,[RSP + 0xf0]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nMOV RDX,RSP\nMOV RDI,RBX\nCALL 0x0000c7d4\nTEST RAX,RAX\nJZ 0x0000ecf2\nMOV RDX,RAX\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x0000eb6f\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0000ecfd\nADD RSP,0xd8\nPOP RBX\nPOP RBP\nRET\nCALL 0x000039a0\nMOV EAX,dword ptr [RAX]\nNEG EAX\nJMP 0x0000ecd8\nCALL 0x00003b80\n"}, "307": {"funcbody": "void [FUNC1] (void)\n{\n  undefined8 uVar1;\n  \n  [FUNC2] (10,stdout);\n  uVar1 = [FUNC3] (0,\"Report bugs to: %s\\n\",5);\n  [FUNC4] (1,uVar1,\"bug-coreutils@gnu.org\");\n  uVar1 = [FUNC3] (0,\"%s home page: <%s>\\n\",5);\n  [FUNC4] (1,uVar1,\"GNU coreutils\",\"https://www.gnu.org/software/coreutils/\");\n  uVar1 = [FUNC3] (0,\"General help using GNU software: <%s>\\n\",5);\n  [FUNC4] (1,uVar1,\"https://www.gnu.org/gethelp/\");\n  return;\n}", "answer": {"FUNC2": "fputc_unlocked", "FUNC3": "dcgettext", "FUNC1": "emit_bug_reporting_address", "FUNC4": "__printf_chk"}, "assembly": "SUB RSP,0x8\nMOV RSI,qword ptr [0x00208088]\nMOV EDI,0xa\nCALL 0x000015b0\nMOV EDX,0x5\nLEA RSI,[0x6182]\nMOV EDI,0x0\nCALL 0x000014a0\nLEA RDX,[0x6196]\nMOV RSI,RAX\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x00001640\nMOV EDX,0x5\nLEA RSI,[0x61ac]\nMOV EDI,0x0\nCALL 0x000014a0\nLEA RCX,[0x5b70]\nLEA RDX,[0x5980]\nMOV RSI,RAX\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x00001640\nMOV EDX,0x5\nLEA RSI,[0x6400]\nMOV EDI,0x0\nCALL 0x000014a0\nLEA RDX,[0x61c0]\nMOV RSI,RAX\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x00001640\nADD RSP,0x8\nRET\n"}, "308": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  undefined8 *ptr;\n  [TYPE2] [VAR2] ;\n  \n  ptr = (undefined8 *)[FUNC7] ();\n  [FUNC6] (*ptr,[FUNC4] );\n  [FUNC3] (ptr);\n  [FUNC5] ([VAR1] ,0);\n  [FUNC2] ([VAR1] ,0);\n  return 1;\n}", "answer": {"VAR1": "bio", "VAR2": "ctx", "FUNC2": "BIO_set_init", "FUNC3": "CRYPTO_free", "FUNC1": "mempacket_test_free", "FUNC6": "OPENSSL_sk_pop_free", "FUNC7": "BIO_get_data", "TYPE2": "MEMPACKET_TEST_CTX *", "FUNC4": "mempacket_free", "FUNC5": "BIO_set_data", "TYPE1": "BIO *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nCALL 0x00003570\nMOV RBP,RAX\nLEA RSI,[0x3be0]\nMOV RDI,qword ptr [RAX]\nCALL 0x000034c0\nMOV EDX,0x149\nLEA RSI,[0xd12c]\nMOV RDI,RBP\nCALL 0x00002f40\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x000030c0\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x00002f20\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "309": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE26 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,TYPE69 [VAR6] ,[TYPE7] [VAR7] )\n{\n  int iVar1;\n  \n  if ([VAR4] == ([TYPE4] )0x0) {\n    if (([VAR5] & 1U) == 0) {\n      [FUNC5] ();\n      [FUNC8] (\"providers/implementations/encode_decode/encode_key2any.c\",0x568,\n            \"ec_to_PrivateKeyInfo_der_encode\");\n      [FUNC7] (0x39,0x80106,(char *)0x0);\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = [FUNC6] ((key2any_ctx_st *)[VAR1] ,[VAR2] ,[VAR3] ,0x198,\"EC PRIVATE KEY\",(check_key_type_fn *)0x0\n                    ,[FUNC3] ,[VAR6] ,[VAR7] ,[FUNC4] ,[FUNC2] );\n    }\n  }\n  else {\n    [FUNC5] ();\n    [FUNC8] (\"providers/implementations/encode_decode/encode_key2any.c\",0x568,\n          \"ec_to_PrivateKeyInfo_der_encode\");\n    [FUNC7] (0x39,0x80106,(char *)0x0);\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "cout", "VAR3": "key", "VAR4": "key_abstract", "VAR5": "selection", "VAR6": "cb", "FUNC2": "ec_pki_priv_to_der", "FUNC3": "key_to_pki_der_priv_bio", "FUNC1": "ec_to_PrivateKeyInfo_der_encode", "FUNC6": "key2any_encode", "TYPE3": "void *", "FUNC7": "ERR_set_error", "TYPE2": "OSSL_CORE_BIO *", "FUNC4": "prepare_ec_params", "TYPE5": "int", "FUNC5": "ERR_new", "TYPE4": "OSSL_PARAM *", "TYPE7": "void *", "TYPE6": "OSSL_PASSPHRASE_CALLBACK *", "FUNC8": "ERR_set_debug", "VAR7": "cbarg", "TYPE1": "void *"}, "assembly": "PUSH RBX\nTEST RCX,RCX\nJNZ 0x001035c1\nMOV EBX,R8D\nAND EBX,0x1\nJNZ 0x00103600\nCALL 0x0009068b\nLEA RDX,[0x288100]\nMOV ESI,0x568\nLEA RDI,[0x287450]\nCALL 0x00090798\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00090aaf\nJMP 0x001035fc\nCALL 0x0009068b\nLEA RDX,[0x288100]\nMOV ESI,0x568\nLEA RDI,[0x287450]\nCALL 0x00090798\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00090aaf\nMOV EBX,0x0\nMOV EAX,EBX\nPOP RBX\nRET\nSUB RSP,0x8\nLEA RAX,[0x1088f9]\nPUSH RAX\nLEA RAX,[0x107d6a]\nPUSH RAX\nPUSH qword ptr [RSP + 0x28]\nPUSH R9\nLEA RAX,[0x10827a]\nPUSH RAX\nMOV R9D,0x0\nLEA R8,[0x287351]\nMOV ECX,0x198\nCALL 0x00100f5e\nMOV EBX,EAX\nADD RSP,0x30\nJMP 0x001035fc\n"}, "310": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE24 [VAR2] ,[TYPE3] [VAR3] ,TYPE41 [VAR4] ,\n         [TYPE5] [VAR5] )\n{\n  long lVar1;\n  TYPE61 [VAR6] ;\n  int iVar2;\n  uint uVar3;\n  long in_FS_OFFSET;\n  [TYPE9] [VAR9] ;\n  TYPE83 [VAR8] ;\n  [TYPE7] [VAR7] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ([VAR1] < 0x100000000) {\n    if ([VAR1] < 0x10000) {\n      if ([VAR1] < 0x100) {\n        [VAR9] = ([TYPE9] )[VAR1] ;\n        [VAR6] = [VAR2] & 4;\n        if (-1 < (char)[VAR9] ) {\n          [VAR6] = [VAR2] & char_type[[VAR1] & 0xff];\n        }\n        if (([VAR6] & 0x61) == 0) {\n          if (([VAR6] & 0x406) == 0) {\n            if (([VAR9] == '\\\\') && (([VAR2] & 0x40f) != 0)) {\n              iVar2 = (*[VAR4] )([VAR5] ,&DAT_0027afc8,2);\n              uVar3 = -(uint)(iVar2 == 0) | 2;\n            }\n            else {\n              iVar2 = (*[VAR4] )([VAR5] ,&[VAR9] ,1);\n              uVar3 = -(uint)(iVar2 == 0) | 1;\n            }\n          }\n          else {\n            [FUNC2] ([VAR8] ,0xb,\"\\\\%02X\",[VAR1] & 0xff);\n            iVar2 = (*[VAR4] )([VAR5] ,[VAR8] ,3);\n            uVar3 = -(uint)(iVar2 == 0) | 3;\n          }\n        }\n        else if (([VAR6] & 8) == 0) {\n          iVar2 = (*[VAR4] )([VAR5] ,&DAT_0027afc9,1);\n          if (iVar2 == 0) {\n            uVar3 = 0xffffffff;\n          }\n          else {\n            iVar2 = (*[VAR4] )([VAR5] ,&[VAR9] ,1);\n            uVar3 = -(uint)(iVar2 == 0) | 2;\n          }\n        }\n        else {\n          if ([VAR3] != (TYPE30x0) {\n            *[VAR3] = '\\x01';\n          }\n          iVar2 = (*[VAR4] )([VAR5] ,&[VAR9] ,1);\n          uVar3 = -(uint)(iVar2 == 0) | 1;\n        }\n      }\n      else {\n        [FUNC2] ([VAR8] ,0x13,\"\\\\U%04lX\",[VAR1] );\n        iVar2 = (*[VAR4] )([VAR5] ,[VAR8] ,6);\n        uVar3 = -(uint)(iVar2 == 0) | 6;\n      }\n    }\n    else {\n      [FUNC2] ([VAR8] ,0x13,\"\\\\W%08lX\",[VAR1] );\n      iVar2 = (*[VAR4] )([VAR5] ,[VAR8] ,10);\n      uVar3 = -(uint)(iVar2 == 0) | 10;\n    }\n  }\n  else {\n    uVar3 = 0xffffffff;\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "c", "VAR2": "flags", "VAR3": "do_quotes", "VAR4": "io_ch", "VAR5": "arg", "VAR6": "chflgs", "FUNC2": "BIO_snprintf", "FUNC3": "__stack_chk_fail", "FUNC1": "do_esc_char", "TYPE3": "char *", "TYPE2": "ushort", "TYPE5": "void *", "TYPE4": "char_io *", "TYPE7": "undefined8", "TYPE6": "ushort", "TYPE9": "uchar", "TYPE8": "char[19]", "VAR7": "local_20", "VAR8": "tmphex", "VAR9": "chtmp", "TYPE1": "ulong"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x30\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x28],RAX\nXOR EAX,EAX\nMOV EAX,0xffffffff\nCMP RDI,RAX\nJA 0x0012e75a\nMOV RBX,RCX\nMOV RBP,R8\nCMP RDI,0xffff\nJA 0x0012e624\nCMP RDI,0xff\nJA 0x0012e677\nMOV byte ptr [RSP + 0xf],DIL\nMOV EAX,ESI\nAND EAX,0x4\nTEST DIL,DIL\nJS 0x0012e5e2\nMOVZX EAX,DIL\nLEA RCX,[0x27b060]\nMOV R9D,ESI\nAND R9W,word ptr [RCX + RAX*0x2]\nMOV EAX,R9D\nTEST AL,0x61\nJZ 0x0012e6d0\nTEST AL,0x8\nJNZ 0x0012e6af\nMOV EDX,0x1\nLEA RSI,[0x27afc9]\nMOV RDI,RBP\nCALL RBX\nTEST EAX,EAX\nJZ 0x0012e764\nLEA RSI,[RSP + 0xf]\nMOV EDX,0x1\nMOV RDI,RBP\nCALL RBX\nCMP EAX,0x1\nSBB EAX,EAX\nOR EAX,0x2\nJMP 0x0012e65a\nLEA R12,[RSP + 0x10]\nMOV RCX,RDI\nLEA RDX,[0x27afb2]\nMOV ESI,0x13\nMOV RDI,R12\nMOV EAX,0x0\nCALL 0x00075c88\nMOV EDX,0xa\nMOV RSI,R12\nMOV RDI,RBP\nCALL RBX\nCMP EAX,0x1\nSBB EAX,EAX\nOR EAX,0xa\nMOV RBX,qword ptr [RSP + 0x28]\nXOR RBX,qword ptr FS:[0x28]\nJNZ 0x0012e76e\nADD RSP,0x30\nPOP RBX\nPOP RBP\nPOP R12\nRET\nLEA R12,[RSP + 0x10]\nMOV RCX,RDI\nLEA RDX,[0x27afba]\nMOV ESI,0x13\nMOV RDI,R12\nMOV EAX,0x0\nCALL 0x00075c88\nMOV EDX,0x6\nMOV RSI,R12\nMOV RDI,RBP\nCALL RBX\nCMP EAX,0x1\nSBB EAX,EAX\nOR EAX,0x6\nJMP 0x0012e65a\nTEST RDX,RDX\nJZ 0x0012e6b7\nMOV byte ptr [RDX],0x1\nLEA RSI,[RSP + 0xf]\nMOV EDX,0x1\nMOV RDI,RBP\nCALL RBX\nCMP EAX,0x1\nSBB EAX,EAX\nOR EAX,0x1\nJMP 0x0012e65a\nTEST AX,0x406\nJNZ 0x0012e6f8\nCMP DIL,0x5c\nJZ 0x0012e734\nLEA RSI,[RSP + 0xf]\nMOV EDX,0x1\nMOV RDI,RBP\nCALL RBX\nCMP EAX,0x1\nSBB EAX,EAX\nOR EAX,0x1\nJMP 0x0012e65a\nMOVZX ECX,DIL\nLEA R12,[RSP + 0x10]\nLEA RDX,[0x27afc2]\nMOV ESI,0xb\nMOV RDI,R12\nMOV EAX,0x0\nCALL 0x00075c88\nMOV EDX,0x3\nMOV RSI,R12\nMOV RDI,RBP\nCALL RBX\nCMP EAX,0x1\nSBB EAX,EAX\nOR EAX,0x3\nJMP 0x0012e65a\nTEST ESI,0x40f\nJZ 0x0012e6dc\nMOV EDX,0x2\nLEA RSI,[0x27afc8]\nMOV RDI,RBP\nCALL RBX\nCMP EAX,0x1\nSBB EAX,EAX\nOR EAX,0x2\nJMP 0x0012e65a\nMOV EAX,0xffffffff\nJMP 0x0012e65a\nMOV EAX,0xffffffff\nJMP 0x0012e65a\nCALL 0x00062690\n"}, "311": {"funcbody": "int [FUNC1] (TYPE16 [VAR1] ,TYPE24 [VAR2] )\n{\n  int iVar1;\n  OPENSSL_STACK *pOVar2;\n  \n  if ([VAR1] ->policies == (stack_st_ASN1_OBJECT *)0x0) {\n    pOVar2 = [FUNC2] ();\n    [VAR1] ->policies = (stack_st_ASN1_OBJECT *)pOVar2;\n    if (pOVar2 == (OPENSSL_STACK *)0x0) {\n      return 0;\n    }\n  }\n  iVar1 = [FUNC3] ((OPENSSL_STACK *)[VAR1] ->policies,[VAR2] );\n  return iVar1;\n}", "answer": {"VAR1": "param", "VAR2": "policy", "FUNC2": "OPENSSL_sk_new_null", "FUNC3": "OPENSSL_sk_push", "FUNC1": "X509_VERIFY_PARAM_add0_policy", "TYPE2": "ASN1_OBJECT *", "TYPE1": "X509_VERIFY_PARAM *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RSI\nCMP qword ptr [RDI + 0x30],0x0\nJZ 0x000ead0b\nMOV RDI,qword ptr [RBX + 0x30]\nMOV RSI,RBP\nCALL 0x000dda15\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x000ddf51\nMOV RDX,RAX\nMOV qword ptr [RBX + 0x30],RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJNZ 0x000eacf8\nJMP 0x000ead04\n"}, "312": {"funcbody": "OSSL_PROVIDER * [FUNC1] ([TYPE1] [VAR1] ,TYPE29 [VAR2] ,TYPE32 [VAR3] )\n{\n  OSSL_PROVIDER *prov;\n  CRYPTO_RWLOCK *pCVar1;\n  char *pcVar2;\n  OPENSSL_STACK *pOVar3;\n  \n  prov = (OSSL_PROVIDER *)[FUNC6] (0xe0,\"crypto/provider_core.c\",0x1cb);\n  if (prov == (OSSL_PROVIDER *)0x0) {\n    [FUNC11] ((void *)0x0);\n    [FUNC12] ();\n    [FUNC9] (\"crypto/provider_core.c\",0x1d1,\"provider_new\");\n    [FUNC3] (0xf,0xc0100,(char *)0x0);\n  }\n  else {\n    prov->refcnt = 1;\n    pCVar1 = [FUNC8] ();\n    prov->opbits_lock = pCVar1;\n    if (pCVar1 != (CRYPTO_RWLOCK *)0x0) {\n      pCVar1 = [FUNC8] ();\n      prov->flag_lock = pCVar1;\n      if (pCVar1 != (CRYPTO_RWLOCK *)0x0) {\n        pcVar2 = [FUNC4] ([VAR1] ,\"crypto/provider_core.c\",0x1d9);\n        prov->name = pcVar2;\n        if (pcVar2 != (char *)0x0) {\n          pOVar3 = [FUNC7] ((OPENSSL_STACK *)[VAR3] ,[FUNC2] ,[FUNC5] );\n          prov->parameters = (stack_st_INFOPAIR *)pOVar3;\n          if (pOVar3 != (OPENSSL_STACK *)0x0) {\n            prov->init_function = [VAR2] ;\n            return prov;\n          }\n        }\n      }\n    }\n    [FUNC10] (prov);\n    [FUNC12] ();\n    [FUNC9] (\"crypto/provider_core.c\",0x1de,\"provider_new\");\n    [FUNC3] (0xf,0xc0100,(char *)0x0);\n  }\n  return (OSSL_PROVIDER *)0x0;\n}", "answer": {"FUNC12": "ERR_new", "FUNC11": "FUNC1", "VAR1": "name", "VAR2": "init_function", "VAR3": "parameters", "FUNC10": "ossl_provider_free", "FUNC2": "infopair_copy", "FUNC3": "ERR_set_error", "FUNC1": "provider_new", "FUNC6": "CRYPTO_zalloc", "TYPE3": "stack_st_INFOPAIR *", "FUNC7": "OPENSSL_sk_deep_copy", "TYPE2": "OSSL_provider_init_fn *", "FUNC4": "CRYPTO_strdup", "FUNC5": "infopair_free", "FUNC8": "CRYPTO_THREAD_lock_new", "FUNC9": "ERR_set_debug", "TYPE1": "char *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R13,RDI\nMOV RBP,RSI\nMOV R12,RDX\nMOV EDX,0x1cb\nLEA RSI,[0x31e913]\nMOV EDI,0xe0\nCALL 0x001f171f\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x001faac1\nMOV dword ptr [RAX + 0x10],0x1\nMFENCE\nCALL 0x001fc398\nMOV qword ptr [RBX + 0xb8],RAX\nTEST RAX,RAX\nJZ 0x001fab0f\nCALL 0x001fc398\nMOV qword ptr [RBX + 0x8],RAX\nTEST RAX,RAX\nJZ 0x001fab0f\nMOV EDX,0x1d9\nLEA RSI,[0x31e913]\nMOV RDI,R13\nCALL 0x001f2c63\nMOV qword ptr [RBX + 0x28],RAX\nTEST RAX,RAX\nJZ 0x001fab0f\nLEA RDX,[0x1f907a]\nLEA RSI,[0x1f916e]\nMOV RDI,R12\nCALL 0x002680e3\nMOV qword ptr [RBX + 0x48],RAX\nTEST RAX,RAX\nJZ 0x001fab0f\nMOV qword ptr [RBX + 0x40],RBP\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV EDX,0x1d0\nLEA RSI,[0x31e913]\nMOV EDI,0x0\nCALL 0x001f1647\nCALL 0x001ab984\nLEA RDX,[0x31eaa0]\nMOV ESI,0x1d1\nLEA RDI,[0x31e913]\nCALL 0x001aba91\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0xf\nMOV EAX,0x0\nCALL 0x001abda8\nJMP 0x001faab3\nMOV RDI,RBX\nCALL 0x001fa76c\nCALL 0x001ab984\nLEA RDX,[0x31eaa0]\nMOV ESI,0x1de\nLEA RDI,[0x31e913]\nCALL 0x001aba91\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0xf\nMOV EAX,0x0\nCALL 0x001abda8\nMOV EBX,0x0\nJMP 0x001faab3\n"}, "313": {"funcbody": "int [FUNC1] (TYPE16 [VAR1] )\n{\n  char cVar1;\n  int iVar2;\n  uint uVar3;\n  char *pcVar4;\n  void *pvVar5;\n  [TYPE2] [VAR2] ;\n  char *pcVar6;\n  \n  pcVar6 = [VAR1] ->scheme;\n  iVar2 = [FUNC8] ((int)*pcVar6,3);\n  if (iVar2 == 0) {\nLAB_000cf012:\n    if (*pcVar6 != '\\0') {\n      [FUNC10] ();\n      [FUNC11] (\"crypto/store/store_register.c\",0xb5,\"ossl_store_register_loader_int\");\n      [FUNC7] (0x2c,0x6a,\"scheme=%s\",[VAR1] ->scheme);\n      return 0;\n    }\n  }\n  else {\n    cVar1 = *pcVar6;\n    while (cVar1 != '\\0') {\n      iVar2 = [FUNC8] ((int)cVar1,3);\n      if (((iVar2 == 0) && (iVar2 = [FUNC2] ((int)*pcVar6), iVar2 == 0)) &&\n         (pcVar4 = [FUNC5] (\"+-.\",(int)*pcVar6), pcVar4 == (char *)0x0)) goto LAB_000cf012;\n      pcVar6 = pcVar6 + 1;\n      cVar1 = *pcVar6;\n    }\n  }\n  if ((([VAR1] ->open == (OSSL_STORE_open_fn)0x0) || ([VAR1] ->load == (OSSL_STORE_load_fn)0x0)) ||\n     (([VAR1] ->eof == (OSSL_STORE_eof_fn)0x0 ||\n      (([VAR1] ->error == (OSSL_STORE_error_fn)0x0 || ([VAR1] ->closefn == (OSSL_STORE_close_fn)0x0))))))\n  {\n    [FUNC10] ();\n    [FUNC11] (\"crypto/store/store_register.c\",0xbd,\"ossl_store_register_loader_int\");\n    [FUNC7] (0x2c,0x74,(char *)0x0);\n    uVar3 = 0;\n  }\n  else {\n    iVar2 = [FUNC13] (&registry_init,[FUNC4] );\n    if ((iVar2 == 0) || (do_registry_init_ossl_ret_ == 0)) {\n      [FUNC10] ();\n      [FUNC11] (\"crypto/store/store_register.c\",0xc2,\"ossl_store_register_loader_int\");\n      [FUNC7] (0x2c,0xc0100,(char *)0x0);\n      uVar3 = 0;\n    }\n    else {\n      uVar3 = [FUNC14] (registry_lock);\n      if (uVar3 != 0) {\n        uVar3 = [FUNC3] ();\n        if (uVar3 != 0) {\n          pvVar5 = [FUNC6] ((OPENSSL_LHASH *)loader_register,[VAR1] );\n          uVar3 = 1;\n          if (pvVar5 == (void *)0x0) {\n            iVar2 = [FUNC12] ((OPENSSL_LHASH *)loader_register);\n            uVar3 = (uint)(iVar2 == 0);\n          }\n        }\n        [FUNC9] (registry_lock);\n      }\n    }\n  }\n  return uVar3;\n}", "answer": {"FUNC12": "OPENSSL_LH_error", "FUNC11": "ERR_set_debug", "FUNC14": "CRYPTO_THREAD_write_lock", "VAR1": "loader", "FUNC13": "CRYPTO_THREAD_run_once", "VAR2": "scheme", "FUNC10": "ERR_new", "FUNC2": "ossl_isdigit", "FUNC3": "ossl_store_register_init", "FUNC1": "ossl_store_register_loader_int", "FUNC6": "OPENSSL_LH_insert", "FUNC7": "ERR_set_error", "TYPE2": "char *", "FUNC4": "do_registry_init_ossl_", "FUNC5": "strchr", "FUNC8": "ossl_ctype_check", "FUNC9": "CRYPTO_THREAD_unlock", "TYPE1": "OSSL_STORE_LOADER *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,RDI\nMOV RBX,qword ptr [RDI]\nMOVSX EDI,byte ptr [RBX]\nMOV ESI,0x3\nCALL 0x000b1fe4\nTEST EAX,EAX\nJZ 0x000cf012\nMOVZX EDI,byte ptr [RBX]\nLEA R12,[0x285431]\nTEST DIL,DIL\nJNZ 0x000cefe4\nCMP qword ptr [RBP + 0x10],0x0\nJZ 0x000cf05e\nCMP qword ptr [RBP + 0x38],0x0\nJZ 0x000cf05e\nCMP qword ptr [RBP + 0x40],0x0\nJZ 0x000cf05e\nCMP qword ptr [RBP + 0x48],0x0\nJZ 0x000cf05e\nCMP qword ptr [RBP + 0x50],0x0\nJZ 0x000cf05e\nLEA RSI,[0xced56]\nLEA RDI,[0x591ca4]\nCALL 0x000bada2\nTEST EAX,EAX\nJZ 0x000cef94\nCMP dword ptr [0x00591ca0],0x0\nJNZ 0x000cf0a0\nCALL 0x00092e26\nLEA RDX,[0x285490]\nMOV ESI,0xc2\nLEA RDI,[0x285413]\nCALL 0x00092f33\nMOV EDX,0x0\nMOV ESI,0xc0100\nMOV EDI,0x2c\nMOV EAX,0x0\nCALL 0x0009324a\nMOV EBX,0x0\nJMP 0x000cf099\nADD RBX,0x1\nMOVZX EDI,byte ptr [RBX]\nTEST DIL,DIL\nJZ 0x000cef39\nMOVSX EDI,DIL\nMOV ESI,0x3\nCALL 0x000b1fe4\nTEST EAX,EAX\nJNZ 0x000cefd4\nMOVSX EDI,byte ptr [RBX]\nCALL 0x000b2006\nTEST EAX,EAX\nJNZ 0x000cefd4\nMOVSX ESI,byte ptr [RBX]\nMOV RDI,R12\nCALL 0x000655e0\nTEST RAX,RAX\nJNZ 0x000cefd4\nCMP byte ptr [RBX],0x0\nJZ 0x000cef39\nCALL 0x00092e26\nLEA RDX,[0x285490]\nMOV ESI,0xb5\nLEA RDI,[0x285413]\nCALL 0x00092f33\nMOV RCX,qword ptr [RBP]\nLEA RDX,[0x285435]\nMOV ESI,0x6a\nMOV EDI,0x2c\nMOV EAX,0x0\nCALL 0x0009324a\nMOV EBX,0x0\nJMP 0x000cf099\nCALL 0x00092e26\nLEA RDX,[0x285490]\nMOV ESI,0xbd\nLEA RDI,[0x285413]\nCALL 0x00092f33\nMOV EDX,0x0\nMOV ESI,0x74\nMOV EDI,0x2c\nMOV EAX,0x0\nCALL 0x0009324a\nMOV EBX,0x0\nMOV EAX,EBX\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,qword ptr [0x00591ca8]\nCALL 0x000bad50\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x000cf099\nCALL 0x000ced9f\nMOV EBX,EAX\nTEST EAX,EAX\nJNZ 0x000cf0cb\nMOV RDI,qword ptr [0x00591ca8]\nCALL 0x000bad66\nJMP 0x000cf099\nMOV RSI,RBP\nMOV RDI,qword ptr [0x00591c98]\nCALL 0x000b004f\nMOV EBX,0x1\nTEST RAX,RAX\nJNZ 0x000cf0bd\nMOV RDI,qword ptr [0x00591c98]\nCALL 0x000b04fa\nTEST EAX,EAX\nSETZ BL\nMOVZX EBX,BL\nJMP 0x000cf0bd\n"}, "314": {"funcbody": "WINDOW * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n              [TYPE5] [VAR5] )\n{\n  WINDOW *pWVar1;\n  \n  if ([VAR1] != ([TYPE1] )0x0) {\n    pWVar1 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,[VAR4] - [VAR1] ->_begy,[VAR5] - [VAR1] ->_begx);\n    return pWVar1;\n  }\n  return (WINDOW *)0x0;\n}", "answer": {"VAR1": "w", "VAR2": "l", "VAR3": "c", "VAR4": "y", "VAR5": "x", "FUNC2": "derwin", "FUNC1": "subwin", "TYPE3": "int", "TYPE2": "int", "TYPE5": "int", "TYPE4": "int", "TYPE1": "WINDOW *"}, "assembly": "TEST RDI,RDI\nJZ 0x00021620\nSUB RSP,0x8\nMOVSX EAX,word ptr [RDI + 0xa]\nMOVSX R9D,word ptr [RDI + 0x8]\nSUB ECX,R9D\nSUB R8D,EAX\nCALL 0x000214ce\nADD RSP,0x8\nRET\nMOV RAX,RDI\nRET\n"}, "315": {"funcbody": "/* DWARF original prototype: PosibErr<void> item_updated(ConfigNotifier * this, KeyInfo * ki, bool\n   value) */\nPosibErr<void> __thiscall\naspeller::SpellerImpl::ConfigNotifier::[FUNC1] \n          (TYPE18 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  long lVar1;\n  PosibErrBase in_RDI;\n  long in_FS_OFFSET;\n  [TYPE4] [VAR4] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC3] ([VAR1] ->speller_,[VAR2] ,[VAR3] ,Bool);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return (PosibErr<void>)(PosibErrBase)in_RDI.err_;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "this", "VAR2": "ki", "VAR3": "value", "VAR4": "local_10", "FUNC2": "__stack_chk_fail", "FUNC3": "callback<bool>", "FUNC1": "item_updated", "TYPE3": "bool", "TYPE2": "KeyInfo *", "TYPE4": "undefined8", "TYPE1": "ConfigNotifier *"}, "assembly": "PUSH RBX\nSUB RSP,0x10\nMOV RBX,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOVZX ECX,CL\nMOV RSI,qword ptr [RSI + 0x8]\nMOV R8D,0x2\nCALL 0x000283f0\nMOV RDI,qword ptr [RSP + 0x8]\nXOR RDI,qword ptr FS:[0x28]\nJNZ 0x0006faaf\nMOV RAX,RBX\nADD RSP,0x10\nPOP RBX\nRET\nCALL 0x00028a30\n"}, "316": {"funcbody": "X509_EXTENSION * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  X509V3_EXT_METHOD *method;\n  TYPE49 [VAR4] ;\n  X509_EXTENSION *pXVar1;\n  \n  method = [FUNC2] ([VAR1] );\n  if (method == (X509V3_EXT_METHOD *)0x0) {\n    [FUNC3] ();\n    [FUNC4] (\"crypto/x509/v3_conf.c\",0xc0,\"X509V3_EXT_i2d\");\n    [FUNC6] (0x22,0x81,(char *)0x0);\n    pXVar1 = (X509_EXTENSION *)0x0;\n  }\n  else {\n    pXVar1 = [FUNC5] ((X509V3_EXT_METHOD *)method,[VAR1] ,[VAR2] ,[VAR3] );\n  }\n  return (X509_EXTENSION *)pXVar1;\n}", "answer": {"VAR1": "ext_nid", "VAR2": "crit", "VAR3": "ext_struc", "VAR4": "method", "FUNC2": "X509V3_EXT_get_nid", "FUNC3": "ERR_new", "FUNC1": "X509V3_EXT_i2d", "FUNC6": "ERR_set_error", "TYPE3": "void *", "TYPE2": "int", "FUNC4": "ERR_set_debug", "FUNC5": "do_ext_i2d", "TYPE4": "X509V3_EXT_METHOD *", "TYPE1": "int"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV EBX,EDI\nMOV EBP,ESI\nMOV R12,RDX\nCALL 0x001fea0a\nTEST RAX,RAX\nJZ 0x0025787f\nMOV RCX,R12\nMOV EDX,EBP\nMOV ESI,EBX\nMOV RDI,RAX\nCALL 0x0025721f\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x0008372e\nLEA RDX,[0x2ac1b8]\nMOV ESI,0xc0\nLEA RDI,[0x2ac0d9]\nCALL 0x0008383b\nMOV EDX,0x0\nMOV ESI,0x81\nMOV EDI,0x22\nMOV EAX,0x0\nCALL 0x00083b52\nMOV EAX,0x0\nJMP 0x0025787a\n"}, "317": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  [TYPE6] [VAR6] ;\n  [TYPE7] [VAR7] ;\n  FFC_PARAMS *a;\n  [TYPE8] [VAR8] ;\n  FFC_PARAMS *b;\n  [TYPE9] [VAR9] ;\n  BIGNUM *pBVar2;\n  [TYPE10] [VAR10] ;\n  BIGNUM *pBVar3;\n  [TYPE11] [VAR11] ;\n  [TYPE4] [VAR4] ;\n  TYPE51 [VAR5] ;\n  bool bVar4;\n  \n  iVar1 = [FUNC4] ();\n  if (iVar1 == 0) {\n    return 0;\n  }\n  if (([VAR3] & 3U) == 0) {\n    if (([VAR3] & 4U) == 0) {\n      return 1;\n    }\n    a = [FUNC3] ((DH *)[VAR1] );\n    b = [FUNC3] ((DH *)[VAR2] );\n  }\n  else {\n    if (([VAR3] & 2U) == 0) {\nLAB_000f80ff:\n      if (([VAR3] & 1U) != 0) {\n        pBVar2 = [FUNC7] ((DH *)[VAR1] );\n        pBVar3 = [FUNC7] ((DH *)[VAR2] );\n        if ((pBVar2 != (BIGNUM *)0x0) && (pBVar3 != (BIGNUM *)0x0)) {\n          iVar1 = [FUNC5] ((BIGNUM *)pBVar2,(BIGNUM *)pBVar3);\n          goto LAB_000f814c;\n        }\n      }\n      bVar4 = false;\n      if (([VAR3] & 4U) != 0) {\n        [FUNC3] ((DH *)[VAR1] );\n        [FUNC3] ((DH *)[VAR2] );\n        return 0;\n      }\n      goto LAB_000f81e2;\n    }\n    pBVar2 = [FUNC6] ((DH *)[VAR1] );\n    pBVar3 = [FUNC6] ((DH *)[VAR2] );\n    if ((pBVar2 == (BIGNUM *)0x0) || (pBVar3 == (BIGNUM *)0x0)) goto LAB_000f80ff;\n    iVar1 = [FUNC5] ((BIGNUM *)pBVar2,(BIGNUM *)pBVar3);\nLAB_000f814c:\n    bVar4 = iVar1 == 0;\n    if (([VAR3] & 4U) == 0) goto LAB_000f81e2;\n    a = [FUNC3] ((DH *)[VAR1] );\n    b = [FUNC3] ((DH *)[VAR2] );\n    if (!bVar4) {\n      return 0;\n    }\n  }\n  iVar1 = [FUNC2] (a,b,1);\n  bVar4 = iVar1 != 0;\nLAB_000f81e2:\n  return (uint)bVar4;\n}", "answer": {"VAR1": "keydata1", "VAR2": "keydata2", "VAR3": "selection", "VAR4": "dh2", "VAR5": "dh1", "VAR6": "pa", "FUNC2": "ossl_ffc_params_cmp", "FUNC3": "ossl_dh_get0_params", "FUNC1": "dh_match", "FUNC6": "DH_get0_pub_key", "TYPE3": "int", "FUNC7": "DH_get0_priv_key", "TYPE2": "void *", "FUNC4": "ossl_prov_is_running", "TYPE5": "DH *", "FUNC5": "BN_cmp", "TYPE4": "DH *", "TYPE7": "BIGNUM *", "TYPE6": "BIGNUM *", "TYPE9": "FFC_PARAMS *", "TYPE8": "FFC_PARAMS *", "VAR7": "pb", "TYPE11": "BIGNUM *", "VAR8": "dhparams1", "VAR9": "dhparams2", "TYPE10": "BIGNUM *", "VAR10": "pa_1", "VAR11": "pb_1", "TYPE1": "void *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R12,RDI\nMOV R13,RSI\nMOV EBP,EDX\nCALL 0x000cacf7\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x000f81e2\nTEST BPL,0x3\nJZ 0x000f81d7\nTEST BPL,0x2\nJNZ 0x000f811c\nTEST BPL,0x1\nJNZ 0x000f8170\nMOV EAX,0x0\nTEST BPL,0x4\nJNZ 0x000f81ef\nMOVZX EBX,AL\nJMP 0x000f81e2\nMOV RDI,R12\nCALL 0x000819c9\nMOV RBX,RAX\nMOV RDI,R13\nCALL 0x000819c9\nTEST RBX,RBX\nJZ 0x000f80ff\nTEST RAX,RAX\nJZ 0x000f80ff\nMOV RSI,RAX\nMOV RDI,RBX\nCALL 0x00079390\nTEST EAX,EAX\nSETZ BL\nMOVZX EBX,BL\nTEST EBX,EBX\nSETNZ AL\nTEST BPL,0x4\nJZ 0x000f8114\nMOV RDI,R12\nCALL 0x000819ef\nMOV RBP,RAX\nMOV RDI,R13\nCALL 0x000819ef\nTEST EBX,EBX\nJZ 0x000f81e2\nJMP 0x000f81bd\nMOV RDI,R12\nCALL 0x000819c4\nMOV RBX,RAX\nMOV RDI,R13\nCALL 0x000819c4\nTEST RBX,RBX\nJZ 0x000f8105\nTEST RAX,RAX\nJZ 0x000f8105\nMOV RSI,RAX\nMOV RDI,RBX\nCALL 0x00079390\nTEST EAX,EAX\nSETZ BL\nMOVZX EBX,BL\nJMP 0x000f814c\nMOV RDI,R12\nCALL 0x000819ef\nMOV RBP,RAX\nMOV RDI,R13\nCALL 0x000819ef\nMOV EDX,0x1\nMOV RSI,RAX\nMOV RDI,RBP\nCALL 0x00099fd8\nTEST EAX,EAX\nSETNZ BL\nMOVZX EBX,BL\nJMP 0x000f81e2\nMOV EBX,0x1\nTEST BPL,0x4\nJNZ 0x000f81aa\nMOV EAX,EBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV RDI,R12\nCALL 0x000819ef\nMOV RDI,R13\nCALL 0x000819ef\nMOV EBX,0x0\nJMP 0x000f81e2\n"}, "318": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] )\n{\n  char *pcVar1;\n  char *pcVar2;\n  uint uVar3;\n  [TYPE2] [VAR2] ;\n  int *piVar4;\n  char *pcVar5;\n  \n  pcVar1 = [VAR1] ->prefix;\n  if (pcVar1 == (char *)0x0) {\n    pcVar5 = [VAR1] ->dir_path;\n  }\n  else {\n    pcVar2 = [VAR1] ->dir_path;\n    pcVar5 = pcVar1;\n    if (pcVar2 != (char *)0x0) {\n      pcVar5 = [VAR1] ->path_buffer;\n      uVar3 = [FUNC3] (pcVar5,0x1000,1,0x1000,\"%s/%s\",pcVar1,pcVar2 + (*pcVar2 == '/'));\n      if ((int)uVar3 < 0) {\n        pcVar5 = (char *)0x0;\n      }\n      else if (0xfff < uVar3) {\n        piVar4 = [FUNC2] ();\n        *piVar4 = 0x24;\n        pcVar5 = (char *)0x0;\n      }\n    }\n  }\n  return pcVar5;\n}", "answer": {"VAR1": "pc", "VAR2": "dirpath", "FUNC2": "__errno_location", "FUNC3": "__snprintf_chk", "FUNC1": "get_absdir", "TYPE2": "char *", "TYPE1": "path_cxt *"}, "assembly": "PUSH RBX\nMOV R9,qword ptr [RDI + 0x18]\nTEST R9,R9\nJZ 0x0000d971\nMOV RAX,qword ptr [RDI + 0x8]\nMOV RBX,R9\nTEST RAX,RAX\nJZ 0x0000d96c\nCMP byte ptr [RAX],0x2f\nSETZ DL\nMOVZX EDX,DL\nADD RAX,RDX\nLEA RBX,[RDI + 0x20]\nSUB RSP,0x8\nPUSH RAX\nLEA R8,[0x179de]\nMOV ECX,0x1000\nMOV EDX,0x1\nMOV ESI,0x1000\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x00002ce0\nADD RSP,0x10\nTEST EAX,EAX\nJS 0x0000d989\nCMP EAX,0xfff\nJA 0x0000d977\nMOV RAX,RBX\nPOP RBX\nRET\nMOV RBX,qword ptr [RDI + 0x8]\nJMP 0x0000d96c\nCALL 0x00002d60\nMOV dword ptr [RAX],0x24\nMOV EBX,0x0\nJMP 0x0000d96c\nMOV EBX,0x0\nJMP 0x0000d96c\n"}, "319": {"funcbody": "ulong [FUNC1] (long param_1)\n{\n  long lVar1;\n  char *pcVar2;\n  ulong uVar3;\n  char *pcVar4;\n  \n  pcVar2 = [FUNC4] (\"NCURSES_NO_UTF8_ACS\");\n  if (pcVar2 == (char *)0x0) {\n    uVar3 = [FUNC2] (&DAT_0000e93a);\n    if ((int)uVar3 < 0) {\n      pcVar2 = [FUNC4] (\"TERM\");\n      uVar3 = 0;\n      if (pcVar2 != (char *)0x0) {\n        pcVar4 = [FUNC5] (pcVar2,\"linux\");\n        uVar3 = 1;\n        if (pcVar4 == (char *)0x0) {\n          pcVar2 = [FUNC5] (pcVar2,\"screen\");\n          uVar3 = 0;\n          if (pcVar2 != (char *)0x0) {\n            pcVar2 = [FUNC4] (\"TERMCAP\");\n            uVar3 = 0;\n            if (pcVar2 != (char *)0x0) {\n              pcVar4 = [FUNC5] (pcVar2,\"screen\");\n              uVar3 = 0;\n              if (pcVar4 != (char *)0x0) {\n                pcVar2 = [FUNC5] (pcVar2,\"hhII00\");\n                uVar3 = 0;\n                if (pcVar2 != (char *)0x0) {\n                  lVar1 = *(long *)(param_1 + 0x20);\n                  pcVar2 = *(char **)(lVar1 + 200);\n                  if (pcVar2 != (char *)0x0) {\n                    pcVar4 = [FUNC6] (pcVar2,0xe);\n                    if (pcVar4 != (char *)0x0) {\n                      return 1;\n                    }\n                    pcVar2 = [FUNC6] (pcVar2,0xf);\n                    if (pcVar2 != (char *)0x0) {\n                      return 1;\n                    }\n                  }\n                  pcVar2 = *(char **)(lVar1 + 0x418);\n                  uVar3 = 0;\n                  if (pcVar2 != (char *)0x0) {\n                    pcVar4 = [FUNC6] (pcVar2,0xe);\n                    uVar3 = 1;\n                    if (pcVar4 == (char *)0x0) {\n                      pcVar2 = [FUNC6] (pcVar2,0xf);\n                      uVar3 = (ulong)(pcVar2 != (char *)0x0);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  else {\n    uVar3 = [FUNC3] (\"NCURSES_NO_UTF8_ACS\");\n  }\n  return uVar3;\n}", "answer": {"FUNC2": "FUN_00008abc", "FUNC3": "FUN_0000cb5f", "FUNC1": "FUN_00008086", "FUNC6": "strchr", "FUNC4": "getenv", "FUNC5": "strstr"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nLEA RDI,[0xe926]\nCALL 0x00007040\nTEST RAX,RAX\nJZ 0x000080b3\nLEA RDI,[0xe926]\nCALL 0x0000cb5f\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nLEA RDI,[0xe93a]\nCALL 0x00008abc\nTEST EAX,EAX\nJNS 0x000080ac\nLEA RDI,[0xe839]\nCALL 0x00007040\nMOV RBP,RAX\nMOV EAX,0x0\nTEST RBP,RBP\nJZ 0x000080ac\nLEA RSI,[0xe93d]\nMOV RDI,RBP\nCALL 0x00007350\nMOV RDX,RAX\nMOV EAX,0x1\nTEST RDX,RDX\nJNZ 0x000080ac\nLEA RSI,[0xed64]\nMOV RDI,RBP\nCALL 0x00007350\nMOV RDX,RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x000080ac\nLEA RDI,[0xe943]\nCALL 0x00007040\nMOV RBP,RAX\nMOV EAX,0x0\nTEST RBP,RBP\nJZ 0x000080ac\nLEA RSI,[0xed64]\nMOV RDI,RBP\nCALL 0x00007350\nMOV RDX,RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x000080ac\nLEA RSI,[0xe94b]\nMOV RDI,RBP\nCALL 0x00007350\nMOV RDX,RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x000080ac\nMOV RBP,qword ptr [RBX + 0x20]\nMOV RBX,qword ptr [RBP + 0xc8]\nTEST RBX,RBX\nJZ 0x000081bd\nMOV ESI,0xe\nMOV RDI,RBX\nCALL 0x00007120\nMOV RDX,RAX\nMOV EAX,0x1\nTEST RDX,RDX\nJNZ 0x000080ac\nMOV ESI,0xf\nMOV RDI,RBX\nCALL 0x00007120\nMOV RDX,RAX\nMOV EAX,0x1\nTEST RDX,RDX\nJNZ 0x000080ac\nMOV RBX,qword ptr [RBP + 0x418]\nMOV EAX,0x0\nTEST RBX,RBX\nJZ 0x000080ac\nMOV ESI,0xe\nMOV RDI,RBX\nCALL 0x00007120\nMOV RDX,RAX\nMOV EAX,0x1\nTEST RDX,RDX\nJNZ 0x000080ac\nMOV ESI,0xf\nMOV RDI,RBX\nCALL 0x00007120\nTEST RAX,RAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x000080ac\n"}, "320": {"funcbody": "stack_st_CONF_VALUE * [FUNC1] (TYPE17 [VAR1] ,[TYPE2] [VAR2] ,TYPE39 [VAR3] )\n{\n  long lVar1;\n  int iVar2;\n  ASN1_OBJECT *a;\n  [TYPE5] [VAR5] ;\n  int i;\n  TYPE48 [VAR4] ;\n  long in_FS_OFFSET;\n  TYPE39 [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  i = 0;\n  [VAR8] = [VAR3] ;\n  while( true ) {\n    iVar2 = [FUNC4] ((OPENSSL_STACK *)[VAR2] );\n    if (iVar2 <= i) break;\n    a = (ASN1_OBJECT *)[FUNC3] ((OPENSSL_STACK *)[VAR2] ,i);\n    [FUNC5] ([VAR7] ,0x50,a);\n    [FUNC6] ((char *)0x0,[VAR7] ,(stack_st_CONF_VALUE **)&[VAR8] );\n    i = i + 1;\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return [VAR8] ;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "method", "VAR2": "a", "VAR3": "ext_list", "VAR4": "eku", "VAR5": "obj", "VAR6": "local_30", "FUNC2": "__stack_chk_fail", "FUNC3": "OPENSSL_sk_value", "FUNC1": "i2v_EXTENDED_KEY_USAGE", "FUNC6": "X509V3_add_value", "TYPE3": "stack_st_CONF_VALUE *", "TYPE2": "void *", "FUNC4": "OPENSSL_sk_num", "TYPE5": "ASN1_OBJECT *", "FUNC5": "i2t_ASN1_OBJECT", "TYPE4": "EXTENDED_KEY_USAGE *", "TYPE7": "char[80]", "TYPE6": "undefined8", "TYPE8": "undefined8", "VAR7": "obj_tmp", "VAR8": "local_90", "TYPE1": "X509V3_EXT_METHOD *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x78\nMOV RBP,RSI\nMOV qword ptr [RSP + 0x8],RDX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x68],RAX\nXOR EAX,EAX\nMOV EBX,0x0\nLEA R12,[RSP + 0x10]\nLEA R13,[RSP + 0x8]\nJMP 0x00258153\nMOV ESI,EBX\nMOV RDI,RBP\nCALL 0x000b4a9e\nMOV RDX,RAX\nMOV ESI,0x50\nMOV RDI,R12\nCALL 0x00124f69\nMOV RDX,R13\nMOV RSI,R12\nMOV EDI,0x0\nCALL 0x002050e4\nADD EBX,0x1\nMOV RDI,RBP\nCALL 0x000b4a90\nCMP EAX,EBX\nJG 0x00258126\nMOV RAX,qword ptr [RSP + 0x8]\nMOV RCX,qword ptr [RSP + 0x68]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0025817f\nADD RSP,0x78\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nCALL 0x00062640\n"}, "321": {"funcbody": "Idx [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  undefined *puVar1;\n  ulong uVar2;\n  size_t sVar3;\n  re_token_t *prVar4;\n  [TYPE4] [VAR4] ;\n  Idx *pIVar5;\n  [TYPE5] [VAR5] ;\n  Idx *pIVar6;\n  [TYPE6] [VAR6] ;\n  re_node_set *prVar7;\n  [TYPE7] [VAR7] ;\n  re_node_set *prVar8;\n  [TYPE8] [VAR8] ;\n  uint uVar9;\n  undefined8 in_RDX;\n  anon_union_8_5_a39f51ca_for_opr in_RSI;\n  [TYPE3] [VAR3] ;\n  [TYPE9] [VAR9] ;\n  \n  uVar2 = [VAR1] ->nodes_alloc;\n  if (uVar2 <= [VAR1] ->nodes_len) {\n    if (0xaaaaaaaaaaaaaaa < uVar2 * 2) {\n      return -1;\n    }\n    prVar4 = (re_token_t *)[FUNC2] ([VAR1] ->nodes,uVar2 << 5);\n    if (prVar4 == (re_token_t *)0x0) {\n      return -1;\n    }\n    [VAR1] ->nodes = prVar4;\n    [VAR1] ->nodes_alloc = uVar2 * 2;\n    pIVar5 = (Idx *)[FUNC2] ([VAR1] ->nexts,uVar2 << 4);\n    if (pIVar5 != (Idx *)0x0) {\n      [VAR1] ->nexts = pIVar5;\n    }\n    pIVar6 = (Idx *)[FUNC2] ([VAR1] ->org_indices,uVar2 << 4);\n    if (pIVar6 != (Idx *)0x0) {\n      [VAR1] ->org_indices = pIVar6;\n    }\n    prVar7 = (re_node_set *)[FUNC2] ([VAR1] ->edests,uVar2 * 0x30);\n    if (prVar7 != (re_node_set *)0x0) {\n      [VAR1] ->edests = prVar7;\n    }\n    prVar8 = (re_node_set *)[FUNC2] ([VAR1] ->eclosures,uVar2 * 0x30);\n    if (prVar8 == (re_node_set *)0x0) {\n      return -1;\n    }\n    [VAR1] ->eclosures = prVar8;\n    if ((pIVar5 == (Idx *)0x0) || (pIVar6 == (Idx *)0x0)) {\n      return -1;\n    }\n    if (prVar7 == (re_node_set *)0x0) {\n      return -1;\n    }\n  }\n  sVar3 = [VAR1] ->nodes_len;\n  prVar4 = [VAR1] ->nodes;\n  prVar4[sVar3].opr = in_RSI;\n  *(undefined8 *)&prVar4[sVar3].field_0x8 = in_RDX;\n  puVar1 = &[VAR1] ->nodes[[VAR1] ->nodes_len].field_0x8;\n  *(uint *)puVar1 = *(uint *)puVar1 & 0xfffc00ff;\n  if (((char)in_RDX != '\\x05') || (uVar9 = 1, [VAR1] ->mb_cur_max < L'\\x02')) {\n    uVar9 = (uint)((char)in_RDX == '\\x06');\n  }\n  [VAR1] ->nodes[[VAR1] ->nodes_len].field_0xa =\n       (byte)(uVar9 << 4) | [VAR1] ->nodes[[VAR1] ->nodes_len].field_0xa & 0xef;\n  [VAR1] ->nexts[[VAR1] ->nodes_len] = -1;\n  prVar7 = [VAR1] ->edests + [VAR1] ->nodes_len;\n  prVar7->alloc = 0;\n  prVar7->nelem = 0;\n  prVar7->elems = (Idx *)0x0;\n  prVar7 = [VAR1] ->eclosures + [VAR1] ->nodes_len;\n  prVar7->alloc = 0;\n  prVar7->nelem = 0;\n  prVar7->elems = (Idx *)0x0;\n  sVar3 = [VAR1] ->nodes_len;\n  [VAR1] ->nodes_len = sVar3 + 1;\n  return sVar3;\n}", "answer": {"VAR1": "dfa", "VAR2": "token", "VAR3": "new_nodes_alloc", "VAR4": "new_nodes", "VAR5": "new_nexts", "VAR6": "new_indices", "FUNC2": "realloc", "FUNC1": "re_dfa_add_node", "TYPE3": "size_t", "TYPE2": "re_token_t", "TYPE5": "Idx *", "TYPE4": "re_token_t *", "TYPE7": "re_node_set *", "TYPE6": "Idx *", "TYPE9": "undefined8", "TYPE8": "re_node_set *", "VAR7": "new_edests", "VAR8": "new_eclosures", "VAR9": "local_40", "TYPE1": "re_dfa_t *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBX,RDI\nMOV R12,RSI\nMOV RBP,RDX\nMOV R13,qword ptr [RDI + 0x8]\nCMP qword ptr [RDI + 0x10],R13\nJNC 0x00031000\nMOV RAX,qword ptr [RBX + 0x10]\nSHL RAX,0x4\nADD RAX,qword ptr [RBX]\nMOV qword ptr [RAX],R12\nMOV qword ptr [RAX + 0x8],RBP\nMOV RAX,qword ptr [RBX + 0x10]\nSHL RAX,0x4\nADD RAX,qword ptr [RBX]\nAND dword ptr [RAX + 0x8],0xfffc00ff\nCMP BPL,0x5\nJZ 0x000310e0\nCMP BPL,0x6\nSETZ DL\nMOVZX EDX,DL\nMOV RAX,qword ptr [RBX + 0x10]\nSHL RAX,0x4\nADD RAX,qword ptr [RBX]\nAND EDX,0x1\nSHL EDX,0x4\nMOVZX ECX,byte ptr [RAX + 0xa]\nAND ECX,0xffffffef\nOR EDX,ECX\nMOV byte ptr [RAX + 0xa],DL\nMOV RDX,qword ptr [RBX + 0x10]\nMOV RAX,qword ptr [RBX + 0x18]\nMOV qword ptr [RAX + RDX*0x8],-0x1\nMOV RAX,qword ptr [RBX + 0x10]\nLEA RDX,[RAX + RAX*0x2]\nMOV RAX,qword ptr [RBX + 0x28]\nLEA RAX,[RAX + RDX*0x8]\nMOV qword ptr [RAX],0x0\nMOV qword ptr [RAX + 0x8],0x0\nMOV qword ptr [RAX + 0x10],0x0\nMOV RAX,qword ptr [RBX + 0x10]\nLEA RDX,[RAX + RAX*0x2]\nMOV RAX,qword ptr [RBX + 0x30]\nLEA RAX,[RAX + RDX*0x8]\nMOV qword ptr [RAX],0x0\nMOV qword ptr [RAX + 0x8],0x0\nMOV qword ptr [RAX + 0x10],0x0\nMOV RAX,qword ptr [RBX + 0x10]\nLEA RDX,[RAX + 0x1]\nMOV qword ptr [RBX + 0x10],RDX\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nADD R13,R13\nMOV RAX,-0x1\nMOV RDX,0xaaaaaaaaaaaaaaa\nCMP R13,RDX\nJA 0x00030ff1\nMOV RSI,R13\nSHL RSI,0x4\nMOV RDI,qword ptr [RDI]\nCALL 0x00005330\nMOV RDX,RAX\nMOV RAX,-0x1\nTEST RDX,RDX\nJZ 0x00030ff1\nMOV qword ptr [RBX],RDX\nMOV qword ptr [RBX + 0x8],R13\nLEA R14,[R13*0x8]\nMOV RDI,qword ptr [RBX + 0x18]\nMOV RSI,R14\nCALL 0x00005330\nMOV R15,RAX\nTEST RAX,RAX\nJZ 0x0003105e\nMOV qword ptr [RBX + 0x18],RAX\nMOV RDI,qword ptr [RBX + 0x20]\nMOV RSI,R14\nCALL 0x00005330\nMOV R14,RAX\nTEST RAX,RAX\nJZ 0x00031076\nMOV qword ptr [RBX + 0x20],RAX\nLEA RAX,[R13 + R13*0x2]\nSHL RAX,0x3\nMOV qword ptr [RSP + 0x8],RAX\nMOV RDI,qword ptr [RBX + 0x28]\nMOV RSI,RAX\nCALL 0x00005330\nMOV R13,RAX\nTEST RAX,RAX\nJZ 0x0003109c\nMOV qword ptr [RBX + 0x28],RAX\nMOV RDI,qword ptr [RBX + 0x30]\nMOV RSI,qword ptr [RSP + 0x8]\nCALL 0x00005330\nMOV RDX,RAX\nMOV RAX,-0x1\nTEST RDX,RDX\nJZ 0x00030ff1\nMOV qword ptr [RBX + 0x30],RDX\nTEST R15,R15\nJZ 0x000310f7\nTEST R14,R14\nJZ 0x000310f7\nTEST R13,R13\nJNZ 0x00030f32\nMOV RAX,-0x1\nJMP 0x00030ff1\nMOV EDX,0x1\nCMP dword ptr [RBX + 0xb4],0x1\nJG 0x00030f6a\nJMP 0x00030f60\nMOV RAX,-0x1\nJMP 0x00030ff1\n"}, "322": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  long lVar1;\n  jmp_buf *pa_Var2;\n  int iVar4;\n  TYPE49 [VAR4] ;\n  zend_result zVar3;\n  TYPE38 [VAR3] ;\n  long in_FS_OFFSET;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  TYPE61 [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR10] = ([TYPE10] )0x0;\n  [VAR9] = (TYPE90x0;\n  zVar3 = [FUNC3] (([VAR1] ->This).u2.next,\"ss\",&[VAR10] ,&[VAR8] ,&[VAR9] ,&[VAR7] );\n  pa_Var2 = executor_globals.bailout;\n  if (zVar3 != FAILURE) {\n    if (ps_globals.session_status == php_session_active) {\n      if (ps_globals.default_mod == (ps_module *)0x0) {\n        [FUNC4] ((zend_class_entry *)0x0,\"Cannot call default session handler\");\n      }\n      else {\n        ps_globals.mod_user_is_open = true;\n        executor_globals.bailout = &[VAR6] ;\n        iVar4 = [FUNC2] ((__jmp_buf_tag *)executor_globals.bailout);\n        if (iVar4 != 0) {\n          ps_globals.session_status = php_session_none;\n          executor_globals.bailout = pa_Var2;\n          [FUNC6] (\"/home/junyeonw/Developer/llm_measure/x64_dataset/php-8.3.0/ext/session/mod_user_class.c\"\n                ,0x38);\n        }\n        zVar3 = (*(ps_globals.default_mod)->s_open)((void **)0x1204920,[VAR10] ,[VAR9] );\n        executor_globals.bailout = pa_Var2;\n        ([VAR2] ->u1).type_info = (zVar3 == SUCCESS) + 2;\n      }\n    }\n    else {\n      [FUNC4] ((zend_class_entry *)0x0,\"Session is not active\");\n    }\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC5] ();\n}", "answer": {"VAR1": "execute_data", "VAR2": "return_value", "VAR3": "__orig_bailout", "VAR4": "ret", "VAR5": "local_10", "VAR6": "__bailout", "FUNC2": "_setjmp", "FUNC3": "zend_parse_parameters", "FUNC1": "zim_SessionHandler_open", "FUNC6": "_zend_bailout", "TYPE3": "jmp_buf *", "TYPE2": "zval *", "FUNC4": "zend_throw_error", "TYPE5": "undefined8", "VAR12": "local_108", "FUNC5": "__stack_chk_fail", "TYPE4": "zend_result", "TYPE7": "size_t", "TYPE6": "jmp_buf", "TYPE9": "char *", "TYPE8": "size_t", "VAR7": "session_name_len", "TYPE11": "undefined8", "VAR8": "save_path_len", "TYPE12": "undefined8", "VAR9": "session_name", "TYPE10": "char *", "VAR10": "save_path", "VAR11": "local_100", "TYPE1": "zend_execute_data *"}, "assembly": "SUB RSP,0x108\nMOV qword ptr [RSP],RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0xf8],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP + 0x10],0x0\nMOV qword ptr [RSP + 0x18],0x0\nLEA RCX,[RSP + 0x20]\nLEA RDX,[RSP + 0x10]\nMOV EDI,dword ptr [RDI + 0x2c]\nLEA R9,[RSP + 0x28]\nLEA R8,[RSP + 0x18]\nLEA RSI,[0x53697e]\nCALL 0x003c15e1\nCMP EAX,-0x1\nJZ 0x00272dee\nCMP dword ptr [0x01204928],0x2\nJNZ 0x00272e09\nCMP qword ptr [0x01204918],0x0\nJZ 0x00272e21\nMOV byte ptr [0x012049f9],0x1\nMOV RAX,qword ptr [0x0121a140]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RDI,[RSP + 0x30]\nMOV qword ptr [0x0121a140],RDI\nCALL 0x000faf40\nTEST EAX,EAX\nJNZ 0x00272e39\nMOV RDX,qword ptr [RSP + 0x18]\nMOV RSI,qword ptr [RSP + 0x10]\nLEA RDI,[0x1204920]\nMOV RAX,qword ptr [0x01204918]\nCALL qword ptr [RAX + 0x8]\nMOV RSI,qword ptr [RSP + 0x8]\nMOV qword ptr [0x0121a140],RSI\nTEST EAX,EAX\nSETZ AL\nMOVZX EAX,AL\nADD EAX,0x2\nMOV RCX,qword ptr [RSP]\nMOV dword ptr [RCX + 0x8],EAX\nMOV RAX,qword ptr [RSP + 0xf8]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x00272e60\nADD RSP,0x108\nRET\nLEA RSI,[0xcf3ba0]\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x003b6f64\nJMP 0x00272dee\nLEA RSI,[0xcf3bb8]\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x003b6f64\nJMP 0x00272dee\nMOV RAX,qword ptr [RSP + 0x8]\nMOV qword ptr [0x0121a140],RAX\nMOV dword ptr [0x01204928],0x1\nMOV ESI,0x38\nLEA RDI,[0xcf3be0]\nCALL 0x003b5fc3\nCALL 0x000fa8a0\n"}, "323": {"funcbody": "/* DWARF original prototype: void ExpGroup(ExpGroup * this, char * nm) */\nvoid __thiscall ExpGroup::[FUNC1] (ExpGroup *this,[TYPE1] [VAR1] )\n{\n  Vector<Experiment*> *pVVar1;\n  char *path;\n  \n  path = (char *)0x0;\n  if ([VAR1] != (TYPE10x0) {\n    path = [FUNC3] ([VAR1] );\n  }\n  this->name = path;\n  [FUNC2] (path);\n  pVVar1 = (Vector<Experiment*> *)[FUNC4] (0x28);\n  pVVar1->_vptr_Vector = (_func_int_varargs **)&PTR__Vector_004d9800;\n  pVVar1->count = 0;\n  pVVar1->data = (Experiment **)0x0;\n  pVVar1->limit = 0;\n  pVVar1->sorted = false;\n  this->exps = pVVar1;\n  this->founder = (Experiment *)0x0;\n  this->groupId = 0;\n  phaseCompareIdx = phaseCompareIdx + 1;\n  this->loadObjs = (Vector<LoadObject*> *)0x0;\n  this->loadObjsMap = (Map<LoadObject*,_int> *)0x0;\n  return;\n}", "answer": {"VAR1": "nm", "FUNC2": "canonical_path", "FUNC3": "strdup", "FUNC1": "ExpGroup", "FUNC4": "operator.new", "TYPE1": "char *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nMOV EDI,0x0\nTEST RSI,RSI\nJZ 0x0010a54b\nMOV RDI,RSI\nCALL 0x000901a0\nMOV RDI,RAX\nMOV qword ptr [RBX + 0x20],RDI\nCALL 0x000a8024\nMOV EDI,0x28\nCALL 0x0008fb10\nLEA RDX,[0x4d9800]\nMOV qword ptr [RAX],RDX\nMOV qword ptr [RAX + 0x10],0x0\nMOV qword ptr [RAX + 0x8],0x0\nMOV qword ptr [RAX + 0x18],0x0\nMOV byte ptr [RAX + 0x20],0x0\nMOV qword ptr [RBX],RAX\nMOV qword ptr [RBX + 0x18],0x0\nMOV dword ptr [RBX + 0x28],0x0\nADD dword ptr [0x005e2698],0x1\nMOV qword ptr [RBX + 0x8],0x0\nMOV qword ptr [RBX + 0x10],0x0\nPOP RBX\nRET\n"}, "324": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  i16 iVar1;\n  int iVar2;\n  \n  if (([VAR2] ->op == 0xa7) && ([VAR2] ->iTable == (([VAR1] ->u).pIdxCover)->iCur)) {\n    iVar1 = [FUNC2] ((([VAR1] ->u).pIdxCover)->pIdx,[VAR2] ->iColumn);\n    iVar2 = 0;\n    if (iVar1 < 0) {\n      [VAR1] ->eCode = 1;\n      iVar2 = 2;\n    }\n    return iVar2;\n  }\n  return 0;\n}", "answer": {"VAR1": "pWalker", "VAR2": "pExpr", "FUNC2": "sqlite3TableColumnToIndex", "FUNC1": "exprIdxCover", "TYPE2": "Expr *", "TYPE1": "Walker *"}, "assembly": "MOV EAX,0x0\nCMP byte ptr [RSI],0xa7\nJZ 0x00014c17\nRET\nMOV RDX,qword ptr [RDI + 0x28]\nMOV ECX,dword ptr [RDX + 0x8]\nCMP dword ptr [RSI + 0x2c],ECX\nJNZ 0x00014c15\nPUSH RBX\nMOV RBX,RDI\nMOVSX ESI,word ptr [RSI + 0x30]\nMOV RDI,qword ptr [RDX]\nCALL 0x00014bc8\nMOV EDX,EAX\nMOV EAX,0x0\nTEST DX,DX\nJS 0x00014c41\nPOP RBX\nRET\nMOV word ptr [RBX + 0x24],0x1\nMOV EAX,0x2\nJMP 0x00014c3f\n"}, "325": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  [TYPE5] [VAR5] ;\n  STROB *strb;\n  [TYPE3] [VAR3] ;\n  char *src;\n  [TYPE4] [VAR4] ;\n  \n  strb = [FUNC6] (10);\n  [FUNC7] (strb,[VAR1] );\n  src = [FUNC2] (strb);\n  [FUNC3] (src,0x5f,0x2d);\n  iVar1 = [FUNC4] (src,[VAR2] );\n  if (iVar1 < 0) {\n    [FUNC3] (src,0x2d,0x5f);\n    iVar1 = [FUNC4] (src,[VAR2] );\n    [FUNC5] (strb);\n  }\n  return iVar1;\n}", "answer": {"VAR1": "fp_optionname", "VAR2": "peop", "VAR3": "tmp", "VAR4": "optionname", "VAR5": "ret", "FUNC2": "strob_str", "FUNC3": "swlib_tr", "FUNC1": "getEnumFromName", "FUNC6": "strob_open", "TYPE3": "STROB *", "FUNC7": "strob_strcpy", "TYPE2": "extendedOptions *", "FUNC4": "i_getEnumFromName", "TYPE5": "int", "FUNC5": "strob_close", "TYPE4": "char *", "TYPE1": "char *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV R13,RSI\nMOV EDI,0xa\nCALL 0x00030251\nMOV R12,RAX\nMOV RSI,RBX\nMOV RDI,RAX\nCALL 0x00030696\nMOV RDI,R12\nCALL 0x00030bcf\nMOV RBX,RAX\nMOV EDX,0x2d\nMOV ESI,0x5f\nMOV RDI,RAX\nCALL 0x00047659\nMOV RSI,R13\nMOV RDI,RBX\nCALL 0x000319b9\nMOV EBP,EAX\nTEST EAX,EAX\nJS 0x00031dff\nMOV EAX,EBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV EDX,0x5f\nMOV ESI,0x2d\nMOV RDI,RBX\nCALL 0x00047659\nMOV RSI,R13\nMOV RDI,RBX\nCALL 0x000319b9\nMOV EBP,EAX\nMOV RDI,R12\nCALL 0x00030148\nJMP 0x00031df2\n"}, "326": {"funcbody": "void [FUNC1] (TYPE19 [VAR1] )\n{\n  if (([VAR1] != (TYPE19)0x0) && (((byte)[VAR1] [8] & 2) != 0)) {\n    [FUNC2] (*(void **)([VAR1] + 0x10));\n    [FUNC2] (*(void **)([VAR1] + 0x18));\n    [FUNC2] ([VAR1] );\n    return;\n  }\n  return;\n}", "answer": {"VAR1": "ameth", "FUNC2": "FUNC1", "FUNC1": "EVP_PKEY_asn1_free", "TYPE1": "EVP_PKEY_ASN1_METHOD *"}, "assembly": "TEST RDI,RDI\nJZ 0x001256c0\nTEST byte ptr [RDI + 0x8],0x2\nJNZ 0x001256c2\nRET\nPUSH RBX\nMOV RBX,RDI\nMOV RDI,qword ptr [RDI + 0x10]\nMOV EDX,0x114\nLEA RSI,[0x279fe4]\nCALL 0x00099268\nMOV RDI,qword ptr [RBX + 0x18]\nMOV EDX,0x115\nLEA RSI,[0x279fe4]\nCALL 0x00099268\nMOV EDX,0x116\nLEA RSI,[0x279fe4]\nMOV RDI,RBX\nCALL 0x00099268\nPOP RBX\nRET\n"}, "327": {"funcbody": "Vector<void*> * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  Vector<void*> *this;\n  Vector<int> *this_00;\n  [TYPE4] [VAR4] ;\n  Vector<int> *this_01;\n  [TYPE5] [VAR5] ;\n  DbeView *pDVar1;\n  [TYPE6] [VAR6] ;\n  Vector<int_pair_t> *pVVar2;\n  int iVar3;\n  [TYPE3] [VAR3] ;\n  \n  this = (Vector<void*> *)[FUNC4] (0x28);\n  Vector<void*>::[FUNC2] (this,2);\n  this_00 = (Vector<int> *)[FUNC4] (0x28);\n  this_00->_vptr_Vector = (_func_int_varargs **)&PTR__Vector_0058e228;\n  this_00->count = 0;\n  this_00->data = (int *)0x0;\n  this_00->limit = 0;\n  this_00->sorted = false;\n  this_01 = (Vector<int> *)[FUNC4] (0x28);\n  this_01->_vptr_Vector = (_func_int_varargs **)&PTR__Vector_0058e228;\n  this_01->count = 0;\n  this_01->data = (int *)0x0;\n  this_01->limit = 0;\n  this_01->sorted = false;\n  pDVar1 = DbeSession::[FUNC6] (dbeSession,[VAR1] );\n  if (pDVar1 == (DbeView *)0x0) {\n    return (Vector<void*> *)0x0;\n  }\n  if ([VAR2] == 5) {\nLAB_000b1f98:\n    pVVar2 = pDVar1->marks2ddis;\n    if (0 < pVVar2->count) {\n      iVar3 = 0;\n      do {\n        Vector<int>::[FUNC5] (this_00,pVVar2->data[iVar3].index1);\n        Vector<int>::[FUNC5] (this_01,pDVar1->marks2ddis->data[iVar3].index2);\n        iVar3 = iVar3 + 1;\n        pVVar2 = pDVar1->marks2ddis;\n      } while ((long)iVar3 < pVVar2->count);\n    }\n  }\n  else {\n    if ([VAR2] < 6) {\n      if ([VAR2] != 4) goto LAB_000b205e;\n    }\n    else if ([VAR2] != 0x1b) {\n      if ([VAR2] != 0x1c) goto LAB_000b205e;\n      goto LAB_000b1f98;\n    }\n    pVVar2 = pDVar1->marks2dsrc;\n    if (0 < pVVar2->count) {\n      iVar3 = 0;\n      do {\n        Vector<int>::[FUNC5] (this_00,pVVar2->data[iVar3].index1);\n        Vector<int>::[FUNC5] (this_01,pDVar1->marks2dsrc->data[iVar3].index2);\n        iVar3 = iVar3 + 1;\n        pVVar2 = pDVar1->marks2dsrc;\n      } while ((long)iVar3 < pVVar2->count);\n    }\n  }\nLAB_000b205e:\n  Vector<void*>::[FUNC3] (this,0,this_00);\n  Vector<void*>::[FUNC3] (this,1,this_01);\n  return this;\n}", "answer": {"VAR1": "dbevindex", "VAR2": "type", "VAR3": "table", "VAR4": "table0", "VAR5": "table1", "VAR6": "dbev", "FUNC2": "Vector", "FUNC3": "store", "FUNC1": "dbeGetHotMarks", "FUNC6": "getView", "TYPE3": "Vector<void*> *", "TYPE2": "int", "FUNC4": "operator.new", "TYPE5": "Vector<int> *", "FUNC5": "append", "TYPE4": "Vector<int> *", "TYPE6": "DbeView *", "TYPE1": "int"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R15D,EDI\nMOV R13D,ESI\nMOV EDI,0x28\nCALL 0x0008f820\nMOV R14,RAX\nMOV ESI,0x2\nMOV RDI,RAX\nCALL 0x000c59a0\nMOV EDI,0x28\nCALL 0x0008f820\nMOV RBP,RAX\nLEA R12,[0x58e228]\nMOV qword ptr [RAX],R12\nMOV qword ptr [RAX + 0x10],0x0\nMOV qword ptr [RAX + 0x8],0x0\nMOV qword ptr [RAX + 0x18],0x0\nMOV byte ptr [RAX + 0x20],0x0\nMOV EDI,0x28\nCALL 0x0008f820\nMOV RBX,RAX\nMOV qword ptr [RAX],R12\nMOV qword ptr [RAX + 0x10],0x0\nMOV qword ptr [RAX + 0x8],0x0\nMOV qword ptr [RAX + 0x18],0x0\nMOV byte ptr [RAX + 0x20],0x0\nMOV ESI,R15D\nMOV RDI,qword ptr [0x005d6b98]\nCALL 0x000daaa2\nTEST RAX,RAX\nJZ 0x000b2090\nMOV R12,RAX\nCMP R13D,0x5\nJZ 0x000b1f98\nCMP R13D,0x5\nJLE 0x000b1ffb\nCMP R13D,0x1b\nJZ 0x000b2001\nCMP R13D,0x1c\nJNZ 0x000b205e\nMOV RAX,qword ptr [R12 + 0xf8]\nCMP qword ptr [RAX + 0x10],0x0\nJLE 0x000b205e\nMOV R13D,0x0\nMOVSXD RDX,R13D\nLEA R15,[RDX*0x8]\nMOV RAX,qword ptr [RAX + 0x8]\nMOV ESI,dword ptr [RAX + RDX*0x8]\nMOV RDI,RBP\nCALL 0x0009e618\nMOV RAX,qword ptr [R12 + 0xf8]\nMOV RAX,qword ptr [RAX + 0x8]\nMOV ESI,dword ptr [RAX + R15*0x1 + 0x4]\nMOV RDI,RBX\nCALL 0x0009e618\nADD R13D,0x1\nMOV RAX,qword ptr [R12 + 0xf8]\nMOVSXD RDX,R13D\nCMP RDX,qword ptr [RAX + 0x10]\nJL 0x000b1fb1\nJMP 0x000b205e\nCMP R13D,0x4\nJNZ 0x000b205e\nMOV RAX,qword ptr [R12 + 0xe8]\nCMP qword ptr [RAX + 0x10],0x0\nJLE 0x000b205e\nMOV R13D,0x0\nMOVSXD RDX,R13D\nLEA R15,[RDX*0x8]\nMOV RAX,qword ptr [RAX + 0x8]\nMOV ESI,dword ptr [RAX + RDX*0x8]\nMOV RDI,RBP\nCALL 0x0009e618\nMOV RAX,qword ptr [R12 + 0xe8]\nMOV RAX,qword ptr [RAX + 0x8]\nMOV ESI,dword ptr [RAX + R15*0x1 + 0x4]\nMOV RDI,RBX\nCALL 0x0009e618\nADD R13D,0x1\nMOV RAX,qword ptr [R12 + 0xe8]\nMOVSXD RDX,R13D\nCMP RDX,qword ptr [RAX + 0x10]\nJL 0x000b2016\nMOV RDX,RBP\nMOV ESI,0x0\nMOV RDI,R14\nCALL 0x000c63c8\nMOV RDX,RBX\nMOV ESI,0x1\nMOV RDI,R14\nCALL 0x000c63c8\nMOV RAX,R14\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV R14D,0x0\nJMP 0x000b207e\n"}, "328": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  char *__s2;\n  int iVar1;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  long *plVar2;\n  [TYPE7] [VAR7] ;\n  char **ppcVar3;\n  [TYPE4] [VAR4] ;\n  char *__s1;\n  \n  if ((*(int *)(*[VAR1] + 0xa8) == 0) && (iVar1 = [FUNC3] ((sglobal *)[VAR1] ), iVar1 != 0)) {\n    return iVar1;\n  }\n  plVar2 = *(long **)(*[VAR1] + 0xb8);\n  if (plVar2 == (long *)0x0) {\n    return 0;\n  }\n  do {\n    iVar1 = [FUNC2] ((char *)plVar2[1],[VAR3] );\n    if (iVar1 == 0) {\n      ppcVar3 = (char **)plVar2[2];\n      __s1 = *ppcVar3;\n      if (__s1 == (char *)0x0) {\n        return 1;\n      }\n      __s2 = [VAR2] ->uuconf_zname;\n      do {\n        iVar1 = [FUNC2] (__s1,__s2);\n        if (iVar1 == 0) {\n          return 0;\n        }\n        ppcVar3 = ppcVar3 + 1;\n        __s1 = *ppcVar3;\n      } while (__s1 != (char *)0x0);\n      return 1;\n    }\n    plVar2 = (long *)*plVar2;\n  } while (plVar2 != (long *)0x0);\n  return 0;\n}", "answer": {"VAR1": "pglobal", "VAR2": "qsys", "VAR3": "zlogin", "VAR4": "qglobal", "VAR5": "q", "VAR6": "iret", "FUNC2": "strcmp", "FUNC3": "_uuconf_iread_locations", "FUNC1": "uuconf_taylor_validate", "TYPE3": "char *", "TYPE2": "uuconf_system *", "TYPE5": "svalidate *", "TYPE4": "sglobal *", "TYPE7": "char * *", "TYPE6": "int", "VAR7": "pz", "TYPE1": "pointer"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV RBP,RSI\nMOV R12,RDX\nMOV RAX,qword ptr [RDI]\nCMP dword ptr [RAX + 0xa8],0x0\nJZ 0x0002f9b3\nMOV RAX,qword ptr [RBX]\nMOV RBX,qword ptr [RAX + 0xb8]\nTEST RBX,RBX\nJZ 0x0002f9ed\nMOV RDI,qword ptr [RBX + 0x8]\nMOV RSI,R12\nCALL 0x00005b28\nTEST EAX,EAX\nJZ 0x0002f9be\nMOV RBX,qword ptr [RBX]\nTEST RBX,RBX\nJNZ 0x0002f991\nMOV EAX,0x0\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x0002ee43\nTEST EAX,EAX\nJZ 0x0002f982\nJMP 0x0002f9ae\nMOV RBX,qword ptr [RBX + 0x10]\nMOV RDI,qword ptr [RBX]\nTEST RDI,RDI\nJZ 0x0002f9f4\nMOV RBP,qword ptr [RBP]\nMOV RSI,RBP\nCALL 0x00005b28\nTEST EAX,EAX\nJZ 0x0002f9ae\nADD RBX,0x8\nMOV RDI,qword ptr [RBX]\nTEST RDI,RDI\nJNZ 0x0002f9ce\nMOV EAX,0x1\nJMP 0x0002f9ae\nMOV EAX,0x0\nJMP 0x0002f9ae\nMOV EAX,0x1\nJMP 0x0002f9ae\n"}, "329": {"funcbody": "void [FUNC1] (float param_1,float param_2,long param_3,int param_4,undefined8 param_5,int param_6,\n          int param_7)\n{\n  uint uVar1;\n  long lVar2;\n  long lVar3;\n  \n  if (0 < param_4) {\n    lVar3 = (long)param_7;\n    param_3 = param_3 + lVar3 * -2;\n    lVar2 = lVar3;\n    do {\n      uVar1 = (uint)*(ushort *)(param_3 + lVar2 * 2);\n      *(short *)(param_3 + lVar2 * 2) =\n           (short)(int)((float)(param_6 - uVar1) * param_1 + (float)uVar1 * param_2);\n      lVar2 = lVar2 + lVar3;\n    } while ((int)lVar2 - param_7 < param_4);\n  }\n  return;\n}", "answer": {"FUNC1": "FUN_003704c0"}, "assembly": "TEST ESI,ESI\nJLE 0x00370512\nMOVSXD R10,R8D\nMOV RAX,R10\nNEG RAX\nLEA R9,[RDI + RAX*0x2]\nMOV RDI,R10\nNOP dword ptr [RAX]\nMOVZX EDX,word ptr [R9 + RDI*0x2]\nPXOR XMM2,XMM2\nPXOR XMM3,XMM3\nMOV EAX,ECX\nSUB EAX,EDX\nCVTSI2SS XMM2,EAX\nCVTSI2SS XMM3,EDX\nMULSS XMM2,XMM0\nMULSS XMM3,XMM1\nADDSS XMM2,XMM3\nCVTTSS2SI EAX,XMM2\nMOV word ptr [R9 + RDI*0x2],AX\nADD RDI,R10\nMOV EAX,EDI\nSUB EAX,R8D\nCMP ESI,EAX\nJG 0x003704d8\nRET\n"}, "330": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,TYPE20 [VAR2] ,TYPE36 [VAR3] )\n{\n  (*[VAR1] ->xvec->bfd_h_putx32)((bfd_vma)[VAR2] ->sh_name,[VAR3] );\n  (*[VAR1] ->xvec->bfd_h_putx32)((bfd_vma)[VAR2] ->sh_type,[VAR3] ->sh_type);\n  (*[VAR1] ->xvec->bfd_h_putx32)([VAR2] ->sh_flags,[VAR3] ->sh_flags);\n  (*[VAR1] ->xvec->bfd_h_putx32)([VAR2] ->sh_addr,[VAR3] ->sh_addr);\n  (*[VAR1] ->xvec->bfd_h_putx32)([VAR2] ->sh_offset,[VAR3] ->sh_offset);\n  (*[VAR1] ->xvec->bfd_h_putx32)([VAR2] ->sh_size,[VAR3] ->sh_size);\n  (*[VAR1] ->xvec->bfd_h_putx32)((bfd_vma)[VAR2] ->sh_link,[VAR3] ->sh_link);\n  (*[VAR1] ->xvec->bfd_h_putx32)((bfd_vma)[VAR2] ->sh_info,[VAR3] ->sh_info);\n  (*[VAR1] ->xvec->bfd_h_putx32)([VAR2] ->sh_addralign,[VAR3] ->sh_addralign);\n  (*[VAR1] ->xvec->bfd_h_putx32)([VAR2] ->sh_entsize,[VAR3] ->sh_entsize);\n  return;\n}", "answer": {"VAR1": "abfd", "VAR2": "src", "VAR3": "dst", "FUNC1": "elf_swap_shdr_out", "TYPE3": "Elf32_External_Shdr *", "TYPE2": "Elf_Internal_Shdr *", "TYPE1": "bfd *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,RDI\nMOV R12,RSI\nMOV RBX,RDX\nMOV EDI,dword ptr [RSI]\nMOV RAX,qword ptr [RBP + 0x8]\nMOV RSI,RDX\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x4]\nMOV EDI,dword ptr [R12 + 0x4]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x8]\nMOV RDI,qword ptr [R12 + 0x8]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0xc]\nMOV RDI,qword ptr [R12 + 0x10]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x10]\nMOV RDI,qword ptr [R12 + 0x18]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x14]\nMOV RDI,qword ptr [R12 + 0x20]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x18]\nMOV EDI,dword ptr [R12 + 0x28]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x1c]\nMOV EDI,dword ptr [R12 + 0x2c]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x20]\nMOV RDI,qword ptr [R12 + 0x30]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x24]\nMOV RDI,qword ptr [R12 + 0x38]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "331": {"funcbody": "void [FUNC1] (TYPE12 [VAR1] )\n{\n  char cVar1;\n  int iVar2;\n  undefined8 *puVar3;\n  [TYPE6] [VAR6] ;\n  [TYPE4] [VAR4] ;\n  long lVar4;\n  [TYPE7] [VAR7] ;\n  uint uVar5;\n  undefined8 *puVar6;\n  [TYPE2] [VAR2] ;\n  char *pcVar7;\n  [TYPE3] [VAR3] ;\n  char *pcVar8;\n  [TYPE5] [VAR5] ;\n  uint uVar9;\n  int [VAR8] ;\n  \n  if (sapi_globals.default_mimetype == (char *)0x0) {\n    uVar5 = 9;\n    pcVar7 = \"text/html\";\n    if (sapi_globals.default_charset != (char *)0x0) goto LAB_0034fad8;\n    [VAR8] = 5;\n    pcVar8 = \"UTF-8\";\nLAB_0034fb7b:\n    iVar2 = [VAR8] + 0xe + uVar5;\n    uVar9 = iVar2 + 10;\n    puVar3 = (undefined8 *)[FUNC3] ((ulong)(iVar2 + 0xb));\n    [FUNC2] ((void *)((long)puVar3 + 0xe),pcVar7,(ulong)uVar5);\n    puVar6 = (undefined8 *)((ulong)uVar5 + (long)(void *)((long)puVar3 + 0xe));\n    *puVar6 = 0x657372616863203b;\n    *(undefined2 *)(puVar6 + 1) = 0x3d74;\n    [FUNC2] ((void *)((long)puVar6 + 10),pcVar8,(ulong)([VAR8] + 1));\n  }\n  else {\n    lVar4 = -1;\n    pcVar7 = sapi_globals.default_mimetype;\n    do {\n      if (lVar4 == 0) break;\n      lVar4 = lVar4 + -1;\n      cVar1 = *pcVar7;\n      pcVar7 = pcVar7 + 1;\n    } while (cVar1 != '\\0');\n    uVar5 = ~(uint)lVar4 - 1;\n    pcVar7 = sapi_globals.default_mimetype;\n    if (sapi_globals.default_charset == (char *)0x0) {\n      [VAR8] = 5;\n      pcVar8 = \"UTF-8\";\nLAB_0034fb63:\n      iVar2 = [FUNC4] (pcVar7,\"text/\",5);\n      if (iVar2 == 0) goto LAB_0034fb7b;\n    }\n    else {\nLAB_0034fad8:\n      lVar4 = -1;\n      pcVar8 = sapi_globals.default_charset;\n      do {\n        if (lVar4 == 0) break;\n        lVar4 = lVar4 + -1;\n        cVar1 = *pcVar8;\n        pcVar8 = pcVar8 + 1;\n      } while (cVar1 != '\\0');\n      [VAR8] = ~(uint)lVar4 - 1;\n      pcVar8 = sapi_globals.default_charset;\n      if (*sapi_globals.default_charset != '\\0') goto LAB_0034fb63;\n    }\n    uVar9 = uVar5 + 0xe;\n    puVar3 = (undefined8 *)[FUNC3] ((ulong)(uVar5 + 0xf));\n    [FUNC2] ((void *)((long)puVar3 + 0xe),pcVar7,(ulong)(uVar5 + 1));\n  }\n  [VAR1] ->header = (char *)puVar3;\n  [VAR1] ->header_len = (ulong)uVar9;\n  *puVar3 = 0x2d746e65746e6f43;\n  *(undefined4 *)(puVar3 + 1) = 0x65707974;\n  *(undefined2 *)((long)puVar3 + 0xc) = 0x203a;\n  return;\n}", "answer": {"VAR1": "default_header", "VAR2": "mimetype", "VAR3": "charset", "VAR4": "charset_len", "VAR5": "len", "VAR6": "content_type", "FUNC2": "memcpy", "FUNC3": "_emalloc", "FUNC1": "sapi_get_default_content_type_header", "TYPE3": "char *", "TYPE2": "char *", "FUNC4": "strncasecmp", "TYPE5": "uint32_t", "TYPE4": "uint32_t", "TYPE7": "char *", "TYPE6": "char *", "TYPE8": "undefined4", "VAR7": "p", "VAR8": "local_3c", "TYPE1": "sapi_header_struct *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV R14,RDI\nMOV R12,qword ptr [0x01219b70]\nTEST R12,R12\nJZ 0x0034fbd8\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,R12\nSCASB.REPNE RDI\nMOV RSI,RCX\nNOT RSI\nLEA EBP,[RSI + -0x1]\nMOV R13,qword ptr [0x01219b78]\nTEST R13,R13\nJZ 0x0034fb54\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,R13\nSCASB.REPNE RDI\nMOV RSI,RCX\nNOT RSI\nMOV RCX,RSI\nSUB RCX,0x1\nCMP byte ptr [R13],0x0\nJNZ 0x0034fb4e\nLEA R15D,[RBP + 0xe]\nLEA EDI,[RBP + 0xf]\nCALL 0x0038c50c\nMOV RBX,RAX\nLEA RDI,[RAX + 0xe]\nLEA EDX,[RBP + 0x1]\nMOV RSI,R12\nCALL 0x000fa320\nMOV qword ptr [R14],RBX\nMOV EAX,R15D\nMOV qword ptr [R14 + 0x8],RAX\nMOV RAX,0x2d746e65746e6f43\nMOV qword ptr [RBX],RAX\nMOV dword ptr [RBX + 0x8],0x65707974\nMOV word ptr [RBX + 0xc],0x203a\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV dword ptr [RSP + 0xc],ECX\nJMP 0x0034fb63\nMOV dword ptr [RSP + 0xc],0x5\nLEA R13,[0xccfb5e]\nMOV EDX,0x5\nLEA RSI,[0xce177f]\nMOV RDI,R12\nCALL 0x000fac00\nTEST EAX,EAX\nJNZ 0x0034fafd\nMOV EAX,dword ptr [RSP + 0xc]\nLEA EAX,[RAX + RBP*0x1 + 0xe]\nLEA R15D,[RAX + 0xa]\nLEA EDI,[RAX + 0xb]\nCALL 0x0038c50c\nMOV RBX,RAX\nLEA RCX,[RAX + 0xe]\nMOV EBP,EBP\nMOV RDX,RBP\nMOV RSI,R12\nMOV R12,RCX\nMOV RDI,RCX\nCALL 0x000fa320\nADD RBP,R12\nMOV RSI,0x657372616863203b\nMOV qword ptr [RBP],RSI\nMOV word ptr [RBP + 0x8],0x3d74\nLEA RDI,[RBP + 0xa]\nMOV EAX,dword ptr [RSP + 0xc]\nLEA EDX,[RAX + 0x1]\nMOV RSI,R13\nCALL 0x000fa320\nJMP 0x0034fb1b\nMOV R13,qword ptr [0x01219b78]\nMOV EBP,0x9\nLEA R12,[0xce1775]\nTEST R13,R13\nJNZ 0x0034fad8\nMOV dword ptr [RSP + 0xc],0x5\nLEA R13,[0xccfb5e]\nJMP 0x0034fb7b\n"}, "332": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] )\n{\n  char *pcVar1;\n  \n  pcVar1 = \"invalid\";\n  if (((([VAR1] < bfd_type_end) && (pcVar1 = \"archive\", [VAR1] != bfd_archive)) &&\n      (pcVar1 = \"core\", [VAR1] != bfd_core)) && (pcVar1 = \"object\", [VAR1] != bfd_object)) {\n    pcVar1 = \"unknown\";\n  }\n  return pcVar1;\n}", "answer": {"VAR1": "format", "FUNC1": "bfd_format_string", "TYPE1": "bfd_format"}, "assembly": "LEA RAX,[0xee243]\nCMP EDI,0x3\nJA 0x000396ea\nLEA RAX,[0xefcfa]\nCMP EDI,0x2\nJZ 0x000396ea\nLEA RAX,[0xf012a]\nCMP EDI,0x3\nJZ 0x000396ea\nCMP EDI,0x1\nLEA RAX,[0xf1201]\nLEA RDX,[0xef5c6]\nCMOVNZ RAX,RDX\nRET\n"}, "333": {"funcbody": "int [FUNC1] (TYPE13 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,TYPE47 [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] ,[TYPE8] [VAR8] ,\n         [TYPE9] [VAR9] )\n{\n  ulong uVar1;\n  int iVar2;\n  ulong uVar3;\n  ulong uVar4;\n  ulong uVar5;\n  ulong uVar6;\n  [TYPE10] [VAR10] ;\n  byte bVar7;\n  size_t good;\n  ulong uVar8;\n  [TYPE11] [VAR11] ;\n  [TYPE12] [VAR12] ;\n  \n  uVar6 = ([VAR6] != 1) + [VAR7] ;\n  uVar1 = *[VAR1] ;\n  if (uVar1 < uVar6) {\n    return 0;\n  }\n  if ([VAR6] == 1) {\n    good = 0xffffffffffffffff;\n    goto LAB_0010a86b;\n  }\n  uVar8 = (ulong)[VAR3] [uVar1 - 1];\n  if ([VAR8] != 0) {\n    *[VAR1] = ((uVar1 - 1) - [VAR7] ) - uVar8;\n    return 1;\n  }\n  uVar6 = uVar6 + uVar8;\n  uVar6 = ~((long)((uVar6 ^ uVar1 | uVar1 - uVar6 ^ uVar6) ^ uVar1) >> 0x3f);\n  bVar7 = (byte)uVar6;\n  if (uVar1 < 0x100) {\n    uVar3 = uVar1;\n    if (uVar1 != 0) goto LAB_0010a7f1;\n  }\n  else {\n    uVar3 = 0x100;\nLAB_0010a7f1:\n    uVar4 = 0;\n    uVar5 = uVar8;\n    do {\n      uVar6 = uVar6 & (~(ulong)([VAR3] [uVar1 - 1] ^ [VAR3] [uVar5 + (uVar1 - uVar8) + -1]) |\n                      (long)((uVar8 ^ uVar4 | uVar5 ^ uVar4) ^ uVar8) >> 0x3f);\n      bVar7 = (byte)uVar6;\n      uVar4 = uVar4 + 1;\n      uVar5 = uVar5 - 1;\n    } while (uVar4 < uVar3);\n  }\n  good = (long)((ulong)(byte)~bVar7 - 1 & ~(ulong)(byte)~bVar7) >> 0x3f;\n  *[VAR1] = uVar1 - (uVar8 + 1 & good);\nLAB_0010a86b:\n  iVar2 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR3] ,[VAR4] ,[VAR5] ,[VAR6] ,[VAR7] ,good,[VAR9] );\n  return iVar2;\n}", "answer": {"VAR1": "reclen", "VAR2": "origreclen", "VAR3": "recdata", "VAR4": "mac", "VAR5": "alloced", "VAR6": "block_size", "FUNC2": "ssl3_cbc_copy_mac", "FUNC1": "tls1_cbc_remove_padding_and_mac", "TYPE3": "uchar *", "TYPE2": "size_t", "TYPE5": "int *", "VAR12": "local_40", "TYPE4": "uchar * *", "TYPE7": "size_t", "TYPE6": "size_t", "TYPE9": "OSSL_LIB_CTX *", "TYPE8": "int", "VAR7": "mac_size", "TYPE11": "size_t", "VAR8": "aead", "TYPE12": "undefined8", "VAR9": "libctx", "TYPE10": "size_t", "VAR10": "overhead", "VAR11": "padding_length", "TYPE1": "size_t *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nCMP R9,0x1\nSETNZ R10B\nMOVZX R10D,R10B\nADD R10,qword ptr [RSP + 0x50]\nMOV R13,qword ptr [RDI]\nMOV EAX,0x0\nCMP R13,R10\nJC 0x0010a882\nCMP R9,0x1\nJZ 0x0010a891\nLEA RAX,[R13 + -0x1]\nMOVZX R14D,byte ptr [RDX + R13*0x1 + -0x1]\nMOVZX R12D,R14B\nCMP dword ptr [RSP + 0x58],0x0\nJNZ 0x0010a7d7\nADD R10,R12\nMOV R11,R13\nSUB R11,R10\nXOR R11,R10\nXOR R10,R13\nOR R10,R11\nMOV R11,R10\nXOR R11,R13\nSAR R11,0x3f\nNOT R11\nCMP R13,0xff\nJA 0x0010a7ec\nMOV RAX,R13\nTEST R13,R13\nJNZ 0x0010a7f1\nJMP 0x0010a846\nSUB RAX,qword ptr [RSP + 0x50]\nSUB RAX,R12\nMOV qword ptr [RDI],RAX\nMOV EAX,0x1\nJMP 0x0010a882\nMOV EAX,0x100\nMOV RBP,R12\nMOV EBX,0x0\nMOV R15,R13\nSUB R15,R12\nADD R15,RDX\nMOV qword ptr [RSP + 0x8],RDX\nMOV RDX,RAX\nMOV R10,R12\nXOR R10,RBX\nMOV RAX,RBP\nXOR RAX,RBX\nOR R10,RAX\nXOR R10,R12\nSAR R10,0x3f\nMOV EAX,R14D\nXOR AL,byte ptr [R15 + RBP*0x1 + -0x1]\nMOVZX EAX,AL\nNOT RAX\nOR RAX,R10\nAND R11,RAX\nADD RBX,0x1\nSUB RBP,0x1\nCMP RBX,RDX\nJC 0x0010a80a\nMOV RDX,qword ptr [RSP + 0x8]\nNOT R11\nMOVZX R11D,R11B\nMOV RAX,R11\nNOT RAX\nSUB R11,0x1\nAND R11,RAX\nSAR R11,0x3f\nADD R12,0x1\nAND R12,R11\nSUB R13,R12\nMOV qword ptr [RDI],R13\nSUB RSP,0x8\nPUSH qword ptr [RSP + 0x68]\nPUSH R11\nPUSH qword ptr [RSP + 0x68]\nCALL 0x0010a42b\nADD RSP,0x20\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV R11,-0x1\nJMP 0x0010a86b\n"}, "334": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  size_t __n;\n  int iVar1;\n  kmac_data_st *vmacctx;\n  TYPE34 [VAR3] ;\n  TYPE26 [VAR2] ;\n  \n  iVar1 = [FUNC2] ();\n  if ((iVar1 != 0) && (vmacctx = [FUNC6] (*[VAR1] ), vmacctx != (kmac_data_st *)0x0)) {\n    iVar1 = [FUNC5] ((EVP_MD_CTX *)vmacctx->ctx,*(EVP_MD_CTX **)((long)[VAR1] + 8));\n    if ((iVar1 != 0) &&\n       (iVar1 = [FUNC4] (&vmacctx->digest,(PROV_DIGEST *)((long)[VAR1] + 0x10)), iVar1 != 0)) {\n      vmacctx->out_len = *(size_t *)((long)[VAR1] + 0x28);\n      vmacctx->key_len = *(size_t *)((long)[VAR1] + 0x30);\n      __n = *(size_t *)((long)[VAR1] + 0x38);\n      vmacctx->custom_len = __n;\n      vmacctx->xof_mode = *(int *)((long)[VAR1] + 0x40);\n      [FUNC3] (vmacctx->key,(void *)((long)[VAR1] + 0x44),*(size_t *)((long)[VAR1] + 0x30));\n      [FUNC3] (vmacctx->custom,(void *)((long)[VAR1] + 0x194),__n);\n      return vmacctx;\n    }\n    [FUNC7] (vmacctx);\n  }\n  return (void *)0x0;\n}", "answer": {"VAR1": "vsrc", "VAR2": "src", "VAR3": "dst", "FUNC2": "ossl_prov_is_running", "FUNC3": "memcpy", "FUNC1": "kmac_dup", "FUNC6": "kmac_new", "TYPE3": "kmac_data_st *", "FUNC7": "kmac_free", "TYPE2": "kmac_data_st *", "FUNC4": "ossl_prov_digest_copy", "FUNC5": "EVP_MD_CTX_copy", "TYPE1": "void *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nCALL 0x000f1526\nTEST EAX,EAX\nJZ 0x001271c9\nMOV RDI,qword ptr [RBX]\nCALL 0x001270c2\nMOV RBP,RAX\nTEST RAX,RAX\nJZ 0x001271d0\nMOV RSI,qword ptr [RBX + 0x8]\nMOV RDI,qword ptr [RAX + 0x8]\nCALL 0x0009ba80\nTEST EAX,EAX\nJZ 0x001271ba\nLEA RSI,[RBX + 0x10]\nLEA RDI,[RBP + 0x10]\nCALL 0x000f20e6\nTEST EAX,EAX\nJZ 0x001271ba\nMOV RAX,qword ptr [RBX + 0x28]\nMOV qword ptr [RBP + 0x28],RAX\nMOV RAX,qword ptr [RBX + 0x30]\nMOV qword ptr [RBP + 0x30],RAX\nMOV R12,qword ptr [RBX + 0x38]\nMOV qword ptr [RBP + 0x38],R12\nMOV EAX,dword ptr [RBX + 0x40]\nMOV dword ptr [RBP + 0x40],EAX\nLEA RDI,[RBP + 0x44]\nLEA RSI,[RBX + 0x44]\nMOV RDX,qword ptr [RBX + 0x30]\nCALL 0x00065830\nLEA RDI,[RBP + 0x194]\nLEA RSI,[RBX + 0x194]\nMOV RDX,R12\nCALL 0x00065830\nMOV RAX,RBP\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,RBP\nCALL 0x00127072\nMOV EBP,0x0\nJMP 0x001271b2\nMOV EBP,0x0\nJMP 0x001271b2\nMOV EBP,0x0\nJMP 0x001271b2\n"}, "335": {"funcbody": "void [FUNC1] (void)\n{\n  long lVar1;\n  \n  if (9 < grub_error_stack_pos) {\n    grub_error_stack_assert = 1;\n    grub_errno = GRUB_ERR_NONE;\n    return;\n  }\n  lVar1 = (long)grub_error_stack_pos;\n  grub_error_stack_items[lVar1].grub_errno = grub_errno;\n  [FUNC2] (grub_error_stack_items[lVar1].errmsg,grub_errmsg,0x100);\n  grub_error_stack_pos = grub_error_stack_pos + 1;\n  grub_errno = GRUB_ERR_NONE;\n  return;\n}", "answer": {"FUNC2": "grub_memmove", "FUNC1": "grub_error_push"}, "assembly": "MOV EAX,dword ptr [0x0025a764]\nCMP EAX,0x9\nJLE 0x0001e571\nMOV dword ptr [0x0025a760],0x1\nMOV dword ptr [0x0025b560],0x0\nRET\nSUB RSP,0x8\nLEA RCX,[0x25a780]\nCDQE\nMOV RDX,RAX\nSHL RDX,0x6\nLEA RSI,[RDX + RAX*0x1]\nMOV EDI,dword ptr [0x0025b560]\nMOV dword ptr [RCX + RSI*0x4],EDI\nLEA RDI,[RCX + RSI*0x4 + 0x4]\nMOV EDX,0x100\nLEA RSI,[0x25b460]\nCALL 0x0001e740\nADD dword ptr [0x0025a764],0x1\nMOV dword ptr [0x0025b560],0x0\nADD RSP,0x8\nRET\n"}, "336": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR6] = [VAR1] ;\n  if ([VAR1] == ([TYPE1] )0x0) {\n    [VAR6] = registrar_list;\n  }\n  [VAR5] .name = [VAR2] ;\n  [VAR5] .flags = [VAR3] ;\n  iVar2 = [FUNC4] ([VAR6] ,[FUNC3] ,&[VAR5] );\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC2] ();\n  }\n  return (int)(iVar2 == 0);\n}", "answer": {"VAR1": "rlist", "VAR2": "name", "VAR3": "flags", "VAR4": "local_10", "VAR5": "cls", "VAR6": "rlist-local", "FUNC2": "__stack_chk_fail", "FUNC3": "record_listable", "FUNC1": "mu_registrar_list_p", "TYPE3": "int", "TYPE2": "char *", "FUNC4": "mu_list_foreach", "TYPE5": "listable_closure", "TYPE4": "undefined8", "TYPE7": "char *", "TYPE6": "mu_list_t", "TYPE8": "int", "VAR7": "name-local", "VAR8": "flags-local", "TYPE1": "mu_list_t"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nSUB RSP,0x40\nMOV qword ptr [RBP + -0x28],RDI\nMOV qword ptr [RBP + -0x30],RSI\nMOV dword ptr [RBP + -0x34],EDX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RBP + -0x8],RAX\nXOR EAX,EAX\nMOV RAX,qword ptr [RBP + -0x30]\nMOV qword ptr [RBP + -0x20],RAX\nMOV EAX,dword ptr [RBP + -0x34]\nMOV dword ptr [RBP + -0x18],EAX\nCMP qword ptr [RBP + -0x28],0x0\nJNZ 0x0003afef\nMOV RAX,qword ptr [0x002df0d8]\nMOV qword ptr [RBP + -0x28],RAX\nLEA RDX,[RBP + -0x20]\nMOV RAX,qword ptr [RBP + -0x28]\nLEA RSI,[0x3af66]\nMOV RDI,RAX\nCALL 0x00025820\nTEST EAX,EAX\nSETZ AL\nMOVZX EAX,AL\nMOV RCX,qword ptr [RBP + -0x8]\nXOR RCX,qword ptr FS:[0x28]\nJZ 0x0003b022\nCALL 0x00023730\nLEAVE\nRET\n"}, "337": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] )\n{\n  int iVar1;\n  [TYPE8] [VAR8] ;\n  \n  iVar1 = [FUNC7] ();\n  if (iVar1 == 0) {\n    return 0;\n  }\n  *(byte *)[VAR1] = *[VAR1] & 0xfe | (byte)[VAR7] & 1;\n  if ([VAR4] != ([TYPE4] )0x0) {\n    if ([VAR5] != 0xfU - *(long *)((long)[VAR1] + 8)) {\n      [FUNC3] ();\n      [FUNC5] (\"providers/implementations/ciphers/ciphercommon_ccm.c\",0xeb,\"ccm_init\");\n      [FUNC4] (0x39,0x6d,(char *)0x0);\n      return 0;\n    }\n    [FUNC2] ((void *)((long)[VAR1] + 0x30),[VAR4] ,[VAR5] );\n    *(byte *)[VAR1] = *[VAR1] | 4;\n  }\n  if ([VAR2] != ([TYPE2] )0x0) {\n    if (*([TYPE3] *)((long)[VAR1] + 0x18) != [VAR3] ) {\n      [FUNC3] ();\n      [FUNC5] (\"providers/implementations/ciphers/ciphercommon_ccm.c\",0xf3,\"ccm_init\");\n      [FUNC4] (0x39,0x69,(char *)0x0);\n      return 0;\n    }\n    iVar1 = (***(code ***)((long)[VAR1] + 0x90))([VAR1] ,[VAR2] );\n    if (iVar1 == 0) {\n      return 0;\n    }\n  }\n  iVar1 = [FUNC6] ([VAR1] ,[VAR6] );\n  return iVar1;\n}", "answer": {"VAR1": "vctx", "VAR2": "key", "VAR3": "keylen", "VAR4": "iv", "VAR5": "ivlen", "VAR6": "params", "FUNC2": "memcpy", "FUNC3": "ERR_new", "FUNC1": "ccm_init", "FUNC6": "ossl_ccm_set_ctx_params", "TYPE3": "size_t", "FUNC7": "ossl_prov_is_running", "TYPE2": "uchar *", "FUNC4": "ERR_set_error", "TYPE5": "size_t", "FUNC5": "ERR_set_debug", "TYPE4": "uchar *", "TYPE7": "int", "TYPE6": "OSSL_PARAM *", "TYPE8": "PROV_CCM_CTX *", "VAR7": "enc", "VAR8": "ctx", "TYPE1": "void *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV R12,RSI\nMOV R14,RDX\nMOV RBP,RCX\nMOV R13,R8\nMOV R15,R9\nCALL 0x000c3c98\nTEST EAX,EAX\nJZ 0x00108295\nMOVZX EDX,byte ptr [RSP + 0x40]\nAND EDX,0x1\nMOVZX EAX,byte ptr [RBX]\nAND EAX,0xfffffffe\nOR EAX,EDX\nMOV byte ptr [RBX],AL\nTEST RBP,RBP\nJZ 0x001082b6\nMOV EAX,0xf\nSUB RAX,qword ptr [RBX + 0x8]\nCMP R13,RAX\nJZ 0x001082a4\nCALL 0x00080e6e\nLEA RDX,[0x292ad8]\nMOV ESI,0xeb\nLEA RDI,[0x292a70]\nCALL 0x00080f7b\nMOV EDX,0x0\nMOV ESI,0x6d\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00081292\nMOV EAX,0x0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nLEA RDI,[RBX + 0x30]\nMOV RDX,R13\nMOV RSI,RBP\nCALL 0x00062840\nOR byte ptr [RBX],0x4\nTEST R12,R12\nJZ 0x001082d7\nMOV RDX,qword ptr [RBX + 0x18]\nCMP RDX,R14\nJNZ 0x001082e4\nMOV RAX,qword ptr [RBX + 0x90]\nMOV RSI,R12\nMOV RDI,RBX\nCALL qword ptr [RAX]\nTEST EAX,EAX\nJZ 0x00108295\nMOV RSI,R15\nMOV RDI,RBX\nCALL 0x00107ddb\nJMP 0x00108295\nCALL 0x00080e6e\nLEA RDX,[0x292ad8]\nMOV ESI,0xf3\nLEA RDI,[0x292a70]\nCALL 0x00080f7b\nMOV EDX,0x0\nMOV ESI,0x69\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00081292\nMOV EAX,0x0\nJMP 0x00108295\n"}, "338": {"funcbody": "void [FUNC1] (TYPE15 [VAR1] ,[TYPE2] [VAR2] )\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC2] (4,(OPENSSL_INIT_SETTINGS *)0x0);\n  [VAR4] .arg = [VAR2] ;\n  [VAR4] .fn = (_func_void_EVP_CIPHER_ptr_char_ptr_char_ptr_void_ptr *)[VAR1] ;\n  [FUNC3] (2,[FUNC5] ,&[VAR4] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC4] ();\n}", "answer": {"VAR1": "fn", "VAR2": "arg", "VAR3": "local_20", "VAR4": "dc", "FUNC2": "OPENSSL_init_crypto", "FUNC3": "OBJ_NAME_do_all", "FUNC1": "EVP_CIPHER_do_all", "TYPE3": "undefined8", "TYPE2": "void *", "FUNC4": "__stack_chk_fail", "FUNC5": "do_all_cipher_fn", "TYPE4": "doall_cipher", "TYPE1": "fn *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV RBP,RDI\nMOV RBX,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV ESI,0x0\nMOV EDI,0x4\nCALL 0x00099046\nMOV qword ptr [RSP + 0x8],RBP\nMOV qword ptr [RSP],RBX\nMOV RDX,RSP\nLEA RSI,[0x8c1a3]\nMOV EDI,0x2\nCALL 0x000a2287\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x0008c539\nADD RSP,0x28\nPOP RBX\nPOP RBP\nRET\nCALL 0x00062640\n"}, "339": {"funcbody": "EVP_RAND_CTX * [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  RAND_GLOBAL *pRVar2;\n  TYPE29 [VAR2] ;\n  EVP_RAND_CTX *val;\n  TYPE32 [VAR3] ;\n  EVP_RAND_CTX *parent;\n  TYPE42 [VAR4] ;\n  OSSL_LIB_CTX *libctx;\n  void *pvVar3;\n  \n  pRVar2 = [FUNC6] ([VAR1] );\n  if (pRVar2 == (RAND_GLOBAL *)0x0) {\n    val = (EVP_RAND_CTX *)0x0;\n  }\n  else {\n    val = (EVP_RAND_CTX *)[FUNC2] (&pRVar2->public);\n    if (val == (EVP_RAND_CTX *)0x0) {\n      parent = [FUNC9] ([VAR1] );\n      if (parent == (EVP_RAND_CTX *)0x0) {\n        val = (EVP_RAND_CTX *)0x0;\n      }\n      else {\n        libctx = [FUNC3] ([VAR1] );\n        pvVar3 = [FUNC2] (&pRVar2->private);\n        if ((pvVar3 != (void *)0x0) || (iVar1 = [FUNC4] ((void *)0x0,libctx,[FUNC5] ), iVar1 != 0)) {\n          val = [FUNC7] (libctx,parent,0x10000,0x1a4);\n          [FUNC8] (&pRVar2->public,val);\n        }\n      }\n    }\n  }\n  return val;\n}", "answer": {"VAR1": "ctx", "VAR2": "dgbl", "VAR3": "rand", "VAR4": "primary", "FUNC2": "CRYPTO_THREAD_get_local", "FUNC3": "ossl_lib_ctx_get_concrete", "FUNC1": "RAND_get0_public", "FUNC6": "rand_get_global", "TYPE3": "EVP_RAND_CTX *", "FUNC7": "rand_new_drbg", "TYPE2": "RAND_GLOBAL *", "FUNC4": "ossl_init_thread_start", "FUNC5": "rand_delete_thread_state", "TYPE4": "EVP_RAND_CTX *", "FUNC8": "CRYPTO_THREAD_set_local", "FUNC9": "RAND_get0_primary", "TYPE1": "OSSL_LIB_CTX *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R12,RDI\nCALL 0x000acd21\nTEST RAX,RAX\nJZ 0x000add06\nMOV RBX,RAX\nLEA R13,[RAX + 0x18]\nMOV RDI,R13\nCALL 0x000a7690\nMOV RBP,RAX\nTEST RAX,RAX\nJZ 0x000adc9e\nMOV RAX,RBP\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV RDI,R12\nCALL 0x000ad8d4\nMOV R14,RAX\nTEST RAX,RAX\nJZ 0x000add0d\nMOV RDI,R12\nCALL 0x0009d21c\nMOV R12,RAX\nLEA RDI,[RBX + 0x1c]\nCALL 0x000a7690\nTEST RAX,RAX\nJZ 0x000adcec\nMOV ECX,0x1a4\nMOV EDX,0x10000\nMOV RSI,R14\nMOV RDI,R12\nCALL 0x000acead\nMOV RBP,RAX\nMOV RSI,RAX\nMOV RDI,R13\nCALL 0x000a76a0\nJMP 0x000adc92\nLEA RDX,[0xad266]\nMOV RSI,R12\nMOV EDI,0x0\nCALL 0x000a0375\nTEST EAX,EAX\nJNZ 0x000adcc7\nJMP 0x000adc92\nMOV EBP,0x0\nJMP 0x000adc92\nMOV RBP,RAX\nJMP 0x000adc92\n"}, "340": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  long lVar2;\n  uint uVar3;\n  uint uVar4;\n  \n  uVar4 = [VAR1] ;\n  if (([VAR1] < 0) && (uVar4 = (uint)(short)[VAR1] , (short)[VAR1] < 0)) {\n    uVar4 = [VAR1] & 0xffff;\n  }\n  if ((_nc_baudrate::last_OSpeed != uVar4) ||\n     ((iVar1 = _nc_baudrate::last_baudrate, _nc_baudrate::last_baudrate == -1 &&\n      (-1 < _nc_baudrate::last_OSpeed)))) {\n    if (uVar4 == 0) {\n      uVar3 = 0;\nLAB_0001ca63:\n      iVar1 = speeds[uVar3].actual_speed;\n    }\n    else {\n      lVar2 = 1;\n      do {\n        uVar3 = (uint)lVar2;\n        if ((int)uVar4 < speeds[lVar2].given_speed) {\n          iVar1 = -1;\n          goto LAB_0001ca70;\n        }\n        if (speeds[lVar2].given_speed == uVar4) goto LAB_0001ca63;\n        lVar2 = lVar2 + 1;\n      } while (lVar2 != 0x1f);\n      iVar1 = -1;\n    }\nLAB_0001ca70:\n    if (_nc_baudrate::last_OSpeed != uVar4) {\n      _nc_baudrate::last_OSpeed = uVar4;\n      _nc_baudrate::last_baudrate = iVar1;\n      return iVar1;\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "OSpeed", "FUNC1": "_nc_baudrate", "TYPE1": "int"}, "assembly": "TEST EDI,EDI\nJS 0x0001ca45\nMOV R8D,dword ptr [0x0023f944]\nCMP R8D,EDI\nJZ 0x0001ca51\nTEST EDI,EDI\nJZ 0x0001ca5e\nMOV EAX,0x1\nLEA RSI,[0x2bf40]\nMOV ECX,EAX\nMOV EDX,dword ptr [RSI + RAX*0x8]\nCMP EDX,EDI\nJG 0x0001ca82\nCMP EDX,EDI\nJZ 0x0001ca63\nADD RAX,0x1\nCMP RAX,0x1f\nJNZ 0x0001ca27\nMOV EAX,0xffffffff\nJMP 0x0001ca70\nMOVSX EDI,DI\nTEST EDI,EDI\nJNS 0x0001ca0b\nMOVZX EDI,DI\nJMP 0x0001ca0b\nMOV EAX,dword ptr [0x0023f940]\nCMP EAX,-0x1\nJZ 0x0001ca89\nRET\nMOV ECX,0x0\nMOV ECX,ECX\nLEA RAX,[0x2bf40]\nMOV EAX,dword ptr [RAX + RCX*0x8 + 0x4]\nCMP R8D,EDI\nJZ 0x0001ca5c\nMOV dword ptr [0x0023f944],EDI\nMOV dword ptr [0x0023f940],EAX\nRET\nMOV EAX,0xffffffff\nJMP 0x0001ca70\nTEST R8D,R8D\nJS 0x0001ca5c\nJMP 0x0001ca17\n"}, "341": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  [TYPE2] [VAR2] ;\n  \n  if ([VAR1] != (TYPE10x0) {\n    if ((([VAR1] [1].have == 0x1c4f) && (*(int *)((long)&[VAR1] [2].pos + 4) == 0)) && ([VAR1] ->have == 0))\n    {\n      [FUNC2] ((gz_statep)[VAR1] );\n    }\n    return *(int *)&[VAR1] [2].pos;\n  }\n  return 0;\n}", "answer": {"VAR1": "file", "VAR2": "state", "FUNC2": "gz_look", "FUNC1": "gzdirect", "TYPE2": "gz_statep", "TYPE1": "gzFile"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x0000e0bd\nPUSH RBX\nMOV RBX,RDI\nCMP dword ptr [RDI + 0x18],0x1c4f\nJZ 0x0000e0ab\nMOV EAX,dword ptr [RBX + 0x40]\nPOP RBX\nRET\nCMP dword ptr [RDI + 0x44],0x0\nJNZ 0x0000e0a6\nCMP dword ptr [RDI],0x0\nJNZ 0x0000e0a6\nCALL 0x0000d691\nJMP 0x0000e0a6\nRET\n"}, "342": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] ,[TYPE2] [VAR2] )\n{\n  if ([VAR1] != (TYPE11)0x0) {\n    [VAR1] ->start_input_type = [VAR2] ;\n    return 1;\n  }\n  [FUNC3] ();\n  [FUNC4] (\"crypto/encode_decode/decoder_lib.c\",0xb8,\"OSSL_DECODER_CTX_set_input_type\");\n  [FUNC2] (0x3c,0xc0102,(char *)0x0);\n  return 0;\n}", "answer": {"VAR1": "ctx", "VAR2": "input_type", "FUNC2": "ERR_set_error", "FUNC3": "ERR_new", "FUNC1": "OSSL_DECODER_CTX_set_input_type", "TYPE2": "char *", "FUNC4": "ERR_set_debug", "TYPE1": "OSSL_DECODER_CTX *"}, "assembly": "TEST RDI,RDI\nJZ 0x00175558\nMOV qword ptr [RDI],RSI\nMOV EAX,0x1\nRET\nSUB RSP,0x8\nCALL 0x00080fee\nLEA RDX,[0x290900]\nMOV ESI,0xb8\nLEA RDI,[0x2905d8]\nCALL 0x000810fb\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0x3c\nMOV EAX,0x0\nCALL 0x00081412\nMOV EAX,0x0\nADD RSP,0x8\nRET\n"}, "343": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,TYPE28 [VAR2] ,[TYPE3] [VAR3] )\n{\n  byte bVar1;\n  int iVar2;\n  TYPE49 [VAR4] ;\n  [TYPE7] [VAR7] ;\n  void *pvVar3;\n  byte *pbVar4;\n  [TYPE5] [VAR5] ;\n  int i;\n  [TYPE6] [VAR6] ;\n  byte *field;\n  \n  if ([VAR1] == (TYPE19)0x0) {\n    return 0;\n  }\n  i = 0;\n  do {\n    iVar2 = [FUNC3] ((OPENSSL_STACK *)[VAR2] );\n    if (iVar2 <= i) {\n      return 1;\n    }\n    pvVar3 = [FUNC4] ((OPENSSL_STACK *)[VAR2] ,i);\n    field = *(byte **)((long)pvVar3 + 8);\n    bVar1 = *field;\n    pbVar4 = field;\n    if (bVar1 == 0) {\n      [VAR7] = 0;\n    }\n    else {\n      do {\n        if (((bVar1 & 0xfd) == 0x2c) || (bVar1 == 0x3a)) {\n          if (pbVar4[1] != 0) {\n            field = pbVar4 + 1;\n          }\n          break;\n        }\n        pbVar4 = pbVar4 + 1;\n        bVar1 = *pbVar4;\n      } while (bVar1 != 0);\n      [VAR7] = 0;\n      if (*field == 0x2b) {\n        field = field + 1;\n        [VAR7] = -1;\n      }\n    }\n    iVar2 = [FUNC2] ([VAR1] ,(char *)field,(int)[VAR3] ,*(uchar **)((long)pvVar3 + 0x10),-1,-1,[VAR7] );\n    if (iVar2 == 0) {\n      return 0;\n    }\n    i = i + 1;\n  } while( true );\n}", "answer": {"VAR1": "nm", "VAR2": "dn_sk", "VAR3": "chtype", "VAR4": "v", "VAR5": "i", "VAR6": "p", "FUNC2": "X509_NAME_add_entry_by_txt", "FUNC3": "OPENSSL_sk_num", "FUNC1": "X509V3_NAME_from_section", "TYPE3": "ulong", "TYPE2": "stack_st_CONF_VALUE *", "FUNC4": "OPENSSL_sk_value", "TYPE5": "int", "TYPE4": "CONF_VALUE *", "TYPE7": "int", "TYPE6": "char *", "VAR7": "mval", "TYPE1": "X509_NAME *"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x0023a8d4\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R14,RDX\nMOV RBP,RSI\nMOV R13,RDI\nMOV EBX,0x0\nMOV R12D,0xffffffff\nJMP 0x0023a863\nMOV EDX,0x0\nJMP 0x0023a83e\nMOV RDX,RSI\nCMP byte ptr [RDX + 0x1],0x0\nJZ 0x0023a834\nLEA RSI,[RDX + 0x1]\nMOV EDX,0x0\nCMP byte ptr [RSI],0x2b\nJZ 0x0023a8ba\nMOV RCX,qword ptr [RAX + 0x10]\nSUB RSP,0x8\nPUSH RDX\nMOV R9D,R12D\nMOV R8D,R12D\nMOV EDX,R14D\nMOV RDI,R13\nCALL 0x000ef78e\nADD RSP,0x10\nTEST EAX,EAX\nJZ 0x0023a8cb\nADD EBX,0x1\nMOV RDI,RBP\nCALL 0x000e197e\nCMP EAX,EBX\nJLE 0x0023a8c6\nMOV ESI,EBX\nMOV RDI,RBP\nCALL 0x000e198c\nMOV RSI,qword ptr [RAX + 0x8]\nMOVZX EDX,byte ptr [RSI]\nTEST DL,DL\nJZ 0x0023a820\nMOV ECX,EDX\nAND ECX,0xfffffffd\nCMP CL,0x2c\nJZ 0x0023a827\nCMP DL,0x3a\nJZ 0x0023a827\nMOV RDX,RSI\nADD RDX,0x1\nMOVZX ECX,byte ptr [RDX]\nTEST CL,CL\nJZ 0x0023a834\nMOV EDI,ECX\nAND EDI,0xfffffffd\nCMP DIL,0x2c\nJZ 0x0023a82a\nCMP CL,0x3a\nJNZ 0x0023a896\nJMP 0x0023a82a\nADD RSI,0x1\nMOV EDX,R12D\nJMP 0x0023a83e\nMOV EAX,0x1\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nRET\n"}, "344": {"funcbody": "void [FUNC1] (TYPE10 [VAR1] ,[TYPE2] [VAR2] ,TYPE37 [VAR3] )\n{\n  long lVar1;\n  \n  lVar1 = 0;\n  do {\n    *(int *)((long)[VAR1] + lVar1) = *(int *)((long)[VAR3] + lVar1) + *(int *)((long)[VAR2] + lVar1);\n    lVar1 = lVar1 + 4;\n  } while (lVar1 != 0x28);\n  return;\n}", "answer": {"VAR1": "h", "VAR2": "f", "VAR3": "g", "FUNC1": "fe_add", "TYPE3": "int32_t *", "TYPE2": "int32_t *", "TYPE1": "int32_t *"}, "assembly": "MOV EAX,0x0\nMOV ECX,dword ptr [RDX + RAX*0x1]\nADD ECX,dword ptr [RSI + RAX*0x1]\nMOV dword ptr [RDI + RAX*0x1],ECX\nADD RAX,0x4\nCMP RAX,0x28\nJNZ 0x0017f316\nRET\n"}, "345": {"funcbody": "Lisp_Object [FUNC1] ([TYPE1] [VAR1] )\n{\n  long lVar1;\n  byte bVar2;\n  byte bVar3;\n  [TYPE2] [VAR2] ;\n  int iVar4;\n  [TYPE3] [VAR3] ;\n  ulong uVar5;\n  Lisp_Object pLVar6;\n  long in_FS_OFFSET;\n  TYPE55 [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((((int)[VAR1] - 2U & 3) != 0) || (uVar5 = (long)[VAR1] >> 2, 0x3fffff < uVar5)) {\n    [FUNC5] ((Lisp_Object)(__DT_SYMTAB + 0x2c9),[VAR1] );\n  }\n  [VAR2] = ([TYPE2] uVar5;\n  bVar3 = (byte)uVar5;\n  if ((uint)[VAR2] < 0x80) {\n    if ((uint)[VAR2] < 0x20) {\n      [VAR5] [0] = '^';\n      [VAR5] [1] = bVar3 + 0x40;\n      iVar4 = (int)[VAR5] + 2;\n    }\n    else if ([VAR2] == 0x7f) {\n      [VAR5] [0] = '^';\n      [VAR5] [1] = '?';\n      iVar4 = (int)[VAR5] + 2;\n    }\n    else {\n      iVar4 = (int)[VAR5] + 1;\n      [VAR5] [0] = bVar3;\n    }\n    pLVar6 = [FUNC4] ([VAR5] ,(long)(iVar4 - (int)[VAR5] ));\n  }\n  else {\n    if ([VAR2] < 0x80) {\n      iVar4 = 1;\n      [VAR5] [0] = bVar3;\n    }\n    else {\n      bVar2 = (byte)([VAR2] >> 6);\n      if ([VAR2] < 0x800) {\n        [VAR5] [1] = bVar3 & 0x3f | 0x80;\n        iVar4 = 2;\n        [VAR5] [0] = bVar2 | 0xc0;\n      }\n      else if ([VAR2] < 0x10000) {\n        [VAR5] [1] = bVar2 & 0x3f | 0x80;\n        [VAR5] [2] = bVar3 & 0x3f | 0x80;\n        iVar4 = 3;\n        [VAR5] [0] = (byte)([VAR2] >> 0xc) | 0xe0;\n      }\n      else {\n        iVar4 = [FUNC2] ([VAR2] ,(uchar *)[VAR5] );\n      }\n    }\n    pLVar6 = [FUNC3] ([VAR5] ,1,(long)iVar4);\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pLVar6;\n  }\n  [FUNC6] ();\n}", "answer": {"VAR1": "character", "VAR2": "c", "VAR3": "len", "VAR4": "local_10", "VAR5": "str", "FUNC2": "FUNC1", "FUNC3": "make_multibyte_string", "FUNC1": "Ftext_char_description", "FUNC6": "__stack_chk_fail", "TYPE3": "int", "TYPE2": "int", "FUNC4": "make_string", "TYPE5": "char[5]", "FUNC5": "wrong_type_argument", "TYPE4": "undefined8", "TYPE1": "Lisp_Object"}, "assembly": "SUB RSP,0x18\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nLEA EAX,[RDI + -0x2]\nTEST AL,0x3\nJNZ 0x00173d26\nMOV RAX,RDI\nSAR RAX,0x2\nCMP RAX,0x3fffff\nJA 0x00173d26\nMOVSXD RDX,EAX\nCMP RDX,0x7f\nJA 0x00173d33\nCMP EAX,0x1f\nJBE 0x00173dba\nCMP EAX,0x7f\nJZ 0x00173df0\nMOV byte ptr [RSP + 0x3],AL\nLEA RSI,[RSP + 0x4]\nJMP 0x00173dcb\nMOV RSI,RDI\nMOV EDI,0x4620\nCALL 0x001ce7ae\nCMP EAX,0x7f\nJLE 0x00173d54\nCMP EAX,0x7ff\nJLE 0x00173d71\nCMP EAX,0xffff\nJLE 0x00173d8e\nLEA RSI,[RSP + 0x3]\nMOV EDI,EAX\nCALL 0x000eacdc\nJMP 0x00173d5d\nMOV byte ptr [RSP + 0x3],AL\nMOV EAX,0x1\nMOVSXD RDX,EAX\nLEA RDI,[RSP + 0x3]\nMOV ESI,0x1\nCALL 0x001c3a9b\nJMP 0x00173ddb\nMOV EDX,EAX\nSAR EDX,0x6\nOR EDX,0xffffffc0\nMOV byte ptr [RSP + 0x3],DL\nAND EAX,0x3f\nOR EAX,0xffffff80\nMOV byte ptr [RSP + 0x4],AL\nMOV EAX,0x2\nJMP 0x00173d5d\nMOV EDX,EAX\nSAR EDX,0xc\nOR EDX,0xffffffe0\nMOV byte ptr [RSP + 0x3],DL\nMOV EDX,EAX\nSAR EDX,0x6\nAND EDX,0x3f\nOR EDX,0xffffff80\nMOV byte ptr [RSP + 0x4],DL\nAND EAX,0x3f\nOR EAX,0xffffff80\nMOV byte ptr [RSP + 0x5],AL\nMOV EAX,0x3\nJMP 0x00173d5d\nMOV byte ptr [RSP + 0x3],0x5e\nADD EAX,0x40\nMOV byte ptr [RSP + 0x4],AL\nLEA RSI,[RSP + 0x5]\nLEA RDI,[RSP + 0x3]\nSUB RSI,RDI\nMOVSXD RSI,ESI\nCALL 0x001c3aca\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00173e01\nADD RSP,0x18\nRET\nMOV byte ptr [RSP + 0x3],0x5e\nMOV byte ptr [RSP + 0x4],0x3f\nLEA RSI,[RSP + 0x5]\nJMP 0x00173dcb\nCALL 0x00042640\n"}, "346": {"funcbody": "/* DWARF original prototype: int operator<=(sccs_date * this, sccs_date * d) */\nint __thiscall sccs_date::[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  \n  iVar1 = [VAR1] ->year - [VAR2] ->year;\n  if ((((iVar1 == 0) && (iVar1 = [VAR1] ->yearday - [VAR2] ->yearday, iVar1 == 0)) &&\n      (iVar1 = [VAR1] ->hour - [VAR2] ->hour, iVar1 == 0)) &&\n     (iVar1 = [VAR1] ->minute - [VAR2] ->minute, iVar1 == 0)) {\n    iVar1 = [VAR1] ->second - [VAR2] ->second;\n  }\n  return (int)(iVar1 < 1);\n}", "answer": {"VAR1": "this", "VAR2": "d", "FUNC1": "operator<=", "TYPE2": "sccs_date *", "TYPE1": "sccs_date *"}, "assembly": "MOV EAX,dword ptr [RDI]\nSUB EAX,dword ptr [RSI]\nJNZ 0x0000f14a\nMOV EAX,dword ptr [RDI + 0x18]\nSUB EAX,dword ptr [RSI + 0x18]\nJNZ 0x0000f14a\nMOV EAX,dword ptr [RDI + 0xc]\nSUB EAX,dword ptr [RSI + 0xc]\nJNZ 0x0000f14a\nMOV EAX,dword ptr [RDI + 0x10]\nSUB EAX,dword ptr [RSI + 0x10]\nJNZ 0x0000f14a\nMOV EAX,dword ptr [RDI + 0x14]\nSUB EAX,dword ptr [RSI + 0x14]\nTEST EAX,EAX\nSETLE AL\nMOVZX EAX,AL\nRET\n"}, "347": {"funcbody": "grub_err_t [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  grub_env_var **ppgVar1;\n  grub_env_var *pgVar2;\n  char cVar3;\n  grub_err_t gVar4;\n  grub_env_var *pgVar5;\n  TYPE39 [VAR3] ;\n  char *pcVar6;\n  char *pcVar7;\n  uint uVar8;\n  [TYPE4] [VAR4] ;\n  \n  pgVar5 = [FUNC2] ([VAR1] );\n  if (pgVar5 == (grub_env_var *)0x0) {\n    pgVar5 = (grub_env_var *)[FUNC4] (0x40);\n    gVar4 = grub_errno;\n    if (pgVar5 != (grub_env_var *)0x0) {\n      pcVar7 = [FUNC5] ([VAR1] );\n      pgVar5->name = pcVar7;\n      if (pcVar7 != (char *)0x0) {\n        pcVar7 = [FUNC5] ([VAR2] );\n        pgVar5->value = pcVar7;\n        if (pcVar7 != (char *)0x0) {\n          pcVar7 = pgVar5->name;\n          cVar3 = *pcVar7;\n          if (cVar3 == '\\0') {\n            uVar8 = 0;\n          }\n          else {\n            uVar8 = 0;\n            do {\n              pcVar7 = pcVar7 + 1;\n              uVar8 = uVar8 + cVar3 * 5;\n              cVar3 = *pcVar7;\n            } while (cVar3 != '\\0');\n          }\n          ppgVar1 = grub_current_context->vars + (int)(uVar8 % 0xd);\n          pgVar5->prevp = ppgVar1;\n          pgVar2 = *ppgVar1;\n          pgVar5->next = pgVar2;\n          if (pgVar2 != (grub_env_var *)0x0) {\n            pgVar2->prevp = &pgVar5->next;\n          }\n          *ppgVar1 = pgVar5;\n          return GRUB_ERR_NONE;\n        }\n      }\n      [FUNC3] (pgVar5->name);\n      [FUNC3] (pgVar5->value);\n      [FUNC3] (pgVar5);\n      gVar4 = grub_errno;\n    }\n  }\n  else {\n    pcVar7 = pgVar5->value;\n    if (pgVar5->write_hook == (grub_env_write_hook_t)0x0) {\n      pcVar6 = [FUNC5] ([VAR2] );\n      pgVar5->value = pcVar6;\n    }\n    else {\n      pcVar6 = (*pgVar5->write_hook)(pgVar5,[VAR2] );\n      pgVar5->value = pcVar6;\n    }\n    if (pgVar5->value == (char *)0x0) {\n      pgVar5->value = pcVar7;\n      gVar4 = grub_errno;\n    }\n    else {\n      [FUNC3] (pcVar7);\n      gVar4 = GRUB_ERR_NONE;\n    }\n  }\n  return gVar4;\n}", "answer": {"VAR1": "name", "VAR2": "val", "VAR3": "var", "VAR4": "old", "FUNC2": "grub_env_find", "FUNC3": "grub_free", "FUNC1": "grub_env_set", "TYPE3": "grub_env_var *", "TYPE2": "char *", "FUNC4": "grub_zalloc", "FUNC5": "grub_strdup", "TYPE4": "char *", "TYPE1": "char *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,RDI\nMOV R12,RSI\nCALL 0x0006489f\nTEST RAX,RAX\nJZ 0x0006497d\nMOV RBX,RAX\nMOV RBP,qword ptr [RAX + 0x8]\nMOV RAX,qword ptr [RAX + 0x18]\nTEST RAX,RAX\nJZ 0x00064963\nMOV RSI,R12\nMOV RDI,RBX\nCALL RAX\nMOV qword ptr [RBX + 0x8],RAX\nCMP qword ptr [RBX + 0x8],0x0\nJZ 0x00064971\nMOV RDI,RBP\nCALL 0x0006485f\nMOV EAX,0x0\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,R12\nCALL 0x00065b0e\nMOV qword ptr [RBX + 0x8],RAX\nJMP 0x0006494a\nMOV qword ptr [RBX + 0x8],RBP\nMOV EAX,dword ptr [0x003015c0]\nJMP 0x0006495e\nMOV EDI,0x40\nCALL 0x0006482f\nMOV RBX,RAX\nMOV EAX,dword ptr [0x003015c0]\nTEST RBX,RBX\nJZ 0x0006495e\nMOV RDI,RBP\nCALL 0x00065b0e\nMOV qword ptr [RBX],RAX\nTEST RAX,RAX\nJZ 0x000649b6\nMOV RDI,R12\nCALL 0x00065b0e\nMOV qword ptr [RBX + 0x8],RAX\nTEST RAX,RAX\nJNZ 0x000649d7\nMOV RDI,qword ptr [RBX]\nCALL 0x0006485f\nMOV RDI,qword ptr [RBX + 0x8]\nCALL 0x0006485f\nMOV RDI,RBX\nCALL 0x0006485f\nMOV EAX,dword ptr [0x003015c0]\nJMP 0x0006495e\nMOV RSI,qword ptr [0x002df8a0]\nMOV RDX,qword ptr [RBX]\nMOVZX EAX,byte ptr [RDX]\nTEST AL,AL\nJZ 0x00064a40\nMOV ECX,0x0\nADD RDX,0x1\nMOVSX EAX,AL\nLEA EAX,[RAX + RAX*0x4]\nADD ECX,EAX\nMOVZX EAX,byte ptr [RDX]\nTEST AL,AL\nJNZ 0x000649ed\nMOV EDX,0x4ec4ec4f\nMOV EAX,ECX\nMUL EDX\nSHR EDX,0x2\nLEA EAX,[RDX + RDX*0x2]\nLEA EAX,[RDX + RAX*0x4]\nSUB ECX,EAX\nMOVSXD RCX,ECX\nLEA RAX,[RSI + RCX*0x8]\nMOV qword ptr [RBX + 0x28],RAX\nMOV RDX,qword ptr [RAX]\nMOV qword ptr [RBX + 0x20],RDX\nTEST RDX,RDX\nJZ 0x00064a33\nLEA RCX,[RBX + 0x20]\nMOV qword ptr [RDX + 0x28],RCX\nMOV qword ptr [RAX],RBX\nMOV EAX,0x0\nJMP 0x0006495e\nMOV ECX,0x0\nJMP 0x00064a00\n"}, "348": {"funcbody": "void [FUNC1] (void)\n{\n  long lVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  [TYPE1] [VAR1] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR2] .flags = 0;\n  [VAR2] ._4_4_ = 0;\n  [VAR2] .language = (char *)0x0;\n  [VAR2] .territory = (char *)0x0;\n  [VAR2] .charset = (char *)0x0;\n  [VAR2] .modifier = (char *)0x0;\n  [VAR3] = [FUNC3] (\"LC_ALL\");\n  if ([VAR3] == (char *)0x0) {\n    [VAR3] = [FUNC3] (\"LANG\");\n  }\n  if ([VAR3] != ([TYPE3] )0x0) {\n    iVar2 = [FUNC4] ([VAR3] ,&[VAR2] ,4);\n    if (iVar2 == 0) {\n      charset = (char *)[FUNC6] ([VAR2] .charset);\n      [FUNC5] (&[VAR2] );\n      goto code_r0x00002ef9;\n    }\n  }\n  charset = (char *)[FUNC6] (\"us-ascii\");\ncode_r0x00002ef9:\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC2] ();\n  }\n  return;\n}", "answer": {"VAR1": "local_10", "VAR2": "lc_all", "VAR3": "ep", "FUNC2": "__stack_chk_fail", "FUNC3": "getenv", "FUNC1": "define_charset", "FUNC6": "mu_strdup", "TYPE3": "char *", "TYPE2": "mu_lc_all", "FUNC4": "mu_parse_lc_all", "FUNC5": "mu_lc_all_free", "TYPE1": "undefined8"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nSUB RSP,0x40\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RBP + -0x8],RAX\nXOR EAX,EAX\nMOV qword ptr [RBP + -0x30],0x0\nMOV qword ptr [RBP + -0x28],0x0\nMOV qword ptr [RBP + -0x20],0x0\nMOV qword ptr [RBP + -0x18],0x0\nMOV qword ptr [RBP + -0x10],0x0\nLEA RDI,[0x4f77]\nCALL 0x00002ad0\nMOV qword ptr [RBP + -0x38],RAX\nCMP qword ptr [RBP + -0x38],0x0\nJNZ 0x00002ea1\nLEA RDI,[0x4f7e]\nCALL 0x00002ad0\nMOV qword ptr [RBP + -0x38],RAX\nCMP qword ptr [RBP + -0x38],0x0\nJZ 0x00002ee5\nLEA RCX,[RBP + -0x30]\nMOV RAX,qword ptr [RBP + -0x38]\nMOV EDX,0x4\nMOV RSI,RCX\nMOV RDI,RAX\nCALL 0x00002b10\nTEST EAX,EAX\nJNZ 0x00002ee5\nMOV RAX,qword ptr [RBP + -0x18]\nMOV RDI,RAX\nCALL 0x00002770\nMOV qword ptr [0x00206538],RAX\nLEA RAX,[RBP + -0x30]\nMOV RDI,RAX\nCALL 0x00002bc0\nJMP 0x00002ef8\nLEA RDI,[0x4f83]\nCALL 0x00002770\nMOV qword ptr [0x00206538],RAX\nNOP\nMOV RAX,qword ptr [RBP + -0x8]\nXOR RAX,qword ptr FS:[0x28]\nJZ 0x00002f0d\nCALL 0x00002b20\nLEAVE\nRET\n"}, "349": {"funcbody": "int [FUNC1] (TYPE12 [VAR1] ,TYPE23 [VAR2] ,TYPE37 [VAR3] ,[TYPE4] [VAR4] \n         )\n{\n  uint uVar1;\n  BIO *in;\n  [TYPE5] [VAR5] ;\n  uint uVar2;\n  [TYPE6] [VAR6] ;\n  long in_FS_OFFSET;\n  [TYPE8] [VAR8] ;\n  long [VAR7] ;\n  \n  [VAR7] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR8] = ([TYPE8] )0x0;\n  in = [FUNC5] ([VAR1] ,[VAR2] );\n  uVar2 = 0;\n  if (in != (BIO *)0x0) {\n    uVar1 = [FUNC6] (in,&[VAR8] );\n    uVar2 = ~uVar1 >> 0x1f;\n    if (-1 < (int)uVar1) {\n      *[VAR3] = (uchar *)[VAR8] ->data;\n      *[VAR4] = [VAR8] ->length;\n      [FUNC2] ([VAR8] );\n    }\n    [FUNC4] ((BIO *)in);\n  }\n  if ([VAR7] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar2;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "provctx", "VAR2": "cin", "VAR3": "data", "VAR4": "len", "VAR5": "in", "VAR6": "ok", "FUNC2": "FUNC1", "FUNC3": "__stack_chk_fail", "FUNC1": "ossl_read_der", "FUNC6": "asn1_d2i_read_bio", "TYPE3": "uchar * *", "TYPE2": "OSSL_CORE_BIO *", "FUNC4": "BIO_free", "TYPE5": "BIO *", "FUNC5": "ossl_bio_new_from_core_bio", "TYPE4": "long *", "TYPE7": "undefined8", "TYPE6": "int", "TYPE8": "BUF_MEM *", "VAR7": "local_30", "VAR8": "mem", "TYPE1": "PROV_CTX *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV R12,RDX\nMOV RBP,RCX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],0x0\nCALL 0x000c4a7c\nMOV EBX,0x0\nTEST RAX,RAX\nJZ 0x000e77e3\nMOV R13,RAX\nMOV RSI,RSP\nMOV RDI,RAX\nCALL 0x0011fcc6\nMOV EBX,EAX\nNOT EBX\nSHR EBX,0x1f\nTEST EAX,EAX\nJNS 0x000e7800\nMOV RDI,R13\nCALL 0x00072a2f\nMOV EAX,EBX\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x000e7826\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV RDI,qword ptr [RSP]\nMOV RAX,qword ptr [RDI + 0x8]\nMOV qword ptr [R12],RAX\nMOV RAX,qword ptr [RDI]\nMOV qword ptr [RBP],RAX\nMOV EDX,0x64\nLEA RSI,[0x2770c0]\nCALL 0x00099ba8\nJMP 0x000e77db\nCALL 0x00062640\n"}, "350": {"funcbody": "SCM [FUNC1] ([TYPE1] [VAR1] )\n{\n  [TYPE2] [VAR2] ;\n  SCM args;\n  \n  if ((((ulong)[VAR1] & 6) == 0) && (((uint)*(undefined8 *)[VAR1] & 0x7f) == 7)) {\n    if (*(SCM *)([VAR1] + 8) != (SCM)((long)QWORD_ARRAY_00000238 + 0x6cc)) {\n      return *(SCM *)([VAR1] + 8);\n    }\n    args = [FUNC2] ([VAR1] );\n    [FUNC3] (\"variable-ref\",\"variable is unbound: ~S\",args);\n  }\n  [FUNC4] (\"variable-ref\",1,[VAR1] ,\"variable\");\n}", "answer": {"VAR1": "var", "VAR2": "val", "FUNC2": "scm_list_1", "FUNC3": "scm_misc_error", "FUNC1": "scm_variable_ref", "TYPE2": "SCM", "FUNC4": "scm_wrong_type_arg_msg", "TYPE1": "SCM"}, "assembly": "SUB RSP,0x8\nTEST DIL,0x6\nJNZ 0x0003bd1a\nMOV RAX,qword ptr [RDI]\nAND EAX,0x7f\nCMP RAX,0x7\nJNZ 0x0003bd1a\nMOV RAX,qword ptr [RDI + 0x8]\nCMP RAX,0x904\nJZ 0x0003bd35\nADD RSP,0x8\nRET\nLEA RCX,[0xea897]\nMOV RDX,RDI\nMOV ESI,0x1\nLEA RDI,[0xeac48]\nCALL 0x00030ff0\nCALL 0x00031770\nMOV RDX,RAX\nLEA RSI,[0xea7a0]\nLEA RDI,[0xeac48]\nCALL 0x00032340\n"}, "351": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  undefined8 uVar1;\n  ulong uVar2;\n  [TYPE3] [VAR3] ;\n  TYPE29 [VAR2] ;\n  undefined8 *puVar3;\n  byte bVar4;\n  \n  bVar4 = 0;\n  uVar1 = *[VAR1] ;\n  [FUNC3] (*(EVP_MAC_CTX **)((long)[VAR1] + 8));\n  [FUNC4] ((PROV_DIGEST *)((long)[VAR1] + 0x10));\n  [FUNC2] (*(void **)((long)[VAR1] + 0x28),*(size_t *)((long)[VAR1] + 0x30),\n        \"providers/implementations/kdfs/sskdf.c\",0x131);\n  [FUNC2] (*(void **)((long)[VAR1] + 0x38),*(size_t *)((long)[VAR1] + 0x40),\n        \"providers/implementations/kdfs/sskdf.c\",0x132);\n  [FUNC2] (*(void **)((long)[VAR1] + 0x48),*(size_t *)((long)[VAR1] + 0x50),\n        \"providers/implementations/kdfs/sskdf.c\",0x133);\n  *(undefined8 *)((long)[VAR1] + 8) = 0;\n  *(undefined8 *)((long)[VAR1] + 0x58) = 0;\n  puVar3 = (undefined8 *)((ulong)(PROV_DIGEST *)((long)[VAR1] + 0x10) & 0xfffffffffffffff8);\n  uVar2 = (ulong)(((int)[VAR1] - (int)puVar3) + 0x60U >> 3);\n  for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n    *puVar3 = 0;\n    puVar3 = puVar3 + (ulong)bVar4 * -2 + 1;\n  }\n  *(undefined8 *)[VAR1] = uVar1;\n  return;\n}", "answer": {"VAR1": "vctx", "VAR2": "ctx", "VAR3": "provctx", "FUNC2": "CRYPTO_clear_free", "FUNC3": "EVP_MAC_CTX_free", "FUNC1": "sskdf_reset", "TYPE3": "void *", "TYPE2": "KDF_SSKDF *", "FUNC4": "ossl_prov_digest_reset", "TYPE1": "void *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV RBP,qword ptr [RDI]\nMOV RDI,qword ptr [RDI + 0x8]\nCALL 0x001992f8\nLEA R12,[RBX + 0x10]\nMOV RDI,R12\nCALL 0x000c8288\nMOV RSI,qword ptr [RBX + 0x30]\nMOV RDI,qword ptr [RBX + 0x28]\nMOV ECX,0x131\nLEA RDX,[0x276a68]\nCALL 0x0009d29e\nMOV RSI,qword ptr [RBX + 0x40]\nMOV RDI,qword ptr [RBX + 0x38]\nMOV ECX,0x132\nLEA RDX,[0x276a68]\nCALL 0x0009d29e\nMOV RSI,qword ptr [RBX + 0x50]\nMOV RDI,qword ptr [RBX + 0x48]\nMOV ECX,0x133\nLEA RDX,[0x276a68]\nCALL 0x0009d29e\nMOV qword ptr [RBX + 0x8],0x0\nMOV qword ptr [RBX + 0x58],0x0\nMOV RDI,R12\nAND RDI,-0x8\nMOV EAX,EBX\nSUB EAX,EDI\nLEA ECX,[RAX + 0x60]\nSHR ECX,0x3\nMOV ECX,ECX\nMOV EAX,0x0\nSTOSQ.REP RDI\nMOV qword ptr [RBX],RBP\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "352": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int enc;\n  EVP_CIPHER *pEVar1;\n  CAST_KEY *key;\n  [TYPE3] in;\n  ulong uVar2;\n  [TYPE5] [VAR5] ;\n  [TYPE6] [VAR6] ;\n  \n  pEVar1 = [FUNC2] ([VAR1] );\n  uVar2 = (ulong)pEVar1->block_size;\n  if (uVar2 <= [VAR4] ) {\n    in = [VAR3] ;\n    do {\n      enc = [FUNC4] ([VAR1] );\n      key = (CAST_KEY *)[FUNC5] ([VAR1] );\n      [FUNC3] (in,[VAR2] ,key,enc);\n      in = in + uVar2;\n      [VAR2] = [VAR2] + uVar2;\n    } while ((ulong)((long)in - (long)[VAR3] ) <= [VAR4] - uVar2);\n  }\n  return 1;\n}", "answer": {"VAR1": "ctx", "VAR2": "out", "VAR3": "in", "VAR4": "inl", "VAR5": "bl", "VAR6": "local_40", "FUNC2": "EVP_CIPHER_CTX_get0_cipher", "FUNC3": "CAST_ecb_encrypt", "FUNC1": "cast5_ecb_cipher", "TYPE3": "uchar *", "TYPE2": "uchar *", "FUNC4": "EVP_CIPHER_CTX_is_encrypting", "TYPE5": "size_t", "FUNC5": "EVP_CIPHER_CTX_get_cipher_data", "TYPE4": "size_t", "TYPE6": "undefined8", "TYPE1": "EVP_CIPHER_CTX *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV R13,RDI\nMOV RBP,RSI\nMOV RBX,RDX\nMOV R14,RCX\nCALL 0x000bc429\nMOVSXD R12,dword ptr [RAX + 0x4]\nCMP R12,R14\nJA 0x001ec05a\nSUB R14,R12\nMOV qword ptr [RSP + 0x8],RBX\nMOV RDI,R13\nCALL 0x000bc460\nMOV R15D,EAX\nMOV RDI,R13\nCALL 0x000bc473\nMOV ECX,R15D\nMOV RDX,RAX\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x0025a25c\nADD RBX,R12\nADD RBP,R12\nMOV RAX,RBX\nSUB RAX,qword ptr [RSP + 0x8]\nCMP R14,RAX\nJNC 0x001ec023\nMOV EAX,0x1\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "353": {"funcbody": "sccs_date * sccs_date::[FUNC1] (void)\n{\n  int iVar1;\n  int iVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  tm *ptVar6;\n  [TYPE1] [VAR1] ;\n  sccs_date *in_RDI;\n  long in_FS_OFFSET;\n  [TYPE3] [VAR3] ;\n  long [VAR2] ;\n  \n  [VAR2] = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC3] (&[VAR3] );\n  ptVar6 = [FUNC5] (&[VAR3] );\n  iVar1 = ptVar6->tm_sec;\n  iVar2 = ptVar6->tm_min;\n  iVar3 = ptVar6->tm_hour;\n  iVar4 = ptVar6->tm_mday;\n  iVar5 = ptVar6->tm_mon;\n  in_RDI->year = ptVar6->tm_year + 0x76c;\n  in_RDI->month = iVar5 + 1;\n  in_RDI->month_day = iVar4;\n  in_RDI->hour = iVar3;\n  in_RDI->minute = iVar2;\n  in_RDI->second = iVar1;\n  [FUNC4] (in_RDI);\n  if ([VAR2] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return in_RDI;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "ptm", "VAR2": "local_20", "VAR3": "tt", "FUNC2": "__stack_chk_fail", "FUNC3": "time", "FUNC1": "now", "TYPE3": "time_t", "TYPE2": "undefined8", "FUNC4": "update_yearday", "FUNC5": "localtime", "TYPE1": "tm *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBX,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV RBP,RSP\nMOV RDI,RBP\nCALL 0x000025a0\nMOV RDI,RBP\nCALL 0x00002550\nMOV ECX,dword ptr [RAX]\nMOV ESI,dword ptr [RAX + 0x4]\nMOV EDI,dword ptr [RAX + 0x8]\nMOV R8D,dword ptr [RAX + 0xc]\nMOV EDX,dword ptr [RAX + 0x10]\nADD EDX,0x1\nMOV EAX,dword ptr [RAX + 0x14]\nADD EAX,0x76c\nMOV dword ptr [RBX],EAX\nMOV dword ptr [RBX + 0x4],EDX\nMOV dword ptr [RBX + 0x8],R8D\nMOV dword ptr [RBX + 0xc],EDI\nMOV dword ptr [RBX + 0x10],ESI\nMOV dword ptr [RBX + 0x14],ECX\nMOV RDI,RBX\nCALL 0x0000d82c\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0000da70\nMOV RAX,RBX\nADD RSP,0x18\nPOP RBX\nPOP RBP\nRET\nCALL 0x00002660\n"}, "354": {"funcbody": "/* Local variable h:elf_link_hash_entry *[RDI:8] conflicts with parameter, skipped.\n   Local variable info:bfd_link_info *[RSI:8] conflicts with parameter, skipped. */\n_Bool [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  _Bool _Var1;\n  \n  if ((*(char *)&[VAR1] [1].next == '\\x02') && ([VAR1] [2].hash == 0xffffffffffffffff)) {\n    _Var1 = [FUNC2] (*(bfd **)((long)[VAR2] + 0x50),(bfd_link_info *)[VAR2] ,(elf_link_hash_entry *)[VAR1] ,\n                  (Elf_Internal_Sym *)0x0);\n    return _Var1;\n  }\n  return true;\n}", "answer": {"VAR1": "bh", "VAR2": "inf", "FUNC2": "elf_i386_finish_dynamic_symbol", "FUNC1": "elf_i386_pie_finish_undefweak_symbol", "TYPE2": "void *", "TYPE1": "bfd_hash_entry *"}, "assembly": "MOV EAX,0x1\nCMP byte ptr [RDI + 0x18],0x2\nJZ 0x0008e485\nRET\nCMP qword ptr [RDI + 0x40],-0x1\nJNZ 0x0008e483\nSUB RSP,0x8\nMOV RDX,RDI\nMOV RDI,qword ptr [RSI + 0x50]\nMOV ECX,0x0\nCALL 0x0008d9c3\nADD RSP,0x8\nRET\n"}, "355": {"funcbody": "undefined8 [FUNC1] (char *param_1)\n{\n  undefined4 uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  \n  uVar3 = current_readline_init_file;\n  iVar2 = current_readline_init_include_level;\n  uVar1 = current_readline_init_lineno;\n  if (_rl_parsing_conditionalized_out == '\\0') {\n    pcVar4 = [FUNC3] (param_1,10);\n    if (pcVar4 != (char *)0x0) {\n      *pcVar4 = '\\0';\n    }\n    uVar5 = [FUNC2] (param_1,iVar2 + 1);\n    current_readline_init_file = uVar3;\n    current_readline_init_lineno = uVar1;\n    current_readline_init_include_level = iVar2;\n    return uVar5;\n  }\n  return 0;\n}", "answer": {"FUNC2": "_rl_read_init_file", "FUNC3": "strchr", "FUNC1": "parser_include"}, "assembly": "MOV EAX,0x0\nCMP byte ptr [0x00c3e388],0x0\nJNZ 0x005d72c4\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV R13,qword ptr [0x00c3e868]\nMOV R12D,dword ptr [0x00c3e860]\nMOV EBP,dword ptr [0x00c3e864]\nMOV ESI,0xa\nCALL 0x000d0570\nTEST RAX,RAX\nJZ 0x005d729a\nMOV byte ptr [RAX],0x0\nLEA ESI,[RBP + 0x1]\nMOV RDI,RBX\nCALL 0x005d6f3f\nMOV qword ptr [0x00c3e868],R13\nMOV dword ptr [0x00c3e860],R12D\nMOV dword ptr [0x00c3e864],EBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nRET\n"}, "356": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC3] ([VAR7] ,[VAR2] ->Z);\n  [FUNC2] ([VAR6] ,[VAR2] ->X,[VAR7] );\n  [FUNC2] ([VAR5] ,[VAR2] ->Y,[VAR7] );\n  [FUNC4] ([VAR1] ,[VAR5] );\n  [FUNC4] ([VAR4] ,[VAR6] );\n  [VAR1] [0x1f] = [VAR1] [0x1f] ^ (byte)(([VAR4] [0] & 1) << 7);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC5] ();\n}", "answer": {"VAR1": "s", "VAR2": "h", "VAR3": "local_30", "VAR4": "s_1", "VAR5": "y", "VAR6": "x", "FUNC2": "fe25519_mul", "FUNC3": "fe25519_invert", "FUNC1": "ge25519_tobytes", "TYPE3": "undefined8", "TYPE2": "ge25519_p2 *", "FUNC4": "fe25519_tobytes", "TYPE5": "fe25519", "FUNC5": "__stack_chk_fail", "TYPE4": "uchar[32]", "TYPE7": "fe25519", "TYPE6": "fe25519", "VAR7": "recip", "TYPE1": "uchar *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0xc8\nMOV RBP,RDI\nMOV RBX,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0xb8],RAX\nXOR EAX,EAX\nLEA RSI,[RSI + 0x50]\nMOV R12,RSP\nMOV RDI,R12\nCALL 0x00014b55\nLEA R13,[RSP + 0x30]\nMOV RDX,R12\nMOV RSI,RBX\nMOV RDI,R13\nCALL 0x00012aed\nLEA RSI,[RBX + 0x28]\nLEA RBX,[RSP + 0x60]\nMOV RDX,R12\nMOV RDI,RBX\nCALL 0x00012aed\nMOV RSI,RBX\nMOV RDI,RBP\nCALL 0x000142ac\nLEA RDI,[RSP + 0x90]\nMOV RSI,R13\nCALL 0x000142ac\nMOVZX EAX,byte ptr [RSP + 0x90]\nAND EAX,0x1\nSHL EAX,0x7\nXOR byte ptr [RBP + 0x1f],AL\nMOV RAX,qword ptr [RSP + 0xb8]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x00016288\nADD RSP,0xc8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nCALL 0x0000cdb0\n"}, "357": {"funcbody": "void [FUNC1] (TYPE18 [VAR1] ,TYPE26 [VAR2] ,[TYPE3] [VAR3] )\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  TYPE55 [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC3] ([VAR5] ,[VAR1] ->z,[VAR2] ->z);\n  [VAR1] ->z[0].limb[0] = [VAR5] [0].limb[0];\n  [VAR1] ->z[0].limb[1] = [VAR5] [0].limb[1];\n  [VAR1] ->z[0].limb[2] = [VAR5] [0].limb[2];\n  [VAR1] ->z[0].limb[3] = [VAR5] [0].limb[3];\n  [VAR1] ->z[0].limb[4] = [VAR5] [0].limb[4];\n  [VAR1] ->z[0].limb[5] = [VAR5] [0].limb[5];\n  [VAR1] ->z[0].limb[6] = [VAR5] [0].limb[6];\n  [VAR1] ->z[0].limb[7] = [VAR5] [0].limb[7];\n  [FUNC4] ([VAR1] ,[VAR2] ->n,[VAR3] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "p", "VAR2": "pn", "VAR3": "before_double", "VAR4": "local_20", "VAR5": "L0", "FUNC2": "__stack_chk_fail", "FUNC3": "gf_mul", "FUNC1": "add_pniels_to_pt", "TYPE3": "int", "TYPE2": "anon_struct_256_2_948a309a *", "FUNC4": "add_niels_to_pt", "TYPE5": "gf", "TYPE4": "undefined8", "TYPE1": "curve448_point_s *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x50\nMOV RBX,RDI\nMOV RBP,RSI\nMOV R12D,EDX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x48],RAX\nXOR EAX,EAX\nLEA RDX,[RSI + 0xc0]\nLEA RSI,[RDI + 0x80]\nMOV RDI,RSP\nCALL 0x00219bd8\nMOV RAX,qword ptr [RSP]\nMOV RDX,qword ptr [RSP + 0x8]\nMOV qword ptr [RBX + 0x80],RAX\nMOV qword ptr [RBX + 0x88],RDX\nMOV RAX,qword ptr [RSP + 0x10]\nMOV RDX,qword ptr [RSP + 0x18]\nMOV qword ptr [RBX + 0x90],RAX\nMOV qword ptr [RBX + 0x98],RDX\nMOV RAX,qword ptr [RSP + 0x20]\nMOV RDX,qword ptr [RSP + 0x28]\nMOV qword ptr [RBX + 0xa0],RAX\nMOV qword ptr [RBX + 0xa8],RDX\nMOV RAX,qword ptr [RSP + 0x30]\nMOV RDX,qword ptr [RSP + 0x38]\nMOV qword ptr [RBX + 0xb0],RAX\nMOV qword ptr [RBX + 0xb8],RDX\nMOV EDX,R12D\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x0014ef3b\nMOV RAX,qword ptr [RSP + 0x48]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x0014f409\nADD RSP,0x50\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x00062640\n"}, "358": {"funcbody": "void [FUNC1] (TYPE16 [VAR1] ,[TYPE2] [VAR2] )\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC5] (8,(OPENSSL_INIT_SETTINGS *)0x0);\n  [VAR4] .arg = [VAR2] ;\n  [VAR4] .fn = (_func_void_EVP_MD_ptr_char_ptr_char_ptr_void_ptr *)[VAR1] ;\n  [FUNC4] (1,[FUNC3] ,&[VAR4] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "fn", "VAR2": "arg", "VAR3": "local_20", "VAR4": "dc", "FUNC2": "__stack_chk_fail", "FUNC3": "do_all_md_fn", "FUNC1": "EVP_MD_do_all_sorted", "TYPE3": "undefined8", "TYPE2": "void *", "FUNC4": "OBJ_NAME_do_all_sorted", "FUNC5": "OPENSSL_init_crypto", "TYPE4": "doall_md", "TYPE1": "fn *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV RBP,RDI\nMOV RBX,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV ESI,0x0\nMOV EDI,0x8\nCALL 0x000a7a79\nMOV qword ptr [RSP + 0x8],RBP\nMOV qword ptr [RSP],RBX\nMOV RDX,RSP\nLEA RSI,[0x9a0e1]\nMOV EDI,0x1\nCALL 0x000b0298\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x0009a569\nADD RSP,0x28\nPOP RBX\nPOP RBP\nRET\nCALL 0x00065630\n"}, "359": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  char *text;\n  long in_FS_OFFSET;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  long [VAR3] ;\n  \n  [VAR3] = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC4] ([VAR2] ,&[VAR4] ,&[VAR5] );\n  if ([VAR4] == (TYPE40x0) {\n    [VAR4] = \"\";\n  }\n  text = [FUNC3] (\"Server sent disconnect message:\\n\\\"%.*s\\\"\",(ulong)(uint)[VAR5] ,[VAR4] );\n  [FUNC5] ([VAR1] ,text);\n  if ([VAR3] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "ssh", "VAR2": "pktin", "VAR3": "local_10", "VAR4": "msg", "VAR5": "msglen", "FUNC2": "__stack_chk_fail", "FUNC3": "dupprintf", "FUNC1": "ssh1_msg_disconnect", "TYPE3": "undefined8", "TYPE2": "Packet *", "FUNC4": "ssh_pkt_getstring", "TYPE5": "int", "FUNC5": "bomb_out", "TYPE4": "char *", "TYPE1": "Ssh"}, "assembly": "PUSH RBX\nSUB RSP,0x20\nMOV RBX,RDI\nMOV RDI,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nLEA RDX,[RSP + 0xc]\nLEA RSI,[RSP + 0x10]\nCALL 0x0001f2f8\nMOV RDX,qword ptr [RSP + 0x10]\nTEST RDX,RDX\nLEA RAX,[0x5f3be]\nCMOVZ RDX,RAX\nMOV ESI,dword ptr [RSP + 0xc]\nLEA RDI,[0x654e0]\nMOV EAX,0x0\nCALL 0x0000e862\nMOV RSI,RAX\nMOV RDI,RBX\nCALL 0x00021053\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x0002131d\nADD RSP,0x20\nPOP RBX\nRET\nCALL 0x00008280\n"}, "360": {"funcbody": "MagickBooleanType [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  MagickBooleanType MVar1;\n  [TYPE4] [VAR4] ;\n  long lVar2;\n  ChromaticityInfo *pCVar3;\n  ImageType IVar4;\n  byte bVar5;\n  \n  bVar5 = 0;\n  if ([VAR1] == (TYPE10x0) {\n    [FUNC3] (\"image != (Image *) NULL\",\"MagickCore/colorspace.c\",0x5eb,\"SetImageColorspace\");\n  }\n  if ([VAR1] ->signature != 0xabacadab) {\n    [FUNC3] (\"image->signature == MagickCoreSignature\",\"MagickCore/colorspace.c\",0x5ec,\n          \"SetImageColorspace\");\n  }\n  if ([VAR3] == (TYPE30x0) {\n    [FUNC3] (\"exception != (ExceptionInfo *) NULL\",\"MagickCore/colorspace.c\",0x5ed,\"SetImageColorspace\"\n         );\n  }\n  if ([VAR3] ->signature == 0xabacadab) {\n    MVar1 = [FUNC2] ();\n    if (MVar1 != MagickFalse) {\n      [FUNC4] (TraceEvent,\"MagickCore/colorspace.c\",\"SetImageColorspace\",0x5f0,\"%s\",[VAR1] ->filename);\n    }\n    MVar1 = MagickTrue;\n    if ([VAR1] ->colorspace != [VAR2] ) {\n      [VAR1] ->colorspace = [VAR2] ;\n      [VAR1] ->rendering_intent = UndefinedIntent;\n      [VAR1] ->gamma = DAT_0038dd70;\n      pCVar3 = &[VAR1] ->chromaticity;\n      for (lVar2 = 0xc; lVar2 != 0; lVar2 = lVar2 + -1) {\n        (pCVar3->red_primary).x = 0.0;\n        pCVar3 = (ChromaticityInfo *)((long)pCVar3 + (ulong)bVar5 * -0x10 + 8);\n      }\n      if (([VAR2] == GRAYColorspace) || ([VAR2] == LinearGRAYColorspace)) {\n        IVar4 = GrayscaleType;\n        if ([VAR2] == LinearGRAYColorspace) {\n          [VAR1] ->gamma = DAT_00380168;\n          IVar4 = GrayscaleType;\n        }\n      }\n      else {\n        IVar4 = [VAR1] ->type;\n        if ((([VAR2] + ~Rec709YCbCrColorspace & 0xfffffffb) < 2) || ([VAR2] == LinearGRAYColorspace)) {\n          [VAR1] ->gamma = DAT_00380168;\n        }\n        else {\n          [VAR1] ->rendering_intent = PerceptualIntent;\n          ([VAR1] ->chromaticity).red_primary.x = DAT_0038dd78;\n          ([VAR1] ->chromaticity).red_primary.y = DAT_0038dd80;\n          ([VAR1] ->chromaticity).red_primary.z = DAT_0038dd88;\n          ([VAR1] ->chromaticity).green_primary.x = DAT_0038dd90;\n          ([VAR1] ->chromaticity).green_primary.y = DAT_0038dd98;\n          ([VAR1] ->chromaticity).green_primary.z = DAT_0038d758;\n          ([VAR1] ->chromaticity).blue_primary.x = DAT_0038dda0;\n          ([VAR1] ->chromaticity).blue_primary.y = DAT_0038dda8;\n          ([VAR1] ->chromaticity).blue_primary.z = DAT_0038ddb0;\n          ([VAR1] ->chromaticity).white_point.x = DAT_0038ddb8;\n          ([VAR1] ->chromaticity).white_point.y = DAT_0038ddc0;\n          ([VAR1] ->chromaticity).white_point.z = DAT_0038ddc8;\n        }\n      }\n      MVar1 = [FUNC5] ([VAR1] ,[VAR3] );\n      [VAR1] ->type = IVar4;\n    }\n    return MVar1;\n  }\n  [FUNC3] (\"exception->signature == MagickCoreSignature\",\"MagickCore/colorspace.c\",0x5ee,\n        \"SetImageColorspace\");\n}", "answer": {"VAR1": "image", "VAR2": "colorspace", "VAR3": "exception", "VAR4": "status", "FUNC2": "IsEventLogging", "FUNC3": "__assert_fail", "FUNC1": "SetImageColorspace", "TYPE3": "ExceptionInfo *", "TYPE2": "ColorspaceType", "FUNC4": "LogMagickEvent", "FUNC5": "SyncImagePixelCache", "TYPE4": "MagickBooleanType", "TYPE1": "Image *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nTEST RDI,RDI\nJZ 0x00090f0a\nMOV RBX,RDI\nMOV EBP,ESI\nMOV R12,RDX\nMOV EAX,0xabacadab\nCMP qword ptr [RDI + 0x3450],RAX\nJNZ 0x00090f29\nTEST RDX,RDX\nJZ 0x00090f48\nMOV EAX,0xabacadab\nCMP qword ptr [RDX + 0x30],RAX\nJNZ 0x00090f67\nCALL 0x00052700\nTEST EAX,EAX\nJNZ 0x00090f86\nMOV EAX,0x1\nCMP dword ptr [RBX + 0x4],EBP\nJZ 0x00090ffc\nMOV dword ptr [RBX + 0x4],EBP\nMOV dword ptr [RBX + 0x210],0x0\nMOV RAX,qword ptr [0x0038dd70]\nMOV qword ptr [RBX + 0x1a8],RAX\nLEA RDX,[RBX + 0x1b0]\nMOV ECX,0xc\nMOV EAX,0x0\nMOV RDI,RDX\nSTOSQ.REP RDI\nCMP EBP,0x21\nSETZ AL\nCMP EBP,0x3\nJZ 0x00090fbb\nTEST AL,AL\nJNZ 0x00090fbb\nMOV R13D,dword ptr [RBX + 0x320]\nSUB EBP,0x15\nAND EBP,0xfffffffb\nCMP EBP,0x1\nJBE 0x00090fdc\nTEST AL,AL\nJNZ 0x00090fdc\nMOV dword ptr [RBX + 0x210],0x2\nMOV RAX,qword ptr [0x0038dd78]\nMOV qword ptr [RBX + 0x1b0],RAX\nMOV RAX,qword ptr [0x0038dd80]\nMOV qword ptr [RBX + 0x1b8],RAX\nMOV RAX,qword ptr [0x0038dd88]\nMOV qword ptr [RBX + 0x1c0],RAX\nMOV RAX,qword ptr [0x0038dd90]\nMOV qword ptr [RBX + 0x1c8],RAX\nMOV RAX,qword ptr [0x0038dd98]\nMOV qword ptr [RBX + 0x1d0],RAX\nMOV RAX,qword ptr [0x0038d758]\nMOV qword ptr [RBX + 0x1d8],RAX\nMOV RAX,qword ptr [0x0038dda0]\nMOV qword ptr [RBX + 0x1e0],RAX\nMOV RAX,qword ptr [0x0038dda8]\nMOV qword ptr [RBX + 0x1e8],RAX\nMOV RAX,qword ptr [0x0038ddb0]\nMOV qword ptr [RBX + 0x1f0],RAX\nMOV RAX,qword ptr [0x0038ddb8]\nMOV qword ptr [RBX + 0x1f8],RAX\nMOV RAX,qword ptr [0x0038ddc0]\nMOV qword ptr [RBX + 0x200],RAX\nMOV RAX,qword ptr [0x0038ddc8]\nMOV qword ptr [RBX + 0x208],RAX\nJMP 0x00090fea\nLEA RCX,[0x38d340]\nMOV EDX,0x5eb\nLEA RSI,[0x38b91f]\nLEA RDI,[0x3a8bb4]\nCALL 0x000541c0\nLEA RCX,[0x38d340]\nMOV EDX,0x5ec\nLEA RSI,[0x38b91f]\nLEA RDI,[0x380528]\nCALL 0x000541c0\nLEA RCX,[0x38d340]\nMOV EDX,0x5ed\nLEA RSI,[0x38b91f]\nLEA RDI,[0x3813e8]\nCALL 0x000541c0\nLEA RCX,[0x38d340]\nMOV EDX,0x5ee\nLEA RSI,[0x38b91f]\nLEA RDI,[0x3815f8]\nCALL 0x000541c0\nLEA R9,[RBX + 0x3f8]\nLEA R8,[0x3a8432]\nMOV ECX,0x5f0\nLEA RDX,[0x38d320]\nLEA RSI,[0x38b91f]\nMOV EDI,0x8000\nMOV EAX,0x0\nCALL 0x00054f70\nJMP 0x00090dde\nMOV R13D,0x2\nCMP EBP,0x21\nJNZ 0x00090fea\nMOV RAX,qword ptr [0x00380168]\nMOV qword ptr [RBX + 0x1a8],RAX\nMOV R13D,0x2\nJMP 0x00090fea\nMOV RAX,qword ptr [0x00380168]\nMOV qword ptr [RBX + 0x1a8],RAX\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x0007ffc6\nMOV dword ptr [RBX + 0x320],R13D\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\n"}, "361": {"funcbody": "int [FUNC1] (void)\n{\n  int iVar1;\n  [TYPE1] [VAR1] ;\n  \n  do {\n    iVar1 = [FUNC2] ();\n    if (iVar1 == 0) {\n      return 1;\n    }\n  } while (iVar1 - 500U < 6);\n  return 0;\n}", "answer": {"VAR1": "o", "FUNC2": "opt_next", "FUNC1": "test_skip_common_options", "TYPE1": "OPTION_CHOICE_DEFAULT"}, "assembly": "SUB RSP,0x8\nCALL 0x000083f9\nTEST EAX,EAX\nJZ 0x000039f9\nSUB EAX,0x1f4\nCMP EAX,0x5\nJBE 0x000039df\nMOV EAX,0x0\nJMP 0x000039fe\nMOV EAX,0x1\nADD RSP,0x8\nRET\n"}, "362": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,TYPE27 [VAR2] ,[TYPE3] [VAR3] )\n{\n  ushort uVar1;\n  ffi_type **ppfVar2;\n  int iVar3;\n  long lVar4;\n  TYPE40 [VAR4] ;\n  \n  ppfVar2 = [VAR1] ->arg_types;\n  if ([VAR1] ->nargs != 0) {\n    lVar4 = 0;\n    do {\n      uVar1 = ppfVar2[lVar4]->type;\n      if ((uVar1 == 3) || ((2 < uVar1 && ((ushort)(uVar1 - 0xb) < 2)))) {\n        [VAR3] [lVar4] = [VAR2] ;\n        [VAR2] = [VAR2] + 2;\n      }\n      else {\n        [VAR3] [lVar4] = [VAR2] ;\n        [VAR2] = [VAR2] + 1;\n      }\n      iVar3 = (int)lVar4;\n      lVar4 = lVar4 + 1;\n    } while (iVar3 + 1U < [VAR1] ->nargs);\n  }\n  return;\n}", "answer": {"VAR1": "cif", "VAR2": "raw", "VAR3": "args", "VAR4": "tp", "FUNC1": "ffi_java_raw_to_ptrarray", "TYPE3": "void * *", "TYPE2": "ffi_java_raw *", "TYPE4": "ffi_type * *", "TYPE1": "ffi_cif *"}, "assembly": "MOV R8,qword ptr [RDI + 0x8]\nCMP dword ptr [RDI + 0x4],0x0\nJZ 0x00082267\nMOV EAX,0x0\nJMP 0x00082240\nMOV qword ptr [RDX + RAX*0x8],RSI\nADD RSI,0x10\nLEA ECX,[RAX + 0x1]\nADD RAX,0x1\nCMP dword ptr [RDI + 0x4],ECX\nJBE 0x00082267\nMOV RCX,qword ptr [R8 + RAX*0x8]\nMOVZX ECX,word ptr [RCX + 0xa]\nCMP CX,0x3\nJZ 0x0008222c\nCMP CX,0x3\nJC 0x0008225d\nSUB ECX,0xb\nCMP CX,0x1\nJBE 0x0008222c\nMOV qword ptr [RDX + RAX*0x8],RSI\nLEA RSI,[RSI + 0x8]\nJMP 0x00082234\nRET\n"}, "363": {"funcbody": "char * [FUNC1] (void)\n{\n  long lVar1;\n  char *pcVar2;\n  int iVar3;\n  int *piVar4;\n  char *__filename;\n  char *pcVar5;\n  [TYPE1] [VAR1] ;\n  [TYPE2] [VAR2] ;\n  [TYPE3] [VAR3] ;\n  long in_FS_OFFSET;\n  TYPE63 [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  __filename = getpwd::pwd;\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  pcVar2 = getpwd::pwd;\n  if (getpwd::pwd == (char *)0x0) {\n    piVar4 = [FUNC7] ();\n    iVar3 = getpwd::failure_errno;\n    *piVar4 = getpwd::failure_errno;\n    pcVar2 = getpwd::pwd;\n    if ((iVar3 == 0) &&\n       ((((__filename = [FUNC4] (\"PWD\"), __filename == (char *)0x0 || (*__filename != '/')) ||\n         (iVar3 = [FUNC2] (1,__filename,(stat *)&[VAR5] ), iVar3 != 0)) ||\n        (((iVar3 = [FUNC2] (1,\".\",(stat *)&[VAR6] ), iVar3 != 0 || ([VAR6] .st_ino != [VAR5] .st_ino)) ||\n         (pcVar2 = __filename, [VAR6] .st_dev != [VAR5] .st_dev)))))) {\n      [VAR2] = 0x1001;\n      while( true ) {\n        __filename = (char *)[FUNC3] ([VAR2] );\n        pcVar5 = [FUNC8] (__filename,[VAR2] );\n        pcVar2 = __filename;\n        if (pcVar5 != (char *)0x0) break;\n        iVar3 = *piVar4;\n        [FUNC6] (__filename);\n        if (iVar3 != 0x22) {\n          __filename = (char *)0x0;\n          getpwd::failure_errno = iVar3;\n          pcVar2 = __filename;\n          break;\n        }\n        [VAR2] = [VAR2] * 2;\n      }\n    }\n  }\n  getpwd::pwd = pcVar2;\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC5] ();\n  }\n  return __filename;\n}", "answer": {"VAR1": "p", "VAR2": "s", "VAR3": "e", "VAR4": "local_30", "VAR5": "pwdstat", "VAR6": "dotstat", "FUNC2": "__xstat", "FUNC3": "xmalloc", "FUNC1": "getpwd", "FUNC6": "free", "TYPE3": "int", "FUNC7": "__errno_location", "TYPE2": "size_t", "FUNC4": "getenv", "TYPE5": "stat", "FUNC5": "__stack_chk_fail", "TYPE4": "undefined8", "TYPE6": "stat", "FUNC8": "getcwd", "TYPE1": "char *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x130\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x128],RAX\nXOR EAX,EAX\nMOV RBX,qword ptr [0x003f7d10]\nTEST RBX,RBX\nJZ 0x00137c50\nMOV RAX,RBX\nMOV RCX,qword ptr [RSP + 0x128]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00137d21\nADD RSP,0x130\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nCALL 0x00049670\nMOV R14,RAX\nMOV EAX,dword ptr [0x003f7d08]\nMOV dword ptr [R14],EAX\nTEST EAX,EAX\nJNZ 0x00137c26\nLEA RDI,[0x175499]\nCALL 0x00049610\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x00137c7e\nCMP byte ptr [RAX],0x2f\nJZ 0x00137cb7\nMOV EBP,0x1001\nMOV RDI,RBP\nCALL 0x0013bf1b\nMOV RBX,RAX\nMOV RSI,RBP\nMOV RDI,RAX\nCALL 0x00049850\nMOV R12,RAX\nTEST RAX,RAX\nJNZ 0x00137d15\nMOV R13D,dword ptr [R14]\nMOV RDI,RBX\nCALL 0x00049ce0\nCMP R13D,0x22\nJNZ 0x00137d0b\nADD RBP,RBP\nJMP 0x00137c83\nLEA RDX,[RSP + 0x90]\nMOV RSI,RAX\nMOV EDI,0x1\nCALL 0x000499e0\nTEST EAX,EAX\nJNZ 0x00137c7e\nMOV RDX,RSP\nLEA RSI,[0x174ab4]\nMOV EDI,0x1\nCALL 0x000499e0\nTEST EAX,EAX\nJNZ 0x00137c7e\nMOV RAX,qword ptr [RSP + 0x98]\nCMP qword ptr [RSP + 0x8],RAX\nJNZ 0x00137c7e\nMOV RAX,qword ptr [RSP + 0x90]\nCMP qword ptr [RSP],RAX\nJNZ 0x00137c7e\nJMP 0x00137d15\nMOV dword ptr [0x003f7d08],R13D\nMOV RBX,R12\nMOV qword ptr [0x003f7d10],RBX\nJMP 0x00137c26\nCALL 0x000497a0\n"}, "364": {"funcbody": "mix_vm_status_t [FUNC1] ([TYPE1] [VAR1] )\n{\n  ushort uVar1;\n  long lVar2;\n  mix_vm_status_t mVar3;\n  uint uVar4;\n  gboolean gVar5;\n  long in_FS_OFFSET;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  \n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  if ([VAR1] == ([TYPE1] )0x0) {\n    [FUNC3] (\"libmix\",\"mix_vm_run\",\"vm != NULL\");\n    mVar3 = MIX_VM_ERROR;\n  }\n  else {\n    while (mVar3 = [VAR1] ->status, mVar3 != MIX_VM_HALT) {\n      uVar1 = [VAR1] ->loc_count;\n      if (((uVar1 & 0x1000) == 0) && (uVar1 < 4000)) {\n        uVar4 = [VAR1] ->cell[uVar1];\n        [VAR3] .address = (mix_address_t)(uVar4 >> 0x12);\n        [VAR3] .index = uVar4 >> 0xc & 7;\n        [VAR3] .fspec = (byte)(uVar4 >> 6) & 0x3f;\n        [VAR3] .opcode = (byte)uVar4 & 0x3f;\n      }\n      else {\n        [VAR3] .address = 0;\n        [VAR3] .index = mix_I0;\n        [VAR3] .fspec = '\\0';\n        [VAR3] .opcode = 0;\n      }\n      if ([VAR1] ->max_backtrace_amount != 0) {\n        [FUNC4] ([VAR1] ->address_list,uVar1);\n        if (0 < [VAR1] ->max_backtrace_amount) {\n          uVar4 = [FUNC6] ([VAR1] ->address_list);\n          if ((uint)[VAR1] ->max_backtrace_amount < uVar4) {\n            [FUNC7] ([VAR1] ->address_list);\n          }\n        }\n      }\n      gVar5 = (*ins_handlers_[[VAR3] .opcode])([VAR1] ,&[VAR3] );\n      if (gVar5 == 0) {\n        [VAR1] ->status = MIX_VM_ERROR;\n        mVar3 = MIX_VM_ERROR;\n        break;\n      }\n      [FUNC2] ([VAR1] ->clock,&[VAR3] );\n      if (((uint)(int)[VAR1] ->bp[[VAR1] ->loc_count >> 3] >> ([VAR1] ->loc_count & 7) & 1) != 0) {\n        [VAR1] ->status = MIX_VM_BREAK;\n        mVar3 = MIX_VM_BREAK;\n        break;\n      }\n      gVar5 = [FUNC5] ([VAR1] ->pred_list);\n      if (gVar5 != 0) {\n        [VAR1] ->status = MIX_VM_COND_BREAK;\n        mVar3 = MIX_VM_COND_BREAK;\n        break;\n      }\n      if (3999 < [VAR1] ->loc_count) {\n        [VAR1] ->status = MIX_VM_HALT;\n      }\n    }\n  }\n  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return mVar3;\n  }\n  [FUNC8] ();\n}", "answer": {"VAR1": "vm", "VAR2": "local_20", "VAR3": "ins", "FUNC2": "mix_vm_clock_add_lapse", "FUNC3": "g_return_if_fail_warning", "FUNC1": "mix_vm_run", "FUNC6": "g_queue_get_length", "TYPE3": "mix_ins_t", "FUNC7": "g_queue_pop_tail", "TYPE2": "undefined8", "FUNC4": "g_queue_push_head", "FUNC5": "mix_predicate_list_eval", "FUNC8": "__stack_chk_fail", "TYPE1": "mix_vm_t *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x20\nMOV RBX,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nLEA R12,[0x223700]\nLEA RBP,[RSP + 0xc]\nTEST RDI,RDI\nJNZ 0x0000ee6c\nLEA RDX,[0x19636]\nLEA RSI,[0x19c68]\nLEA RDI,[0x16f0d]\nCALL 0x00006490\nMOV EAX,0x0\nJMP 0x0000ed84\nMOVZX ESI,SI\nMOV RDI,qword ptr [RBX + 0x4198]\nCALL 0x000062e0\nCMP dword ptr [RBX + 0x3f60],0x0\nJLE 0x0000edfc\nMOV RDI,qword ptr [RBX + 0x4198]\nCALL 0x00006670\nCMP EAX,dword ptr [RBX + 0x3f60]\nJBE 0x0000edfc\nMOV RDI,qword ptr [RBX + 0x4198]\nCALL 0x00006400\nJMP 0x0000edfc\nMOV dword ptr [RBX + 0x3eb0],0x0\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0000eec9\nADD RSP,0x20\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV dword ptr [RBX + 0x3eb0],0x1\nMOV EAX,0x1\nJMP 0x0000ed84\nMOV dword ptr [RBX + 0x3eb0],0x2\nMOV EAX,0x2\nJMP 0x0000ed84\nMOV dword ptr [RBX + 0x3eb0],0x3\nJMP 0x0000ee6c\nMOV word ptr [RSP + 0xc],0x0\nMOV dword ptr [RSP + 0x10],0x0\nMOV byte ptr [RSP + 0x14],0x0\nMOV EAX,0x0\nMOV byte ptr [RSP + 0x15],AL\nCMP dword ptr [RBX + 0x3f60],0x0\nJNZ 0x0000ed35\nMOVZX EAX,byte ptr [RSP + 0x15]\nMOV RSI,RBP\nMOV RDI,RBX\nCALL qword ptr [R12 + RAX*0x8]\nTEST EAX,EAX\nJZ 0x0000ed7a\nMOV RDI,qword ptr [RBX + 0x4170]\nMOV RSI,RBP\nCALL 0x0001579c\nMOVZX EAX,word ptr [RBX + 0x3eac]\nMOV EDX,EAX\nSHR DX,0x3\nAND EDX,0x1fff\nMOVSX EDX,byte ptr [RBX + RDX*0x1 + 0x3f78]\nAND EAX,0x7\nBT EDX,EAX\nJC 0x0000eda1\nMOV RDI,qword ptr [RBX + 0x4190]\nCALL 0x0001587c\nTEST EAX,EAX\nJNZ 0x0000edb2\nCMP word ptr [RBX + 0x3eac],0xf9f\nJA 0x0000edc3\nMOV EAX,dword ptr [RBX + 0x3eb0]\nCMP EAX,0x3\nJZ 0x0000ed84\nMOVZX ESI,word ptr [RBX + 0x3eac]\nTEST SI,0x1000\nJNZ 0x0000edd2\nCMP SI,0xf9f\nJA 0x0000edd2\nMOVZX EAX,SI\nMOV EAX,dword ptr [RBX + RAX*0x4 + 0x24]\nMOV EDX,EAX\nSHR EDX,0x12\nMOV word ptr [RSP + 0xc],DX\nMOV EDX,EAX\nSHR EDX,0xc\nAND EDX,0x7\nMOV dword ptr [RSP + 0x10],EDX\nMOV EDX,EAX\nSHR EDX,0x6\nAND EDX,0x3f\nMOV byte ptr [RSP + 0x14],DL\nAND EAX,0x3f\nJMP 0x0000edeb\nCALL 0x000065f0\n"}, "365": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  int *piVar2;\n  ossl_uintmax_t oVar3;\n  [TYPE3] [VAR3] ;\n  long in_FS_OFFSET;\n  [TYPE5] [VAR5] ;\n  long [VAR4] ;\n  \n  [VAR4] = *(long *)(in_FS_OFFSET + 0x28);\n  piVar2 = [FUNC2] ();\n  iVar1 = *piVar2;\n  *piVar2 = 0;\n  oVar3 = [FUNC5] ([VAR1] ,&[VAR5] ,0,0);\n  if ((*[VAR5] == '\\0') && ([VAR5] != [VAR1] )) {\n    if (oVar3 == 0xffffffffffffffff) {\n      if (*piVar2 == 0x22) goto LAB_0006432d;\n    }\n    else if ((oVar3 == 0) && (*piVar2 != 0)) goto LAB_0006432d;\n    *[VAR2] = oVar3;\n    *piVar2 = iVar1;\n    iVar1 = 1;\n  }\n  else {\nLAB_0006432d:\n    [FUNC4] ([VAR1] );\n    *piVar2 = iVar1;\n    iVar1 = 0;\n  }\n  if ([VAR4] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "value", "VAR2": "result", "VAR3": "oerrno", "VAR4": "local_30", "VAR5": "endp", "FUNC2": "__errno_location", "FUNC3": "__stack_chk_fail", "FUNC1": "opt_uintmax", "TYPE3": "int", "TYPE2": "ossl_uintmax_t *", "FUNC4": "opt_number_error", "TYPE5": "char *", "FUNC5": "__strtoul_internal", "TYPE4": "undefined8", "TYPE1": "char *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBP,RDI\nMOV R13,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nCALL 0x00062600\nMOV RBX,RAX\nMOV R12D,dword ptr [RAX]\nMOV dword ptr [RAX],0x0\nMOV RSI,RSP\nMOV ECX,0x0\nMOV EDX,0x0\nMOV RDI,RBP\nCALL 0x00062360\nMOV RDX,qword ptr [RSP]\nCMP byte ptr [RDX],0x0\nJNZ 0x0006432d\nCMP RDX,RBP\nJZ 0x0006432d\nCMP RAX,-0x1\nJZ 0x00064328\nTEST RAX,RAX\nJNZ 0x0006431a\nCMP dword ptr [RBX],0x0\nJNZ 0x0006432d\nMOV qword ptr [R13],RAX\nMOV dword ptr [RBX],R12D\nMOV EAX,0x1\nJMP 0x0006433d\nCMP dword ptr [RBX],0x22\nJNZ 0x0006431a\nMOV RDI,RBP\nCALL 0x00063787\nMOV dword ptr [RBX],R12D\nMOV EAX,0x0\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00064358\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nCALL 0x00062640\n"}, "366": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  measurenode *pmVar1;\n  [TYPE2] [VAR2] ;\n  \n  for (pmVar1 = [VAR1] ->themeasures; pmVar1 != (measurenode *)0x0; pmVar1 = pmVar1->next) {\n    [FUNC2] ((DenemoMeasure *)pmVar1->data);\n  }\n  return;\n}", "answer": {"VAR1": "thestaff", "VAR2": "curmeasure", "FUNC2": "calculatebeamsandstemdirs", "FUNC1": "staff_beams_and_stems_dirs", "TYPE2": "measurenode *", "TYPE1": "DenemoStaff *"}, "assembly": "PUSH RBX\nMOV RBX,qword ptr [RDI + 0x20]\nTEST RBX,RBX\nJZ 0x0006fa22\nMOV RDI,qword ptr [RBX]\nCALL 0x00053563\nMOV RBX,qword ptr [RBX + 0x8]\nTEST RBX,RBX\nJNZ 0x0006fa11\nPOP RBX\nRET\n"}, "367": {"funcbody": "int [FUNC1] (TYPE12 [VAR1] ,[TYPE2] [VAR2] )\n{\n  uint uVar1;\n  char *pcVar2;\n  [TYPE3] [VAR3] ;\n  uint uVar3;\n  \n  uVar1 = [VAR2] + 0xfff + [VAR1] ->ibuf_off;\n  uVar3 = uVar1 + 0xfff;\n  if (-1 < (int)uVar1) {\n    uVar3 = uVar1;\n  }\n  uVar3 = uVar3 & 0xfffff000;\n  [VAR3] ._0_4_ = 1;\n  if ([VAR1] ->ibuf_size < (int)uVar3) {\n    pcVar2 = (char *)[FUNC2] ([VAR1] ->ibuf,uVar3,\"crypto/bio/bf_readbuff.c\",0x61);\n    [VAR3] ._0_4_ = 0;\n    if (pcVar2 != (char *)0x0) {\n      [VAR1] ->ibuf = pcVar2;\n      [VAR1] ->ibuf_size = uVar3;\n      [VAR3] ._0_4_ = 1;\n    }\n  }\n  return (int)[VAR3] ;\n}", "answer": {"VAR1": "ctx", "VAR2": "sz", "VAR3": "tmp", "FUNC2": "FUNC1", "FUNC1": "readbuffer_resize", "TYPE3": "char *", "TYPE2": "int", "TYPE1": "BIO_F_BUFFER_CTX *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV EAX,dword ptr [RDI + 0x14]\nLEA EAX,[RSI + RAX*0x1 + 0xfff]\nLEA EBX,[RAX + 0xfff]\nTEST EAX,EAX\nCMOVNS EBX,EAX\nAND EBX,0xfffff000\nMOV EAX,0x1\nCMP dword ptr [RDI],EBX\nJL 0x0020e418\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RBP,RDI\nMOVSXD RSI,EBX\nMOV RDI,qword ptr [RDI + 0x8]\nMOV ECX,0x61\nLEA RDX,[0x29ef2c]\nCALL 0x0009968a\nMOV RDX,RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x0020e411\nMOV qword ptr [RBP + 0x8],RDX\nMOV dword ptr [RBP],EBX\nMOV EAX,0x1\nJMP 0x0020e411\n"}, "368": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  switch(*[VAR1] ) {\n  case 'F':\n  case 'R':\n  case 'U':\n  case 'V':\n  case 'W':\n  case 'Y':\n    return 1;\n  default:\n    return 0;\n  }\n}", "answer": {"VAR1": "mangled", "FUNC1": "dlang_call_convention_p", "TYPE1": "char *"}, "assembly": "MOVZX EAX,byte ptr [RDI]\nSUB EAX,0x46\nCMP AL,0x13\nJA 0x0022f48c\nMOVZX EAX,AL\nLEA RDX,[0x29c4dc]\nMOVSXD RAX,dword ptr [RDX + RAX*0x4]\nADD RAX,RDX\nJMP RAX\nMOV EAX,0x0\nRET\nMOV EAX,0x1\nRET\n"}, "369": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  lang_statement_union **pplVar1;\n  [TYPE3] [VAR3] ;\n  \n  if ([VAR2] ->head != [VAR1] ->head) {\n    [FUNC2] (\"ldlang.c\",0x1f0f);\n  }\n  pplVar1 = [VAR2] ->tail;\n  [VAR2] ->head = *pplVar1;\n  [VAR2] ->tail = [VAR1] ->tail;\n  [VAR1] ->tail = pplVar1;\n  *pplVar1 = (lang_statement_union *)0x0;\n  return;\n}", "answer": {"VAR1": "destlist", "VAR2": "origlist", "VAR3": "savetail", "FUNC2": "info_assert", "FUNC1": "lang_list_remove_tail", "TYPE3": "lang_statement_union * *", "TYPE2": "lang_statement_list_type *", "TYPE1": "lang_statement_list_type *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV RBX,RSI\nMOV RAX,qword ptr [RDI]\nCMP qword ptr [RSI],RAX\nJZ 0x0003cec0\nMOV ESI,0x1f0f\nLEA RDI,[0x148974]\nCALL 0x000516fd\nMOV RAX,qword ptr [RBX + 0x8]\nMOV RDX,qword ptr [RAX]\nMOV qword ptr [RBX],RDX\nMOV RDX,qword ptr [RBP + 0x8]\nMOV qword ptr [RBX + 0x8],RDX\nMOV qword ptr [RBP + 0x8],RAX\nMOV qword ptr [RAX],0x0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "370": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  char cVar1;\n  [TYPE7] [VAR7] ;\n  char *pcVar2;\n  long lVar3;\n  ulong uVar4;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE8] [VAR8] ;\n  int iVar5;\n  [TYPE4] [VAR4] ;\n  [TYPE9] [VAR9] ;\n  char *pcVar6;\n  [TYPE3] pcVar7;\n  byte bVar8;\n  \n  bVar8 = 0;\n  lVar3 = -1;\n  pcVar7 = [VAR3] ;\n  do {\n    if (lVar3 == 0) break;\n    lVar3 = lVar3 + -1;\n    cVar1 = *pcVar7;\n    pcVar7 = pcVar7 + 1;\n  } while (cVar1 != '\\0');\n  iVar5 = ~(uint)lVar3 - 1;\n  if ([VAR2] != ([TYPE2] )0x0) {\n    [FUNC3] ([VAR1] ,[VAR2] );\n    [VAR1] ->tok_ = (char *)[VAR1] ->str_;\n  }\n  [VAR8] = [VAR1] ->tok_;\n  if (*[VAR8] == '\\0') {\n    [VAR8] = (char *)0x0;\n  }\n  else {\n    [VAR6] = ([TYPE6] )0x0;\n    do {\n      if ([VAR8] == [VAR6] ) {\n        [VAR8] = [VAR8] + iVar5;\n      }\n      [VAR6] = [FUNC2] ([VAR8] ,[VAR3] );\n    } while (([VAR6] != (char *)0x0) && ([VAR8] == [VAR6] ));\n    if ([VAR6] == (char *)0x0) {\n      uVar4 = 0xffffffffffffffff;\n      pcVar6 = [VAR8] ;\n      do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar6;\n        pcVar6 = pcVar6 + (ulong)bVar8 * -2 + 1;\n      } while (cVar1 != '\\0');\n      [VAR1] ->tok_ = [VAR8] + (~uVar4 - 1);\n    }\n    else {\n      *[VAR6] = '\\0';\n      lVar3 = (long)iVar5;\n      pcVar6 = [VAR6] + lVar3;\n      uVar4 = 0xffffffffffffffff;\n      pcVar2 = pcVar6;\n      do {\n        if (uVar4 == 0) break;\n        uVar4 = uVar4 - 1;\n        cVar1 = *pcVar2;\n        pcVar2 = pcVar2 + (ulong)bVar8 * -2 + 1;\n      } while (cVar1 != '\\0');\n      if (*[VAR8] == '\\0') {\n        [VAR8] = (TYPE80x0;\n      }\n      [VAR1] ->tok_ = [VAR6] + lVar3 + -1 + ~uVar4;\n      if ([VAR6] < [VAR6] + lVar3 + -1 + ~uVar4) {\n        cVar1 = *pcVar6;\n        while ((cVar1 != '\\0' && (pcVar2 = [FUNC2] (pcVar6,[VAR3] ), pcVar2 == pcVar6))) {\n          pcVar6 = pcVar6 + lVar3;\n          cVar1 = *pcVar6;\n        }\n        [VAR1] ->tok_ = pcVar6;\n      }\n    }\n    if (*[VAR8] == '\\0') {\n      [VAR8] = (char *)0x0;\n    }\n  }\n  return [VAR8] ;\n}", "answer": {"VAR1": "buf", "VAR2": "s", "VAR3": "delim", "VAR4": "dlen", "VAR5": "start", "VAR6": "p", "FUNC2": "strstr", "FUNC3": "strob_strcpy", "FUNC1": "strob_strstrtok", "TYPE3": "char *", "TYPE2": "char *", "TYPE5": "char *", "TYPE4": "int", "TYPE7": "char *", "TYPE6": "char *", "TYPE9": "char *", "TYPE8": "char *", "VAR7": "end", "VAR8": "retval", "VAR9": "m", "TYPE1": "STROB *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R13,RDI\nMOV R12,RDX\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,RDX\nSCASB.REPNE RDI\nNOT RCX\nLEA RBP,[RCX + -0x1]\nMOV R14D,EBP\nTEST RSI,RSI\nJZ 0x0003096e\nMOV RDI,R13\nCALL 0x00030696\nMOV RAX,qword ptr [R13]\nMOV qword ptr [R13 + 0x8],RAX\nMOV RBX,qword ptr [R13 + 0x8]\nCMP byte ptr [RBX],0x0\nJZ 0x00030a46\nMOV EDX,0x0\nMOVSXD R14,R14D\nLEA RAX,[RBX + R14*0x1]\nCMP RBX,RDX\nCMOVZ RBX,RAX\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x0000a000\nMOV RDX,RAX\nTEST RAX,RAX\nJZ 0x000309a6\nCMP RBX,RAX\nJZ 0x00030983\nTEST RDX,RDX\nJZ 0x00030a24\nMOV byte ptr [RDX],0x0\nMOVSXD R14,EBP\nLEA RBP,[RDX + R14*0x1]\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,RBP\nSCASB.REPNE RDI\nMOV RSI,RCX\nNOT RSI\nLEA RAX,[R14 + RSI*0x1 + -0x1]\nADD RAX,RDX\nCMP byte ptr [RBX],0x0\nMOV ECX,0x0\nCMOVZ RBX,RCX\nMOV qword ptr [R13 + 0x8],RAX\nCMP RDX,RAX\nJNC 0x00030a0c\nCMP byte ptr [RBP],0x0\nJZ 0x00030a08\nMOV RSI,R12\nMOV RDI,RBP\nCALL 0x0000a000\nCMP RAX,RBP\nJNZ 0x00030a08\nADD RBP,R14\nCMP byte ptr [RBP],0x0\nJNZ 0x000309ef\nMOV qword ptr [R13 + 0x8],RBP\nCMP byte ptr [RBX],0x0\nMOV EAX,0x0\nCMOVZ RBX,RAX\nMOV RAX,RBX\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,RBX\nSCASB.REPNE RDI\nMOV RSI,RCX\nNOT RSI\nLEA RAX,[RBX + RSI*0x1 + -0x1]\nMOV qword ptr [R13 + 0x8],RAX\nJMP 0x00030a0c\nMOV EBX,0x0\nJMP 0x00030a18\n"}, "371": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  uchar *__dest;\n  EVP_MD *md;\n  [TYPE4] [VAR4] ;\n  ENGINE *impl;\n  size_t num;\n  \n  if ([VAR1] ->key != (uchar *)0x0) {\n    [FUNC2] ([VAR1] ->key,[VAR1] ->keylen,\"providers/implementations/macs/hmac_prov.c\",0x9d);\n  }\n  num = 1;\n  if ([VAR3] != 0) {\n    num = [VAR3] ;\n  }\n  __dest = (uchar *)[FUNC6] (num,\"providers/implementations/macs/hmac_prov.c\",0x9f);\n  [VAR1] ->key = __dest;\n  iVar1 = 0;\n  if (__dest != (uchar *)0x0) {\n    [FUNC3] (__dest,[VAR2] ,[VAR3] );\n    [VAR1] ->keylen = [VAR3] ;\n    md = [FUNC7] (&[VAR1] ->digest);\n    if (([VAR2] == ([TYPE2] )0x0) && (([VAR1] ->tls_data_size != 0 || (md == (EVP_MD *)0x0)))) {\n      iVar1 = 1;\n    }\n    else {\n      impl = [FUNC5] (&[VAR1] ->digest);\n      iVar1 = [FUNC4] ((HMAC_CTX *)[VAR1] ->ctx,[VAR2] ,(int)[VAR3] ,(EVP_MD *)md,(ENGINE *)impl);\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "macctx", "VAR2": "key", "VAR3": "keylen", "VAR4": "digest", "FUNC2": "CRYPTO_secure_clear_free", "FUNC3": "memcpy", "FUNC1": "hmac_setkey", "FUNC6": "CRYPTO_secure_malloc", "TYPE3": "size_t", "FUNC7": "ossl_prov_digest_md", "TYPE2": "uchar *", "FUNC4": "HMAC_Init_ex", "FUNC5": "ossl_prov_digest_engine", "TYPE4": "EVP_MD *", "TYPE1": "hmac_data_st *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV R12,RSI\nMOV RBP,RDX\nMOV RDI,qword ptr [RDI + 0x28]\nTEST RDI,RDI\nJZ 0x000f8778\nMOV RSI,qword ptr [RBX + 0x30]\nMOV ECX,0x9d\nLEA RDX,[0x276fb8]\nCALL 0x0009a98b\nTEST RBP,RBP\nMOV EDI,0x1\nCMOVNZ RDI,RBP\nMOV EDX,0x9f\nLEA RSI,[0x276fb8]\nCALL 0x0009a524\nMOV RDI,RAX\nMOV qword ptr [RBX + 0x28],RAX\nMOV EAX,0x0\nTEST RDI,RDI\nJZ 0x000f87e5\nMOV RDX,RBP\nMOV RSI,R12\nCALL 0x00062960\nMOV qword ptr [RBX + 0x30],RBP\nLEA R13,[RBX + 0x10]\nMOV RDI,R13\nCALL 0x000c4908\nMOV R14,RAX\nTEST R12,R12\nJZ 0x000f87ee\nMOV RDI,R13\nCALL 0x000c490c\nMOV R8,RAX\nMOV RDI,qword ptr [RBX + 0x8]\nMOV RCX,R14\nMOV EDX,EBP\nMOV RSI,R12\nCALL 0x0019f0fd\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nCMP qword ptr [RBX + 0x38],0x0\nJNZ 0x000f87fa\nTEST RAX,RAX\nJNZ 0x000f87c9\nMOV EAX,0x1\nJMP 0x000f87e5\n"}, "372": {"funcbody": "void [FUNC1] (void)\n{\n  OPENSSL_INIT_STOP *pOVar1;\n  OPENSSL_INIT_STOP *ptr;\n  TYPE17 [VAR1] ;\n  TYPE27 [VAR2] ;\n  \n  if ((base_inited != 0) && (stopped == 0)) {\n    stopped = 1;\n    [FUNC6] ();\n    ptr = stop_handlers;\n    while (ptr != (OPENSSL_INIT_STOP *)0x0) {\n      (*ptr->handler)();\n      pOVar1 = ptr->next;\n      [FUNC9] (ptr);\n      ptr = pOVar1;\n    }\n    stop_handlers = (OPENSSL_INIT_STOP *)0x0;\n    [FUNC13] (optsdone_lock);\n    optsdone_lock = (CRYPTO_RWLOCK *)0x0;\n    [FUNC13] (init_lock);\n    init_lock = (CRYPTO_RWLOCK *)0x0;\n    [FUNC14] (&in_init_config_local);\n    [FUNC4] ();\n    if (async_inited != 0) {\n      [FUNC15] ();\n    }\n    [FUNC8] ();\n    [FUNC11] ();\n    [FUNC7] ();\n    [FUNC2] ();\n    [FUNC10] ();\n    [FUNC16] ();\n    [FUNC19] ();\n    [FUNC12] ();\n    [FUNC20] ();\n    [FUNC3] ();\n    [FUNC17] ();\n    [FUNC18] ();\n    [FUNC5] ();\n    base_inited = 0;\n    return;\n  }\n  return;\n}", "answer": {"FUNC20": "ossl_obj_cleanup_int", "FUNC12": "evp_cleanup_int", "FUNC11": "ossl_config_modules_free", "FUNC14": "CRYPTO_THREAD_cleanup_local", "VAR1": "currhandler", "FUNC13": "CRYPTO_THREAD_lock_free", "VAR2": "lasthandler", "FUNC10": "ossl_lib_ctx_default_deinit", "FUNC19": "bio_cleanup", "FUNC2": "ossl_store_cleanup_int", "FUNC16": "ossl_cleanup_thread", "FUNC3": "err_cleanup", "FUNC15": "async_deinit", "FUNC18": "OSSL_CMP_log_close", "FUNC1": "OPENSSL_cleanup", "FUNC17": "CRYPTO_secure_malloc_done", "FUNC6": "OPENSSL_thread_stop", "FUNC7": "engine_cleanup_int", "TYPE2": "OPENSSL_INIT_STOP *", "FUNC4": "ossl_comp_zlib_cleanup", "FUNC5": "ossl_trace_cleanup", "FUNC8": "ossl_rand_cleanup_int", "FUNC9": "CRYPTO_free", "TYPE1": "OPENSSL_INIT_STOP *"}, "assembly": "CMP dword ptr [0x005775c8],0x0\nJZ 0x0009c9b9\nCMP dword ptr [0x005775f8],0x0\nJZ 0x0009c9bb\nRET\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV dword ptr [0x005775f8],0x1\nCALL 0x0009d614\nMOV RBX,qword ptr [0x005775e8]\nTEST RBX,RBX\nJZ 0x0009c9ff\nLEA R12,[0x26332d]\nCALL qword ptr [RBX]\nMOV RBP,qword ptr [RBX + 0x8]\nMOV EDX,0x175\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x0009d828\nMOV RBX,RBP\nTEST RBP,RBP\nJNZ 0x0009c9e1\nMOV qword ptr [0x005775e8],0x0\nMOV RDI,qword ptr [0x005775e0]\nCALL 0x000a46d5\nMOV qword ptr [0x005775e0],0x0\nMOV RDI,qword ptr [0x005775d8]\nCALL 0x000a46d5\nMOV qword ptr [0x005775d8],0x0\nLEA RDI,[0x5775d0]\nCALL 0x000a474f\nCALL 0x00144900\nCMP dword ptr [0x00577584],0x0\nJNZ 0x0009caa2\nCALL 0x000ae109\nCALL 0x00145ee4\nCALL 0x0017fca2\nCALL 0x000b96b7\nCALL 0x0009a44d\nCALL 0x0009d5e5\nCALL 0x00077639\nCALL 0x0009061a\nCALL 0x000a9312\nCALL 0x00083d3c\nCALL 0x0009e698\nCALL 0x001441f8\nCALL 0x000a4851\nMOV dword ptr [0x005775c8],0x0\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x0012eb25\nJMP 0x0009ca52\n"}, "373": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  char *pcVar2;\n  \n  [FUNC3] ([VAR1] ->buffer_,[VAR2] );\n  iVar1 = 0;\n  while( true ) {\n    if (iVar1 == 0) {\n      pcVar2 = [FUNC4] ([VAR1] ->buffer_);\n    }\n    else {\n      pcVar2 = (char *)0x0;\n    }\n    pcVar2 = [FUNC2] (pcVar2,\"/\");\n    if (pcVar2 == (char *)0x0) break;\n    iVar1 = iVar1 + 1;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "swpath", "VAR2": "str", "FUNC2": "strtok", "FUNC3": "strob_strcpy", "FUNC1": "swpath_num_of_components", "TYPE2": "char *", "FUNC4": "strob_str", "TYPE1": "SWPATH *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV R12,RDI\nMOV RDI,qword ptr [RDI + 0x48]\nCALL 0x0001770c\nMOV EBX,0x0\nMOV EBP,0x0\nJMP 0x0001f008\nADD EBX,0x1\nTEST EBX,EBX\nJZ 0x0001f027\nMOV RDI,RBP\nLEA RSI,[0x737a9]\nCALL 0x0000d830\nTEST RAX,RAX\nJNZ 0x0001f005\nMOV EAX,EBX\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,qword ptr [R12 + 0x48]\nCALL 0x00017c45\nMOV RDI,RAX\nJMP 0x0001f00f\n"}, "374": {"funcbody": "/* DWARF original prototype: Vector<LoadObject*> * get_text_segments(DbeSession * this) */\nVector<LoadObject*> * __thiscall DbeSession::[FUNC1] (TYPE14 [VAR1] )\n{\n  Vector<LoadObject*> *pVVar1;\n  Vector<LoadObject*> *this;\n  int iVar2;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  \n  this = (Vector<LoadObject*> *)[FUNC2] (0x28);\n  this->_vptr_Vector = (_func_int_varargs **)&PTR__Vector_004d3870;\n  this->count = 0;\n  this->data = (LoadObject **)0x0;\n  this->limit = 0;\n  this->sorted = false;\n  pVVar1 = [VAR1] ->lobjs;\n  if ((pVVar1 != (Vector<LoadObject*> *)0x0) && (0 < pVVar1->count)) {\n    [VAR3] = *pVVar1->data;\n    iVar2 = 0;\n    while ((long)iVar2 < [VAR1] ->lobjs->count) {\n      if ([VAR3] ->type == SEG_TEXT) {\n        Vector<LoadObject*>::[FUNC3] (this,[VAR3] );\n      }\n      iVar2 = iVar2 + 1;\n      [VAR3] = ([TYPE3] )0x0;\n      if ((long)iVar2 < [VAR1] ->lobjs->count) {\n        [VAR3] = [VAR1] ->lobjs->data[iVar2];\n      }\n    }\n  }\n  return this;\n}", "answer": {"VAR1": "this", "VAR2": "tlobjs", "VAR3": "lo", "FUNC2": "operator.new", "FUNC3": "append", "FUNC1": "get_text_segments", "TYPE3": "LoadObject *", "TYPE2": "Vector<LoadObject*> *", "TYPE1": "DbeSession *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV EDI,0x28\nCALL 0x0008fb10\nMOV R12,RAX\nLEA RAX,[0x4d3870]\nMOV qword ptr [R12],RAX\nMOV qword ptr [R12 + 0x10],0x0\nMOV qword ptr [R12 + 0x8],0x0\nMOV qword ptr [R12 + 0x18],0x0\nMOV byte ptr [R12 + 0x20],0x0\nMOV RAX,qword ptr [RBP + 0x68]\nTEST RAX,RAX\nJZ 0x000ce86c\nCMP qword ptr [RAX + 0x10],0x0\nJLE 0x000ce86c\nMOV RAX,qword ptr [RAX + 0x8]\nMOV RSI,qword ptr [RAX]\nMOV EBX,0x0\nMOV R13D,0x0\nMOVSXD RAX,EBX\nMOV RDX,qword ptr [RBP + 0x68]\nCMP RAX,qword ptr [RDX + 0x10]\nJGE 0x000ce86c\nCMP dword ptr [RSI + 0x74],0x0\nJZ 0x000ce862\nADD EBX,0x1\nMOV RAX,qword ptr [RBP + 0x68]\nMOVSXD RDX,EBX\nMOV RSI,R13\nCMP RDX,qword ptr [RAX + 0x10]\nJGE 0x000ce832\nMOV RCX,qword ptr [RAX + 0x8]\nMOV RSI,qword ptr [RCX + RDX*0x8]\nJMP 0x000ce832\nMOV RDI,R12\nCALL 0x000d5070\nJMP 0x000ce845\nMOV RAX,R12\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\n"}, "375": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         TYPE55 [VAR5] ,TYPE68 [VAR6] ,[TYPE7] [VAR7] )\n{\n  int iVar1;\n  X509_PUBKEY *x;\n  long in_FS_OFFSET;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  long [VAR8] ;\n  \n  [VAR8] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR9] = ([TYPE9] )0x0;\n  [VAR10] = -1;\n  if ([VAR5] != (TYPE55)0x0) {\n    iVar1 = (*[VAR5] )([VAR2] ,[VAR3] ,[VAR7] ->save_parameters,&[VAR9] ,&[VAR10] );\n    if (iVar1 == 0) goto LAB_000e6562;\n  }\n  x = [FUNC4] ([VAR2] ,[VAR3] ,[VAR9] ,[VAR10] ,[VAR6] );\n  if (x == (X509_PUBKEY *)0x0) {\n    [FUNC3] ([VAR10] ,[VAR9] );\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = [FUNC2] ([VAR1] ,x);\n  }\n  [FUNC6] ((X509_PUBKEY *)x);\nLAB_000e6562:\n  if ([VAR8] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n  [FUNC5] ();\n}", "answer": {"VAR1": "out", "VAR2": "key", "VAR3": "key_nid", "VAR4": "pemname", "VAR5": "p2s", "VAR6": "k2d", "FUNC2": "PEM_write_bio_X509_PUBKEY", "FUNC3": "free_asn1_data", "FUNC1": "key_to_spki_pem_pub_bio", "FUNC6": "X509_PUBKEY_free", "TYPE3": "int", "TYPE2": "void *", "FUNC4": "key_to_pubkey", "TYPE5": "key_to_paramstring_fn *", "FUNC5": "__stack_chk_fail", "TYPE4": "char *", "TYPE7": "key2any_ctx_st *", "TYPE6": "i2d_of_void *", "TYPE9": "void *", "TYPE8": "undefined8", "VAR7": "ctx", "VAR8": "local_30", "VAR9": "str", "TYPE10": "int", "VAR10": "strtype", "TYPE1": "BIO *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x20\nMOV R13,RDI\nMOV RBP,RSI\nMOV R12D,EDX\nMOV R14,R9\nMOV RDX,qword ptr [RSP + 0x50]\nMOV RSI,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RSI\nXOR ESI,ESI\nMOV qword ptr [RSP + 0x10],0x0\nMOV dword ptr [RSP + 0xc],0xffffffff\nTEST R8,R8\nJZ 0x000e652e\nMOV RAX,R8\nLEA RCX,[RSP + 0x10]\nMOV EDX,dword ptr [RDX + 0x8]\nLEA R8,[RSP + 0xc]\nMOV ESI,R12D\nMOV RDI,RBP\nCALL RAX\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x000e6562\nMOV R8,R14\nMOV ECX,dword ptr [RSP + 0xc]\nMOV RDX,qword ptr [RSP + 0x10]\nMOV ESI,R12D\nMOV RDI,RBP\nCALL 0x000e6317\nMOV RBP,RAX\nTEST RAX,RAX\nJZ 0x000e6581\nMOV RSI,RAX\nMOV RDI,R13\nCALL 0x001b45b0\nMOV EBX,EAX\nMOV RDI,RBP\nCALL 0x000c3b39\nMOV EAX,EBX\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x000e6596\nADD RSP,0x20\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV RSI,qword ptr [RSP + 0x10]\nMOV EDI,dword ptr [RSP + 0xc]\nCALL 0x000e5e98\nMOV EBX,0x0\nJMP 0x000e655a\nCALL 0x00062640\n"}, "376": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  [TYPE5] *pTVar1;\n  [TYPE5] *pTVar2;\n  [TYPE5] *pTVar4;\n  int iVar5;\n  [TYPE3] [VAR3] ;\n  long in_FS_OFFSET;\n  [TYPE5] [VAR5] ;\n  long [VAR4] ;\n  [TYPE5] *pTVar3;\n  \n  [VAR4] = *(long *)(in_FS_OFFSET + 0x28);\n  if ([VAR2] == 0xffff) {\n    iVar5 = *(int *)((long)[VAR1] + 0x18);\n    if (iVar5 <= *(int *)((long)[VAR1] + 8)) {\n      if (iVar5 < 1) goto LAB_000166a2;\n      pTVar4 = *([TYPE5] **)((long)[VAR1] + 0x10);\n      goto LAB_000166d3;\n    }\n  }\n  else {\n    [VAR5] = ([TYPE5] [VAR2] ;\n    if (0 < *(int *)((long)[VAR1] + 8)) {\n      iVar5 = 1;\n      pTVar4 = &[VAR5] ;\nLAB_000166d3:\n      pTVar3 = pTVar4;\n      do {\n        pTVar2 = pTVar3 + 1;\n        pTVar1 = *[VAR1] ;\n        *([TYPE5] **)[VAR1] = pTVar1 + 1;\n        *pTVar1 = *pTVar3;\n        *(int *)((long)[VAR1] + 8) = *(int *)((long)[VAR1] + 8) + -1;\n        pTVar3 = pTVar2;\n      } while (0 < (iVar5 + (int)pTVar4) - (int)pTVar2);\n      goto LAB_000166a2;\n    }\n  }\n  *(undefined4 *)((long)[VAR1] + 0x1c) = 1;\nLAB_000166a2:\n  if ([VAR4] != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC2] ();\n  }\n  return;\n}", "answer": {"VAR1": "ctx", "VAR2": "output", "VAR3": "param", "VAR4": "local_10", "VAR5": "outval", "FUNC2": "__stack_chk_fail", "FUNC1": "charset_emit", "TYPE3": "charset_emit_param *", "TYPE2": "long", "TYPE5": "char", "TYPE4": "undefined8", "TYPE1": "void *"}, "assembly": "SUB RSP,0x18\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nCMP RSI,0xffff\nJZ 0x000166b7\nMOV byte ptr [RSP + 0x7],SIL\nCMP dword ptr [RDI + 0x8],0x0\nJG 0x000166c9\nMOV dword ptr [RDI + 0x1c],0x1\nMOV RAX,qword ptr [RSP + 0x8]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x000166fa\nADD RSP,0x18\nRET\nMOV ESI,dword ptr [RDI + 0x18]\nCMP dword ptr [RDI + 0x8],ESI\nJL 0x0001669b\nTEST ESI,ESI\nJLE 0x000166a2\nMOV RDX,qword ptr [RDI + 0x10]\nJMP 0x000166d3\nMOV ESI,0x1\nLEA RDX,[RSP + 0x7]\nMOV RAX,RDX\nADD ESI,EDX\nADD RAX,0x1\nMOV RDX,qword ptr [RDI]\nLEA RCX,[RDX + 0x1]\nMOV qword ptr [RDI],RCX\nMOVZX ECX,byte ptr [RAX + -0x1]\nMOV byte ptr [RDX],CL\nSUB dword ptr [RDI + 0x8],0x1\nMOV EDX,ESI\nSUB EDX,EAX\nTEST EDX,EDX\nJG 0x000166d8\nJMP 0x000166a2\nCALL 0x00015250\n"}, "377": {"funcbody": "/* DWARF original prototype: void operator()(PathSmoothQuadraticCurvetoAbs * this, DrawingWand *\n   context_) */\nvoid __thiscall\nMagick::PathSmoothQuadraticCurvetoAbs::[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  pointer pCVar1;\n  pointer pCVar2;\n  \n  pCVar1 = ([VAR1] ->_coordinates).\n           super__Vector_base<Magick::Coordinate,_std::allocator<Magick::Coordinate>_>._M_impl.\n           _M_start;\n  if (pCVar1 != ([VAR1] ->_coordinates).\n                super__Vector_base<Magick::Coordinate,_std::allocator<Magick::Coordinate>_>._M_impl.\n                _M_finish) {\n    do {\n      pCVar2 = pCVar1 + 1;\n      [FUNC2] (pCVar1->_x,pCVar1->_y,[VAR2] );\n      pCVar1 = pCVar2;\n    } while (([VAR1] ->_coordinates).\n             super__Vector_base<Magick::Coordinate,_std::allocator<Magick::Coordinate>_>._M_impl.\n             _M_finish != pCVar2);\n  }\n  return;\n}", "answer": {"VAR1": "this", "VAR2": "context_", "FUNC2": "DrawPathCurveToQuadraticBezierSmoothAbsolute", "FUNC1": "operator()", "TYPE2": "DrawingWand *", "TYPE1": "PathSmoothQuadraticCurvetoAbs *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,qword ptr [RDI + 0x8]\nCMP RBX,qword ptr [RDI + 0x10]\nJZ 0x000561de\nMOV R13,RSI\nMOV R12,RDI\nADD RBX,0x18\nMOV RBP,RBX\nMOVSD XMM1,qword ptr [RBX + -0x8]\nMOVSD XMM0,qword ptr [RBX + -0x10]\nMOV RDI,R13\nCALL 0x0004fae0\nADD RBX,0x18\nCMP qword ptr [R12 + 0x10],RBP\nJNZ 0x000561be\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\n"}, "378": {"funcbody": "void [FUNC1] (long param_1,long param_2,undefined8 param_3,undefined8 param_4,int param_5,long param_6)\n{\n  uint uVar1;\n  long lVar2;\n  \n  if (0 < param_5) {\n    lVar2 = 0;\n    do {\n      uVar1 = *(uint *)(param_6 + (ulong)*(byte *)(param_2 + lVar2) * 4);\n      *(ushort *)(param_1 + lVar2 * 2) = (ushort)((uVar1 >> 0x18) << 6) | (ushort)(uVar1 >> 0x1a);\n      lVar2 = lVar2 + 1;\n    } while ((ulong)(param_5 - 1) + 1 != lVar2);\n  }\n  return;\n}", "answer": {"FUNC1": "FUN_00f60f40"}, "assembly": "TEST R8D,R8D\nJLE 0x00f60f72\nSUB R8D,0x1\nXOR EDX,EDX\nADD R8,0x1\nNOP\nMOVZX EAX,byte ptr [RSI + RDX*0x1]\nMOV ECX,dword ptr [R9 + RAX*0x4]\nMOV EAX,ECX\nSHR ECX,0x1a\nSHR EAX,0x18\nSHL EAX,0x6\nOR EAX,ECX\nMOV word ptr [RDI + RDX*0x2],AX\nADD RDX,0x1\nCMP R8,RDX\nJNZ 0x00f60f50\nRET\n"}, "379": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] ,TYPE21 [VAR2] ,TYPE31 [VAR3] )\n{\n  int iVar1;\n  DH *dh;\n  DSA *d;\n  BIGNUM *bn;\n  \n  iVar1 = [FUNC6] ((EVP_PKEY *)[VAR3] ->p2);\n  if (iVar1 == 0x1c) {\n    dh = [FUNC5] ((EVP_PKEY *)[VAR3] ->p2);\n    bn = [FUNC4] (dh);\n  }\n  else if (iVar1 == 0x74) {\n    d = [FUNC7] ((EVP_PKEY *)[VAR3] ->p2);\n    bn = [FUNC2] (d);\n  }\n  else {\n    bn = (BIGNUM *)0x0;\n  }\n  iVar1 = [FUNC3] ([VAR1] ,[VAR2] ,[VAR3] ,bn);\n  return iVar1;\n}", "answer": {"VAR1": "state", "VAR2": "translation", "VAR3": "ctx", "FUNC2": "DSA_get0_q", "FUNC3": "get_payload_bn", "FUNC1": "get_dh_dsa_payload_q", "FUNC6": "EVP_PKEY_get_base_id", "TYPE3": "translation_ctx_st *", "FUNC7": "EVP_PKEY_get0_DSA", "TYPE2": "translation_st *", "FUNC4": "DH_get0_q", "FUNC5": "EVP_PKEY_get0_DH", "TYPE1": "state"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV EBP,EDI\nMOV R12,RSI\nMOV RBX,RDX\nMOV RDI,qword ptr [RDX + 0x20]\nCALL 0x0008d105\nCMP EAX,0x1c\nJZ 0x00182722\nCMP EAX,0x74\nJZ 0x00182748\nMOV ECX,0x0\nJMP 0x00182736\nMOV RDI,qword ptr [RBX + 0x20]\nCALL 0x0008f6e3\nMOV RDI,RAX\nCALL 0x001497ee\nMOV RCX,RAX\nMOV RDX,RBX\nMOV RSI,R12\nMOV EDI,EBP\nCALL 0x001808f8\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV RDI,qword ptr [RBX + 0x20]\nCALL 0x0008f597\nMOV RDI,RAX\nCALL 0x0014c2a9\nMOV RCX,RAX\nJMP 0x00182736\n"}, "380": {"funcbody": "/* DWARF original prototype: int get_subscript_correction(font * this, glyph * g, int point_size) */\nint __thiscall font::[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  \n  iVar1 = [VAR2] ->index;\n  if (iVar1 < 0) {\n    [FUNC3] (\"idx >= 0\",\"src/libs/libgroff/font.cpp\",0x1db,\n          \"int font::get_subscript_correction(glyph*, int)\");\n  }\n  if ((iVar1 < [VAR1] ->nindices) && (-1 < [VAR1] ->ch_index[iVar1])) {\n    iVar1 = [VAR1] ->ch[[VAR1] ->ch_index[iVar1]].subscript_correction;\n    if ([VAR1] ->zoom == 0) {\n      if ([VAR3] != unitwidth) {\n        iVar1 = [FUNC2] (iVar1,[VAR3] ,unitwidth);\n      }\n    }\n    else {\n      iVar1 = [FUNC4] (iVar1,[VAR3] ,unitwidth,[VAR1] ->zoom);\n    }\n  }\n  else {\n    if (!is_unicode) {\n      [FUNC3] (\"0 == \\\"glyph is not indexed and device lacks Unicode support\\\"\",\n            \"src/libs/libgroff/font.cpp\",0x1e4,\"int font::get_subscript_correction(glyph*, int)\");\n    }\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "this", "VAR2": "g", "VAR3": "point_size", "FUNC2": "scale_round", "FUNC3": "__assert_fail", "FUNC1": "get_subscript_correction", "TYPE3": "int", "TYPE2": "glyph *", "FUNC4": "scale_round", "TYPE1": "font *"}, "assembly": "SUB RSP,0x8\nMOV EAX,dword ptr [RSI]\nTEST EAX,EAX\nJS 0x0000dd58\nMOV R8D,EDX\nCMP dword ptr [RDI + 0x48],EAX\nJLE 0x0000dd45\nCDQE\nMOV RDX,qword ptr [RDI + 0x40]\nMOV EAX,dword ptr [RDX + RAX*0x4]\nTEST EAX,EAX\nJNS 0x0000dd77\nCMP byte ptr [0x002228c0],0x0\nJZ 0x0000ddb8\nMOV EAX,0x0\nADD RSP,0x8\nRET\nLEA RCX,[0x18d60]\nMOV EDX,0x1db\nLEA RSI,[0x1807f]\nLEA RDI,[0x180dd]\nCALL 0x00006e50\nCDQE\nLEA RAX,[RAX + RAX*0x4]\nSHL RAX,0x3\nADD RAX,qword ptr [RDI + 0x50]\nMOV EAX,dword ptr [RAX + 0x1c]\nMOV ECX,dword ptr [RDI + 0x38]\nTEST ECX,ECX\nJNZ 0x0000dda6\nMOV EDX,dword ptr [0x002228e0]\nCMP R8D,EDX\nJZ 0x0000dd53\nMOV ESI,R8D\nMOV EDI,EAX\nCALL 0x0000d1f6\nJMP 0x0000dd53\nMOV EDX,dword ptr [0x002228e0]\nMOV ESI,R8D\nMOV EDI,EAX\nCALL 0x0000d12e\nJMP 0x0000dd53\nLEA RCX,[0x18d60]\nMOV EDX,0x1e4\nLEA RSI,[0x1807f]\nLEA RDI,[0x18300]\nCALL 0x00006e50\n"}, "381": {"funcbody": "quoting_options * [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  [TYPE2] [VAR2] ;\n  int *piVar2;\n  quoting_options *pqVar3;\n  [TYPE3] [VAR3] ;\n  \n  piVar2 = [FUNC2] ();\n  iVar1 = *piVar2;\n  if ([VAR1] == ([TYPE1] )0x0) {\n    [VAR1] = &default_quoting_options;\n  }\n  pqVar3 = (quoting_options *)[FUNC3] ([VAR1] ,0x38);\n  *piVar2 = iVar1;\n  return pqVar3;\n}", "answer": {"VAR1": "o", "VAR2": "p", "VAR3": "e", "FUNC2": "__errno_location", "FUNC3": "xmemdup", "FUNC1": "clone_quoting_options", "TYPE3": "wchar_t", "TYPE2": "quoting_options *", "TYPE1": "quoting_options *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nCALL 0x000037e0\nMOV RBP,RAX\nMOV R12D,dword ptr [RAX]\nTEST RBX,RBX\nLEA RAX,[0x244720]\nCMOVZ RBX,RAX\nMOV ESI,0x38\nMOV RDI,RBX\nCALL 0x000286f4\nMOV dword ptr [RBP],R12D\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "382": {"funcbody": "void [FUNC1] (TYPE11 [VAR1] ,[TYPE2] [VAR2] )\n{\n  if ([VAR1] != (TYPE11)0x0) {\n    if ([VAR2] == 0) {\n      [VAR2] = 0x19000;\n    }\n    [VAR1] ->max_resp_len = [VAR2] ;\n    return;\n  }\n  [FUNC4] ();\n  [FUNC2] (\"crypto/http/http_client.c\",0x9f,\"OSSL_HTTP_REQ_CTX_set_max_response_length\");\n  [FUNC3] (0x3d,0xc0102,(char *)0x0);\n  return;\n}", "answer": {"VAR1": "rctx", "VAR2": "len", "FUNC2": "ERR_set_debug", "FUNC3": "ERR_set_error", "FUNC1": "OSSL_HTTP_REQ_CTX_set_max_response_length", "TYPE2": "ulong", "FUNC4": "ERR_new", "TYPE1": "OSSL_HTTP_REQ_CTX *"}, "assembly": "TEST RDI,RDI\nJZ 0x001acb0a\nTEST RSI,RSI\nMOV EAX,0x19000\nCMOVZ RSI,RAX\nMOV qword ptr [RDI + 0x98],RSI\nRET\nSUB RSP,0x8\nCALL 0x00081cae\nLEA RDX,[0x296440]\nMOV ESI,0x9f\nLEA RDI,[0x295f93]\nCALL 0x00081dbb\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0x3d\nMOV EAX,0x0\nCALL 0x000820d2\nADD RSP,0x8\nRET\n"}, "383": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,TYPE30 [VAR3] ,[TYPE4] [VAR4] ,\n            [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  long lVar1;\n  void *pvVar2;\n  [TYPE7] [VAR7] ;\n  long in_FS_OFFSET;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR7] = ([TYPE7] )0x0;\n  if ([VAR3] != (TYPE30)0x0) {\n    [VAR7] = *[VAR3] ;\n  }\n  [VAR9] .store = (OSSL_METHOD_STORE *)0x0;\n  [VAR9] .force_store = [VAR4] ;\n  [VAR9] .mcm = [VAR5] ;\n  [VAR9] .mcm_data = [VAR6] ;\n  [FUNC7] ([VAR1] ,[VAR2] ,[VAR7] ,[FUNC3] ,[FUNC6] ,[FUNC4] ,[FUNC8] ,[FUNC2] ,&[VAR9] );\n  if ([VAR9] .store != (OSSL_METHOD_STORE *)0x0) {\n    pvVar2 = (*[VAR5] ->get)([VAR9] .store,[VAR3] ,[VAR6] );\n    if (pvVar2 != (void *)0x0) goto LAB_00097596;\n  }\n  pvVar2 = (*[VAR5] ->get)((void *)0x0,[VAR3] ,[VAR6] );\nLAB_00097596:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return pvVar2;\n  }\n  [FUNC5] ();\n}", "answer": {"VAR1": "libctx", "VAR2": "operation_id", "VAR3": "provider_rw", "VAR4": "force_store", "VAR5": "mcm", "VAR6": "mcm_data", "FUNC2": "ossl_method_construct_postcondition", "FUNC3": "ossl_method_construct_precondition", "FUNC1": "ossl_method_construct", "FUNC6": "ossl_method_construct_reserve_store", "TYPE3": "OSSL_PROVIDER * *", "FUNC7": "ossl_algorithm_do_all", "TYPE2": "int", "FUNC4": "ossl_method_construct_this", "TYPE5": "OSSL_METHOD_CONSTRUCT_METHOD *", "FUNC5": "__stack_chk_fail", "TYPE4": "int", "TYPE7": "OSSL_PROVIDER *", "TYPE6": "void *", "FUNC8": "ossl_method_construct_unreserve_store", "TYPE9": "construct_data_st", "TYPE8": "undefined8", "VAR7": "provider", "VAR8": "local_20", "VAR9": "cbdata", "TYPE1": "OSSL_LIB_CTX *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x30\nMOV RBX,RDX\nMOV RBP,R8\nMOV R12,R9\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x28],RAX\nXOR EAX,EAX\nMOV EDX,0x0\nTEST RBX,RBX\nJZ 0x00097521\nMOV RDX,qword ptr [RBX]\nMOV qword ptr [RSP + 0x8],0x0\nMOV dword ptr [RSP + 0x14],ECX\nMOV qword ptr [RSP + 0x18],RBP\nMOV qword ptr [RSP + 0x20],R12\nSUB RSP,0x8\nLEA RAX,[RSP + 0x8]\nPUSH RAX\nLEA RAX,[0x97482]\nPUSH RAX\nLEA RAX,[0x9738c]\nPUSH RAX\nLEA R9,[0x973a7]\nLEA R8,[0x97342]\nLEA RCX,[0x9740a]\nCALL 0x000971df\nMOV RDI,qword ptr [RSP + 0x28]\nADD RSP,0x20\nTEST RDI,RDI\nJZ 0x00097588\nMOV RDX,R12\nMOV RSI,RBX\nCALL qword ptr [RBP + 0x18]\nTEST RAX,RAX\nJNZ 0x00097596\nMOV RDX,R12\nMOV RSI,RBX\nMOV EDI,0x0\nCALL qword ptr [RBP + 0x18]\nMOV RBX,qword ptr [RSP + 0x28]\nXOR RBX,qword ptr FS:[0x28]\nJNZ 0x000975af\nADD RSP,0x30\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x000627e0\n"}, "384": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  TYPE40 [VAR4] ;\n  long in_FS_OFFSET;\n  TYPE64 [VAR6] ;\n  long [VAR5] ;\n  \n  [VAR5] = *(long *)(in_FS_OFFSET + 0x28);\n  if ([VAR3] == 0) {\n    [FUNC4] ([VAR2] ,*(int *)&[VAR1] [1].pVtab);\n    iVar1 = 0;\n  }\n  else if ([VAR3] == 1) {\n    [VAR6] = (TYPE64)0x0;\n    iVar1 = *(int *)((long)&[VAR1] [4].pVtab + 4);\n    if (*(Pgno *)&[VAR1] [1].pVtab == sqlite3PendingByte / iVar1 + 1U) {\n      [FUNC6] ([VAR2] ,iVar1);\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = [FUNC7] ((Pager *)[VAR1] [2].pVtab,*(Pgno *)&[VAR1] [1].pVtab,&[VAR6] ,0);\n      if (iVar1 == 0) {\n        [FUNC2] ([VAR2] ,[VAR6] ->pData,*(int *)((long)&[VAR1] [4].pVtab + 4),\n              (_func_void_void_ptr *)0xffffffffffffffff);\n      }\n      [FUNC5] ([VAR6] );\n    }\n  }\n  else {\n    [FUNC3] ([VAR2] ,[VAR2] ->pOut->db->aDb[*(int *)&[VAR1] [4].pVtab].zDbSName,-1,(_func_void_void_ptr *)0x0);\n    iVar1 = 0;\n  }\n  if ([VAR5] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n  [FUNC8] ();\n}", "answer": {"VAR1": "pCursor", "VAR2": "ctx", "VAR3": "i", "VAR4": "pCsr", "VAR5": "local_20", "VAR6": "pDbPage", "FUNC2": "sqlite3_result_blob", "FUNC3": "sqlite3_result_text", "FUNC1": "dbpageColumn", "FUNC6": "sqlite3_result_zeroblob", "TYPE3": "int", "FUNC7": "sqlite3PagerGet", "TYPE2": "sqlite3_context *", "FUNC4": "sqlite3_result_int", "TYPE5": "undefined8", "FUNC5": "sqlite3PagerUnref", "TYPE4": "DbpageCursor *", "TYPE6": "DbPage *", "FUNC8": "__stack_chk_fail", "TYPE1": "sqlite3_vtab_cursor *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x10\nMOV RBP,RDI\nMOV R12,RSI\nMOV EBX,EDX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nTEST EDX,EDX\nJZ 0x0006e65c\nCMP EDX,0x1\nJZ 0x0006e682\nMOV RAX,qword ptr [RSI]\nMOV RDX,qword ptr [RAX + 0x18]\nMOVSXD RAX,dword ptr [RDI + 0x20]\nSHL RAX,0x5\nADD RAX,qword ptr [RDX + 0x20]\nMOV ECX,0x0\nMOV EDX,0xffffffff\nMOV RSI,qword ptr [RAX]\nMOV RDI,R12\nCALL 0x0006e349\nMOV EBX,0x0\nJMP 0x0006e667\nMOV ESI,dword ptr [RDI + 0x8]\nMOV RDI,R12\nCALL 0x0004dae6\nMOV EAX,EBX\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0006e6ef\nADD RSP,0x10\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV qword ptr [RSP],0x0\nMOV ESI,dword ptr [RDI + 0x8]\nMOV ECX,dword ptr [RDI + 0x24]\nMOV EAX,dword ptr [0x0033a980]\nCDQ\nIDIV ECX\nADD EAX,0x1\nCMP ESI,EAX\nJZ 0x0006e6c2\nMOV RDX,RSP\nMOV RDI,qword ptr [RDI + 0x10]\nMOV ECX,0x0\nCALL 0x0003ca35\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x0006e6d3\nMOV RDI,qword ptr [RSP]\nCALL 0x0003ca92\nJMP 0x0006e667\nMOV ESI,ECX\nMOV RDI,R12\nCALL 0x0005bc45\nMOV EBX,0x0\nJMP 0x0006e667\nMOV EDX,dword ptr [RBP + 0x24]\nMOV RAX,qword ptr [RSP]\nMOV RSI,qword ptr [RAX + 0x8]\nMOV RCX,-0x1\nMOV RDI,R12\nCALL 0x0006e238\nJMP 0x0006e6b7\nCALL 0x0000fbd0\n"}, "385": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC3] ();\n  if (([VAR4] < 0x40) || (iVar1 == 0)) {\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = [FUNC2] ([VAR2] ,(SHA512_CTX *)[VAR1] );\n    if (iVar1 != 0) {\n      *[VAR3] = 0x40;\n      iVar1 = 1;\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "out", "VAR3": "outl", "VAR4": "outsz", "FUNC2": "SHA512_Final", "FUNC3": "ossl_prov_is_running", "FUNC1": "sha512_internal_final", "TYPE3": "size_t *", "TYPE2": "uchar *", "TYPE4": "size_t", "TYPE1": "void *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R12,RDI\nMOV RBP,RSI\nMOV R13,RDX\nMOV RBX,RCX\nCALL 0x000d9802\nCMP RBX,0x3f\nJBE 0x000eec8f\nTEST EAX,EAX\nJNZ 0x000eec9f\nMOV EAX,0x0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV RSI,R12\nMOV RDI,RBP\nCALL 0x00205f18\nTEST EAX,EAX\nJZ 0x000eec94\nMOV qword ptr [R13],0x40\nMOV EAX,0x1\nJMP 0x000eec94\n"}, "386": {"funcbody": "_Bool [FUNC1] ([TYPE1] [VAR1] )\n{\n  undefined uVar1;\n  \n  uVar1 = 0;\n  if ([VAR1] != ([TYPE1] )0x0) {\n    uVar1 = [VAR1] ->_notimeout;\n  }\n  return (_Bool)uVar1;\n}", "answer": {"VAR1": "z", "FUNC1": "is_notimeout", "TYPE1": "WINDOW *"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x00023be5\nMOVZX EAX,byte ptr [RDI + 0x18]\nRET\n"}, "387": {"funcbody": "int [FUNC1] (TYPE14 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  ECX_KEY *key;\n  TYPE59 [VAR5] ;\n  void *pvVar2;\n  [TYPE6] [VAR6] ;\n  size_t siz;\n  \n  if ([VAR2] == 9) {\n    key = [FUNC3] ((X509_ALGOR *)0x0,(uchar *)[VAR4] ,(int)[VAR3] ,[VAR1] ->ameth->pkey_id,KEY_OP_PUBLIC,\n                (OSSL_LIB_CTX *)0x0,(char *)0x0);\n    iVar1 = 0;\n    if (key != (ECX_KEY *)0x0) {\n      [FUNC2] ((EVP_PKEY *)[VAR1] ,[VAR1] ->ameth->pkey_id,key);\n      iVar1 = 1;\n    }\n  }\n  else if ([VAR2] == 10) {\n    iVar1 = 0;\n    if (([VAR1] ->pkey).rsa != (rsa_st *)0x0) {\n      iVar1 = [VAR1] ->ameth->pkey_id;\n      if ((iVar1 == 0x40a) || (iVar1 == 0x43f)) {\n        siz = 0x20;\n      }\n      else {\n        siz = (ulong)(iVar1 != 0x40b) + 0x38;\n      }\n      pvVar2 = [FUNC4] ((void *)((long)&(([VAR1] ->pkey).rsa)->version + 1),siz,\"crypto/ec/ecx_meth.c\",\n                     0xeb);\n      *(void **)[VAR4] = pvVar2;\n      iVar1 = 0;\n      if (pvVar2 != (void *)0x0) {\n        iVar1 = [VAR1] ->ameth->pkey_id;\n        if ((iVar1 == 0x40a) || (iVar1 == 0x43f)) {\n          iVar1 = 0x20;\n        }\n        else {\n          iVar1 = (iVar1 != 0x40b) + 0x38;\n        }\n      }\n    }\n  }\n  else {\n    iVar1 = -2;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "pkey", "VAR2": "op", "VAR3": "arg1", "VAR4": "arg2", "VAR5": "ecx", "VAR6": "ppt", "FUNC2": "EVP_PKEY_assign", "FUNC3": "ossl_ecx_key_op", "FUNC1": "ecx_ctrl", "TYPE3": "long", "TYPE2": "int", "FUNC4": "CRYPTO_memdup", "TYPE5": "ECX_KEY *", "TYPE4": "void *", "TYPE6": "uchar * *", "TYPE1": "EVP_PKEY *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RCX\nCMP ESI,0x9\nJZ 0x00172c7a\nCMP ESI,0xa\nJZ 0x00172cc5\nMOV EAX,0xfffffffe\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RAX,qword ptr [RDI + 0x8]\nSUB RSP,0x8\nPUSH 0x0\nMOV R9D,0x0\nMOV R8D,0x0\nMOV ECX,dword ptr [RAX]\nMOV RSI,RBP\nMOV EDI,0x0\nCALL 0x00171fb1\nMOV RDX,RAX\nADD RSP,0x10\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x00172c73\nMOV RAX,qword ptr [RBX + 0x8]\nMOV ESI,dword ptr [RAX]\nMOV RDI,RBX\nCALL 0x0008dcd0\nMOV EAX,0x1\nJMP 0x00172c73\nMOV RDI,qword ptr [RDI + 0x20]\nMOV EAX,0x0\nTEST RDI,RDI\nJZ 0x00172c73\nMOV RAX,qword ptr [RBX + 0x8]\nMOV EAX,dword ptr [RAX]\nCMP EAX,0x40a\nJZ 0x00172d49\nCMP EAX,0x43f\nJZ 0x00172d49\nCMP EAX,0x40b\nSETNZ SIL\nMOVZX ESI,SIL\nADD RSI,0x38\nADD RDI,0x11\nMOV ECX,0xeb\nLEA RDX,[0x290301]\nCALL 0x0009ab8b\nMOV RDX,RAX\nMOV qword ptr [RBP],RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x00172c73\nMOV RAX,qword ptr [RBX + 0x8]\nMOV EAX,dword ptr [RAX]\nCMP EAX,0x40a\nJZ 0x00172d50\nCMP EAX,0x43f\nJZ 0x00172d50\nCMP EAX,0x40b\nSETNZ AL\nMOVZX EAX,AL\nADD EAX,0x38\nJMP 0x00172c73\nMOV ESI,0x20\nJMP 0x00172cf8\nMOV EAX,0x20\nJMP 0x00172c73\n"}, "388": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  X509_LOOKUP_METHOD *m;\n  X509_LOOKUP *ctx;\n  [TYPE2] [VAR2] ;\n  \n  m = [FUNC2] ();\n  ctx = (X509_LOOKUP *)[FUNC4] ((X509_STORE *)[VAR1] ->cert_store,m);\n  if (ctx != (X509_LOOKUP *)0x0) {\n    [FUNC3] ();\n    [FUNC5] (ctx,1,(char *)0x0,3,(char **)0x0,[VAR1] ->libctx,[VAR1] ->propq);\n    [FUNC6] ();\n  }\n  return (int)(ctx != (X509_LOOKUP *)0x0);\n}", "answer": {"VAR1": "ctx", "VAR2": "lookup", "FUNC2": "X509_LOOKUP_file", "FUNC3": "ERR_set_mark", "FUNC1": "SSL_CTX_set_default_verify_file", "FUNC6": "ERR_pop_to_mark", "TYPE2": "X509_LOOKUP *", "FUNC4": "X509_STORE_add_lookup", "FUNC5": "X509_LOOKUP_ctrl_ex", "TYPE1": "SSL_CTX *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nCALL 0x00166505\nMOV RDI,qword ptr [RBX + 0x28]\nMOV RSI,RAX\nCALL 0x001758cb\nMOV RBP,RAX\nMOV EAX,0x0\nTEST RBP,RBP\nJZ 0x0007b81d\nCALL 0x0010b7cf\nSUB RSP,0x8\nPUSH qword ptr [RBX + 0x440]\nMOV R9,qword ptr [RBX]\nMOV R8D,0x0\nMOV ECX,0x3\nMOV EDX,0x0\nMOV ESI,0x1\nMOV RDI,RBP\nCALL 0x00175471\nCALL 0x0010b805\nADD RSP,0x10\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "389": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  void *vctx;\n  TYPE25 [VAR2] ;\n  PROV_CIPHER_HW *hw;\n  \n  iVar1 = [FUNC4] ();\n  if (iVar1 == 0) {\n    vctx = (void *)0x0;\n  }\n  else {\n    vctx = [FUNC2] (0x1d8,\"providers/implementations/ciphers/cipher_aria.c\",0x36);\n    if (vctx != (void *)0x0) {\n      hw = [FUNC3] (0xc0);\n      [FUNC5] (vctx,0xc0,0x80,0x80,2,0,hw,[VAR1] );\n    }\n  }\n  return vctx;\n}", "answer": {"VAR1": "provctx", "VAR2": "ctx", "FUNC2": "CRYPTO_zalloc", "FUNC3": "ossl_prov_cipher_hw_aria_cbc", "FUNC1": "aria_192_cbc_newctx", "TYPE2": "PROV_ARIA_CTX *", "FUNC4": "ossl_prov_is_running", "FUNC5": "ossl_cipher_generic_initkey", "TYPE1": "void *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nCALL 0x000f2d2a\nTEST EAX,EAX\nJZ 0x000fe0d9\nMOV EDX,0x36\nLEA RSI,[0x27d090]\nMOV EDI,0x1d8\nCALL 0x000bd016\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x000fe0cf\nMOV EDI,0xc0\nCALL 0x000febf1\nPUSH RBP\nPUSH RAX\nMOV R9D,0x0\nMOV R8D,0x2\nMOV ECX,0x80\nMOV EDX,0x80\nMOV ESI,0xc0\nMOV RDI,RBX\nCALL 0x0013686c\nADD RSP,0x10\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV EBX,0x0\nJMP 0x000fe0cf\n"}, "390": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] )\n{\n  long lVar1;\n  int *piVar2;\n  \n  if ([VAR1] == 0x2d3) {\n    lVar1 = 0;\n  }\n  else {\n    piVar2 = &nist_curves[1].nid;\n    lVar1 = 1;\n    while (*piVar2 != [VAR1] ) {\n      lVar1 = lVar1 + 1;\n      piVar2 = piVar2 + 4;\n      if (lVar1 == 0xf) {\n        return (char *)0x0;\n      }\n    }\n  }\n  return nist_curves[lVar1].name;\n}", "answer": {"VAR1": "nid", "FUNC1": "ossl_ec_curve_nid2nist_int", "TYPE1": "int"}, "assembly": "CMP EDI,0x2d3\nJZ 0x000b73bd\nLEA RDX,[0x5328d8]\nMOV EAX,0x1\nCMP dword ptr [RDX],EDI\nJZ 0x000b73c2\nADD RAX,0x1\nADD RDX,0x10\nCMP RAX,0xf\nJNZ 0x000b73a5\nMOV EAX,0x0\nRET\nMOV EAX,0x0\nSHL RAX,0x4\nLEA RDX,[0x5328c0]\nMOV RAX,qword ptr [RDX + RAX*0x1]\nRET\n"}, "391": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  int iVar1;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  TYPE78 [VAR7] ;\n  long in_FS_OFFSET;\n  [TYPE11] [VAR11] ;\n  long [VAR10] ;\n  \n  [VAR10] = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = [FUNC3] (*(EC_KEY **)((long)[VAR1] + 0x10));\n  if ([VAR2] == ([TYPE2] )0x0) {\n    *[VAR3] = (long)iVar1;\n    [VAR9] = 1;\n  }\n  else {\n    [VAR9] = 0;\n    if (((ulong)(long)iVar1 <= [VAR4] ) &&\n       ((*([TYPE6] *)((long)[VAR1] + 0x170) == [VAR6] ||\n        (*([TYPE6] *)((long)[VAR1] + 0x170) == 0)))) {\n      iVar1 = [FUNC2] ([VAR5] ,(int)[VAR6] ,[VAR2] ,&[VAR11] ,*(EC_KEY **)((long)[VAR1] + 0x10));\n      [VAR9] = 0;\n      if (0 < iVar1) {\n        *[VAR3] = (ulong)[VAR11] ;\n        [VAR9] = 1;\n      }\n    }\n  }\n  if ([VAR10] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return [VAR9] ;\n  }\n  [FUNC4] ();\n}", "answer": {"VAR1": "vpsm2ctx", "VAR2": "sig", "VAR3": "siglen", "VAR4": "sigsize", "VAR5": "tbs", "VAR6": "tbslen", "FUNC2": "ossl_sm2_internal_sign", "FUNC3": "ECDSA_size", "FUNC1": "sm2sig_sign", "TYPE3": "size_t *", "TYPE2": "uchar *", "FUNC4": "__stack_chk_fail", "TYPE5": "uchar *", "TYPE4": "size_t", "TYPE7": "PROV_SM2_CTX.conflict *", "TYPE6": "size_t", "TYPE9": "int", "TYPE8": "size_t", "VAR7": "ctx", "TYPE11": "uint", "VAR8": "ecsize", "VAR9": "ret", "TYPE10": "undefined8", "VAR10": "local_40", "VAR11": "sltmp", "TYPE1": "void *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBX,RDI\nMOV RBP,RSI\nMOV R14,RDX\nMOV R12,RCX\nMOV R15,R8\nMOV R13,R9\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV RDI,qword ptr [RDI + 0x10]\nCALL 0x0008a89f\nMOVSXD RDX,EAX\nTEST RBP,RBP\nJZ 0x00132227\nMOV EAX,0x0\nCMP RDX,R12\nJA 0x0013222f\nMOV RDX,qword ptr [RBX + 0x170]\nCMP RDX,R13\nJZ 0x001321f7\nTEST RDX,RDX\nJNZ 0x0013222f\nLEA RCX,[RSP + 0x4]\nMOV R8,qword ptr [RBX + 0x10]\nMOV RDX,RBP\nMOV ESI,R13D\nMOV RDI,R15\nCALL 0x002222e4\nMOV EDX,EAX\nMOV EAX,0x0\nTEST EDX,EDX\nJLE 0x0013222f\nMOV EAX,dword ptr [RSP + 0x4]\nMOV qword ptr [R14],RAX\nMOV EAX,0x1\nJMP 0x0013222f\nMOV qword ptr [R14],RDX\nMOV EAX,0x1\nMOV RSI,qword ptr [RSP + 0x8]\nXOR RSI,qword ptr FS:[0x28]\nJNZ 0x0013224e\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nCALL 0x000627c0\n"}, "392": {"funcbody": "int [FUNC1] (TYPE12 [VAR1] )\n{\n  ulong uVar1;\n  undefined8 *puVar2;\n  \n  [VAR1] ->Nl = 0;\n  [VAR1] ->Nh = 0;\n  *(undefined8 *)([VAR1] ->data + 0xf) = 0;\n  puVar2 = (undefined8 *)((ulong)[VAR1] ->data & 0xfffffffffffffff8);\n  uVar1 = (ulong)(((int)[VAR1] - (int)puVar2) + 0x5cU >> 3);\n  for (; uVar1 != 0; uVar1 = uVar1 - 1) {\n    *puVar2 = 0;\n    puVar2 = puVar2 + 1;\n  }\n  [VAR1] ->A = 0x67452301;\n  [VAR1] ->B = 0xefcdab89;\n  [VAR1] ->C = 0x98badcfe;\n  [VAR1] ->D = 0x10325476;\n  return 1;\n}", "answer": {"VAR1": "c", "FUNC1": "MD5_Init", "TYPE1": "MD5_CTX *"}, "assembly": "MOV RDX,RDI\nMOV qword ptr [RDI + 0x10],0x0\nMOV qword ptr [RDI + 0x54],0x0\nLEA RDI,[RDI + 0x18]\nAND RDI,-0x8\nMOV EAX,EDX\nSUB EAX,EDI\nLEA ECX,[RAX + 0x5c]\nSHR ECX,0x3\nMOV ECX,ECX\nMOV EAX,0x0\nSTOSQ.REP RDI\nMOV dword ptr [RDX],0x67452301\nMOV dword ptr [RDX + 0x4],0xefcdab89\nMOV dword ptr [RDX + 0x8],0x98badcfe\nMOV dword ptr [RDX + 0xc],0x10325476\nMOV EAX,0x1\nRET\n"}, "393": {"funcbody": "/* DWARF original prototype: DbeInstr * adjustEvent(CallStackP * this, DbeInstr * leafPC, DbeInstr *\n   candPC, Vaddr * eventVA, int abst_type) */\nDbeInstr * __thiscall\nCallStackP::[FUNC1] (CallStackP *this,TYPE11 [VAR1] ,TYPE28 [VAR2] ,\n                 TYPE32 [VAR3] ,[TYPE4] [VAR4] )\n{\n  uint64_t *puVar1;\n  Function *this_00;\n  [TYPE7] [VAR7] ;\n  uint uVar2;\n  ulong uVar3;\n  TYPE63 [VAR6] ;\n  int iVar4;\n  [TYPE8] [VAR8] ;\n  ulong uVar5;\n  target_info_t **pptVar6;\n  ulong uVar7;\n  [TYPE5] [VAR5] ;\n  \n  puVar1 = &this->experiment->dsevents;\n  *puVar1 = *puVar1 + 1;\n  if (([VAR4] - 0x203U & 0xfffffdff) != 0) {\n    this_00 = [VAR1] ->func;\n    uVar3 = (this_00->module->bTargets).count;\n    iVar4 = (int)uVar3;\n    if (iVar4 == 0) {\n      puVar1 = &this->experiment->dsnoxhwcevents;\n      *puVar1 = *puVar1 + 1;\n      if (dbeSession->settings->ignore_no_xhwcprof == false) {\n        if (0xff < *[VAR3] ) {\n          *[VAR3] = 0;\n        }\n        *[VAR3] = *[VAR3] | 0x10;\n        [VAR2] = [VAR1] ;\n      }\n    }\n    else {\n      uVar3 = uVar3 & 0xffffffff;\n      uVar5 = this_00->img_offset + [VAR1] ->addr;\n      pptVar6 = (this_00->module->bTargets).data + (iVar4 + -1);\n      do {\n        uVar2 = (int)uVar3 - 1;\n        uVar3 = (ulong)uVar2;\n        if ((int)uVar2 < 1) {\n          uVar7 = (ulong)(*pptVar6)->offset;\n          if (uVar5 < uVar7) {\n            if (0xff < *[VAR3] ) {\n              *[VAR3] = 0;\n            }\n            *[VAR3] = *[VAR3] | 0x20;\n            return [VAR1] ;\n          }\n          break;\n        }\n        uVar7 = (ulong)(*pptVar6)->offset;\n        pptVar6 = pptVar6 + -1;\n      } while (uVar5 < uVar7);\n      if ([VAR2] ->addr + [VAR2] ->func->img_offset < uVar7) {\n        [VAR2] = Function::[FUNC2] (this_00,2,uVar7 - this_00->img_offset);\n        if (0xff < *[VAR3] ) {\n          *[VAR3] = 0;\n        }\n        *[VAR3] = *[VAR3] | 0x30;\n      }\n    }\n  }\n  return [VAR2] ;\n}", "answer": {"VAR1": "leafPC", "VAR2": "candPC", "VAR3": "eventVA", "VAR4": "abst_type", "VAR5": "func", "VAR6": "bt_entries", "FUNC2": "find_dbeinstr", "FUNC1": "adjustEvent", "TYPE3": "Vaddr *", "TYPE2": "DbeInstr *", "TYPE5": "Function *", "TYPE4": "int", "TYPE7": "int", "TYPE6": "uint", "TYPE8": "uint64_t", "VAR7": "bt_entry", "VAR8": "leafPC_offset", "TYPE1": "DbeInstr *"}, "assembly": "PUSH RBX\nMOV RAX,RDX\nMOV RBX,RCX\nMOV RCX,qword ptr [RDI + 0x8]\nADD qword ptr [RCX + 0xa18],0x1\nSUB R8D,0x203\nTEST R8D,0xfffffdff\nJNZ 0x001479eb\nPOP RBX\nRET\nMOV R10,qword ptr [RSI + 0x40]\nMOV R8,qword ptr [R10 + 0x28]\nMOV RDX,qword ptr [R8 + 0x140]\nTEST EDX,EDX\nJNZ 0x00147a3a\nMOV RDX,qword ptr [RDI + 0x8]\nADD qword ptr [RDX + 0xa20],0x1\nMOV RDX,qword ptr [0x005ce9b8]\nMOV RDX,qword ptr [RDX + 0x150]\nCMP byte ptr [RDX + 0x118],0x0\nJNZ 0x001479e9\nCMP qword ptr [RBX],0xff\nJBE 0x00147a31\nMOV qword ptr [RBX],0x0\nOR qword ptr [RBX],0x10\nMOV RAX,RSI\nJMP 0x001479e9\nMOV ECX,EDX\nMOV R11,qword ptr [R10 + 0x60]\nMOV RDI,R11\nADD RDI,qword ptr [RSI + 0x28]\nSUB EDX,0x1\nMOVSXD RDX,EDX\nMOV R8,qword ptr [R8 + 0x138]\nLEA R8,[R8 + RDX*0x8]\nSUB ECX,0x1\nMOV R9,qword ptr [R8]\nTEST ECX,ECX\nJLE 0x00147aaf\nMOV R9D,dword ptr [R9]\nSUB R8,0x8\nCMP R9,RDI\nJA 0x00147a58\nMOV RCX,qword ptr [RAX + 0x40]\nMOV RDX,qword ptr [RAX + 0x28]\nADD RDX,qword ptr [RCX + 0x60]\nCMP RDX,R9\nJNC 0x001479e9\nMOV RDX,R9\nSUB RDX,R11\nMOV ESI,0x2\nMOV RDI,R10\nCALL 0x000d115a\nCMP qword ptr [RBX],0xff\nJBE 0x00147aa6\nMOV qword ptr [RBX],0x0\nOR qword ptr [RBX],0x30\nJMP 0x001479e9\nMOV R9D,dword ptr [R9]\nCMP R9,RDI\nJBE 0x00147a6e\nCMP qword ptr [RBX],0xff\nJBE 0x00147ac7\nMOV qword ptr [RBX],0x0\nOR qword ptr [RBX],0x20\nMOV RAX,RSI\nJMP 0x001479e9\n"}, "394": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  zend_object *pzVar2;\n  long lVar3;\n  zend_result zVar4;\n  timelib_time_offset *t;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  [TYPE5] [VAR5] ;\n  [TYPE6] [VAR6] ;\n  zval *this_ptr;\n  long in_FS_OFFSET;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  long [VAR7] ;\n  \n  [VAR7] = *(long *)(in_FS_OFFSET + 0x28);\n  this_ptr = (zval *)0x0;\n  if (([VAR1] ->This).u1.v.type == '\\b') {\n    this_ptr = &[VAR1] ->This;\n  }\n  zVar4 = [FUNC3] (([VAR1] ->This).u2.next,this_ptr,\"OO\",&[VAR9] ,date_ce_timezone,&[VAR8] ,date_ce_interface);\n  if (zVar4 != FAILURE) {\n    pzVar2 = ([VAR9] ->value).obj;\n    if (*(char *)&pzVar2[-1].handlers == '\\0') {\n      [FUNC6] (pzVar2->ce);\n    }\n    else {\n      lVar3 = *(long *)&([VAR8] ->value).obj[-1].properties_table[0].u1;\n      if (lVar3 == 0) {\n        [FUNC6] ((([VAR8] ->value).obj)->ce);\n      }\n      else {\n        iVar1 = *(int *)((long)&pzVar2[-1].handlers + 4);\n        if (iVar1 == 2) {\n          ([VAR2] ->value).counted =\n               (zend_refcounted *)\n               ((long)&((pzVar2[-1].properties)->gc).refcount +\n               (long)(int)(pzVar2[-1].properties_table[0].u1.type_info * 0xe10));\n          ([VAR2] ->u1).type_info = 4;\n        }\n        else if (iVar1 == 3) {\n          t = [FUNC2] (*(timelib_sll *)(lVar3 + 0xc0),(timelib_tzinfo *)pzVar2[-1].properties);\n          [VAR2] ->value = (zend_value)(long)t->offset;\n          ([VAR2] ->u1).type_info = 4;\n          [FUNC5] (t);\n        }\n        else if (iVar1 == 1) {\n          [VAR2] ->value = (zend_value)pzVar2[-1].properties;\n          ([VAR2] ->u1).type_info = 4;\n        }\n      }\n    }\n  }\n  if ([VAR7] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC4] ();\n}", "answer": {"VAR1": "execute_data", "VAR2": "return_value", "VAR3": "__z_1", "VAR4": "offset", "VAR5": "__z", "VAR6": "__z_2", "FUNC2": "timelib_get_time_zone_info", "FUNC3": "zend_parse_method_parameters", "FUNC1": "zif_timezone_offset_get", "FUNC6": "date_throw_uninitialized_error", "TYPE3": "zval *", "TYPE2": "zval *", "FUNC4": "__stack_chk_fail", "TYPE5": "zval *", "FUNC5": "timelib_time_offset_dtor", "TYPE4": "timelib_time_offset *", "TYPE7": "undefined8", "TYPE6": "zval *", "TYPE9": "zval *", "TYPE8": "zval *", "VAR7": "local_10", "VAR8": "dateobject", "VAR9": "object", "TYPE1": "zend_execute_data *"}, "assembly": "PUSH RBX\nSUB RSP,0x20\nMOV RBX,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV RAX,qword ptr [0x01202148]\nMOV R8,qword ptr [0x01202168]\nMOV ESI,0x0\nCMP byte ptr [RDI + 0x28],0x8\nJZ 0x000fa27c\nLEA RCX,[RSP + 0x8]\nMOV EDI,dword ptr [RDI + 0x2c]\nSUB RSP,0x8\nPUSH RAX\nLEA R9,[RSP + 0x20]\nLEA RDX,[0x4a043c]\nMOV EAX,0x0\nCALL 0x003b3537\nADD RSP,0x10\nCMP EAX,-0x1\nJZ 0x000fa28b\nMOV RAX,qword ptr [RSP + 0x8]\nMOV RAX,qword ptr [RAX]\nCMP byte ptr [RAX + -0x20],0x0\nJZ 0x000fa282\nMOV RDX,qword ptr [RSP + 0x10]\nMOV RDX,qword ptr [RDX]\nMOV RCX,qword ptr [RDX + -0x8]\nTEST RCX,RCX\nJZ 0x000fa2a1\nMOV EDX,dword ptr [RAX + -0x1c]\nCMP EDX,0x2\nJZ 0x000fa2d3\nCMP EDX,0x3\nJZ 0x000fa2ac\nCMP EDX,0x1\nJNZ 0x000fa28b\nMOV RAX,qword ptr [RAX + -0x18]\nMOV qword ptr [RBX],RAX\nMOV dword ptr [RBX + 0x8],0x4\nJMP 0x000fa28b\nLEA RSI,[RDI + 0x20]\nJMP 0x000fa20f\nMOV RDI,qword ptr [RAX + 0x10]\nCALL 0x000f685b\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x000fa2ed\nADD RSP,0x20\nPOP RBX\nRET\nMOV RDI,qword ptr [RDX + 0x10]\nCALL 0x000f685b\nJMP 0x000fa28b\nMOV RSI,qword ptr [RAX + -0x18]\nMOV RDI,qword ptr [RCX + 0xc0]\nCALL 0x0012b0ab\nMOVSXD RDX,dword ptr [RAX]\nMOV qword ptr [RBX],RDX\nMOV dword ptr [RBX + 0x8],0x4\nMOV RDI,RAX\nCALL 0x0012c13f\nJMP 0x000fa28b\nIMUL EDX,dword ptr [RAX + -0x8],0xe10\nMOVSXD RDX,EDX\nADD RDX,qword ptr [RAX + -0x18]\nMOV qword ptr [RBX],RDX\nMOV dword ptr [RBX + 0x8],0x4\nJMP 0x000fa28b\nCALL 0x000ec720\n"}, "395": {"funcbody": "int [FUNC1] (TYPE15 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] )\n{\n  byte bVar1;\n  RSA_PKEY_CTX *ctx;\n  int iVar2;\n  int iVar3;\n  [TYPE8] [VAR8] ;\n  uint uVar4;\n  RSA *rsa;\n  TYPE73 [VAR7] ;\n  TYPE62 [VAR6] ;\n  long in_FS_OFFSET;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  long [VAR9] ;\n  \n  [VAR9] = *(long *)(in_FS_OFFSET + 0x28);\n  ctx = (RSA_PKEY_CTX *)[VAR1] ->data;\n  rsa = [FUNC9] ([VAR1] ->pkey);\n  if (ctx->md == (EVP_MD *)0x0) {\n    [VAR10] ._0_4_ = [FUNC7] ((int)[VAR5] ,[VAR4] ,[VAR2] ,(RSA *)rsa,ctx->pad_mode);\n  }\n  else if (ctx->pad_mode == 5) {\n    iVar2 = [FUNC13] (ctx,[VAR1] );\n    if (iVar2 == 0) {\n      iVar2 = -1;\n      goto LAB_001564de;\n    }\n    iVar3 = [FUNC7] ((int)[VAR5] ,[VAR4] ,ctx->tbuf,(RSA *)rsa,5);\n    iVar2 = 0;\n    if (iVar3 < 1) goto LAB_001564de;\n    iVar3 = iVar3 + -1;\n    bVar1 = ctx->tbuf[iVar3];\n    iVar2 = [FUNC11] (ctx->md);\n    uVar4 = [FUNC10] (iVar2);\n    if (bVar1 != uVar4) {\n      [FUNC4] ();\n      [FUNC3] (\"crypto/rsa/rsa_pmeth.c\",0xe2,\"pkey_rsa_verifyrecover\");\n      [FUNC2] (4,100,(char *)0x0);\n      iVar2 = 0;\n      goto LAB_001564de;\n    }\n    iVar2 = [FUNC12] (ctx->md);\n    if (iVar2 != iVar3) {\n      [FUNC4] ();\n      [FUNC3] (\"crypto/rsa/rsa_pmeth.c\",0xe6,\"pkey_rsa_verifyrecover\");\n      [FUNC2] (4,0x8f,(char *)0x0);\n      iVar2 = 0;\n      goto LAB_001564de;\n    }\n    [VAR10] ._0_4_ = iVar3;\n    if ([VAR2] != ([TYPE2] )0x0) {\n      [FUNC6] ([VAR2] ,ctx->tbuf,(long)iVar3);\n    }\n  }\n  else {\n    iVar2 = -1;\n    if (ctx->pad_mode != 1) goto LAB_001564de;\n    iVar2 = [FUNC11] (ctx->md);\n    iVar3 = [FUNC5] (iVar2,(uchar *)0x0,0,[VAR2] ,&[VAR10] ,[VAR4] ,[VAR5] ,rsa);\n    iVar2 = 0;\n    if (iVar3 < 1) goto LAB_001564de;\n  }\n  iVar2 = (int)[VAR10] ;\n  if (-1 < (int)[VAR10] ) {\n    *[VAR3] = (long)(int)[VAR10] ;\n    iVar2 = 1;\n  }\nLAB_001564de:\n  if ([VAR9] != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC8] ();\n  }\n  return iVar2;\n}", "answer": {"FUNC12": "EVP_MD_get_size", "FUNC11": "EVP_MD_get_type", "VAR1": "ctx", "FUNC13": "setup_tbuf", "VAR2": "rout", "VAR3": "routlen", "VAR4": "sig", "FUNC10": "RSA_X931_hash_id", "VAR5": "siglen", "VAR6": "rctx", "FUNC2": "ERR_set_error", "FUNC3": "ERR_set_debug", "FUNC1": "pkey_rsa_verifyrecover", "FUNC6": "memcpy", "TYPE3": "size_t *", "FUNC7": "RSA_public_decrypt", "TYPE2": "uchar *", "FUNC4": "ERR_new", "TYPE5": "size_t", "FUNC5": "ossl_rsa_verify", "TYPE4": "uchar *", "TYPE7": "RSA *", "TYPE6": "RSA_PKEY_CTX *", "FUNC8": "__stack_chk_fail", "TYPE9": "undefined8", "FUNC9": "EVP_PKEY_get0_RSA", "TYPE8": "int", "VAR7": "rsa", "TYPE11": "undefined8", "VAR8": "ret", "VAR9": "local_40", "TYPE10": "size_t", "VAR10": "sltmp", "VAR11": "local_50", "TYPE1": "EVP_PKEY_CTX *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV RBX,RDI\nMOV R15,RSI\nMOV qword ptr [RSP + 0x8],RDX\nMOV R13,RCX\nMOV R12,R8\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV RBP,qword ptr [RDI + 0x98]\nMOV RDI,qword ptr [RDI + 0x88]\nCALL 0x00127b4f\nMOV R14,RAX\nMOV RDI,qword ptr [RBP + 0x20]\nTEST RDI,RDI\nJZ 0x00156605\nMOV EAX,dword ptr [RBP + 0x1c]\nCMP EAX,0x5\nJZ 0x00156503\nMOV EBX,0xffffffff\nCMP EAX,0x1\nJNZ 0x001564de\nCALL 0x001200b1\nPUSH R14\nPUSH R12\nMOV R9,R13\nLEA R8,[RSP + 0x20]\nMOV RCX,R15\nMOV EDX,0x0\nMOV ESI,0x0\nMOV EDI,EAX\nCALL 0x00158257\nADD RSP,0x10\nMOV EBX,0x0\nTEST EAX,EAX\nJLE 0x001564de\nMOV EBX,dword ptr [RSP + 0x10]\nTEST EBX,EBX\nJS 0x001564de\nMOVSXD RBX,EBX\nMOV RAX,qword ptr [RSP + 0x8]\nMOV qword ptr [RAX],RBX\nMOV EBX,0x1\nMOV EAX,EBX\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0015662b\nADD RSP,0x28\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV RSI,RBX\nMOV RDI,RBP\nCALL 0x001561d2\nTEST EAX,EAX\nJZ 0x00156621\nMOV RDX,qword ptr [RBP + 0x38]\nMOV R8D,0x5\nMOV RCX,R14\nMOV RSI,R13\nMOV EDI,R12D\nCALL 0x001504bf\nMOV EBX,0x0\nTEST EAX,EAX\nJLE 0x001564de\nLEA EBX,[RAX + -0x1]\nMOVSXD R12,EBX\nMOV RAX,qword ptr [RBP + 0x38]\nMOVZX R13D,byte ptr [RAX + R12*0x1]\nMOV RDI,qword ptr [RBP + 0x20]\nCALL 0x001200b1\nMOV EDI,EAX\nCALL 0x00159fad\nCMP R13D,EAX\nJZ 0x0015659b\nCALL 0x001152cb\nLEA RDX,[0x2f9ec0]\nMOV ESI,0xe2\nLEA RDI,[0x2f9dad]\nCALL 0x001153d8\nMOV EDX,0x0\nMOV ESI,0x64\nMOV EDI,0x4\nMOV EAX,0x0\nCALL 0x001156ef\nMOV EBX,0x0\nJMP 0x001564de\nMOV RDI,qword ptr [RBP + 0x20]\nCALL 0x0012019a\nCMP EAX,EBX\nJNZ 0x001565c5\nTEST R15,R15\nJZ 0x001564ca\nMOV RSI,qword ptr [RBP + 0x38]\nMOV RDX,R12\nMOV RDI,R15\nCALL 0x0006dca0\nJMP 0x001564ca\nCALL 0x001152cb\nLEA RDX,[0x2f9ec0]\nMOV ESI,0xe6\nLEA RDI,[0x2f9dad]\nCALL 0x001153d8\nMOV EDX,0x0\nMOV ESI,0x8f\nMOV EDI,0x4\nMOV EAX,0x0\nCALL 0x001156ef\nMOV EBX,0x0\nJMP 0x001564de\nMOV R8D,dword ptr [RBP + 0x1c]\nMOV RCX,RAX\nMOV RDX,R15\nMOV RSI,R13\nMOV EDI,R12D\nCALL 0x001504bf\nMOV EBX,EAX\nJMP 0x001564ca\nMOV EBX,0xffffffff\nJMP 0x001564de\nCALL 0x0006daa0\n"}, "396": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  byte bVar1;\n  int iVar2;\n  int iVar3;\n  [TYPE5] [VAR5] ;\n  [TYPE7] [VAR7] ;\n  long lVar4;\n  byte bVar5;\n  byte *pbVar6;\n  [TYPE6] [VAR6] ;\n  ulong uVar7;\n  [TYPE8] [VAR8] ;\n  ulong uVar8;\n  int iVar9;\n  ulong uVar10;\n  byte *pbVar11;\n  long in_FS_OFFSET;\n  [TYPE10] [VAR10] ;\n  long [VAR9] ;\n  \n  uVar10 = (ulong)(uint)[VAR2] ;\n  uVar8 = (ulong)(uint)[VAR1] ;\n  uVar7 = (ulong)*[VAR4] ;\n  [VAR9] = *(long *)(in_FS_OFFSET + 0x28);\n  pbVar6 = (byte *)*[VAR3] ;\n  [VAR10] = 0;\n  _[VAR6] = pbVar6 + uVar7;\n  pbVar11 = pbVar6;\n  if (_[VAR6] <= pbVar6) goto LAB_00015f60;\n  do {\n    iVar9 = (int)uVar10;\n    iVar3 = (int)uVar7;\n    bVar1 = *pbVar6;\n    for (bVar5 = bVar1 & 0xfe; bVar5 != 0; bVar5 = bVar5 | bVar1 & 0xfe) {\n      bVar5 = bVar1 & 0x80;\n      pbVar6 = pbVar6 + 1;\n      if (_[VAR6] == pbVar6) {\n        iVar2 = (int)_[VAR6] - (int)pbVar11;\n        pbVar6 = _[VAR6] ;\n        if ((int)uVar8 != [VAR10] ) goto LAB_00015f2c;\n        goto LAB_00015f71;\n      }\n      bVar1 = *pbVar6;\n    }\nLAB_00015f60:\n    do {\n      iVar9 = (int)uVar10;\n      iVar3 = (int)uVar7;\n      iVar2 = (int)pbVar6 - (int)pbVar11;\n      if ((int)uVar8 == [VAR10] ) {\nLAB_00015f71:\n        if (iVar9 != 0) {\nLAB_00015f76:\n          pbVar6 = pbVar11 + iVar2;\n          if (pbVar6 != _[VAR6] ) {\n            [FUNC4] (pbVar6,0,(long)_[VAR6] - (long)pbVar6);\n          }\n        }\nLAB_00015f8e:\n        *[VAR3] = (char *)pbVar11;\n        *[VAR4] = iVar2;\n        if ([VAR9] == *(long *)(in_FS_OFFSET + 0x28)) {\n          return;\n        }\n        [FUNC2] ();\n      }\nLAB_00015f2c:\n      pbVar11 = pbVar6;\n      uVar7 = (ulong)(uint)(iVar3 - iVar2);\n      if (iVar3 - iVar2 == 0) {\n        iVar2 = 0;\n        if ((int)uVar10 == 0) goto LAB_00015f8e;\n        goto LAB_00015f76;\n      }\n      pbVar6 = pbVar11 + 1;\n      if ((char)pbVar11[1] < '\\0') {\n        iVar3 = [FUNC3] ((char *)pbVar6,&[VAR10] );\n        lVar4 = (long)iVar3;\n      }\n      else {\n        lVar4 = 1;\n        [VAR10] = (uint)pbVar11[1];\n      }\n      pbVar6 = pbVar6 + lVar4;\n    } while (_[VAR6] <= pbVar6);\n  } while( true );\n}", "answer": {"VAR1": "iCol", "VAR2": "bZero", "VAR3": "ppList", "VAR4": "pnList", "VAR5": "pList", "VAR6": "nList", "FUNC2": "__stack_chk_fail", "FUNC3": "sqlite3Fts3GetVarint32", "FUNC1": "fts3ColumnFilter", "TYPE3": "char * *", "TYPE2": "int", "FUNC4": "memset", "TYPE5": "char *", "TYPE4": "int *", "TYPE7": "char *", "TYPE6": "int", "TYPE9": "undefined8", "TYPE8": "char *", "VAR7": "p", "VAR8": "pEnd", "VAR9": "local_40", "TYPE10": "int", "VAR10": "iCurrent", "TYPE1": "int"}, "assembly": "PUSH R15\nMOV R11D,ESI\nMOV R10D,EDI\nXOR ESI,ESI\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nMOV RBP,RDX\nPUSH RBX\nMOV RBX,RCX\nSUB RSP,0x18\nMOVSXD R8,dword ptr [RCX]\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV RAX,qword ptr [RDX]\nLEA R12,[RSP + 0x4]\nMOV dword ptr [RSP + 0x4],0x0\nMOV R9,R8\nADD R8,RAX\nMOV R13,RAX\nCMP RAX,R8\nJNC 0x00015f60\nNOP dword ptr [RAX]\nMOVZX EDX,byte ptr [RAX]\nTEST DL,0xfe\nJNZ 0x00015f0d\nJMP 0x00015f60\nMOVZX EDX,byte ptr [RAX]\nOR ECX,EDX\nAND ECX,0xfe\nJZ 0x00015f60\nAND EDX,0xffffff80\nADD RAX,0x1\nMOV ECX,EDX\nCMP R8,RAX\nJNZ 0x00015f00\nMOV R14,R8\nMOV RAX,R14\nSUB RAX,R13\nMOV R15D,EAX\nCMP R10D,ESI\nJZ 0x00015f71\nSUB R9D,EAX\nJZ 0x00015fcb\nMOVZX ESI,byte ptr [R14 + 0x1]\nLEA RCX,[R14 + 0x1]\nTEST SIL,SIL\nJS 0x00015fb8\nMOV dword ptr [RSP + 0x4],ESI\nMOV EAX,0x1\nADD RAX,RCX\nMOV R13,R14\nCMP RAX,R8\nJC 0x00015ef0\nNOP word ptr [RAX + RAX*0x1]\nMOV R14,RAX\nMOV RAX,R14\nSUB RAX,R13\nMOV R15D,EAX\nCMP R10D,ESI\nJNZ 0x00015f2c\nTEST R11D,R11D\nJZ 0x00015f8e\nMOVSXD RDI,R15D\nADD RDI,R13\nCMP RDI,R8\nJZ 0x00015f8e\nMOV RDX,R8\nXOR ESI,ESI\nSUB RDX,RDI\nCALL 0x0000a1a0\nMOV qword ptr [RBP],R13\nMOV dword ptr [RBX],R15D\nMOV RAX,qword ptr [RSP + 0x8]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x00015fd8\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV RSI,R12\nMOV RDI,RCX\nCALL 0x00012db0\nMOV ESI,dword ptr [RSP + 0x4]\nCDQE\nJMP 0x00015f4c\nXOR R15D,R15D\nMOV R13,R14\nTEST R11D,R11D\nJZ 0x00015f8e\nJMP 0x00015f76\nCALL 0x0000a140\n"}, "397": {"funcbody": "void [FUNC2] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  grecs_list_entry *pgVar1;\n  [TYPE5] [VAR5] ;\n  \n  if ([VAR2] == ([TYPE2] )0x0) {\n    [VAR3] ->prev = (grecs_list_entry *)0x0;\n    [VAR3] ->next = [VAR1] ->head;\n    if ([VAR1] ->head == (grecs_list_entry *)0x0) {\n      [VAR1] ->tail = [VAR3] ;\n    }\n    else {\n      [VAR1] ->head->prev = [VAR3] ;\n    }\n    [VAR1] ->head = [VAR3] ;\n    [VAR1] ->count = [VAR1] ->count + 1;\n    return;\n  }\n  if ([VAR4] == 0) {\n    [VAR3] ->prev = [VAR2] ;\n    pgVar1 = [VAR2] ->next;\n    if (pgVar1 == (grecs_list_entry *)0x0) {\n      [VAR1] ->tail = [VAR3] ;\n    }\n    else {\n      pgVar1->prev = [VAR3] ;\n    }\n    [VAR3] ->next = pgVar1;\n    [VAR2] ->next = [VAR3] ;\n    [VAR1] ->count = [VAR1] ->count + 1;\n    return;\n  }\n  [FUNC2] ([VAR1] ,[VAR2] ->prev,[VAR3] ,0);\n  return;\n}", "answer": {"VAR1": "lp", "VAR2": "anchor", "VAR3": "ent", "VAR4": "before", "VAR5": "p", "FUNC2": "FUNC1", "FUNC1": "grecs_list_insert_entry", "TYPE3": "grecs_list_entry *", "TYPE2": "grecs_list_entry *", "TYPE5": "grecs_list_entry *", "TYPE4": "int", "TYPE1": "grecs_list *"}, "assembly": "TEST RSI,RSI\nJZ 0x00012280\nTEST ECX,ECX\nJNZ 0x000122a9\nMOV qword ptr [RDX + 0x8],RSI\nMOV RAX,qword ptr [RSI]\nTEST RAX,RAX\nJZ 0x000122c0\nMOV qword ptr [RAX + 0x8],RDX\nMOV qword ptr [RDX],RAX\nMOV qword ptr [RSI],RDX\nADD qword ptr [RDI + 0x10],0x1\nRET\nMOV qword ptr [RDX + 0x8],0x0\nMOV RAX,qword ptr [RDI]\nMOV qword ptr [RDX],RAX\nMOV RAX,qword ptr [RDI]\nTEST RAX,RAX\nJZ 0x000122a3\nMOV qword ptr [RAX + 0x8],RDX\nMOV qword ptr [RDI],RDX\nADD qword ptr [RDI + 0x10],0x1\nRET\nMOV qword ptr [RDI + 0x8],RDX\nJMP 0x0001229a\nSUB RSP,0x8\nMOV RSI,qword ptr [RSI + 0x8]\nMOV ECX,0x0\nCALL 0x0001225b\nADD RSP,0x8\nRET\nMOV qword ptr [RDI + 0x8],RDX\nJMP 0x00012274\n"}, "398": {"funcbody": "undefined4 [FUNC1] (undefined8 param_1,long param_2)\n{\n  void *__ptr;\n  undefined4 uVar1;\n  \n  uVar1 = 0;\n  if (*(long *)(param_2 + 0x38) != 0) {\n    __ptr = *(void **)(*(long *)(param_2 + 0x38) + 8);\n    if (3 < loglevel) {\n      [FUNC3] (*(undefined8 *)PTR_stderr_0127bff8,1,\"Free object BLOCKMOVEACTION [%d]\\n\",\n            *(undefined4 *)(param_2 + 0x14));\n    }\n    uVar1 = [FUNC5] (param_1,param_1,param_1,param_2);\n    [FUNC6] (param_2);\n    [FUNC2] (param_2);\n    if (__ptr != (void *)0x0) {\n      [FUNC4] (__ptr);\n    }\n    if (*(void **)(param_2 + 0x38) != (void *)0x0) {\n      [FUNC4] (*(void **)(param_2 + 0x38));\n    }\n    *(undefined8 *)(param_2 + 0x38) = 0;\n  }\n  *(undefined8 *)(param_2 + 0x58) = 0;\n  return uVar1;\n}", "answer": {"FUNC2": "dwg_free_eed", "FUNC3": "__fprintf_chk", "FUNC1": "dwg_free_BLOCKMOVEACTION", "FUNC6": "dwg_free_common_object_data", "FUNC4": "free", "FUNC5": "dwg_free_BLOCKMOVEACTION_private"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RSI\nMOV RAX,qword ptr [RSI + 0x38]\nMOV R12D,0x0\nTEST RAX,RAX\nJZ 0x0050506b\nMOV RBP,RDI\nMOV R13,qword ptr [RAX + 0x8]\nCMP dword ptr [0x0127c8d0],0x3\nJA 0x00505081\nMOV RCX,RBX\nMOV RDX,RBP\nMOV RSI,RBP\nMOV RDI,RBP\nCALL 0x004e4967\nMOV R12D,EAX\nMOV RDI,RBX\nCALL 0x004d32c2\nMOV RDI,RBX\nCALL 0x004fff98\nTEST R13,R13\nJZ 0x00505055\nMOV RDI,R13\nCALL 0x0006cd10\nMOV RDI,qword ptr [RBX + 0x38]\nTEST RDI,RDI\nJZ 0x00505063\nCALL 0x0006cd10\nMOV qword ptr [RBX + 0x38],0x0\nMOV qword ptr [RBX + 0x58],0x0\nMOV EAX,R12D\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV ECX,dword ptr [RSI + 0x14]\nLEA RDX,[0xf85118]\nMOV ESI,0x1\nMOV RAX,qword ptr [0x0127bff8]\nMOV RDI,qword ptr [RAX]\nMOV EAX,0x0\nCALL 0x0006d560\nJMP 0x00505024\n"}, "399": {"funcbody": "undefined4 [FUNC1] (long param_1,long param_2,undefined8 *param_3)\n{\n  undefined8 uVar1;\n  \n  *param_3 = 0;\n  param_3[1] = 0;\n  param_3[2] = 0;\n  param_3[3] = 0;\n  param_3[4] = 0;\n  param_3[5] = 0;\n  param_3[6] = 0;\n  (**(code **)(*(long *)(param_1 + 8) + 0xb0))(0,param_3);\n  (**(code **)(*(long *)(param_1 + 8) + 0xb0))(0xffff,(long)param_3 + 2);\n  (**(code **)(*(long *)(param_1 + 8) + 0xb0))(2,(long)param_3 + 4);\n  uVar1 = DAT_007fdff8;\n  *(undefined8 *)((long)param_3 + 0xc) = header_bigobj_classid;\n  *(undefined8 *)((long)param_3 + 0x14) = uVar1;\n  (**(code **)(*(long *)(param_1 + 8) + 0xb0))(*(undefined2 *)(param_2 + 0x90),(long)param_3 + 6);\n  (**(code **)(*(long *)(param_1 + 8) + 0x98))(*(undefined4 *)(param_2 + 0x94),(long)param_3 + 0x2c)\n  ;\n  (**(code **)(*(long *)(param_1 + 8) + 0x98))(*(undefined8 *)(param_2 + 0x98),param_3 + 1);\n  (**(code **)(*(long *)(param_1 + 8) + 0x98))(*(undefined8 *)(param_2 + 0xa0),param_3 + 6);\n  (**(code **)(*(long *)(param_1 + 8) + 0x98))(*(undefined8 *)(param_2 + 0xa8),(long)param_3 + 0x34)\n  ;\n  return *(undefined4 *)(*(long *)(*(long *)(param_1 + 8) + 0x380) + 0x50);\n}", "answer": {"FUNC1": "coff_bigobj_swap_filehdr_out"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBP,RDI\nMOV R12,RSI\nMOV RBX,RDX\nMOV qword ptr [RDX],0x0\nMOV qword ptr [RDX + 0x8],0x0\nMOV qword ptr [RDX + 0x10],0x0\nMOV qword ptr [RDX + 0x18],0x0\nMOV qword ptr [RDX + 0x20],0x0\nMOV qword ptr [RDX + 0x28],0x0\nMOV qword ptr [RDX + 0x30],0x0\nMOV RAX,qword ptr [RDI + 0x8]\nMOV RSI,RDX\nMOV EDI,0x0\nCALL qword ptr [RAX + 0xb0]\nLEA RSI,[RBX + 0x2]\nMOV RAX,qword ptr [RBP + 0x8]\nMOV EDI,0xffff\nCALL qword ptr [RAX + 0xb0]\nLEA RSI,[RBX + 0x4]\nMOV RAX,qword ptr [RBP + 0x8]\nMOV EDI,0x2\nCALL qword ptr [RAX + 0xb0]\nMOV RAX,qword ptr [0x007fdff0]\nMOV RDX,qword ptr [0x007fdff8]\nMOV qword ptr [RBX + 0xc],RAX\nMOV qword ptr [RBX + 0x14],RDX\nLEA RSI,[RBX + 0x6]\nMOVZX EDI,word ptr [R12 + 0x90]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0xb0]\nLEA RSI,[RBX + 0x2c]\nMOV EDI,dword ptr [R12 + 0x94]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x8]\nMOV RDI,qword ptr [R12 + 0x98]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x30]\nMOV RDI,qword ptr [R12 + 0xa0]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nLEA RSI,[RBX + 0x34]\nMOV RDI,qword ptr [R12 + 0xa8]\nMOV RAX,qword ptr [RBP + 0x8]\nCALL qword ptr [RAX + 0x98]\nMOV RAX,qword ptr [RBP + 0x8]\nMOV RAX,qword ptr [RAX + 0x380]\nMOV EAX,dword ptr [RAX + 0x50]\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "400": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  ASN1_INTEGER *izone;\n  TYPE58 [VAR5] ;\n  \n  izone = [FUNC5] ((X509V3_EXT_METHOD *)0x0,[VAR2] );\n  if (izone == (ASN1_INTEGER *)0x0) {\n    [FUNC2] ();\n    [FUNC4] (\"crypto/x509/v3_sxnet.c\",0x7b,\"SXNET_add_id_asc\");\n    [FUNC6] (0x22,0x83,(char *)0x0);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = [FUNC3] ([VAR1] ,izone,[VAR3] ,[VAR4] );\n  }\n  return iVar1;\n}", "answer": {"VAR1": "psx", "VAR2": "zone", "VAR3": "user", "VAR4": "userlen", "VAR5": "izone", "FUNC2": "ERR_new", "FUNC3": "SXNET_add_id_INTEGER", "FUNC1": "SXNET_add_id_asc", "FUNC6": "ERR_set_error", "TYPE3": "char *", "TYPE2": "char *", "FUNC4": "ERR_set_debug", "TYPE5": "ASN1_INTEGER *", "FUNC5": "s2i_ASN1_INTEGER", "TYPE4": "int", "TYPE1": "SXNET * *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV RBP,RDX\nMOV R12D,ECX\nMOV EDI,0x0\nCALL 0x002026b5\nTEST RAX,RAX\nJZ 0x00200de1\nMOV ECX,R12D\nMOV RDX,RBP\nMOV RSI,RAX\nMOV RDI,RBX\nCALL 0x00200b68\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x00080b6e\nLEA RDX,[0x29a630]\nMOV ESI,0x7b\nLEA RDI,[0x29a57b]\nCALL 0x00080c7b\nMOV EDX,0x0\nMOV ESI,0x83\nMOV EDI,0x22\nMOV EAX,0x0\nCALL 0x00080f92\nMOV EAX,0x0\nJMP 0x00200ddc\n"}, "401": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  \n  iVar1 = [FUNC2] ([VAR1] ,[VAR2] ,[VAR4] );\n  if (iVar1 != 0) {\n    iVar1 = [FUNC3] ((BIGNUM *)0x0,[VAR1] ,[VAR1] ,[VAR3] ,[VAR4] );\n  }\n  return iVar1;\n}", "answer": {"VAR1": "r", "VAR2": "a", "VAR3": "m", "VAR4": "ctx", "FUNC2": "BN_sqr", "FUNC3": "BN_div", "FUNC1": "BN_mod_sqr", "TYPE3": "BIGNUM *", "TYPE2": "BIGNUM *", "TYPE4": "BN_CTX *", "TYPE1": "BIGNUM *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV R12,RDX\nMOV RBP,RCX\nMOV RDX,RCX\nCALL 0x0007ecc0\nTEST EAX,EAX\nJNZ 0x00159420\nPOP RBX\nPOP RBP\nPOP R12\nRET\nMOV R8,RBP\nMOV RCX,R12\nMOV RDX,RBX\nMOV RSI,RBX\nMOV EDI,0x0\nCALL 0x001547c7\nJMP 0x0015941b\n"}, "402": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  \n  if (stdscr == (WINDOW *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    if ([VAR1] != ([TYPE1] )0x0) {\n      *[VAR1] = stdscr->_attrs;\n    }\n    iVar1 = 0;\n    if ([VAR2] != ([TYPE2] )0x0) {\n      *[VAR2] = (ushort)*(byte *)((long)&stdscr->_attrs + 1);\n      return 0;\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "a1", "VAR2": "a2", "VAR3": "z", "FUNC1": "attr_get", "TYPE3": "void *", "TYPE2": "short *", "TYPE1": "attr_t *"}, "assembly": "MOV RAX,qword ptr [0x0023c950]\nTEST RAX,RAX\nJZ 0x00022d9c\nTEST RDI,RDI\nJZ 0x00022d7e\nMOV EAX,dword ptr [RAX + 0x10]\nMOV dword ptr [RDI],EAX\nMOV EAX,0x0\nTEST RSI,RSI\nJZ 0x00022da1\nMOV RAX,qword ptr [0x0023c950]\nMOVZX EAX,byte ptr [RAX + 0x11]\nMOV word ptr [RSI],AX\nMOV EAX,0x0\nRET\nMOV EAX,0xffffffff\nRET\n"}, "403": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  ulong data_plus_mac_plus_padding_size;\n  size_t mac_secret_length;\n  uchar *mac_secret;\n  int iVar1;\n  EVP_MD *md;\n  TYPE42 [VAR4] ;\n  \n  data_plus_mac_plus_padding_size = *(ulong *)((long)[VAR1] + 0x38);\n  if (data_plus_mac_plus_padding_size == 0) {\n    iVar1 = [FUNC2] (*(HMAC_CTX **)((long)[VAR1] + 8),[VAR2] ,[VAR3] );\n  }\n  else if (*(int *)((long)[VAR1] + 0x50) == 0) {\n    iVar1 = 0;\n    if ([VAR3] == 0xd) {\n      *(undefined8 *)((long)[VAR1] + 0x40) = *(undefined8 *)[VAR2] ;\n      *(undefined4 *)((long)[VAR1] + 0x48) = *(undefined4 *)([VAR2] + 8);\n      *(uchar *)((long)[VAR1] + 0x4c) = [VAR2] [0xc];\n      *(undefined4 *)((long)[VAR1] + 0x50) = 1;\n      iVar1 = 1;\n    }\n  }\n  else {\n    iVar1 = 0;\n    if ([VAR3] <= data_plus_mac_plus_padding_size) {\n      mac_secret_length = *(size_t *)((long)[VAR1] + 0x30);\n      mac_secret = *(uchar **)((long)[VAR1] + 0x28);\n      md = [FUNC4] ((PROV_DIGEST *)((long)[VAR1] + 0x10));\n      iVar1 = [FUNC3] (md,(uchar *)((long)[VAR1] + 0x54),(size_t *)((long)[VAR1] + 0x98),\n                    (uchar *)((long)[VAR1] + 0x40),[VAR2] ,[VAR3] ,data_plus_mac_plus_padding_size,\n                    mac_secret,mac_secret_length,'\\0');\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "vmacctx", "VAR2": "data", "VAR3": "datalen", "VAR4": "macctx", "FUNC2": "HMAC_Update", "FUNC3": "ssl3_cbc_digest_record", "FUNC1": "hmac_update", "TYPE3": "size_t", "TYPE2": "uchar *", "FUNC4": "ossl_prov_digest_md", "TYPE4": "hmac_data_st *", "TYPE1": "void *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV R13,RSI\nMOV R12,RDX\nMOV RBP,qword ptr [RDI + 0x38]\nTEST RBP,RBP\nJZ 0x001007d0\nMOV EAX,dword ptr [RDI + 0x50]\nTEST EAX,EAX\nJNZ 0x0010078b\nCMP RDX,0xd\nJNZ 0x001007d9\nMOV RDX,qword ptr [RSI]\nMOV qword ptr [RDI + 0x40],RDX\nMOV EDX,dword ptr [RSI + 0x8]\nMOV dword ptr [RDI + 0x48],EDX\nMOVZX EDX,byte ptr [RSI + 0xc]\nMOV byte ptr [RDI + 0x4c],DL\nMOV dword ptr [RDI + 0x50],0x1\nMOV EAX,0x1\nJMP 0x001007d9\nMOV EAX,0x0\nCMP RBP,RDX\nJC 0x001007d9\nMOV R15,qword ptr [RDI + 0x30]\nMOV R14,qword ptr [RDI + 0x28]\nLEA RDI,[RDI + 0x10]\nCALL 0x000cc580\nLEA RCX,[RBX + 0x40]\nLEA RDX,[RBX + 0x98]\nLEA RSI,[RBX + 0x54]\nPUSH 0x0\nPUSH R15\nPUSH R14\nPUSH RBP\nMOV R9,R12\nMOV R8,R13\nMOV RDI,RAX\nCALL 0x0010c7c1\nADD RSP,0x20\nJMP 0x001007d9\nMOV RDI,qword ptr [RDI + 0x8]\nCALL 0x001a41e8\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "404": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  ref *op;\n  ulong uVar1;\n  v vVar2;\n  int iVar3;\n  ref *prVar4;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  \n  op = ([VAR1] ->op_stack).stack.p;\n  if (*(char *)((long)&(op->tas).type_attrs + 1) == '\\v') {\n    uVar1 = (op->value).saveid;\n    if (uVar1 < (ulong)((long)op - (long)([VAR1] ->op_stack).stack.bot >> 4)) {\n      vVar2 = op[(int)~(uint)uVar1].value;\n      op->tas = op[(int)~(uint)uVar1].tas;\n      op->value = vVar2;\n      iVar3 = 0;\n    }\n    else if ((long)uVar1 < 0) {\n      iVar3 = -0xf;\n    }\n    else {\n      prVar4 = [FUNC2] (&([VAR1] ->op_stack).stack,uVar1 + 1);\n      if (prVar4 == (ref *)0x0) {\n        iVar3 = -0x11;\n      }\n      else {\n        vVar2 = prVar4->value;\n        op->tas = prVar4->tas;\n        op->value = vVar2;\n        iVar3 = 0;\n      }\n    }\n  }\n  else {\n    iVar3 = [FUNC3] (op);\n  }\n  return iVar3;\n}", "answer": {"VAR1": "i_ctx_p", "VAR2": "op", "VAR3": "elt", "FUNC2": "ref_stack_index", "FUNC3": "check_type_failed", "FUNC1": "zindex", "TYPE3": "ref *", "TYPE2": "os_ptr", "TYPE1": "i_ctx_t *"}, "assembly": "PUSH RBX\nMOV RBX,qword ptr [RDI + 0x270]\nCMP byte ptr [RBX + 0x1],0xb\nJNZ 0x0017af83\nMOV RSI,qword ptr [RBX + 0x8]\nMOV RAX,RBX\nSUB RAX,qword ptr [RDI + 0x278]\nSAR RAX,0x4\nCMP RSI,RAX\nJC 0x0017af8d\nTEST RSI,RSI\nJS 0x0017afad\nADD RSI,0x1\nADD RDI,0x270\nCALL 0x00169023\nTEST RAX,RAX\nJZ 0x0017afb4\nMOV RDX,qword ptr [RAX + 0x8]\nMOV RAX,qword ptr [RAX]\nMOV qword ptr [RBX],RAX\nMOV qword ptr [RBX + 0x8],RDX\nMOV EAX,0x0\nJMP 0x0017af8b\nMOV RDI,RBX\nCALL 0x0016af47\nPOP RBX\nRET\nNOT ESI\nMOVSXD RSI,ESI\nSHL RSI,0x4\nMOV RAX,qword ptr [RBX + RSI*0x1]\nMOV RDX,qword ptr [RBX + RSI*0x1 + 0x8]\nMOV qword ptr [RBX],RAX\nMOV qword ptr [RBX + 0x8],RDX\nMOV EAX,0x0\nJMP 0x0017af8b\nMOV EAX,0xfffffff1\nJMP 0x0017af8b\nMOV EAX,0xffffffef\nJMP 0x0017af8b\n"}, "405": {"funcbody": "SWI_CONTROL_SCRIPT * [FUNC1] (void)\n{\n  SWI_CONTROL_SCRIPT *p;\n  TYPE10 [VAR1] ;\n  \n  p = (SWI_CONTROL_SCRIPT *)[FUNC3] (0x68);\n  [FUNC2] (p,\"swi_afile.c\",0xd5);\n  [FUNC4] (p,0x44,(SWHEADER *)0x0,(SWPATH_EX *)0x0);\n  swi_control_script_create::id = swi_control_script_create::id + 1;\n  p->sidM = swi_control_script_create::id;\n  p->afileM = (SWI_FILE_MEMBER *)0x0;\n  p->swi_xfileM = (void *)0x0;\n  p->INFO_offsetM = -1;\n  p->resultM = 0xff;\n  return p;\n}", "answer": {"VAR1": "s", "FUNC2": "swi_com_assert_pointer", "FUNC3": "malloc", "FUNC1": "swi_control_script_create", "FUNC4": "swi_vbase_init", "TYPE1": "SWI_CONTROL_SCRIPT *"}, "assembly": "PUSH RBX\nMOV EDI,0x68\nCALL 0x00011aa0\nMOV RBX,RAX\nMOV EDX,0xd5\nLEA RSI,[0x8f446]\nMOV RDI,RAX\nCALL 0x00048bd9\nMOV ECX,0x0\nMOV EDX,0x0\nMOV ESI,0x44\nMOV RDI,RBX\nCALL 0x000486c9\nMOV EAX,dword ptr [0x002b9bec]\nADD EAX,0x1\nMOV dword ptr [0x002b9bec],EAX\nMOV dword ptr [RBX + 0x48],EAX\nMOV qword ptr [RBX + 0x50],0x0\nMOV qword ptr [RBX + 0x58],0x0\nMOV dword ptr [RBX + 0x60],0xffffffff\nMOV dword ptr [RBX + 0x4c],0xff\nMOV RAX,RBX\nPOP RBX\nRET\n"}, "406": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE24 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,TYPE64 [VAR6] ,[TYPE7] [VAR7] )\n{\n  int iVar1;\n  \n  if ([VAR4] == ([TYPE4] )0x0) {\n    if (([VAR5] & 0x84U) == 0) {\n      [FUNC4] ();\n      [FUNC5] (\"providers/implementations/encode_decode/encode_key2any.c\",0x51b,\n            \"dh_to_type_specific_params_der_encode\");\n      [FUNC2] (0x39,0x80106,(char *)0x0);\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = [FUNC6] ((key2any_ctx_st *)[VAR1] ,[VAR2] ,[VAR3] ,0x1c,\"DH PARAMETERS\",[FUNC8] ,[FUNC3] ,\n                    (OSSL_PASSPHRASE_CALLBACK *)0x0,(void *)0x0,(key_to_paramstring_fn *)0x0,[FUNC7] );\n    }\n  }\n  else {\n    [FUNC4] ();\n    [FUNC5] (\"providers/implementations/encode_decode/encode_key2any.c\",0x51b,\n          \"dh_to_type_specific_params_der_encode\");\n    [FUNC2] (0x39,0x80106,(char *)0x0);\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "cout", "VAR3": "key", "VAR4": "key_abstract", "VAR5": "selection", "VAR6": "cb", "FUNC2": "ERR_set_error", "FUNC3": "key_to_type_specific_der_bio", "FUNC1": "dh_to_type_specific_params_der_encode", "FUNC6": "key2any_encode", "TYPE3": "void *", "FUNC7": "dh_type_specific_params_to_der", "TYPE2": "OSSL_CORE_BIO *", "FUNC4": "ERR_new", "TYPE5": "int", "FUNC5": "ERR_set_debug", "TYPE4": "OSSL_PARAM *", "TYPE7": "void *", "TYPE6": "OSSL_PASSPHRASE_CALLBACK *", "FUNC8": "dh_check_key_type", "VAR7": "cbarg", "TYPE1": "void *"}, "assembly": "PUSH RBX\nTEST RCX,RCX\nJNZ 0x000dddb8\nMOV EBX,R8D\nAND EBX,0x84\nJNZ 0x000dddf7\nCALL 0x00080e6e\nLEA RDX,[0x2759c0]\nMOV ESI,0x51b\nLEA RDI,[0x2741d0]\nCALL 0x00080f7b\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00081292\nJMP 0x000dddf3\nCALL 0x00080e6e\nLEA RDX,[0x2759c0]\nMOV ESI,0x51b\nLEA RDI,[0x2741d0]\nCALL 0x00080f7b\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00081292\nMOV EBX,0x0\nMOV EAX,EBX\nPOP RBX\nRET\nSUB RSP,0x8\nLEA RAX,[0xe46d4]\nPUSH RAX\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nLEA RAX,[0xdda64]\nPUSH RAX\nLEA R9,[0xe46ae]\nLEA R8,[0x274095]\nMOV ECX,0x1c\nCALL 0x000ddb16\nMOV EBX,EAX\nADD RSP,0x30\nJMP 0x000dddf3\n"}, "407": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  [TYPE2] [VAR2] ;\n  \n  if ([VAR1] != (TYPE10x0) {\n    if ((([VAR1] [1].have == 0x1c4f) && (*(int *)((long)&[VAR1] [2].pos + 4) == 0)) && ([VAR1] ->have == 0))\n    {\n      [FUNC2] ((gz_statep)[VAR1] );\n    }\n    return *(int *)&[VAR1] [2].pos;\n  }\n  return 0;\n}", "answer": {"VAR1": "file", "VAR2": "state", "FUNC2": "gz_look", "FUNC1": "gzdirect", "TYPE2": "gz_statep", "TYPE1": "gzFile"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x0000dcc5\nPUSH RBX\nMOV RBX,RDI\nCMP dword ptr [RDI + 0x18],0x1c4f\nJZ 0x0000dcb3\nMOV EAX,dword ptr [RBX + 0x40]\nPOP RBX\nRET\nCMP dword ptr [RDI + 0x44],0x0\nJNZ 0x0000dcae\nCMP dword ptr [RDI],0x0\nJNZ 0x0000dcae\nCALL 0x0000d2bb\nJMP 0x0000dcae\nRET\n"}, "408": {"funcbody": "void [FUNC1] (undefined [VAR1] ,undefined [VAR2] ,undefined [VAR3] ,undefined [VAR4] ,[TYPE5] [VAR5] ,\n          undefined [VAR6] ,int [VAR7] ,int [VAR8] ,int [VAR9] )\n{\n  int iVar1;\n  undefined2 *puVar2;\n  int iVar3;\n  int iVar4;\n  int iVar5;\n  long lVar6;\n  long lVar7;\n  long lVar8;\n  long lVar9;\n  long lVar10;\n  long lVar11;\n  undefined7 in_register_00000009;\n  int iVar12;\n  uint uVar13;\n  undefined7 in_register_00000011;\n  int iVar14;\n  undefined7 in_register_00000031;\n  undefined7 in_register_00000039;\n  undefined7 in_register_00000089;\n  undefined2 *puVar15;\n  long lVar16;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  \n  puVar15 = (undefined2 *)CONCAT71(in_register_00000089,[VAR6] );\n  lVar6 = *(long *)CONCAT71(in_register_00000031,[VAR2] );\n  lVar7 = ((long *)CONCAT71(in_register_00000031,[VAR2] ))[1];\n  lVar8 = *(long *)CONCAT71(in_register_00000011,[VAR3] );\n  lVar9 = ((long *)CONCAT71(in_register_00000011,[VAR3] ))[1];\n  lVar10 = *(long *)CONCAT71(in_register_00000009,[VAR4] );\n  lVar11 = ((long *)CONCAT71(in_register_00000009,[VAR4] ))[1];\n  if (0 < [VAR7] ) {\n    lVar16 = 0;\n    puVar2 = puVar15 + (ulong)([VAR7] - 1) * 3 + 3;\n    do {\n      iVar3 = *(int *)((long)&__DT_RELA[0x40a].r_offset + CONCAT71(in_register_00000039,[VAR1] ));\n      iVar1 = (((0x1000 - [VAR8] ) * *(int *)(lVar6 + lVar16) + [VAR8] * *(int *)(lVar7 + lVar16) >> 0xe)\n              - *(int *)((long)&__DT_RELA[0x409].r_info + CONCAT71(in_register_00000039,[VAR1] ) + 4))\n              * *(int *)((long)&__DT_RELA[0x409].r_addend + CONCAT71(in_register_00000039,[VAR1] )) +\n              -0x1fffe000;\n      iVar14 = *(int *)(lVar8 + lVar16) * (0x1000 - [VAR9] ) + -0x40000000 +\n               *(int *)(lVar9 + lVar16) * [VAR9] >> 0xe;\n      iVar4 = *(int *)((long)&__DT_RELA[0x40a].r_offset + CONCAT71(in_register_00000039,[VAR1] ) + 4);\n      iVar12 = *(int *)(lVar10 + lVar16) * (0x1000 - [VAR9] ) + -0x40000000 +\n               *(int *)(lVar11 + lVar16) * [VAR9] >> 0xe;\n      iVar5 = *(int *)((long)&__DT_RELA[0x40a].r_info + CONCAT71(in_register_00000039,[VAR1] ));\n      uVar13 = (iVar12 * *(int *)((long)&__DT_RELA[0x409].r_addend +\n                                 CONCAT71(in_register_00000039,[VAR1] ) + 4) + iVar1 >> 0xe) + 0x8000;\n      if ((uVar13 & 0xffff0000) != 0) {\n        uVar13 = (int)~uVar13 >> 0x1f & 0xffff;\n      }\n      *puVar15 = (short)uVar13;\n      uVar13 = (iVar4 * iVar14 + iVar3 * iVar12 + iVar1 >> 0xe) + 0x8000;\n      if ((uVar13 & 0xffff0000) != 0) {\n        uVar13 = (int)~uVar13 >> 0x1f & 0xffff;\n      }\n      puVar15[1] = (short)uVar13;\n      uVar13 = (iVar1 + iVar14 * iVar5 >> 0xe) + 0x8000;\n      if ((uVar13 & 0xffff0000) != 0) {\n        uVar13 = (int)~uVar13 >> 0x1f;\n      }\n      puVar15[2] = (short)uVar13;\n      lVar16 = lVar16 + 4;\n      puVar15 = puVar15 + 3;\n    } while (puVar15 != puVar2);\n  }\n  return;\n}", "answer": {"VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "VAR5": "param_5", "VAR6": "param_6", "FUNC1": "FUN_00f6f5f0", "TYPE3": "undefined", "TYPE2": "undefined", "TYPE5": "undefined", "VAR12": "local_48", "TYPE4": "undefined", "TYPE7": "undefined4", "TYPE6": "undefined", "TYPE9": "undefined4", "TYPE8": "undefined4", "VAR7": "param_7", "TYPE11": "undefined4", "VAR8": "param_8", "TYPE12": "undefined8", "VAR9": "param_9", "TYPE10": "undefined8", "VAR10": "local_38", "VAR11": "local_3c", "TYPE1": "undefined"}, "assembly": "MOV R11D,0x1000\nPUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nMOV R14,qword ptr [RSI]\nMOV EAX,dword ptr [RSP + 0x38]\nMOV EBX,dword ptr [RSP + 0x48]\nMOV RBP,qword ptr [RSI + 0x8]\nMOV ESI,R11D\nSUB ESI,dword ptr [RSP + 0x40]\nMOV R12,qword ptr [RDX]\nMOV qword ptr [RSP + -0x18],R14\nMOV R13,qword ptr [RDX + 0x8]\nSUB R11D,EBX\nTEST EAX,EAX\nMOV R14,qword ptr [RCX]\nMOV R15,qword ptr [RCX + 0x8]\nMOV dword ptr [RSP + -0xc],ESI\nJLE 0x00f6f745\nSUB EAX,0x1\nXOR R10D,R10D\nLEA RAX,[RAX + RAX*0x2 + 0x3]\nLEA RAX,[R9 + RAX*0x2]\nMOV qword ptr [RSP + -0x8],RAX\nNOP dword ptr [RAX]\nMOV RSI,qword ptr [RSP + -0x18]\nMOV EAX,dword ptr [RSP + -0xc]\nMOV ECX,dword ptr [RSP + 0x40]\nMOV EDX,dword ptr [R13 + R10*0x1]\nIMUL ECX,dword ptr [RBP + R10*0x1]\nIMUL EAX,dword ptr [RSI + R10*0x1]\nIMUL EDX,EBX\nMOV R8D,dword ptr [RDI + 0x9d70]\nADD EAX,ECX\nMOV ECX,dword ptr [R12 + R10*0x1]\nSAR EAX,0xe\nSUB EAX,dword ptr [RDI + 0x9d64]\nIMUL EAX,dword ptr [RDI + 0x9d68]\nIMUL ECX,R11D\nLEA ESI,[RCX + RDX*0x1 + -0x40000000]\nMOV ECX,dword ptr [R14 + R10*0x1]\nMOV EDX,dword ptr [R15 + R10*0x1]\nLEA EAX,[RAX + -0x1fffe000]\nSAR ESI,0xe\nIMUL ECX,R11D\nIMUL EDX,EBX\nLEA EDX,[RCX + RDX*0x1 + -0x40000000]\nMOV ECX,dword ptr [RDI + 0x9d74]\nSAR EDX,0xe\nIMUL R8D,EDX\nIMUL EDX,dword ptr [RDI + 0x9d6c]\nIMUL ECX,ESI\nIMUL ESI,dword ptr [RDI + 0x9d78]\nADD ECX,R8D\nADD EDX,EAX\nSAR EDX,0xe\nADD EDX,0x8000\nTEST EDX,0xffff0000\nJZ 0x00f6f6f3\nNOT EDX\nSAR EDX,0x1f\nMOVZX EDX,DX\nADD ECX,EAX\nMOV word ptr [R9],DX\nSAR ECX,0xe\nADD ECX,0x8000\nTEST ECX,0xffff0000\nJZ 0x00f6f712\nNOT ECX\nSAR ECX,0x1f\nMOVZX ECX,CX\nADD EAX,ESI\nMOV word ptr [R9 + 0x2],CX\nSAR EAX,0xe\nADD EAX,0x8000\nTEST EAX,0xffff0000\nJZ 0x00f6f72d\nNOT EAX\nSAR EAX,0x1f\nMOV word ptr [R9 + 0x4],AX\nADD R10,0x4\nADD R9,0x6\nCMP R9,qword ptr [RSP + -0x8]\nJNZ 0x00f6f650\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "409": {"funcbody": "int [FUNC1] (TYPE14 [VAR1] ,TYPE21 [VAR2] ,TYPE31 [VAR3] )\n{\n  if ((([VAR1] != (TYPE14)0x0) && ([VAR3] != (TYPE31)0x0)) &&\n     ([VAR2] + 0xffffffff < 5)) {\n    [VAR1] ->d_printing = 0;\n    [VAR1] ->d_counting = 0;\n    [VAR1] ->type = DEMANGLE_COMPONENT_CTOR;\n    ([VAR1] ->u).s_ctor.kind = [VAR2] ;\n    ([VAR1] ->u).s_extended_operator.name = [VAR3] ;\n    return 1;\n  }\n  return 0;\n}", "answer": {"VAR1": "p", "VAR2": "kind", "VAR3": "name", "FUNC1": "cplus_demangle_fill_ctor", "TYPE3": "demangle_component *", "TYPE2": "gnu_v3_ctor_kinds", "TYPE1": "demangle_component *"}, "assembly": "TEST RDI,RDI\nJZ 0x000e0494\nTEST RDX,RDX\nJZ 0x000e0494\nLEA ECX,[RSI + -0x1]\nMOV EAX,0x0\nCMP ECX,0x4\nJA 0x000e0499\nMOV dword ptr [RDI + 0x4],0x0\nMOV dword ptr [RDI + 0x8],0x0\nMOV dword ptr [RDI],0x7\nMOV dword ptr [RDI + 0x10],ESI\nMOV qword ptr [RDI + 0x18],RDX\nMOV EAX,0x1\nRET\nMOV EAX,0x0\nRET\n"}, "410": {"funcbody": "ufile_ptr [FUNC1] ([TYPE1] [VAR1] )\n{\n  long lVar1;\n  int iVar2;\n  ufile_ptr uVar3;\n  long in_FS_OFFSET;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  if ([VAR1] ->size < 2) {\n    if (([VAR1] ->size != 1) || (([VAR1] ->field_0x48 & 0x10) != 0)) goto LAB_000662de;\nLAB_0006630b:\n    uVar3 = 0;\n  }\n  else {\n    if (([VAR1] ->field_0x48 & 0x10) != 0) {\nLAB_000662de:\n      iVar2 = [FUNC2] ([VAR1] ,&[VAR3] );\n      if ((iVar2 != 0) || ([VAR3] .st_size == 0)) {\n        [VAR1] ->size = 1;\n        goto LAB_0006630b;\n      }\n      [VAR1] ->size = [VAR3] .st_size;\n    }\n    uVar3 = [VAR1] ->size;\n  }\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "abfd", "VAR2": "local_10", "VAR3": "buf", "FUNC2": "bfd_stat", "FUNC3": "__stack_chk_fail", "FUNC1": "bfd_get_size", "TYPE3": "stat", "TYPE2": "undefined8", "TYPE1": "bfd *"}, "assembly": "PUSH RBX\nSUB RSP,0xa0\nMOV RBX,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x98],RAX\nXOR EAX,EAX\nMOV RAX,qword ptr [RDI + 0xd8]\nCMP RAX,0x1\nJBE 0x000662d2\nTEST byte ptr [RDI + 0x48],0x10\nJNZ 0x000662de\nMOV RAX,qword ptr [RBX + 0xd8]\nJMP 0x00066310\nCMP RAX,0x1\nJNZ 0x000662de\nTEST byte ptr [RDI + 0x48],0x10\nJZ 0x0006630b\nMOV RSI,RSP\nMOV RDI,RBX\nCALL 0x000660e2\nTEST EAX,EAX\nJNZ 0x00066300\nMOV RAX,qword ptr [RSP + 0x30]\nTEST RAX,RAX\nJZ 0x00066300\nMOV qword ptr [RBX + 0xd8],RAX\nJMP 0x000662c9\nMOV qword ptr [RBX + 0xd8],0x1\nMOV EAX,0x0\nMOV RDX,qword ptr [RSP + 0x98]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x0006632c\nADD RSP,0xa0\nPOP RBX\nRET\nCALL 0x000334e0\n"}, "411": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  long [VAR3] ;\n  \n  [VAR3] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR7] = 0;\n  iVar1 = [FUNC9] ([VAR1] ,4);\n  if (iVar1 == 0) {\n    iVar1 = [FUNC12] (&[VAR4] ,[VAR1] ,1);\n    if (iVar1 != 0) {\n      [FUNC11] (4,\"mu_file_stream_create\",[VAR1] ,iVar1);\n      [FUNC2] (1);\n    }\n    [VAR5] = [FUNC8] ([VAR4] );\n    [FUNC10] ([VAR4] );\n    [FUNC4] ([VAR5] );\n    [FUNC3] (&[VAR5] );\n  }\n  else {\n    piVar2 = [FUNC6] ();\n    uVar3 = [FUNC5] (*piVar2);\n    [FUNC13] (\"%s: %s\",[VAR1] ,uVar3);\n    [VAR7] = -1;\n  }\n  if ([VAR3] != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC7] ();\n  }\n  return [VAR7] ;\n}", "answer": {"FUNC12": "mu_file_stream_create", "FUNC11": "mu_diag_funcall", "VAR1": "filename", "FUNC13": "mu_error", "VAR2": "check", "VAR3": "local_10", "VAR4": "str", "FUNC10": "mu_stream_unref", "VAR5": "hdr", "VAR6": "rc_1", "FUNC2": "exit", "FUNC3": "mu_header_destroy", "FUNC1": "mh_whom_file", "FUNC6": "__errno_location", "TYPE3": "undefined8", "FUNC7": "__stack_chk_fail", "TYPE2": "int", "FUNC4": "mh_whom_header", "TYPE5": "mu_header_t", "FUNC5": "mu_strerror", "TYPE4": "mu_stream_t", "TYPE7": "int", "TYPE6": "int", "FUNC8": "read_header", "TYPE9": "int", "FUNC9": "access", "TYPE8": "char *", "VAR7": "rc", "VAR8": "filename-local", "VAR9": "check-local", "TYPE1": "char *"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nSUB RSP,0x30\nMOV qword ptr [RBP + -0x28],RDI\nMOV dword ptr [RBP + -0x2c],ESI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RBP + -0x8],RAX\nXOR EAX,EAX\nMOV dword ptr [RBP + -0x20],0x0\nMOV RAX,qword ptr [RBP + -0x28]\nMOV ESI,0x4\nMOV RDI,RAX\nCALL 0x00007520\nTEST EAX,EAX\nJZ 0x00018137\nCALL 0x000071d0\nMOV EAX,dword ptr [RAX]\nMOV EDI,EAX\nCALL 0x000074e0\nMOV RDX,RAX\nMOV RAX,qword ptr [RBP + -0x28]\nMOV RSI,RAX\nLEA RDI,[0x1f4b0]\nMOV EAX,0x0\nCALL 0x00006a40\nMOV dword ptr [RBP + -0x20],0xffffffff\nJMP 0x000181b6\nMOV RCX,qword ptr [RBP + -0x28]\nLEA RAX,[RBP + -0x10]\nMOV EDX,0x1\nMOV RSI,RCX\nMOV RDI,RAX\nCALL 0x00007130\nMOV dword ptr [RBP + -0x1c],EAX\nCMP dword ptr [RBP + -0x1c],0x0\nJZ 0x0001817f\nMOV EDX,dword ptr [RBP + -0x1c]\nMOV RAX,qword ptr [RBP + -0x28]\nMOV ECX,EDX\nMOV RDX,RAX\nLEA RSI,[0x1f4b7]\nMOV EDI,0x4\nCALL 0x000068d0\nMOV EDI,0x1\nCALL 0x000069e0\nMOV RAX,qword ptr [RBP + -0x10]\nMOV RDI,RAX\nCALL 0x00017d0a\nMOV qword ptr [RBP + -0x18],RAX\nMOV RAX,qword ptr [RBP + -0x10]\nMOV RDI,RAX\nCALL 0x000075b0\nMOV RAX,qword ptr [RBP + -0x18]\nMOV RDI,RAX\nCALL 0x00017f0c\nMOV dword ptr [RBP + -0x1c],EAX\nLEA RAX,[RBP + -0x18]\nMOV RDI,RAX\nCALL 0x00006c00\nMOV EAX,dword ptr [RBP + -0x20]\nMOV RCX,qword ptr [RBP + -0x8]\nXOR RCX,qword ptr FS:[0x28]\nJZ 0x000181cd\nCALL 0x000072b0\nLEAVE\nRET\n"}, "412": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  uchar *puVar2;\n  int iVar3;\n  int iVar4;\n  [TYPE5] [VAR5] ;\n  [TYPE6] [VAR6] ;\n  [TYPE3] [VAR3] ;\n  int iVar5;\n  [TYPE4] [VAR4] ;\n  \n  iVar1 = [VAR1] ->size;\n  iVar3 = 0;\n  if (iVar1 != [VAR1] ->maxsize) {\n    iVar5 = [VAR1] ->alloc - iVar1;\n    iVar4 = (([VAR2] + [VAR1] ->alloc) / 1000) * 1000 + 1000;\n    iVar3 = [VAR1] ->maxsize + iVar5;\n    if (iVar3 <= iVar4) {\n      iVar4 = iVar3;\n    }\n    puVar2 = (uchar *)[FUNC2] ([VAR1] ->data,(long)iVar4);\n    iVar3 = 0;\n    if (puVar2 != (uchar *)0x0) {\n      [VAR1] ->data = puVar2;\n      [VAR1] ->alloc = iVar4;\n      iVar4 = iVar4 - iVar5;\n      [VAR1] ->size = iVar4;\n      iVar3 = [VAR1] ->i_rep;\n      if ([VAR1] ->i_in < iVar3) {\n        iVar5 = (iVar1 + 1) - iVar3;\n        iVar4 = (iVar4 + 1) - iVar5;\n        [FUNC3] (puVar2 + iVar4,puVar2 + iVar3,(long)iVar5);\n        if ([VAR1] ->i_rep <= [VAR1] ->i_out) {\n          [VAR1] ->i_out = [VAR1] ->i_out + (iVar4 - [VAR1] ->i_rep);\n        }\n        [VAR1] ->i_rep = iVar4;\n      }\n      iVar3 = [VAR1] ->size - iVar1;\n    }\n  }\n  return iVar3;\n}", "answer": {"VAR1": "cb", "VAR2": "n", "VAR3": "size_old", "VAR4": "size_meta", "VAR5": "m", "VAR6": "data", "FUNC2": "realloc", "FUNC3": "memmove", "FUNC1": "cbuf_grow", "TYPE3": "int", "TYPE2": "int", "TYPE5": "int", "TYPE4": "int", "TYPE6": "uchar *", "TYPE1": "cbuf_t"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R12D,dword ptr [RDI + 0xc]\nMOV ECX,dword ptr [RDI + 0x8]\nMOV EAX,0x0\nCMP R12D,ECX\nJZ 0x0001bab3\nMOV RBX,RDI\nMOV EAX,dword ptr [RDI]\nMOV R13D,EAX\nSUB R13D,R12D\nADD ESI,EAX\nMOV EDX,0x10624dd3\nMOV EAX,ESI\nIMUL EDX\nSAR EDX,0x6\nSAR ESI,0x1f\nSUB EDX,ESI\nIMUL EDX,EDX,0x3e8\nLEA EBP,[RDX + 0x3e8]\nADD ECX,R13D\nCMP ECX,EBP\nCMOVLE EBP,ECX\nMOV RDI,qword ptr [RDI + 0x28]\nMOVSXD RSI,EBP\nCALL 0x00004610\nMOV RDI,RAX\nMOV EAX,0x0\nTEST RDI,RDI\nJZ 0x0001bab3\nMOV qword ptr [RBX + 0x28],RDI\nMOV dword ptr [RBX],EBP\nSUB EBP,R13D\nMOV dword ptr [RBX + 0xc],EBP\nMOV ESI,dword ptr [RBX + 0x24]\nCMP ESI,dword ptr [RBX + 0x1c]\nJG 0x0001babe\nMOV EAX,dword ptr [RBX + 0xc]\nSUB EAX,R12D\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nLEA EDX,[R12 + 0x1]\nSUB EDX,ESI\nADD EBP,0x1\nSUB EBP,EDX\nMOVSXD RDX,EDX\nMOVSXD RSI,ESI\nADD RSI,RDI\nMOVSXD RAX,EBP\nADD RDI,RAX\nCALL 0x00004350\nMOV EAX,dword ptr [RBX + 0x20]\nMOV EDX,dword ptr [RBX + 0x24]\nCMP EAX,EDX\nJL 0x0001baf1\nMOV ECX,EBP\nSUB ECX,EDX\nADD EAX,ECX\nMOV dword ptr [RBX + 0x20],EAX\nMOV dword ptr [RBX + 0x24],EBP\nJMP 0x0001baad\n"}, "413": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  uint uVar1;\n  uint uVar2;\n  uint uVar4;\n  TYPE44 [VAR4] ;\n  [TYPE7] [VAR7] ;\n  [TYPE9] [VAR9] ;\n  TYPE54 [VAR5] ;\n  [TYPE6] [VAR6] ;\n  [TYPE8] [VAR8] ;\n  ulong uVar3;\n  \n  uVar1 = [FUNC2] ();\n  if (uVar1 != 0) {\n    uVar4 = 1;\n    uVar2 = uVar1;\n    if (([VAR3] & 4U) != 0) {\n      uVar2 = *(uint *)((long)[VAR2] + 0x60);\n      uVar4 = (uint)(*(uint *)((long)[VAR1] + 0x60) == uVar2);\n    }\n    uVar1 = uVar4;\n    uVar3 = (ulong)uVar2;\n    if (([VAR3] & 3U) != 0) {\n      uVar2 = uVar1;\n      if ((((([VAR3] & 2U) == 0) || ((*(byte *)((long)[VAR1] + 0x10) & 1) == 0)) ||\n          ((*(byte *)((long)[VAR2] + 0x10) & 1) == 0)) ||\n         (((void *)((long)[VAR1] + 0x11) == (void *)0x0 ||\n          ((void *)((long)[VAR2] + 0x11) == (void *)0x0)))) {\n        uVar4 = [VAR3] & 1;\n        if (uVar4 != 0) {\n          if ((*(void **)((long)[VAR1] + 0x50) == (void *)0x0) ||\n             (*(void **)((long)[VAR2] + 0x50) == (void *)0x0)) {\n            uVar4 = 0;\n          }\n          else if (uVar1 != 0) {\n            uVar3 = (ulong)*(uint *)((long)[VAR2] + 0x60);\n            if ((*(uint *)((long)[VAR1] + 0x60) == *(uint *)((long)[VAR2] + 0x60)) &&\n               (*(size_t *)((long)[VAR2] + 0x58) == *(size_t *)((long)[VAR1] + 0x58))) {\n              uVar2 = [FUNC3] (*(void **)((long)[VAR1] + 0x50),*(void **)((long)[VAR2] + 0x50),\n                            *(size_t *)((long)[VAR1] + 0x58));\n              uVar3 = (ulong)uVar2;\n              uVar2 = (uint)(uVar2 == 0);\n              uVar4 = uVar1;\n            }\n            else {\n              uVar2 = 0;\n              uVar4 = uVar1;\n            }\n          }\n        }\n      }\n      else {\n        uVar4 = 1;\n        if (uVar1 != 0) {\n          uVar3 = (ulong)*(uint *)((long)[VAR2] + 0x60);\n          if ((*(uint *)((long)[VAR1] + 0x60) == *(uint *)((long)[VAR2] + 0x60)) &&\n             (*(size_t *)((long)[VAR2] + 0x58) == *(size_t *)((long)[VAR1] + 0x58))) {\n            uVar2 = [FUNC3] ((void *)((long)[VAR1] + 0x11),(void *)((long)[VAR2] + 0x11),\n                          *(size_t *)((long)[VAR1] + 0x58));\n            uVar3 = (ulong)uVar2;\n            uVar2 = (uint)(uVar2 == 0);\n            uVar4 = uVar1;\n          }\n          else {\n            uVar2 = 0;\n            uVar4 = uVar1;\n          }\n        }\n      }\n      uVar1 = (uint)(uVar4 != 0) & (uint)CONCAT71((int7)(uVar3 >> 8),uVar2 != 0);\n    }\n  }\n  return uVar1;\n}", "answer": {"VAR1": "keydata1", "VAR2": "keydata2", "VAR3": "selection", "VAR4": "key2", "VAR5": "key1", "VAR6": "pa", "FUNC2": "ossl_prov_is_running", "FUNC3": "CRYPTO_memcmp", "FUNC1": "ecx_match", "TYPE3": "int", "TYPE2": "void *", "TYPE5": "ECX_KEY *", "TYPE4": "ECX_KEY *", "TYPE7": "uchar *", "TYPE6": "uchar *", "TYPE9": "uchar *", "TYPE8": "uchar *", "VAR7": "pb", "VAR8": "pa_1", "VAR9": "pb_1", "TYPE1": "void *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R12,RDI\nMOV R13,RSI\nMOV EBP,EDX\nCALL 0x000f25ff\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x001241d6\nMOV EBX,0x1\nTEST BPL,0x4\nJZ 0x00124107\nMOV EAX,dword ptr [R13 + 0x60]\nCMP dword ptr [R12 + 0x60],EAX\nSETZ BL\nMOVZX EBX,BL\nTEST BPL,0x3\nJZ 0x001241d6\nTEST BPL,0x2\nJZ 0x00124176\nTEST byte ptr [R12 + 0x10],0x1\nJZ 0x00124176\nLEA RDI,[R12 + 0x11]\nTEST byte ptr [R13 + 0x10],0x1\nJZ 0x00124176\nLEA RSI,[R13 + 0x11]\nTEST RDI,RDI\nJZ 0x00124176\nTEST RSI,RSI\nJZ 0x00124176\nMOV EBP,0x1\nTEST EBX,EBX\nJZ 0x001241c7\nMOV RDX,qword ptr [R12 + 0x58]\nMOV EAX,dword ptr [R13 + 0x60]\nCMP dword ptr [R12 + 0x60],EAX\nJNZ 0x0012415c\nCMP qword ptr [R13 + 0x58],RDX\nJZ 0x00124165\nMOV EBP,EBX\nMOV EBX,0x0\nJMP 0x001241c7\nCALL 0x000c3ef0\nTEST EAX,EAX\nMOV EBP,EBX\nSETZ BL\nMOVZX EBX,BL\nJMP 0x001241c7\nAND EBP,0x1\nJZ 0x001241c7\nMOV RDI,qword ptr [R12 + 0x50]\nMOV RSI,qword ptr [R13 + 0x50]\nTEST RDI,RDI\nJZ 0x001241c2\nTEST RSI,RSI\nJZ 0x001241c2\nTEST EBX,EBX\nJZ 0x001241c7\nMOV RDX,qword ptr [R12 + 0x58]\nMOV EAX,dword ptr [R13 + 0x60]\nCMP dword ptr [R12 + 0x60],EAX\nJNZ 0x001241a8\nCMP qword ptr [R13 + 0x58],RDX\nJZ 0x001241b1\nMOV EBP,EBX\nMOV EBX,0x0\nJMP 0x001241c7\nCALL 0x000c3ef0\nTEST EAX,EAX\nMOV EBP,EBX\nSETZ BL\nMOVZX EBX,BL\nJMP 0x001241c7\nMOV EBP,0x0\nTEST EBX,EBX\nSETNZ AL\nTEST EBP,EBP\nSETNZ BL\nMOVZX EBX,BL\nAND EBX,EAX\nMOV EAX,EBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\n"}, "414": {"funcbody": "/* scoped_enable_commit_resumed::~scoped_enable_commit_resumed() */\nvoid __thiscall scoped_enable_commit_resumed::[FUNC1] (scoped_enable_commit_resumed *this)\n{\n  int iVar1;\n  char *pcVar2;\n  long *plVar3;\n  long lVar4;\n  undefined unaff_BL;\n  undefined in_R8B;\n  undefined in_R9B;\n  \n  if (debug_infrun != '\\0') {\n    [FUNC3] (\"infrun\",\"~scoped_enable_commit_resumed\",\"reason=%s\",(char)*(undefined8 *)this,in_R8B,\n          in_R9B,unaff_BL);\n  }\n  if (enable_commit_resumed == (scoped_enable_commit_resumed)0x0) {\n    pcVar2 = (char *)[FUNC4] (\"%s: Assertion `%s\\' failed.\");\n    [FUNC2] (\"infrun.c\",0xc91,pcVar2,0x50,0x38,in_R9B,unaff_BL);\n  }\n  enable_commit_resumed = this[8];\n  if ((enable_commit_resumed == (scoped_enable_commit_resumed)0x0) && (inferior_list != 0)) {\n    iVar1 = *(int *)(inferior_list + 100);\n    lVar4 = inferior_list;\n    while (iVar1 == 0) {\n      plVar3 = (long *)(lVar4 + 8);\n      if (lVar4 == 0) {\n        plVar3 = (long *)0x0;\n      }\n      lVar4 = *plVar3;\n      if (lVar4 == 0) {\n        return;\n      }\n      iVar1 = *(int *)(lVar4 + 100);\n    }\n    while (lVar4 != 0) {\n      *(undefined *)(*(long *)(lVar4 + 0x1d0) + 0x14) = 0;\n      for (lVar4 = *(long *)(lVar4 + 8); (lVar4 != 0 && (*(int *)(lVar4 + 100) == 0));\n          lVar4 = *(long *)(lVar4 + 8)) {\n      }\n    }\n  }\n  return;\n}", "answer": {"FUNC2": "internal_error_loc", "FUNC3": "debug_prefixed_printf", "FUNC1": "~scoped_enable_commit_resumed", "FUNC4": "gettext"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nCMP byte ptr [0x00c365e5],0x0\nJNZ 0x00381808\nCMP byte ptr [0x00c18480],0x0\nJZ 0x0038182c\nMOVZX EAX,byte ptr [RBX + 0x8]\nMOV byte ptr [0x00c18480],AL\nTEST AL,AL\nJZ 0x0038185f\nPOP RBX\nRET\nMOV RCX,qword ptr [RDI]\nLEA RDX,[0x78d62d]\nLEA RSI,[0x792450]\nLEA RDI,[0x727f76]\nMOV EAX,0x0\nCALL 0x006daba1\nJMP 0x003817ef\nLEA RDI,[0x706c44]\nCALL 0x000d0680\nLEA R8,[0x78d638]\nLEA RCX,[0x792450]\nMOV RDX,RAX\nMOV ESI,0xc91\nLEA RDI,[0x78d4f5]\nMOV EAX,0x0\nCALL 0x006ddbcc\nMOV RAX,qword ptr [0x00c364d0]\nTEST RAX,RAX\nJZ 0x00381806\nCMP dword ptr [RAX + 0x64],0x0\nJNZ 0x003818bb\nMOV ECX,0x0\nLEA RDX,[RAX + 0x8]\nTEST RAX,RAX\nMOV RAX,RDX\nCMOVZ RAX,RCX\nMOV RAX,qword ptr [RAX]\nTEST RAX,RAX\nJZ 0x00381806\nCMP dword ptr [RAX + 0x64],0x0\nJZ 0x00381876\nJMP 0x003818bb\nMOV RDX,qword ptr [RAX + 0x1d0]\nMOV byte ptr [RDX + 0x14],0x0\nMOV RAX,qword ptr [RAX + 0x8]\nTEST RAX,RAX\nJZ 0x003818bb\nCMP dword ptr [RAX + 0x64],0x0\nJNZ 0x003818bb\nMOV RAX,qword ptr [RAX + 0x8]\nTEST RAX,RAX\nJNZ 0x003818ac\nTEST RAX,RAX\nJNZ 0x00381898\nJMP 0x00381806\n"}, "415": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] )\n{\n  byte bVar1;\n  [TYPE6] [VAR6] ;\n  uint uVar2;\n  byte *pbVar3;\n  [TYPE7] [VAR7] ;\n  [TYPE4] TVar4;\n  \n  uVar2 = 0;\n  if ([VAR1] != [VAR3] ) {\n    if ([VAR5] < [VAR2] ) {\n      [VAR2] = [VAR5] ;\n    }\n    TVar4 = [VAR2] ;\n    if ([VAR4] <= [VAR2] ) {\n      TVar4 = [VAR4] ;\n    }\n    pbVar3 = (byte *)[VAR3] ;\n    while (pbVar3 != (byte *)([VAR3] + TVar4)) {\n      bVar1 = *[VAR1] ;\n      [VAR7] = ([TYPE7] )\"\"[*pbVar3];\n      pbVar3 = pbVar3 + 1;\n      [VAR1] = ([TYPE1] ((byte *)[VAR1] + 1);\n      if ((uint)\"\"[bVar1] != [VAR7] ) {\n        return (uint)\"\"[bVar1] - [VAR7] ;\n      }\n    }\n    if ([VAR5] < [VAR4] ) {\n      [VAR4] = [VAR5] ;\n    }\n    uVar2 = 0;\n    if ([VAR4] != [VAR2] ) {\n      uVar2 = -(uint)([VAR2] < [VAR4] ) | 1;\n    }\n  }\n  return uVar2;\n}", "answer": {"VAR1": "s1", "VAR2": "len1", "VAR3": "s2", "VAR4": "len2", "VAR5": "length", "VAR6": "c1", "FUNC1": "zend_binary_strncasecmp", "TYPE3": "char *", "TYPE2": "size_t", "TYPE5": "size_t", "TYPE4": "size_t", "TYPE7": "int", "TYPE6": "int", "VAR7": "c2", "TYPE1": "char *"}, "assembly": "MOV EAX,0x0\nCMP RDI,RDX\nJZ 0x003ad672\nCMP RSI,R8\nCMOVA RSI,R8\nCMP RCX,RSI\nMOV R11,RSI\nCMOVBE R11,RCX\nADD R11,RDX\nLEA R9,[0xd2eea0]\nCMP RDX,R11\nJZ 0x003ad659\nADD RDI,0x1\nMOVZX EAX,byte ptr [RDI + -0x1]\nMOVZX EAX,byte ptr [R9 + RAX*0x1]\nADD RDX,0x1\nMOVZX R10D,byte ptr [RDX + -0x1]\nMOVZX R10D,byte ptr [R9 + R10*0x1]\nCMP EAX,R10D\nJZ 0x003ad630\nSUB EAX,R10D\nRET\nCMP RCX,R8\nCMOVA RCX,R8\nMOV EAX,0x0\nCMP RCX,RSI\nJZ 0x003ad672\nCMP RSI,RCX\nSBB EAX,EAX\nOR EAX,0x1\nRET\n"}, "416": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  cb_statement *pcVar1;\n  cb_tree pcVar2;\n  \n  if ([VAR1] == ([TYPE1] )0x0) {\n    pcVar2 = [FUNC4] (\"cob_destroy_control\",1,(cb_tree)0x0,(cb_tree)0x0,(cb_tree)0x0,(cb_tree)0x0,\n                   (cb_tree)0x0,(cb_tree)0x0,(cb_tree)0x0,(cb_tree)0x0,(cb_tree)0x0,(cb_tree)0x0,\n                   (cb_tree)0x0,(cb_tree)0x0,(cb_tree)0x0,(cb_tree)0x0);\n    pcVar1 = current_statement;\n    pcVar2 = [FUNC2] (current_statement->body,pcVar2);\n    pcVar1->body = pcVar2;\n  }\n  else {\n    [FUNC3] ([VAR1] );\n  }\n  return;\n}", "answer": {"VAR1": "controls", "FUNC2": "cb_list_add", "FUNC3": "cb_validate_list", "FUNC1": "cb_emit_destroy", "FUNC4": "cb_build_funcall", "TYPE1": "cb_tree"}, "assembly": "PUSH RBX\nTEST RDI,RDI\nJZ 0x0008babe\nCALL 0x0007ad3a\nPOP RBX\nRET\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nPUSH 0x0\nMOV R9D,0x0\nMOV R8D,0x0\nMOV ECX,0x0\nMOV EDX,0x0\nMOV ESI,0x1\nLEA RDI,[0x116a6f]\nCALL 0x000726f1\nMOV RBX,qword ptr [0x0034fec8]\nADD RSP,0x50\nMOV RDI,qword ptr [RBX + 0x20]\nMOV RSI,RAX\nCALL 0x0006a570\nMOV qword ptr [RBX + 0x20],RAX\nJMP 0x0008babc\n"}, "417": {"funcbody": "void [FUNC1] (undefined8 param_1)\n{\n  undefined8 uVar1;\n  \n  if ((var_7958 & 0xfffffffffffffeff) == 4) {\n    uVar1 = [FUNC3] (\"srfi srfi-4\");\n    var_7958 = [FUNC2] (uVar1,\"u16vector\");\n  }\n  [FUNC4] (*(undefined8 *)(var_7958 + 8),param_1);\n  return;\n}", "answer": {"FUNC2": "scm_c_module_lookup", "FUNC3": "scm_c_resolve_module", "FUNC1": "scm_u16vector", "FUNC4": "scm_apply_0"}, "assembly": "ENDBR64\nPUSH RBX\nMOV RBX,RDI\nMOV RAX,qword ptr [0x00142e08]\nAND AH,0xfe\nCMP RAX,0x4\nJZ 0x00081596\nMOV RAX,qword ptr [0x00142e08]\nMOV RDI,qword ptr [RAX + 0x8]\nMOV RSI,RBX\nCALL 0x00034f50\nPOP RBX\nRET\nLEA RDI,[0x102363]\nCALL 0x000338d0\nMOV RDI,RAX\nLEA RSI,[0x1022bd]\nCALL 0x00033a00\nMOV qword ptr [0x00142e08],RAX\nJMP 0x00081581\n"}, "418": {"funcbody": "void * [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  void *pvVar2;\n  TYPE21 [VAR2] ;\n  \n  iVar1 = [FUNC3] ();\n  if (iVar1 == 0) {\n    pvVar2 = (void *)0x0;\n  }\n  else {\n    pvVar2 = [FUNC2] (0x170,\"providers/implementations/macs/blake2_mac_impl.c\",0x31);\n    if (pvVar2 != (void *)0x0) {\n      [FUNC4] ((BLAKE2B_PARAM *)((long)pvVar2 + 0xf0));\n    }\n  }\n  return pvVar2;\n}", "answer": {"VAR1": "unused_provctx", "VAR2": "macctx", "FUNC2": "CRYPTO_zalloc", "FUNC3": "ossl_prov_is_running", "FUNC1": "blake2_mac_new", "TYPE2": "blake2_mac_data_st *", "FUNC4": "ossl_blake2b_param_init", "TYPE1": "void *"}, "assembly": "PUSH RBX\nCALL 0x000e549f\nTEST EAX,EAX\nJZ 0x001190fc\nMOV EDX,0x31\nLEA RSI,[0x28ce68]\nMOV EDI,0x170\nCALL 0x000ada0f\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x001190f7\nLEA RDI,[RAX + 0xf0]\nCALL 0x000f7dd1\nMOV RAX,RBX\nPOP RBX\nRET\nMOV EBX,0x0\nJMP 0x001190f7\n"}, "419": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  byte bVar1;\n  byte bVar2;\n  uint uVar3;\n  ulong uVar4;\n  \n  uVar4 = 0;\n  uVar3 = 0;\n  if ([VAR3] != 0) {\n    if ([VAR3] == 0x10) {\n      return (int)((*[VAR1] ^ *[VAR2] | *(ulong *)((long)[VAR1] + 8) ^ *(ulong *)((long)[VAR2] + 8)) != 0);\n    }\n    do {\n      bVar1 = *[VAR1] ;\n      [VAR1] = ([TYPE1] )((long)[VAR1] + 1);\n      bVar2 = *[VAR2] ;\n      [VAR2] = ([TYPE2] ((long)[VAR2] + 1);\n      uVar4 = (ulong)(byte)((byte)uVar4 | bVar1 ^ bVar2);\n      [VAR3] = [VAR3] - 1;\n    } while ([VAR3] != 0);\n    uVar3 = (uint)(-uVar4 >> 0x3f);\n  }\n  return uVar3;\n}", "answer": {"VAR1": "a", "VAR2": "b", "VAR3": "len", "FUNC1": "CRYPTO_memcmp", "TYPE3": "size_t", "TYPE2": "void *", "TYPE1": "void *"}, "assembly": "ENDBR64\nXOR RAX,RAX\nXOR R10,R10\nCMP RDX,0x0\nJZ 0x000b9f5d\nCMP RDX,0x10\nJNZ 0x000b9f40\nMOV R10,qword ptr [RDI]\nMOV R11,qword ptr [RDI + 0x8]\nMOV RDX,0x1\nXOR R10,qword ptr [RSI]\nXOR R11,qword ptr [RSI + 0x8]\nOR R10,R11\nCMOVNZ RAX,RDX\nRET\nMOV R10B,byte ptr [RDI]\nLEA RDI,[RDI + 0x1]\nXOR R10B,byte ptr [RSI]\nLEA RSI,[RSI + 0x1]\nOR AL,R10B\nDEC RDX\nJNZ 0x000b9f40\nNEG RAX\nSHR RAX,0x3f\nRET\n"}, "420": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  \n  if ([VAR1] != (TYPE19)0x0) {\n    iVar1 = [FUNC2] ([VAR1] ->prov,[VAR1] ->name_id,(char *)0x0,[VAR2] );\n    return (int)(iVar1 != 0);\n  }\n  return 0;\n}", "answer": {"VAR1": "kem", "VAR2": "name", "FUNC2": "evp_is_a", "FUNC1": "EVP_KEM_is_a", "TYPE2": "char *", "TYPE1": "EVP_KEM *"}, "assembly": "MOV EAX,0x0\nTEST RDI,RDI\nJZ 0x0019e045\nSUB RSP,0x8\nMOV RCX,RSI\nMOV RAX,RDI\nMOV RDI,qword ptr [RDI + 0x18]\nMOV EDX,0x0\nMOV ESI,dword ptr [RAX]\nCALL 0x0008c323\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nADD RSP,0x8\nRET\nRET\n"}, "421": {"funcbody": "/* DWARF original prototype: intmax_t xFormat_write_file(swCatalogFile * this) */\nintmax_t __thiscall swCatalogFile::[FUNC1] ([TYPE1] [VAR1] )\n{\n  int uxfio_fildes;\n  [TYPE3] [VAR3] ;\n  int iVar1;\n  undefined4 extraout_var;\n  [TYPE2] [VAR2] ;\n  off_t oVar2;\n  [TYPE4] [VAR4] ;\n  intmax_t iVar3;\n  \n  iVar1 = (*([VAR1] ->super_swPackageFile).super_swAttribute.super_swMetaData._vptr_swMetaData[0x16])()\n  ;\n  uxfio_fildes = (*([VAR1] ->super_swPackageFile).super_swAttribute.super_swMetaData._vptr_swMetaData\n                   [0x21])([VAR1] );\n  oVar2 = [FUNC3] (uxfio_fildes,0,2);\n  if ((int)oVar2 < 0) {\n    [FUNC4] (\"internal error in swAttributeFile::xFormat_write_file loc=1\\n\",1,0x3c,stderr);\n    [FUNC2] (0x21);\n  }\n  oVar2 = [FUNC3] (uxfio_fildes,0,1);\n  [FUNC9] ((XFORMAT *)swPackageFile::uxformatM->xxformatM,oVar2);\n  [FUNC5] ((XFORMAT *)swPackageFile::uxformatM->xxformatM,'0');\n  [FUNC8] ((XFORMAT *)swPackageFile::uxformatM->xxformatM,(char *)CONCAT44(extraout_var,iVar1)\n       );\n  [FUNC6] ((XFORMAT *)swPackageFile::uxformatM->xxformatM,1);\n  oVar2 = [FUNC3] (uxfio_fildes,0,0);\n  if (-1 < (int)oVar2) {\n    iVar3 = [FUNC7] ((XFORMAT *)swPackageFile::uxformatM->xxformatM,(stat *)0x0,\n                  (char *)CONCAT44(extraout_var,iVar1),(_func_int_int *)0x0,uxfio_fildes);\n    return iVar3;\n  }\n  [FUNC4] (\"internal error in swAttributeFile::xFormat_write_file loc=2\\n\",1,0x3c,stderr);\n  [FUNC2] (0x21);\n}", "answer": {"VAR1": "this", "VAR2": "name", "VAR3": "source_fd", "VAR4": "size", "FUNC2": "exit", "FUNC3": "uxfio_lseek", "FUNC1": "xFormat_write_file", "FUNC6": "xformat_set_nlink", "TYPE3": "int", "FUNC7": "xformat_write_file_by_fd", "TYPE2": "char *", "FUNC4": "fwrite", "FUNC5": "xformat_set_filetype_from_tartype", "TYPE4": "off_t", "FUNC8": "xformat_set_name", "FUNC9": "xformat_set_filesize", "TYPE1": "swCatalogFile *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RAX,qword ptr [RDI]\nCALL qword ptr [RAX + 0xb0]\nMOV RBP,RAX\nMOV RAX,qword ptr [RBX]\nMOV RDI,RBX\nCALL qword ptr [RAX + 0x108]\nMOV EBX,EAX\nMOV EDX,0x2\nMOV ESI,0x0\nMOV EDI,EAX\nCALL 0x0008aec0\nTEST EAX,EAX\nJS 0x000287a7\nMOV EDX,0x1\nMOV ESI,0x0\nMOV EDI,EBX\nCALL 0x0008aec0\nMOV RDX,qword ptr [0x002e9870]\nMOV RDI,qword ptr [RDX + 0x8]\nMOV RSI,RAX\nCALL 0x0008c9cf\nMOV RAX,qword ptr [0x002e9870]\nMOV RDI,qword ptr [RAX + 0x8]\nMOV ESI,0x30\nCALL 0x0008c8d7\nMOV RAX,qword ptr [0x002e9870]\nMOV RDI,qword ptr [RAX + 0x8]\nMOV RSI,RBP\nCALL 0x0008ca3b\nMOV RAX,qword ptr [0x002e9870]\nMOV RDI,qword ptr [RAX + 0x8]\nMOV ESI,0x1\nCALL 0x0008c9e1\nMOV EDX,0x0\nMOV ESI,0x0\nMOV EDI,EBX\nCALL 0x0008aec0\nTEST EAX,EAX\nJS 0x000287ce\nMOV RAX,qword ptr [0x002e9870]\nMOV RDI,qword ptr [RAX + 0x8]\nMOV R8D,EBX\nMOV ECX,0x0\nMOV RDX,RBP\nMOV ESI,0x0\nCALL 0x0008d758\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RCX,qword ptr [0x002e9380]\nMOV EDX,0x3c\nMOV ESI,0x1\nLEA RDI,[0xa2bc0]\nCALL 0x0001b570\nMOV EDI,0x21\nCALL 0x0001b240\nMOV RCX,qword ptr [0x002e9380]\nMOV EDX,0x3c\nMOV ESI,0x1\nLEA RDI,[0xa2c00]\nCALL 0x0001b570\nMOV EDI,0x21\nCALL 0x0001b240\n"}, "422": {"funcbody": "int [FUNC1] (TYPE11 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         TYPE56 [VAR5] )\n{\n  undefined8 uVar1;\n  ulong uVar2;\n  undefined8 *puVar3;\n  \n  if ([VAR2] == 1) {\n    if ([VAR4] + 1 < 0x6d) {\n      *(undefined8 *)([VAR1] ->sa).sa_data = 0;\n      *(undefined8 *)(([VAR1] ->s_un).sun_path + 100) = 0;\n      puVar3 = (undefined8 *)((ulong)(([VAR1] ->sa).sa_data + 8) & 0xfffffffffffffff8);\n      uVar2 = (ulong)(((int)([VAR1] ->sa).sa_data - (int)puVar3) + 0x6cU >> 3);\n      for (; uVar2 != 0; uVar2 = uVar2 - 1) {\n        *puVar3 = 0;\n        puVar3 = puVar3 + 1;\n      }\n      ([VAR1] ->sa).sa_family = 1;\n      [FUNC2] (([VAR1] ->sa).sa_data,(char *)[VAR3] ,0x6b);\n      return 1;\n    }\n  }\n  else {\n    if ([VAR2] != 2) {\n      if (([VAR2] == 10) && ([VAR4] == 0x10)) {\n        *(undefined8 *)(([VAR1] ->sa).sa_data + 2) = 0;\n        *(undefined8 *)(([VAR1] ->sa).sa_data + 10) = 0;\n        *(undefined8 *)((long)&([VAR1] ->s_in6).sin6_addr.__in6_u + 0xc) = 0;\n        ([VAR1] ->sa).sa_family = 10;\n        ([VAR1] ->s_in6).sin6_port = [VAR5] ;\n        uVar1 = *(undefined8 *)((long)[VAR3] + 8);\n        *(undefined8 *)(([VAR1] ->sa).sa_data + 6) = *[VAR3] ;\n        *(undefined8 *)((long)&([VAR1] ->s_in6).sin6_addr.__in6_u + 8) = uVar1;\n        return 1;\n      }\n      return 0;\n    }\n    if ([VAR4] == 4) {\n      *(undefined8 *)(([VAR1] ->sa).sa_data + 2) = 0;\n      *(undefined4 *)(([VAR1] ->sa).sa_data + 10) = 0;\n      ([VAR1] ->sa).sa_family = 2;\n      ([VAR1] ->s_in6).sin6_port = [VAR5] ;\n      ([VAR1] ->s_in6).sin6_flowinfo = *[VAR3] ;\n      return 1;\n    }\n  }\n  return 0;\n}", "answer": {"VAR1": "ap", "VAR2": "family", "VAR3": "where", "VAR4": "wherelen", "VAR5": "port", "FUNC2": "strncpy", "FUNC1": "BIO_ADDR_rawmake", "TYPE3": "void *", "TYPE2": "int", "TYPE5": "ushort", "TYPE4": "size_t", "TYPE1": "BIO_ADDR *"}, "assembly": "CMP ESI,0x1\nJZ 0x0012c98a\nCMP ESI,0x2\nJZ 0x0012c9ef\nCMP ESI,0xa\nJNZ 0x0012c984\nCMP RCX,0x10\nJZ 0x0012ca1e\nMOV EAX,0x0\nRET\nADD RCX,0x1\nMOV EAX,0x0\nCMP RCX,0x6c\nJBE 0x0012c99b\nRET\nPUSH RBX\nMOV R8,RDX\nMOV EBX,ESI\nMOV RDX,RDI\nLEA R9,[RDI + 0x2]\nMOV qword ptr [RDI + 0x2],0x0\nMOV qword ptr [RDI + 0x66],0x0\nLEA RDI,[RDI + 0xa]\nAND RDI,-0x8\nMOV RCX,R9\nSUB RCX,RDI\nADD ECX,0x6c\nSHR ECX,0x3\nMOV ECX,ECX\nMOV EAX,0x0\nSTOSQ.REP RDI\nMOV word ptr [RDX],0x1\nMOV EDX,0x6b\nMOV RSI,R8\nMOV RDI,R9\nCALL 0x00062750\nMOV EAX,EBX\nPOP RBX\nRET\nMOV EAX,0x0\nCMP RCX,0x4\nJNZ 0x0012c999\nMOV qword ptr [RDI + 0x4],0x0\nMOV dword ptr [RDI + 0xc],0x0\nMOV word ptr [RDI],0x2\nMOV word ptr [RDI + 0x2],R8W\nMOV EAX,dword ptr [RDX]\nMOV dword ptr [RDI + 0x4],EAX\nMOV EAX,0x1\nRET\nMOV qword ptr [RDI + 0x4],0x0\nMOV qword ptr [RDI + 0xc],0x0\nMOV qword ptr [RDI + 0x14],0x0\nMOV word ptr [RDI],SI\nMOV word ptr [RDI + 0x2],R8W\nMOV RAX,qword ptr [RDX]\nMOV RDX,qword ptr [RDX + 0x8]\nMOV qword ptr [RDI + 0x8],RAX\nMOV qword ptr [RDI + 0x10],RDX\nMOV EAX,0x1\nRET\n"}, "423": {"funcbody": "int [FUNC1] (TYPE15 [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  char *pcVar2;\n  \n  if ([VAR1] == (TYPE15)0x0) {\n    [FUNC6] ();\n    [FUNC5] (\"crypto/cmp/cmp_ctx.c\",0x364,\"OSSL_CMP_CTX_set1_no_proxy\");\n    [FUNC3] (0x3a,0x67,(char *)0x0);\n    iVar1 = 0;\n  }\n  else {\n    if ([VAR2] == (TYPE20x0) {\n      pcVar2 = (char *)0x0;\n    }\n    else {\n      pcVar2 = [FUNC4] ([VAR2] ,\"crypto/cmp/cmp_ctx.c\",0x364);\n      if (pcVar2 == (char *)0x0) {\n        return 0;\n      }\n    }\n    [FUNC2] ([VAR1] ->no_proxy);\n    [VAR1] ->no_proxy = pcVar2;\n    iVar1 = 1;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "val", "FUNC2": "CRYPTO_free", "FUNC3": "ERR_set_error", "FUNC1": "OSSL_CMP_CTX_set1_no_proxy", "FUNC6": "ERR_new", "TYPE2": "char *", "FUNC4": "CRYPTO_strdup", "FUNC5": "ERR_set_debug", "TYPE1": "OSSL_CMP_CTX *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nTEST RDI,RDI\nJZ 0x00085fc7\nMOV RDI,RSI\nTEST RSI,RSI\nJZ 0x00086004\nMOV EDX,0x364\nLEA RSI,[0x270934]\nCALL 0x000b3da8\nMOV RBP,RAX\nMOV EAX,0x0\nTEST RBP,RBP\nJZ 0x00085fc0\nMOV RDI,qword ptr [RBX + 0x58]\nMOV EDX,0x364\nLEA RSI,[0x270934]\nCALL 0x000b28d0\nMOV qword ptr [RBX + 0x58],RBP\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x00091b69\nLEA RDX,[0x270cd0]\nMOV ESI,0x364\nLEA RDI,[0x270934]\nCALL 0x00091c76\nMOV EDX,0x0\nMOV ESI,0x67\nMOV EDI,0x3a\nMOV EAX,0x0\nCALL 0x00091f8d\nMOV EAX,0x0\nJMP 0x00085fc0\nMOV EBP,0x0\nJMP 0x00085fa2\n"}, "424": {"funcbody": "OSSL_PARAM * [FUNC1] ([TYPE1] [VAR1] )\n{\n  uint uVar1;\n  bool bVar2;\n  \n  bVar2 = ([VAR1] & 0x84U) != 0;\n  uVar1 = (uint)bVar2;\n  if (([VAR1] & 3U) != 0) {\n    uVar1 = bVar2 + 2;\n  }\n  return dsa_types[(int)uVar1];\n}", "answer": {"VAR1": "selection", "FUNC1": "dsa_import_types", "TYPE1": "int"}, "assembly": "TEST DIL,0x84\nSETNZ AL\nMOVZX EAX,AL\nAND EDI,0x3\nLEA EDX,[RAX + 0x2]\nTEST EDI,EDI\nCMOVNZ EAX,EDX\nCDQE\nLEA RDX,[0x5467e0]\nMOV RAX,qword ptr [RDX + RAX*0x8]\nRET\n"}, "425": {"funcbody": "undefined8 [FUNC1] (undefined8 *param_1)\n{\n  undefined8 uVar1;\n  \n  if ((((ulong)param_1 & 6) == 0) &&\n     (((ulong)*(ushort *)param_1 != *(ulong *)PTR_scm_tc16_port_with_ps_0013f9b0 ||\n      (param_1 = (undefined8 *)param_1[1], ((ulong)param_1 & 6) == 0)))) {\n    uVar1 = 4;\n    if (((uint)*param_1 & 0x47f) == 0x47d) {\n      uVar1 = 0x404;\n    }\n    return uVar1;\n  }\n  return 4;\n}", "answer": {"FUNC1": "scm_output_port_p"}, "assembly": "ENDBR64\nMOV EAX,0x4\nTEST DIL,0x6\nJNZ 0x0008e205\nMOVZX EDX,word ptr [RDI]\nMOV RAX,qword ptr [0x0013f9b0]\nCMP RDX,qword ptr [RAX]\nJZ 0x0008e1f6\nMOV RAX,qword ptr [RDI]\nAND EAX,0x47f\nCMP RAX,0x47d\nMOV EAX,0x4\nMOV EDX,0x404\nCMOVZ RAX,RDX\nRET\nMOV RDI,qword ptr [RDI + 0x8]\nTEST DIL,0x6\nJZ 0x0008e1d9\nMOV EAX,0x4\nRET\n"}, "426": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  [TYPE5] [VAR5] ;\n  \n  iVar1 = [VAR2] + transformation[0x2f7][VAR1];\n  if (stackp == 0) {\n    return worm[iVar1].attack_codes[0];\n  }\n  iVar1 = [FUNC2] (iVar1,(int *)0x0);\n  return iVar1;\n}", "answer": {"VAR1": "trans", "VAR2": "move", "VAR3": "color", "VAR4": "action", "VAR5": "A", "FUNC2": "attack", "FUNC1": "autohelperbarrierspat40", "TYPE3": "int", "TYPE2": "int", "TYPE5": "int", "TYPE4": "int", "TYPE1": "int"}, "assembly": "MOVSXD RDI,EDI\nLEA RAX,[0xcc6f20]\nADD ESI,dword ptr [RAX + RDI*0x4 + 0x5ee0]\nMOV EDI,ESI\nCMP dword ptr [0x00c2d064],0x0\nJNZ 0x001bfd4d\nMOVSXD RSI,ESI\nIMUL RSI,RSI,0x17c\nLEA RAX,[0xc33880]\nMOV EAX,dword ptr [RAX + RSI*0x1 + 0x64]\nRET\nSUB RSP,0x8\nMOV ESI,0x0\nCALL 0x00186451\nADD RSP,0x8\nRET\n"}, "427": {"funcbody": "object [FUNC1] ([TYPE1] [VAR1] ,...)\n{\n  long lVar1;\n  char in_AL;\n  object plVar2;\n  [TYPE2] [VAR2] ;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  [TYPE18] [VAR18] ;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  undefined8 [VAR15] ;\n  undefined8 [VAR14] ;\n  undefined8 [VAR13] ;\n  undefined8 [VAR12] ;\n  undefined8 [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  if (in_AL != '\\0') {\n    [VAR10] ._0_4_ = in_XMM0_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR18] [0].gp_offset = 8;\n  [VAR18] [0].fp_offset = 0x30;\n  [VAR18] [0].overflow_arg_area = &stack0x00000008;\n  [VAR18] [0].reg_save_area = &[VAR16] ;\n  [VAR15] = in_RSI;\n  [VAR14] = in_RDX;\n  [VAR13] = in_RCX;\n  [VAR12] = in_R8;\n  [VAR11] = in_R9;\n  plVar2 = [FUNC3] ((object)VVi[234],gcl_init_alloc::lexical_block_1::estack_buf + 0x3dac0,[VAR1] ,[VAR18] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return plVar2;\n  }\n  [FUNC2] ();\n}", "answer": {"TYPE17": "undefined8", "TYPE18": "va_list", "VAR1": "first", "VAR2": "V1", "VAR3": "local_18", "VAR4": "local_28", "VAR5": "local_38", "VAR6": "local_48", "FUNC2": "__stack_chk_fail", "FUNC3": "call_vproc_new", "FUNC1": "LnkTLI234", "TYPE3": "undefined1[16]", "VAR14": "local_a8", "TYPE2": "object", "VAR15": "local_b0", "TYPE5": "undefined1[16]", "VAR12": "local_98", "TYPE4": "undefined1[16]", "VAR13": "local_a0", "TYPE7": "undefined1[16]", "VAR18": "ap", "TYPE6": "undefined1[16]", "TYPE9": "undefined1[16]", "VAR16": "local_b8", "TYPE8": "undefined1[16]", "VAR17": "local_c0", "VAR7": "local_58", "TYPE11": "undefined8", "VAR8": "local_68", "TYPE12": "undefined8", "VAR9": "local_78", "TYPE10": "undefined1[16]", "VAR10": "local_88", "TYPE15": "undefined8", "VAR11": "local_90", "TYPE16": "undefined1", "TYPE1": "object", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "SUB RSP,0xd8\nMOV qword ptr [RSP + 0x28],RSI\nMOV qword ptr [RSP + 0x30],RDX\nMOV qword ptr [RSP + 0x38],RCX\nMOV qword ptr [RSP + 0x40],R8\nMOV qword ptr [RSP + 0x48],R9\nTEST AL,AL\nJZ 0x003624dc\nMOVAPS xmmword ptr [RSP + 0x50],XMM0\nMOVAPS xmmword ptr [RSP + 0x60],XMM1\nMOVAPS xmmword ptr [RSP + 0x70],XMM2\nMOVAPS xmmword ptr [RSP + 0x80],XMM3\nMOVAPS xmmword ptr [RSP + 0x90],XMM4\nMOVAPS xmmword ptr [RSP + 0xa0],XMM5\nMOVAPS xmmword ptr [RSP + 0xb0],XMM6\nMOVAPS xmmword ptr [RSP + 0xc0],XMM7\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0x8\nMOV dword ptr [RSP + 0x4],0x30\nLEA RAX,[RSP + 0xe0]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nMOV RCX,RSP\nMOV RDX,RDI\nMOV ESI,0x945400\nMOV RDI,qword ptr [0x00745b90]\nCALL 0x001b582c\nMOV RDX,qword ptr [RSP + 0x18]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x00362541\nADD RSP,0xd8\nRET\nCALL 0x0010bc40\n"}, "428": {"funcbody": "int [FUNC1] (TYPE18 [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  OSSL_PARAM *pOVar2;\n  [TYPE3] [VAR3] ;\n  size_t sVar3;\n  long in_FS_OFFSET;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  long [VAR4] ;\n  \n  [VAR4] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR6] = -1;\n  [VAR5] = -1;\n  pOVar2 = [FUNC2] ([VAR2] ,\"point-format\");\n  if (pOVar2 != (OSSL_PARAM *)0x0) {\n    iVar1 = [FUNC8] (pOVar2,&[VAR5] );\n    if (iVar1 == 0) {\n      [FUNC6] ();\n      [FUNC10] (\"crypto/ec/ec_lib.c\",0x5e6,\"ossl_ec_group_set_params\");\n      [FUNC3] (0x10,0x68,(char *)0x0);\n      iVar1 = 0;\n      goto LAB_0016943d;\n    }\n    [FUNC11] ((EC_GROUP *)[VAR1] ,[VAR5] );\n  }\n  pOVar2 = [FUNC2] ([VAR2] ,\"encoding\");\n  if (pOVar2 != (OSSL_PARAM *)0x0) {\n    iVar1 = [FUNC9] (pOVar2,&[VAR6] );\n    if (iVar1 == 0) {\n      [FUNC6] ();\n      [FUNC10] (\"crypto/ec/ec_lib.c\",0x5ef,\"ossl_ec_group_set_params\");\n      [FUNC3] (0x10,0x68,(char *)0x0);\n      iVar1 = 0;\n      goto LAB_0016943d;\n    }\n    [FUNC7] ((EC_GROUP *)[VAR1] ,[VAR6] );\n  }\n  pOVar2 = [FUNC2] ([VAR2] ,\"seed\");\n  iVar1 = 1;\n  if ((pOVar2 != (OSSL_PARAM *)0x0) &&\n     ((pOVar2->data_type != 5 ||\n      (sVar3 = [FUNC4] ((EC_GROUP *)[VAR1] ,(uchar *)pOVar2->data,pOVar2->data_size), sVar3 == 0)))) {\n    [FUNC6] ();\n    [FUNC10] (\"crypto/ec/ec_lib.c\",0x5fa,\"ossl_ec_group_set_params\");\n    [FUNC3] (0x10,0xaf,(char *)0x0);\n    iVar1 = 0;\n  }\nLAB_0016943d:\n  if ([VAR4] != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC5] ();\n  }\n  return iVar1;\n}", "answer": {"FUNC11": "EC_GROUP_set_point_conversion_form", "VAR1": "group", "VAR2": "params", "VAR3": "p", "VAR4": "local_20", "FUNC10": "ERR_set_debug", "VAR5": "format", "VAR6": "encoding_flag", "FUNC2": "OSSL_PARAM_locate_const", "FUNC3": "ERR_set_error", "FUNC1": "ossl_ec_group_set_params", "FUNC6": "ERR_new", "TYPE3": "OSSL_PARAM *", "FUNC7": "EC_GROUP_set_asn1_flag", "TYPE2": "OSSL_PARAM *", "FUNC4": "EC_GROUP_set_seed", "TYPE5": "int", "FUNC5": "__stack_chk_fail", "TYPE4": "undefined8", "TYPE6": "int", "FUNC8": "ossl_ec_pt_format_param2id", "FUNC9": "ossl_ec_encoding_param2id", "TYPE1": "EC_GROUP *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x10\nMOV R12,RDI\nMOV RBP,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0xffffffff\nMOV dword ptr [RSP + 0x4],0xffffffff\nLEA RSI,[0x265654]\nMOV RDI,RBP\nCALL 0x000a5037\nTEST RAX,RAX\nJZ 0x00169373\nLEA RSI,[RSP + 0x4]\nMOV RDI,RAX\nCALL 0x00163b84\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x00169407\nMOV ESI,dword ptr [RSP + 0x4]\nMOV RDI,R12\nCALL 0x001670d6\nLEA RSI,[0x298a26]\nMOV RDI,RBP\nCALL 0x000a5037\nTEST RAX,RAX\nJZ 0x001693a7\nMOV RSI,RSP\nMOV RDI,RAX\nCALL 0x00163af9\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x00169458\nMOV ESI,dword ptr [RSP]\nMOV RDI,R12\nCALL 0x001670ce\nLEA RSI,[0x2ac1a8]\nMOV RDI,RBP\nCALL 0x000a5037\nMOV EBX,0x1\nTEST RAX,RAX\nJZ 0x0016943d\nCMP dword ptr [RAX + 0x8],0x5\nJZ 0x00169490\nCALL 0x0008a597\nLEA RDX,[0x293d80]\nMOV ESI,0x5fa\nLEA RDI,[0x293d1b]\nCALL 0x0008a6a4\nMOV EDX,0x0\nMOV ESI,0xaf\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x0008a9bb\nMOV EBX,0x0\nJMP 0x0016943d\nCALL 0x0008a597\nLEA RDX,[0x293d80]\nMOV ESI,0x5e6\nLEA RDI,[0x293d1b]\nCALL 0x0008a6a4\nMOV EDX,0x0\nMOV ESI,0x68\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x0008a9bb\nMOV EAX,EBX\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x001694ab\nADD RSP,0x10\nPOP RBX\nPOP RBP\nPOP R12\nRET\nCALL 0x0008a597\nLEA RDX,[0x293d80]\nMOV ESI,0x5ef\nLEA RDI,[0x293d1b]\nCALL 0x0008a6a4\nMOV EDX,0x0\nMOV ESI,0x68\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x0008a9bb\nJMP 0x0016943d\nMOV RDX,qword ptr [RAX + 0x18]\nMOV RSI,qword ptr [RAX + 0x10]\nMOV RDI,R12\nCALL 0x001670de\nTEST RAX,RAX\nJZ 0x001693ca\nJMP 0x0016943d\nCALL 0x00062640\n"}, "429": {"funcbody": "asn1_iterator_result [FUNC1] ([TYPE1] [VAR1] )\n{\n  asn1_iterator_result aVar1;\n  \n  if ([VAR1] ->buffer_length != [VAR1] ->pos) {\n    return ASN1_ITERATOR_ERROR;\n  }\n  aVar1 = [FUNC2] ([VAR1] ,[VAR1] );\n  return aVar1;\n}", "answer": {"VAR1": "i", "FUNC2": "nettle_asn1_der_decode_bitstring", "FUNC1": "nettle_asn1_der_decode_bitstring_last", "TYPE1": "asn1_der_iterator *"}, "assembly": "MOV EAX,0x0\nMOV RDX,qword ptr [RDI + 0x10]\nCMP qword ptr [RDI],RDX\nJZ 0x00011552\nRET\nSUB RSP,0x8\nMOV RSI,RDI\nCALL 0x000088b0\nADD RSP,0x8\nRET\n"}, "430": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] )\n{\n  char cVar1;\n  long lVar2;\n  char *pcVar3;\n  ulong uVar4;\n  [TYPE2] [VAR2] ;\n  char *pcVar5;\n  [TYPE3] [VAR3] ;\n  undefined *puVar6;\n  long in_FS_OFFSET;\n  undefined8 uStack_30;\n  [TYPE6] [VAR6] ;\n  undefined auStack_28 [8];\n  long [VAR5] ;\n  [TYPE4] [VAR4] ;\n  \n  puVar6 = auStack_28;\n  [VAR5] = *(long *)(in_FS_OFFSET + 0x28);\n  if (*[VAR1] == '/') {\n    uStack_30 = 0x4606e;\n    pcVar3 = [FUNC2] ([VAR1] );\n  }\n  else {\n    uVar4 = 0xffffffffffffffff;\n    pcVar3 = _gst_executable_path;\n    do {\n      if (uVar4 == 0) break;\n      uVar4 = uVar4 - 1;\n      cVar1 = *pcVar3;\n      pcVar3 = pcVar3 + 1;\n    } while (cVar1 != '\\0');\n    pcVar3 = _gst_executable_path + (~uVar4 - 1);\n    do {\n      pcVar5 = pcVar3;\n      if (pcVar5 + -1 < _gst_executable_path) break;\n      pcVar3 = pcVar5 + -1;\n    } while (pcVar5[-1] != '/');\n    uVar4 = 0xffffffffffffffff;\n    do {\n      if (uVar4 == 0) break;\n      uVar4 = uVar4 - 1;\n      cVar1 = *[VAR1] ;\n      [VAR1] = [VAR1] + 1;\n    } while (cVar1 != '\\0');\n    lVar2 = -(((long)pcVar5 - (long)_gst_executable_path) + 0x1e + ~uVar4 & 0xfffffffffffffff0);\n    puVar6 = auStack_28 + lVar2;\n    *(undefined8 *)((long)&stack0xffffffffffffffd0 + lVar2) = 0x460c8;\n    [FUNC5] ((char *)((long)&[VAR5] + lVar2),\"%.*s%s\",(long)pcVar5 - (long)_gst_executable_path,\n          _gst_executable_path);\n    *(undefined8 *)((long)&stack0xffffffffffffffd0 + lVar2) = 0x460d0;\n    pcVar3 = [FUNC3] ((char *)((long)&[VAR5] + lVar2));\n  }\n  if ([VAR5] != *(long *)(in_FS_OFFSET + 0x28)) {\n    *(code **)(puVar6 + -8) = _gst_set_executable_path;\n    [FUNC4] ();\n  }\n  return pcVar3;\n}", "answer": {"VAR1": "path", "VAR2": "p", "VAR3": "s", "VAR4": "local_10", "VAR5": "local_20", "VAR6": "local_29", "FUNC2": "xstrdup", "FUNC3": "_gst_get_full_file_name", "FUNC1": "_gst_relocate_path", "TYPE3": "char *", "TYPE2": "char *", "FUNC4": "__stack_chk_fail", "TYPE5": "undefined8", "FUNC5": "snv_sprintf", "TYPE4": "undefined8", "TYPE6": "undefined1", "TYPE1": "char *"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nPUSH RBX\nSUB RSP,0x18\nMOV R8,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RBP + -0x18],RAX\nXOR EAX,EAX\nCMP byte ptr [RDI],0x2f\nJZ 0x00046069\nLEA RAX,[0x2ba1c0]\nMOV RSI,qword ptr [RAX]\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,RSI\nSCASB.REPNE RDI\nMOV RBX,RCX\nNOT RBX\nLEA RDX,[RSI + RBX*0x1 + -0x1]\nJMP 0x00046073\nCALL 0x0004fb17\nJMP 0x000460d0\nMOV RDX,RAX\nLEA RAX,[RDX + -0x1]\nCMP RSI,RAX\nJA 0x00046082\nCMP byte ptr [RDX + -0x1],0x2f\nJNZ 0x00046070\nSUB RDX,RSI\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,R8\nSCASB.REPNE RDI\nMOV RBX,RCX\nNOT RBX\nLEA RAX,[RDX + RBX*0x1 + 0x1e]\nAND RAX,-0x10\nSUB RSP,RAX\nLEA RBX,[RSP + 0xf]\nAND RBX,-0x10\nMOV RCX,RSI\nLEA RSI,[0x9701a]\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x0008a2ea\nMOV RDI,RBX\nCALL 0x00045ca0\nMOV RBX,qword ptr [RBP + -0x18]\nXOR RBX,qword ptr FS:[0x28]\nJNZ 0x000460e5\nMOV RBX,qword ptr [RBP + -0x8]\nLEAVE\nRET\nCALL 0x0000fd50\n"}, "431": {"funcbody": "uint [FUNC1] (TYPE19 [VAR1] )\n{\n  int iVar1;\n  uint uVar2;\n  [TYPE2] [VAR2] ;\n  \n  iVar1 = [FUNC2] ([VAR1] );\n  uVar2 = 0;\n  if (iVar1 != 0) {\n    uVar2 = [FUNC4] ([VAR1] );\n    [FUNC3] ([VAR1] );\n  }\n  return uVar2;\n}", "answer": {"VAR1": "ctx", "VAR2": "res", "FUNC2": "evp_rand_lock", "FUNC3": "evp_rand_unlock", "FUNC1": "EVP_RAND_get_strength", "TYPE2": "uint", "FUNC4": "evp_rand_strength_locked", "TYPE1": "EVP_RAND_CTX *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nCALL 0x00193f68\nMOV EBP,0x0\nTEST EAX,EAX\nJNZ 0x00194d86\nMOV EAX,EBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RDI,RBX\nCALL 0x001945ca\nMOV EBP,EAX\nMOV RDI,RBX\nCALL 0x00193f89\nJMP 0x00194d7d\n"}, "432": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  [TYPE6] [VAR6] ;\n  char *__ptr;\n  [TYPE4] [VAR4] ;\n  char *pcVar2;\n  void *pvVar3;\n  [TYPE5] [VAR5] ;\n  char *pcVar4;\n  [TYPE7] [VAR7] ;\n  char cVar5;\n  char *pcVar6;\n  int [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  \n  __ptr = [FUNC4] ([VAR1] );\n  if (__ptr == (char *)0x0) {\n    [VAR11] = -1;\n  }\n  else {\n    [VAR11] = 0;\n    pcVar4 = __ptr;\n    while (cVar5 = *pcVar4, pcVar6 = pcVar4, cVar5 != '\\0') {\n      while (pcVar4 = [FUNC2] (\"\\t, \",(int)cVar5), pcVar4 != (char *)0x0) {\n        pcVar6 = pcVar6 + 1;\n        cVar5 = *pcVar6;\n        if (cVar5 == '\\0') goto cleanup;\n      }\n      pcVar4 = pcVar6;\n      if (cVar5 == '\\0') break;\n      while( true ) {\n        while ((cVar5 = *pcVar4, cVar5 != '\\0' &&\n               (pcVar2 = [FUNC2] (\"\\t, \",(int)cVar5), pcVar2 == (char *)0x0))) {\n          pcVar4 = pcVar4 + 1;\n        }\n        pvVar3 = [FUNC5] (pcVar6,0x5b,(long)pcVar4 - (long)pcVar6);\n        if ((((pvVar3 == (void *)0x0) ||\n             (pvVar3 = [FUNC5] (pcVar6,0x5d,(long)pcVar4 - (long)pcVar6), pvVar3 != (void *)0x0)) ||\n            (pcVar2 = [FUNC2] (pcVar4,0x5d), pcVar2 == (char *)0x0)) ||\n           (pvVar3 = [FUNC5] (pcVar4,0x5b,(long)pcVar2 - (long)pcVar4), pvVar3 != (void *)0x0)) break;\n        pcVar4 = pcVar2 + 1;\n      }\n      while ((cVar5 != '\\0' && (pcVar2 = [FUNC2] (\"\\t, \",(int)cVar5), pcVar2 != (char *)0x0))) {\n        *pcVar4 = '\\0';\n        cVar5 = pcVar4[1];\n        pcVar4 = pcVar4 + 1;\n      }\n      if (pcVar6 == (char *)0x0) break;\n      pcVar6 = [FUNC6] (pcVar6);\n      iVar1 = (*[VAR3] )([VAR2] ->hl,pcVar6);\n      [FUNC3] (pcVar6);\n      if (iVar1 == 0) {\n        [VAR11] = -1;\n        break;\n      }\n      [VAR11] = [VAR11] + iVar1;\n    }\n  }\ncleanup:\n  [FUNC3] (__ptr);\n  return [VAR11] ;\n}", "answer": {"VAR1": "hosts", "VAR2": "fihl", "VAR3": "hfn", "VAR4": "copy", "VAR5": "tok_parsed", "VAR6": "ret", "FUNC2": "strchr", "FUNC3": "free", "FUNC1": "_fi_hosts", "FUNC6": "_fi_preparse_host", "TYPE3": "HostlistFn *", "TYPE2": "fi_hostlist_t", "FUNC4": "strdup", "TYPE5": "char *", "FUNC5": "memchr", "TYPE4": "char *", "TYPE7": "char *", "TYPE6": "int", "TYPE9": "undefined8", "TYPE8": "undefined8", "VAR7": "q", "TYPE11": "undefined4", "VAR8": "local_40", "VAR9": "local_48", "TYPE10": "undefined8", "VAR10": "local_50", "VAR11": "local_54", "TYPE1": "char *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV qword ptr [RSP + 0x8],RSI\nMOV qword ptr [RSP + 0x10],RDX\nCALL 0x000045a0\nMOV qword ptr [RSP + 0x18],RAX\nTEST RAX,RAX\nJZ 0x0001c191\nMOV R12,RAX\nMOV dword ptr [RSP + 0x4],0x0\nLEA R14,[0x25288]\nJMP 0x0001c10c\nTEST BL,BL\nJZ 0x0001c136\nMOV RBP,R12\nJMP 0x0001c05e\nADD RBP,0x1\nMOVZX EBX,byte ptr [RBP]\nTEST BL,BL\nJZ 0x0001c076\nMOVSX ESI,BL\nMOV RDI,R14\nCALL 0x00004520\nTEST RAX,RAX\nJZ 0x0001c05a\nMOV R13,RBP\nSUB R13,R12\nMOV RDX,R13\nMOV ESI,0x5b\nMOV RDI,R12\nCALL 0x00004100\nTEST RAX,RAX\nJZ 0x0001c0aa\nMOV RDX,R13\nMOV ESI,0x5d\nMOV RDI,R12\nCALL 0x00004100\nTEST RAX,RAX\nJZ 0x0001c153\nTEST BL,BL\nJZ 0x0001c0ce\nMOVSX ESI,BL\nMOV RDI,R14\nCALL 0x00004520\nTEST RAX,RAX\nJZ 0x0001c0ce\nADD RBP,0x1\nMOV byte ptr [RBP + -0x1],0x0\nMOVZX EBX,byte ptr [RBP]\nTEST BL,BL\nJNZ 0x0001c0ae\nTEST R12,R12\nJZ 0x0001c136\nMOV RDI,R12\nCALL 0x0001bec3\nMOV RBX,RAX\nMOV RSI,RAX\nMOV RAX,qword ptr [RSP + 0x8]\nMOV RDI,qword ptr [RAX]\nMOV RAX,qword ptr [RSP + 0x10]\nCALL RAX\nMOV R12D,EAX\nMOV RDI,RBX\nCALL 0x00004330\nTEST R12D,R12D\nJZ 0x0001c19b\nADD dword ptr [RSP + 0x4],R12D\nMOV R12,RBP\nMOVZX EBX,byte ptr [R12]\nTEST BL,BL\nJZ 0x0001c136\nMOVSX ESI,BL\nMOV RDI,R14\nCALL 0x00004520\nTEST RAX,RAX\nJZ 0x0001c04d\nADD R12,0x1\nMOVZX EBX,byte ptr [R12]\nTEST BL,BL\nJNZ 0x0001c115\nMOV RDI,qword ptr [RSP + 0x18]\nCALL 0x00004330\nMOV EAX,dword ptr [RSP + 0x4]\nADD RSP,0x28\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV ESI,0x5d\nMOV RDI,RBP\nCALL 0x00004520\nMOV R13,RAX\nTEST RAX,RAX\nJZ 0x0001c0aa\nMOV RDX,RAX\nSUB RDX,RBP\nMOV ESI,0x5b\nMOV RDI,RBP\nCALL 0x00004100\nTEST RAX,RAX\nJNZ 0x0001c0aa\nLEA RBP,[R13 + 0x1]\nJMP 0x0001c05e\nMOV dword ptr [RSP + 0x4],0xffffffff\nJMP 0x0001c136\nMOV dword ptr [RSP + 0x4],0xffffffff\nJMP 0x0001c136\n"}, "433": {"funcbody": "OSSL_PARAM * [FUNC1] (TYPE12 [VAR1] )\n{\n  OSSL_PROVIDER *prov;\n  void *pvVar1;\n  [TYPE2] [VAR2] ;\n  OSSL_PARAM *pOVar2;\n  \n  if ([VAR1] ->gettable_ctx_params != (undefined1 *)0x0) {\n    prov = [FUNC3] ([VAR1] );\n    pvVar1 = [FUNC2] (prov);\n    pOVar2 = (OSSL_PARAM *)(*(code *)[VAR1] ->gettable_ctx_params)(0,pvVar1);\n    return pOVar2;\n  }\n  return (OSSL_PARAM *)0x0;\n}", "answer": {"VAR1": "kdf", "VAR2": "alg", "FUNC2": "ossl_provider_ctx", "FUNC3": "EVP_KDF_get0_provider", "FUNC1": "EVP_KDF_gettable_ctx_params", "TYPE2": "void *", "TYPE1": "EVP_KDF *"}, "assembly": "CMP qword ptr [RDI + 0x60],0x0\nJZ 0x001d8a4b\nPUSH RBX\nMOV RBX,RDI\nCALL 0x001d84db\nMOV RDI,RAX\nCALL 0x000c26e8\nMOV RSI,RAX\nMOV EDI,0x0\nCALL qword ptr [RBX + 0x60]\nPOP RBX\nRET\nMOV EAX,0x0\nRET\n"}, "434": {"funcbody": "void [FUNC1] (void)\n{\n  int iVar1;\n  ENGINE *e;\n  TYPE11 [VAR1] ;\n  \n  if ((DAT_005794b4._3_1_ & 0x40) == 0) {\n    return;\n  }\n  e = [FUNC12] ();\n  if (e != (ENGINE *)0x0) {\n    iVar1 = [FUNC5] (e,\"rdrand\");\n    if ((((iVar1 != 0) && (iVar1 = [FUNC6] (e,\"Intel RDRAND engine\"), iVar1 != 0)) &&\n        (iVar1 = [FUNC7] (e,8), iVar1 != 0)) &&\n       ((iVar1 = [FUNC10] (e,[FUNC9] ), iVar1 != 0 &&\n        (iVar1 = [FUNC2] (e,(RAND_METHOD *)&rdrand_meth), iVar1 != 0)))) {\n      [FUNC11] ();\n      [FUNC8] (e);\n      [FUNC3] (e);\n      [FUNC4] ();\n      return;\n    }\n    [FUNC3] (e);\n  }\n  return;\n}", "answer": {"FUNC12": "ENGINE_new", "FUNC11": "ERR_set_mark", "VAR1": "ret", "FUNC10": "ENGINE_set_init_function", "FUNC2": "ENGINE_set_RAND", "FUNC3": "ENGINE_free", "FUNC1": "engine_load_rdrand_int", "FUNC6": "ENGINE_set_name", "FUNC7": "ENGINE_set_flags", "FUNC4": "ERR_pop_to_mark", "FUNC5": "ENGINE_set_id", "FUNC8": "ENGINE_add", "FUNC9": "rdrand_init", "TYPE1": "ENGINE *"}, "assembly": "LEA RAX,[0x5794b0]\nTEST byte ptr [RAX + 0x7],0x40\nJNZ 0x0017e838\nRET\nPUSH RBX\nCALL 0x0017cbbd\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x0017e8cb\nLEA RSI,[0x2942f8]\nMOV RDI,RAX\nCALL 0x0017ceca\nTEST EAX,EAX\nJNZ 0x0017e867\nMOV RDI,RBX\nCALL 0x0017cdb1\nJMP 0x0017e8cb\nLEA RSI,[0x2942ff]\nMOV RDI,RBX\nCALL 0x0017cf1c\nTEST EAX,EAX\nJZ 0x0017e85d\nMOV ESI,0x8\nMOV RDI,RBX\nCALL 0x0017cf97\nTEST EAX,EAX\nJZ 0x0017e85d\nLEA RSI,[0x17e801]\nMOV RDI,RBX\nCALL 0x0017cf79\nTEST EAX,EAX\nJZ 0x0017e85d\nLEA RSI,[0x56d4e0]\nMOV RDI,RBX\nCALL 0x0017f9c0\nTEST EAX,EAX\nJZ 0x0017e85d\nCALL 0x000820b2\nMOV RDI,RBX\nCALL 0x0017d47b\nMOV RDI,RBX\nCALL 0x0017cdb1\nCALL 0x000820e8\nPOP RBX\nRET\n"}, "435": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] ,[TYPE8] [VAR8] )\n{\n  if ([VAR5] != (TYPE50x0) {\n    *(double *)[VAR5] = [VAR2] ->doubleval;\n    return 0;\n  }\n  [FUNC2] ([VAR1] ,0x11);\n  return -1;\n}", "answer": {"VAR1": "cf", "VAR2": "data", "VAR3": "optionname", "VAR4": "option_type", "VAR5": "option_ptr", "VAR6": "option_data", "FUNC2": "conffile_seterrnum", "FUNC1": "conffile_double", "TYPE3": "char *", "TYPE2": "conffile_data *", "TYPE5": "void *", "TYPE4": "int", "TYPE7": "void *", "TYPE6": "int", "TYPE8": "int", "VAR7": "app_ptr", "VAR8": "app_data", "TYPE1": "conffile_t"}, "assembly": "TEST R8,R8\nJZ 0x001ed82c\nMOVSD XMM0,qword ptr [RSI + 0x8]\nMOVSD qword ptr [R8],XMM0\nMOV EAX,0x0\nRET\nSUB RSP,0x8\nMOV ESI,0x11\nCALL 0x001ec93d\nMOV EAX,0xffffffff\nADD RSP,0x8\nRET\n"}, "436": {"funcbody": "void [FUNC1] (void)\n{\n  object *pplVar1;\n  int iVar2;\n  Screen *i;\n  undefined4 extraout_var;\n  [TYPE2] [VAR2] ;\n  [TYPE3] [VAR3] ;\n  [TYPE4] [VAR4] ;\n  [TYPE1] [VAR1] ;\n  long i_00;\n  \n  pplVar1 = vs_base;\n  i = (Screen *)[FUNC3] (*vs_base);\n  iVar2 = [FUNC2] (i);\n  i_00 = CONCAT44(extraout_var,iVar2);\n  vs_top = pplVar1 + 1;\n  vs_base = pplVar1;\n  if ((i_00 + 0x2000000000000000U & 0xc000000000000000) == 0) {\n    [VAR4] = ([TYPE4] (i_00 + -0x6000000000000000);\n  }\n  else {\n    [VAR4] = [FUNC4] (i_00);\n  }\n  *vs_base = [VAR4] ;\n  return;\n}", "answer": {"VAR1": "old_base", "VAR2": "x", "VAR3": "_q1", "VAR4": "_q4", "FUNC2": "Screen_root_input_mask", "FUNC3": "object_to_fixnum", "FUNC1": "L89", "TYPE3": "fixnum", "TYPE2": "fixnum", "FUNC4": "make_fixnum1", "TYPE4": "object", "TYPE1": "object *"}, "assembly": "PUSH RBX\nMOV RBX,qword ptr [0x00971288]\nMOV RDI,qword ptr [RBX]\nCALL 0x0018c8b8\nMOV RDI,RAX\nCALL 0x0047711f\nMOV qword ptr [0x00971288],RBX\nADD RBX,0x8\nMOV qword ptr [0x00a86200],RBX\nMOV RDX,0x2000000000000000\nADD RDX,RAX\nMOV RCX,-0x4000000000000000\nTEST RDX,RCX\nJNZ 0x002a6a99\nMOV RDI,-0x6000000000000000\nADD RAX,RDI\nMOV RDX,qword ptr [0x00971288]\nMOV qword ptr [RDX],RAX\nPOP RBX\nRET\nMOV RDI,RAX\nCALL 0x0013926f\nJMP 0x002a6a8d\n"}, "437": {"funcbody": "undefined8 [FUNC1] (void)\n{\n  long lVar1;\n  double dVar2;\n  undefined8 uStack_18;\n  \n  lVar1 = 0;\n  do {\n    dVar2 = [FUNC2] ((double)(int)lVar1 * _DAT_01324170);\n    (&DAT_025129e0)[lVar1] = (float)dVar2;\n    lVar1 = lVar1 + 1;\n  } while (lVar1 != 0x10);\n  DAT_02512a20 = 0;\n  return uStack_18;\n}", "answer": {"FUNC2": "cos", "FUNC1": "FUN_0019dc98"}, "assembly": "PUSH RBP\nPUSH RBX\nXOR EBX,EBX\nSUB RSP,0x8\nLEA RBP,[0x25129e0]\nCVTSI2SD XMM0,EBX\nMULSD XMM0,qword ptr [0x01324170]\nCALL 0x0010edf8\nCVTSD2SS XMM1,XMM0\nMOVSS dword ptr [RBP + RBX*0x4],XMM1\nINC RBX\nCMP RBX,0x10\nJNZ 0x0019dca7\nMOV dword ptr [RBP + 0x40],0x0\nPOP RAX\nPOP RBX\nPOP RBP\nRET\n"}, "438": {"funcbody": "int [FUNC1] (TYPE18 [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  int iVar1;\n  int iVar2;\n  long lVar3;\n  long in_FS_OFFSET;\n  [TYPE5] [VAR5] ;\n  long [VAR4] ;\n  \n  [VAR4] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR5] = ([TYPE5] )0x0;\n  if (([VAR1] == (TYPE18)0x0) ||\n     (([VAR3] == ([TYPE3] )0x0 && ([VAR2] != (TYPE20x0)))) {\n    [FUNC6] ();\n    [FUNC9] (\"crypto/http/http_client.c\",0x113,\"set1_content\");\n    [FUNC7] (0x3d,0xc0102,(char *)0x0);\n    iVar1 = 0;\n    goto LAB_001df8d3;\n  }\n  if ([VAR1] ->keep_alive != 0) {\n    iVar1 = [FUNC12] ([VAR1] ,\"Connection\",\"keep-alive\");\n    if (iVar1 == 0) goto LAB_001df8d3;\n  }\n  [FUNC3] ((BIO *)[VAR1] ->req);\n  [VAR1] ->req = (BIO *)0x0;\n  iVar1 = 1;\n  if ([VAR3] == ([TYPE3] )0x0) goto LAB_001df8d3;\n  if ([VAR1] ->method_POST == 0) {\n    [FUNC6] ();\n    [FUNC9] (\"crypto/http/http_client.c\",0x120,\"set1_content\");\n    [FUNC7] (0x3d,0xc0101,(char *)0x0);\n    iVar1 = 0;\n    goto LAB_001df8d3;\n  }\n  if ([VAR2] != (TYPE20x0) {\n    iVar2 = [FUNC5] ((BIO *)[VAR1] ->mem,\"Content-Type: %s\\r\\n\",[VAR2] );\n    iVar1 = 0;\n    if (iVar2 < 1) goto LAB_001df8d3;\n  }\n  iVar1 = [FUNC13] ((BIO *)[VAR3] );\n  if (iVar1 == 0x402) {\n    lVar3 = [FUNC2] ((BIO *)[VAR3] ,0x6b,0,&[VAR5] );\n    if (lVar3 == 1) {\n      iVar1 = [FUNC8] ((FILE *)[VAR5] ,0,2);\n      if (iVar1 == 0) {\n        lVar3 = [FUNC4] ((FILE *)[VAR5] );\n        [FUNC8] ((FILE *)[VAR5] ,0,0);\n        goto LAB_001df996;\n      }\n    }\n    [VAR5] = ([TYPE5] )0x0;\n  }\n  else {\n    lVar3 = [FUNC2] ((BIO *)[VAR3] ,3,0,(void *)0x0);\nLAB_001df996:\n    if (([VAR5] != ([TYPE5] )0x0) || (0 < lVar3)) {\n      iVar2 = [FUNC5] ((BIO *)[VAR1] ->mem,\"Content-Length: %ld\\r\\n\",lVar3);\n      iVar1 = 0;\n      if (iVar2 < 0) goto LAB_001df8d3;\n    }\n  }\n  iVar1 = [FUNC10] ([VAR3] );\n  if (iVar1 != 0) {\n    [VAR1] ->req = [VAR3] ;\n    iVar1 = 1;\n  }\nLAB_001df8d3:\n  if ([VAR4] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar1;\n  }\n  [FUNC11] ();\n}", "answer": {"FUNC12": "OSSL_HTTP_REQ_CTX_add1_header", "FUNC11": "__stack_chk_fail", "VAR1": "rctx", "FUNC13": "BIO_method_type", "VAR2": "content_type", "VAR3": "req", "VAR4": "local_30", "FUNC10": "BIO_up_ref", "VAR5": "fp", "FUNC2": "BIO_ctrl", "FUNC3": "BIO_free", "FUNC1": "set1_content", "FUNC6": "ERR_new", "TYPE3": "BIO *", "FUNC7": "ERR_set_error", "TYPE2": "char *", "FUNC4": "ftell", "TYPE5": "FILE *", "FUNC5": "BIO_printf", "TYPE4": "undefined8", "FUNC8": "fseek", "FUNC9": "ERR_set_debug", "TYPE1": "OSSL_HTTP_REQ_CTX *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV qword ptr [RSP],0x0\nTEST RDI,RDI\nJZ 0x001df898\nMOV RBX,RDI\nMOV R13,RSI\nMOV R12,RDX\nTEST RDX,RDX\nJNZ 0x001df8f4\nTEST RSI,RSI\nJZ 0x001df8f4\nCALL 0x0009ff03\nLEA RDX,[0x29b6b8]\nMOV ESI,0x113\nLEA RDI,[0x29b2b3]\nCALL 0x000a0010\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0x3d\nMOV EAX,0x0\nCALL 0x000a0327\nMOV EBP,0x0\nMOV EAX,EBP\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x001dfa82\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nCMP dword ptr [RBX + 0xa0],0x0\nJZ 0x001df919\nLEA RDX,[0x29b2f4]\nLEA RSI,[0x29b2ff]\nMOV RDI,RBX\nCALL 0x001df74b\nMOV EBP,EAX\nTEST EAX,EAX\nJZ 0x001df8d3\nMOV RDI,qword ptr [RBX + 0x60]\nCALL 0x00073cde\nMOV qword ptr [RBX + 0x60],0x0\nMOV EBP,0x1\nTEST R12,R12\nJZ 0x001df8d3\nMOV EBP,dword ptr [RBX + 0x68]\nTEST EBP,EBP\nJZ 0x001df9e7\nTEST R13,R13\nJZ 0x001df969\nMOV RDI,qword ptr [RBX + 0x58]\nMOV RDX,R13\nLEA RSI,[0x29b30a]\nMOV EAX,0x0\nCALL 0x00076deb\nMOV EBP,0x0\nTEST EAX,EAX\nJLE 0x001df8d3\nMOV RDI,R12\nCALL 0x00073e1c\nCMP EAX,0x402\nJZ 0x001dfa22\nMOV ECX,0x0\nMOV EDX,0x0\nMOV ESI,0x3\nMOV RDI,R12\nCALL 0x000743a6\nMOV RBP,RAX\nCMP qword ptr [RSP],0x0\nJNZ 0x001df9a2\nTEST RBP,RBP\nJLE 0x001df9c7\nMOV RDI,qword ptr [RBX + 0x58]\nMOV RDX,RBP\nLEA RSI,[0x29b31d]\nMOV EAX,0x0\nCALL 0x00076deb\nMOV EBP,0x0\nTEST EAX,EAX\nJS 0x001df8d3\nMOV RDI,R12\nCALL 0x00073dce\nMOV EBP,EAX\nTEST EAX,EAX\nJZ 0x001df8d3\nMOV qword ptr [RBX + 0x60],R12\nMOV EBP,0x1\nJMP 0x001df8d3\nCALL 0x0009ff03\nLEA RDX,[0x29b6b8]\nMOV ESI,0x120\nLEA RDI,[0x29b2b3]\nCALL 0x000a0010\nMOV EDX,0x0\nMOV ESI,0xc0101\nMOV EDI,0x3d\nMOV EAX,0x0\nCALL 0x000a0327\nJMP 0x001df8d3\nMOV RCX,RSP\nMOV EDX,0x0\nMOV ESI,0x6b\nMOV RDI,R12\nCALL 0x000743a6\nCMP RAX,0x1\nJZ 0x001dfa47\nMOV qword ptr [RSP],0x0\nJMP 0x001df9c7\nMOV EDX,0x2\nMOV ESI,0x0\nMOV RDI,qword ptr [RSP]\nCALL 0x00062950\nTEST EAX,EAX\nJNZ 0x001dfa3d\nMOV RDI,qword ptr [RSP]\nCALL 0x00062880\nMOV RBP,RAX\nMOV EDX,0x0\nMOV ESI,0x0\nMOV RDI,qword ptr [RSP]\nCALL 0x00062950\nJMP 0x001df996\nCALL 0x00062d60\n"}, "439": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  zend_object *pzVar1;\n  zend_refcounted_h zVar2;\n  long lVar3;\n  zend_result zVar4;\n  int iVar5;\n  [TYPE5] [VAR5] ;\n  undefined8 uVar6;\n  [TYPE6] [VAR6] ;\n  undefined8 uVar7;\n  [TYPE7] [VAR7] ;\n  xmlNodePtr obj;\n  [TYPE8] [VAR8] ;\n  [TYPE3] [VAR3] ;\n  TYPE46 [VAR4] ;\n  long in_FS_OFFSET;\n  [TYPE10] [VAR10] ;\n  long [VAR9] ;\n  \n  [VAR9] = *(long *)(in_FS_OFFSET + 0x28);\n  zVar4 = [FUNC5] (([VAR1] ->This).u2.next,\"l\",&[VAR10] );\n  if (zVar4 != FAILURE) {\n    pzVar1 = ([VAR1] ->This).value.obj;\n    if (pzVar1[-1].properties == (HashTable *)0x0) {\n      [FUNC10] ((zend_class_entry *)0x0,\"Couldn\\'t fetch %s\",pzVar1->ce->name->val);\n    }\n    else {\n      zVar2 = (pzVar1[-1].properties)->gc;\n      if ([VAR10] < 0) {\n        [FUNC2] (1,\"must be greater than or equal to 0\");\n      }\n      else if (*(int *)((long)zVar2 + 8) - 3U < 2) {\n        lVar3 = *(long *)((long)zVar2 + 0x50);\n        if (lVar3 == 0) {\n          ([VAR2] ->u1).type_info = 2;\n        }\n        else {\n          iVar5 = [FUNC4] (lVar3);\n          if (([VAR10] < 0x80000000) && ((int)[VAR10] <= iVar5)) {\n            uVar6 = [FUNC3] (lVar3);\n            uVar7 = [FUNC7] (lVar3,[VAR10] ,iVar5 - (int)[VAR10] );\n            [FUNC9] (zVar2,uVar6);\n            obj = (xmlNodePtr)[FUNC8] (*(undefined8 *)((long)zVar2 + 0x40),uVar7);\n            (*xmlFree)(uVar6);\n            (*xmlFree)(uVar7);\n            if (obj == (xmlNodePtr)0x0) {\n              ([VAR2] ->u1).type_info = 2;\n            }\n            else {\n              if (*(long *)((long)zVar2 + 0x28) != 0) {\n                obj->type = XML_ELEMENT_NODE;\n                [FUNC12] (zVar2,obj);\n                obj->type = XML_TEXT_NODE;\n              }\n              [FUNC6] (obj,[VAR2] ,(dom_object *)&pzVar1[-1].properties);\n            }\n          }\n          else {\n            ([VAR2] ->u1).type_info = 2;\n          }\n        }\n      }\n      else {\n        ([VAR2] ->u1).type_info = 2;\n      }\n    }\n  }\n  if ([VAR9] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC11] ();\n}", "answer": {"FUNC12": "xmlAddNextSibling", "FUNC11": "__stack_chk_fail", "VAR1": "execute_data", "VAR2": "return_value", "VAR3": "node", "VAR4": "cur", "FUNC10": "zend_throw_error", "VAR5": "length", "VAR6": "first", "FUNC2": "zend_argument_value_error", "FUNC3": "xmlUTF8Strndup", "FUNC1": "zim_DOMText_splitText", "FUNC6": "php_dom_create_object", "TYPE3": "xmlNodePtr", "FUNC7": "xmlUTF8Strsub", "TYPE2": "zval *", "FUNC4": "xmlUTF8Strlen", "TYPE5": "int", "FUNC5": "zend_parse_parameters", "TYPE4": "xmlChar *", "TYPE7": "xmlChar *", "TYPE6": "xmlChar *", "FUNC8": "xmlNewDocText", "TYPE9": "undefined8", "FUNC9": "xmlNodeSetContent", "TYPE8": "xmlNodePtr", "VAR7": "second", "VAR8": "nnode", "VAR9": "local_40", "TYPE10": "zend_long", "VAR10": "offset", "TYPE1": "zend_execute_data *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBX,RDI\nMOV RBP,RSI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV RDX,RSP\nMOV EDI,dword ptr [RDI + 0x2c]\nLEA RSI,[0x536523]\nCALL 0x003c15e1\nCMP EAX,-0x1\nJZ 0x001ccea0\nMOV R12,qword ptr [RBX + 0x20]\nMOV RAX,qword ptr [R12 + -0x18]\nTEST RAX,RAX\nJZ 0x001ccec3\nMOV RBX,qword ptr [RAX]\nCMP qword ptr [RSP],0x0\nJS 0x001ccee8\nMOV EAX,dword ptr [RBX + 0x8]\nSUB EAX,0x3\nCMP EAX,0x1\nJBE 0x001ccf00\nMOV dword ptr [RBP + 0x8],0x2\nMOV RAX,qword ptr [RSP + 0x8]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x001ccfd0\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV RAX,qword ptr [R12 + 0x10]\nMOV RDX,qword ptr [RAX + 0x8]\nADD RDX,0x18\nLEA RSI,[0x536420]\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x003b6f64\nJMP 0x001ccea0\nLEA RSI,[0x536d40]\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x003b8e80\nJMP 0x001ccea0\nMOV R13,qword ptr [RBX + 0x50]\nTEST R13,R13\nJZ 0x001ccf31\nMOV RDI,R13\nCALL 0x000fb890\nMOV R14D,EAX\nMOV RSI,qword ptr [RSP]\nCMP RSI,0x7fffffff\nJG 0x001ccf25\nCMP ESI,EAX\nJLE 0x001ccf3d\nMOV dword ptr [RBP + 0x8],0x2\nJMP 0x001ccea0\nMOV dword ptr [RBP + 0x8],0x2\nJMP 0x001ccea0\nMOV RDI,R13\nCALL 0x000fa410\nMOV R15,RAX\nMOV RSI,qword ptr [RSP]\nMOV EDX,R14D\nSUB EDX,ESI\nMOV RDI,R13\nCALL 0x000f9700\nMOV R14,RAX\nMOV RSI,R15\nMOV RDI,RBX\nCALL 0x000f9cc0\nMOV RDI,qword ptr [RBX + 0x40]\nMOV RSI,R14\nCALL 0x000fb650\nMOV R13,RAX\nMOV RDI,R15\nCALL qword ptr [0x01202248]\nMOV RDI,R14\nCALL qword ptr [0x01202248]\nTEST R13,R13\nJZ 0x001ccfc4\nCMP qword ptr [RBX + 0x28],0x0\nJZ 0x001ccfaf\nMOV dword ptr [R13 + 0x8],0x1\nMOV RSI,R13\nMOV RDI,RBX\nCALL 0x000fab30\nMOV dword ptr [R13 + 0x8],0x3\nLEA RDX,[R12 + -0x18]\nMOV RSI,RBP\nMOV RDI,R13\nCALL 0x001bec08\nJMP 0x001ccea0\nMOV dword ptr [RBP + 0x8],0x2\nJMP 0x001ccea0\nCALL 0x000fa8a0\n"}, "440": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,...)\n{\n  long lVar1;\n  char in_AL;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  [TYPE15] [VAR15] ;\n  undefined8 [VAR14] ;\n  undefined8 [VAR13] ;\n  [TYPE12] [VAR12] ;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  if (in_AL != '\\0') {\n    [VAR12] ._0_4_ = in_XMM0_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR17] [0].gp_offset = 0x20;\n  [VAR17] [0].fp_offset = 0x30;\n  [VAR17] [0].overflow_arg_area = &stack0x00000008;\n  [VAR17] [0].reg_save_area = &[VAR15] ;\n  [VAR14] = in_R8;\n  [VAR13] = in_R9;\n  [FUNC3] ([VAR1] ,[VAR2] ,[VAR3] ,[VAR4] ,[VAR17] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n  [FUNC2] ();\n}", "answer": {"TYPE17": "va_list", "VAR1": "stream", "VAR2": "command_name", "VAR3": "package", "VAR4": "version", "VAR5": "local_18", "VAR6": "local_28", "FUNC2": "__stack_chk_fail", "FUNC3": "version_etc_va", "FUNC1": "version_etc", "TYPE3": "char *", "VAR14": "local_98", "TYPE2": "char *", "VAR15": "local_b8", "TYPE5": "undefined1[16]", "VAR12": "local_88", "TYPE4": "char *", "VAR13": "local_90", "TYPE7": "undefined1[16]", "TYPE6": "undefined1[16]", "TYPE9": "undefined1[16]", "VAR16": "local_c0", "TYPE8": "undefined1[16]", "VAR17": "authors", "VAR7": "local_38", "TYPE11": "undefined1[16]", "VAR8": "local_48", "TYPE12": "undefined1[16]", "VAR9": "local_58", "TYPE10": "undefined1[16]", "VAR10": "local_68", "TYPE15": "undefined1", "VAR11": "local_78", "TYPE16": "undefined8", "TYPE1": "FILE *", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "SUB RSP,0xd8\nMOV qword ptr [RSP + 0x40],R8\nMOV qword ptr [RSP + 0x48],R9\nTEST AL,AL\nJZ 0x00043ab0\nMOVAPS xmmword ptr [RSP + 0x50],XMM0\nMOVAPS xmmword ptr [RSP + 0x60],XMM1\nMOVAPS xmmword ptr [RSP + 0x70],XMM2\nMOVAPS xmmword ptr [RSP + 0x80],XMM3\nMOVAPS xmmword ptr [RSP + 0x90],XMM4\nMOVAPS xmmword ptr [RSP + 0xa0],XMM5\nMOVAPS xmmword ptr [RSP + 0xb0],XMM6\nMOVAPS xmmword ptr [RSP + 0xc0],XMM7\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0x20\nMOV dword ptr [RSP + 0x4],0x30\nLEA RAX,[RSP + 0xe0]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nMOV R8,RSP\nCALL 0x000113f0\nMOV RAX,qword ptr [RSP + 0x18]\nXOR RAX,qword ptr FS:[0x28]\nJNZ 0x00043b06\nADD RSP,0xd8\nRET\nCALL 0x0000fbf0\n"}, "441": {"funcbody": "void [FUNC1] (long param_1,long param_2,long param_3,long param_4,long param_5)\n{\n  float fVar1;\n  long lVar2;\n  \n  fVar1 = *(float *)(param_3 + param_4 * 4);\n  if (0 < param_5) {\n    lVar2 = 0;\n    do {\n      *(float *)(param_1 + lVar2) = *(float *)(param_2 + lVar2) * fVar1;\n      lVar2 = lVar2 + 4;\n    } while (param_5 * 4 != lVar2);\n  }\n  return;\n}", "answer": {"FUNC1": "FUN_00f3bef0"}, "assembly": "TEST R8,R8\nMOVSS XMM1,dword ptr [RDX + RCX*0x4]\nJLE 0x00f3bf17\nSHL R8,0x2\nXOR EAX,EAX\nMOVSS XMM0,dword ptr [RSI + RAX*0x1]\nMULSS XMM0,XMM1\nMOVSS dword ptr [RDI + RAX*0x1],XMM0\nADD RAX,0x4\nCMP R8,RAX\nJNZ 0x00f3bf00\nRET\n"}, "442": {"funcbody": "/* DWARF original prototype: void ~Vector(Vector<StringMap<Symbol*>::Entry*> * this, int __in_chrg)\n    */\nvoid __thiscall\nVector<StringMap<Symbol*>::Entry*>::[FUNC1] \n          (Vector<StringMap<Symbol*>::Entry*> *this,[TYPE1] [VAR1] )\n{\n  [FUNC3] (this->data);\n  [FUNC2] (this,0x28);\n  return;\n}", "answer": {"VAR1": "__in_chrg", "FUNC2": "operator.delete", "FUNC3": "free", "FUNC1": "~Vector", "TYPE1": "int"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nMOV RDI,qword ptr [RDI + 0x8]\nCALL 0x0015378f\nMOV ESI,0x28\nMOV RDI,RBX\nCALL 0x0008feb0\nPOP RBX\nRET\n"}, "443": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  mu_pop3_t *ppop3;\n  [TYPE3] [VAR3] ;\n  [TYPE2] [VAR2] ;\n  \n  ppop3 = (mu_pop3_t *)[VAR1] ->data;\n  if (ppop3 != (mu_pop3_t *)0x0) {\n    [FUNC4] (ppop3);\n    if (ppop3[8] != (mu_pop3_t)0x0) {\n      [FUNC2] (ppop3[8]);\n    }\n    if (ppop3[9] != (mu_pop3_t)0x0) {\n      [FUNC3] (ppop3[9]);\n    }\n  }\n  return;\n}", "answer": {"VAR1": "mbox", "VAR2": "mpd", "VAR3": "mbox-local", "FUNC2": "free", "FUNC3": "mu_secret_unref", "FUNC1": "pop_destroy", "TYPE3": "mu_mailbox_t", "TYPE2": "_pop3_mailbox *", "FUNC4": "mu_pop3_destroy", "TYPE1": "mu_mailbox_t"}, "assembly": "PUSH RBP\nMOV RBP,RSP\nSUB RSP,0x20\nMOV qword ptr [RBP + -0x18],RDI\nMOV RAX,qword ptr [RBP + -0x18]\nMOV RAX,qword ptr [RAX + 0x60]\nMOV qword ptr [RBP + -0x8],RAX\nCMP qword ptr [RBP + -0x8],0x0\nJZ 0x00004b94\nMOV RAX,qword ptr [RBP + -0x8]\nMOV RDI,RAX\nCALL 0x00003ed0\nMOV RAX,qword ptr [RBP + -0x8]\nMOV RAX,qword ptr [RAX + 0x40]\nTEST RAX,RAX\nJZ 0x00004b77\nMOV RAX,qword ptr [RBP + -0x8]\nMOV RAX,qword ptr [RAX + 0x40]\nMOV RDI,RAX\nCALL 0x00003a90\nMOV RAX,qword ptr [RBP + -0x8]\nMOV RAX,qword ptr [RAX + 0x48]\nTEST RAX,RAX\nJZ 0x00004b94\nMOV RAX,qword ptr [RBP + -0x8]\nMOV RAX,qword ptr [RAX + 0x48]\nMOV RDI,RAX\nCALL 0x00003c00\nNOP\nLEAVE\nRET\n"}, "444": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] )\n{\n  char cVar1;\n  [TYPE2] [VAR2] ;\n  ulong uVar2;\n  char *pcVar3;\n  \n  uVar2 = 0xffffffffffffffff;\n  pcVar3 = prog;\n  do {\n    if (uVar2 == 0) break;\n    uVar2 = uVar2 - 1;\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar3 + 1;\n  } while (cVar1 != '\\0');\n  if ([VAR1] != (TYPE10x0) {\n    [FUNC2] ((char *)(~uVar2 + 0x21831f),0x27 - (~uVar2 - 1),\" %s\",[VAR1] );\n    return prog;\n  }\n  return prog;\n}", "answer": {"VAR1": "argv0", "VAR2": "len", "FUNC2": "BIO_snprintf", "FUNC1": "opt_appname", "TYPE2": "size_t", "TYPE1": "char *"}, "assembly": "MOV RDX,RDI\nLEA RDI,[0x218320]\nMOV RCX,-0x1\nMOV EAX,0x0\nSCASB.REPNE RDI\nMOV RAX,RCX\nNOT RAX\nSUB RAX,0x1\nTEST RDX,RDX\nJZ 0x000095be\nSUB RSP,0x8\nMOV RCX,RDX\nMOV ESI,0x27\nSUB RSI,RAX\nLEA RDI,[0x218320]\nADD RDI,RAX\nLEA RDX,[0xbc4a]\nMOV EAX,0x0\nCALL 0x00002430\nLEA RAX,[0x218320]\nADD RSP,0x8\nRET\nLEA RAX,[0x218320]\nRET\n"}, "445": {"funcbody": "int [FUNC1] (long param_1,long param_2)\n{\n  undefined8 uVar1;\n  uint uVar2;\n  int iVar3;\n  int iVar4;\n  \n  uVar1 = *(undefined8 *)(param_1 + 0x20);\n  [FUNC6] (uVar1);\n  uVar2 = [FUNC6] (uVar1);\n  iVar3 = [FUNC3] (uVar1);\n  if ((uVar2 < 5) && (uVar2 != 3)) {\n    if (iVar3 - 9U < 0xffff8) {\n      iVar4 = [FUNC5] (uVar1,param_2,iVar3 + -8);\n      if (iVar4 < 1) {\n        iVar4 = -5;\n      }\n      else {\n        [FUNC4] (uVar1,-iVar3 & 0x1ff);\n        if (uVar2 < 3) {\n          if (uVar2 == 0) {\n            *(undefined4 *)(param_2 + 0x28) = 1;\n          }\n          *(undefined4 *)(param_2 + 0x24) = 0;\n        }\n        else if (uVar2 == 4) {\n          *(undefined4 *)(param_2 + 0x24) = 1;\n          return iVar4;\n        }\n      }\n    }\n    else {\n      iVar4 = -5;\n      [FUNC2] (param_1,0x10,\"packet size %d is invalid\\n\",iVar3);\n    }\n  }\n  else {\n    iVar4 = -5;\n    [FUNC2] (param_1,0x10,\"invalid or unsupported frame_type\\n\");\n  }\n  return iVar4;\n}", "answer": {"FUNC2": "FUN_00fb6de0", "FUNC3": "FUN_00458e00", "FUNC1": "FUN_004bfd90", "FUNC6": "FUN_00458da0", "FUNC4": "FUN_004579e0", "FUNC5": "FUN_0059d7d0"}, "assembly": "PUSH R14\nPUSH R13\nMOV R14,RDI\nPUSH R12\nPUSH RBP\nMOV R13,RSI\nPUSH RBX\nMOV RBX,qword ptr [RDI + 0x20]\nMOV RDI,RBX\nCALL 0x00458da0\nMOV RDI,RBX\nCALL 0x00458da0\nMOV RDI,RBX\nMOV R12D,EAX\nCALL 0x00458e00\nMOV EBP,EAX\nNEG EBP\nAND EBP,0x1ff\nCMP R12D,0x4\nJA 0x004bfe80\nCMP R12D,0x3\nJZ 0x004bfe80\nLEA ECX,[RAX + -0x9]\nCMP ECX,0xffff7\nJA 0x004bfe60\nLEA EDX,[RAX + -0x8]\nMOV RSI,R13\nMOV RDI,RBX\nCALL 0x0059d7d0\nTEST EAX,EAX\nMOV R14D,EAX\nJLE 0x004bfe50\nMOV ESI,EBP\nMOV RDI,RBX\nCALL 0x004579e0\nCMP R12D,0x2\nJA 0x004bfe30\nCMP R12D,0x1\nJNC 0x004bfe19\nMOV dword ptr [R13 + 0x28],0x1\nMOV dword ptr [R13 + 0x24],0x0\nPOP RBX\nMOV EAX,R14D\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nCMP R12D,0x4\nJNZ 0x004bfe21\nPOP RBX\nMOV EAX,R14D\nMOV dword ptr [R13 + 0x24],0x1\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nMOV R14D,0xfffffffb\nJMP 0x004bfe21\nLEA RDX,[0x1086b1b]\nMOV ECX,EAX\nMOV RDI,R14\nMOV ESI,0x10\nXOR EAX,EAX\nMOV R14D,0xfffffffb\nCALL 0x00fb6de0\nJMP 0x004bfe21\nLEA RDX,[0x1086af8]\nMOV RDI,R14\nMOV ESI,0x10\nXOR EAX,EAX\nMOV R14D,0xfffffffb\nCALL 0x00fb6de0\nJMP 0x004bfe21\n"}, "446": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] ,[TYPE7] [VAR7] )\n{\n  uint uVar1;\n  char *pcVar2;\n  [TYPE9] [VAR9] ;\n  [TYPE10] [VAR10] ;\n  int iVar3;\n  [TYPE8] [VAR8] ;\n  [TYPE5] [VAR12] ;\n  int [VAR11] ;\n  \n  if ([VAR1] == ([TYPE1] )0x0) {\n    [VAR11] = -1;\n  }\n  else if (([VAR2] != [VAR4] ) || ([VAR11] = 0, [VAR3] != [VAR5] )) {\n    iVar3 = (int)[VAR1] ->_columns;\n    [VAR12] = [VAR5] ;\n    if (iVar3 <= [VAR5] ) {\n      [VAR12] = [VAR5] % iVar3;\n      [VAR4] = [VAR4] + [VAR5] / iVar3;\n    }\n    uVar1 = *[VAR1] ->_current_attr;\n    if (((uVar1 & 0x400000) != 0) ||\n       (((uVar1 & 0xffffff00) != 0 && ((cur_term->type).Booleans[0xe] == '\\0')))) {\n      [FUNC4] ([VAR1] ,0,[VAR6] );\n    }\n    if ([VAR1] ->_columns <= [VAR3] ) {\n      [VAR11] = ([VAR3] + 1) / (int)[VAR1] ->_columns;\n      [VAR2] = [VAR2] + [VAR11] ;\n      if ([VAR1] ->_lines <= [VAR2] ) {\n        [VAR11] = ([VAR1] ->_lines - [VAR2] ) + 1 + [VAR11] ;\n      }\n      if (0 < [VAR11] ) {\n        pcVar2 = (cur_term->type).Strings[2];\n        [VAR3] = [VAR11] ;\n        if (pcVar2 == (char *)0x0) {\n          (*[VAR6] )([VAR1] ,0xd);\n        }\n        else {\n          [FUNC2] ([VAR1] ,\"carriage_return\",pcVar2);\n        }\n        do {\n          pcVar2 = (cur_term->type).Strings[0x67];\n          if (pcVar2 == (char *)0x0) {\n            (*[VAR6] )([VAR1] ,10);\n          }\n          else {\n            [FUNC2] ([VAR1] ,\"newline\",pcVar2);\n          }\n          [VAR3] = [VAR3] + -1;\n        } while ([VAR3] != 0);\n      }\n    }\n    iVar3 = [VAR1] ->_lines + -1;\n    if (iVar3 <= [VAR4] ) {\n      [VAR4] = iVar3;\n    }\n    if ([VAR2] < iVar3) {\n      iVar3 = [VAR2] ;\n    }\n    [VAR11] = [FUNC3] ([VAR1] ,iVar3,[VAR3] ,[VAR4] ,[VAR12] ,[VAR7] ,[VAR6] );\n    if (((uVar1 ^ *[VAR1] ->_current_attr) & 0xffffff00) != 0) {\n      [FUNC4] ([VAR1] ,uVar1 & 0xffffff00,[VAR6] );\n    }\n  }\n  return [VAR11] ;\n}", "answer": {"VAR1": "sp", "VAR2": "yold", "VAR3": "xold", "VAR4": "ynew", "VAR5": "xnew", "VAR6": "myOutCh", "FUNC2": "_nc_putp_sp", "FUNC3": "onscreen_mvcur", "FUNC1": "_nc_real_mvcur", "TYPE3": "int", "TYPE2": "int", "FUNC4": "vidputs_sp", "TYPE5": "int", "VAR12": "local_40", "TYPE4": "int", "TYPE7": "int", "TYPE6": "NCURSES_OUTC_sp", "TYPE9": "int", "TYPE8": "chtype", "VAR7": "ovw", "TYPE11": "undefined4", "VAR8": "oldattr", "TYPE12": "undefined4", "VAR9": "l", "TYPE10": "int", "VAR10": "code", "VAR11": "local_3c", "TYPE1": "SCREEN *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV dword ptr [RSP + 0x8],R8D\nTEST RDI,RDI\nJZ 0x0000b7bb\nMOV RBX,RDI\nMOV R13D,ESI\nMOV EBP,EDX\nMOV R12D,ECX\nMOV R14,R9\nCMP ESI,ECX\nJNZ 0x0000b65e\nMOV dword ptr [RSP + 0xc],0x0\nCMP EDX,R8D\nJNZ 0x0000b65e\nMOV EAX,dword ptr [RSP + 0xc]\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOVSX ECX,word ptr [RBX + 0x76]\nMOV EAX,dword ptr [RSP + 0x8]\nCMP ECX,EAX\nJG 0x0000b674\nCDQ\nIDIV ECX\nADD R12D,EAX\nMOV dword ptr [RSP + 0x8],EDX\nMOV RAX,qword ptr [RBX + 0x2e0]\nMOV R15D,dword ptr [RAX]\nTEST R15D,0x400000\nJNZ 0x0000b6a1\nTEST R15D,0xffffff00\nJZ 0x0000b6b1\nMOV RAX,qword ptr [0x0023c8a8]\nMOV RAX,qword ptr [RAX + 0x10]\nCMP byte ptr [RAX + 0xe],0x0\nJNZ 0x0000b6b1\nMOV RDX,R14\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x0000e9c2\nMOVSX ECX,word ptr [RBX + 0x76]\nCMP ECX,EBP\nJG 0x0000b753\nLEA EAX,[RBP + 0x1]\nCDQ\nIDIV ECX\nMOV dword ptr [RSP + 0xc],EAX\nADD R13D,EAX\nMOVSX EDX,word ptr [RBX + 0x74]\nCMP EDX,R13D\nJG 0x0000b6de\nSUB EDX,R13D\nLEA EAX,[RDX + RAX*0x1 + 0x1]\nMOV dword ptr [RSP + 0xc],EAX\nCMP dword ptr [RSP + 0xc],0x0\nJLE 0x0000b753\nMOV RAX,qword ptr [0x0023c8a8]\nMOV RAX,qword ptr [RAX + 0x20]\nMOV RDX,qword ptr [RAX + 0x10]\nTEST RDX,RDX\nJNZ 0x0000b70a\nMOV ESI,0xd\nMOV RDI,RBX\nCALL R14\nMOV EBP,dword ptr [RSP + 0xc]\nJMP 0x0000b72f\nLEA RSI,[0x2a32b]\nMOV RDI,RBX\nCALL 0x0001d74f\nJMP 0x0000b704\nLEA RSI,[0x2a319]\nMOV RDI,RBX\nCALL 0x0001d74f\nSUB EBP,0x1\nJZ 0x0000b753\nMOV RAX,qword ptr [0x0023c8a8]\nMOV RAX,qword ptr [RAX + 0x20]\nMOV RDX,qword ptr [RAX + 0x338]\nTEST RDX,RDX\nJNZ 0x0000b71b\nMOV ESI,0xa\nMOV RDI,RBX\nCALL R14\nJMP 0x0000b72a\nMOVSX ESI,word ptr [RBX + 0x74]\nSUB ESI,0x1\nCMP ESI,R12D\nMOV ECX,R12D\nCMOVLE ECX,ESI\nCMP ESI,R13D\nCMOVG ESI,R13D\nSUB RSP,0x8\nPUSH R14\nMOV R9D,dword ptr [RSP + 0x60]\nMOV R8D,dword ptr [RSP + 0x18]\nMOV EDX,EBP\nMOV RDI,RBX\nCALL 0x0000b0af\nMOV dword ptr [RSP + 0x1c],EAX\nMOV RAX,qword ptr [RBX + 0x2e0]\nMOV EDI,R15D\nXOR EDI,dword ptr [RAX]\nMOV EAX,EDI\nADD RSP,0x10\nTEST EAX,0xffffff00\nJZ 0x0000b64b\nMOV ESI,R15D\nMOV SIL,0x0\nMOV RDX,R14\nMOV RDI,RBX\nCALL 0x0000e9c2\nJMP 0x0000b64b\nMOV dword ptr [RSP + 0xc],0xffffffff\nJMP 0x0000b64b\n"}, "447": {"funcbody": "/* Local variable l:lister *[RDI:8] conflicts with parameter, skipped. */\nsize_t [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  size_t sVar1;\n  [TYPE3] [VAR3] ;\n  \n  if ([VAR1] == ([TYPE1] )0x0) {\n    [VAR1] = &lister_default;\n  }\n  sVar1 = [VAR1] ->before;\n  [VAR1] ->before = [VAR2] ;\n  return sVar1;\n}", "answer": {"VAR1": "lister", "VAR2": "size", "VAR3": "old", "FUNC1": "lister_before_set", "TYPE3": "size_t", "TYPE2": "size_t", "TYPE1": "lister *"}, "assembly": "TEST RDI,RDI\nLEA RAX,[0x2580c0]\nCMOVZ RDI,RAX\nMOV RAX,qword ptr [RDI + 0x20]\nMOV qword ptr [RDI + 0x20],RSI\nRET\n"}, "448": {"funcbody": "iconv_ostream_t [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  iconv_ostream_t paVar1;\n  [TYPE4] [VAR4] ;\n  char *pcVar2;\n  iconv_t pvVar3;\n  \n  paVar1 = (iconv_ostream_t)[FUNC4] (0x70);\n  (paVar1->base).vtable = &libtextstyle_iconv_ostream_vtable;\n  paVar1->destination = [VAR3] ;\n  pcVar2 = [FUNC2] ([VAR1] );\n  paVar1->from_encoding = pcVar2;\n  pcVar2 = [FUNC2] ([VAR2] );\n  paVar1->to_encoding = pcVar2;\n  pvVar3 = [FUNC3] ([VAR2] ,[VAR1] );\n  paVar1->cd = pvVar3;\n  if (pvVar3 == (iconv_t)0xffffffffffffffff) {\n    pvVar3 = [FUNC3] (\"UTF-8\",[VAR1] );\n    if (pvVar3 == (iconv_t)0xffffffffffffffff) {\n      [FUNC5] (1,0,\"%s does not support conversion from %s\",\"iconv\",[VAR1] );\n    }\n    else {\n      pvVar3 = [FUNC3] ([VAR2] ,\"UTF-8\");\n      if (pvVar3 == (iconv_t)0xffffffffffffffff) {\n        [FUNC5] (1,0,\"%s does not support conversion to %s\",\"iconv\",[VAR2] );\n      }\n      else {\n        [FUNC5] (1,0,\"%s does not support conversion from %s to %s\",\"iconv\",[VAR1] ,[VAR2] );\n      }\n    }\n  }\n  paVar1->buflen = 0;\n  return paVar1;\n}", "answer": {"VAR1": "from_encoding", "VAR2": "to_encoding", "VAR3": "destination", "VAR4": "stream", "FUNC2": "libtextstyle_xstrdup", "FUNC3": "iconv_open", "FUNC1": "iconv_ostream_create", "TYPE3": "ostream_t.conflict3", "TYPE2": "char *", "FUNC4": "libtextstyle_xmalloc", "FUNC5": "error", "TYPE4": "iconv_ostream_t", "TYPE1": "char *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV R12,RSI\nMOV R13,RDX\nMOV EDI,0x70\nCALL 0x000106c9\nMOV RBX,RAX\nLEA RAX,[0x28be40]\nMOV qword ptr [RBX],RAX\nMOV qword ptr [RBX + 0x8],R13\nMOV RDI,RBP\nCALL 0x00010803\nMOV qword ptr [RBX + 0x10],RAX\nMOV RDI,R12\nCALL 0x00010803\nMOV qword ptr [RBX + 0x18],RAX\nMOV RSI,RBP\nMOV RDI,R12\nCALL 0x00007240\nMOV qword ptr [RBX + 0x20],RAX\nCMP RAX,-0x1\nJZ 0x00009b10\nMOV qword ptr [RBX + 0x68],0x0\nMOV RAX,RBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV RSI,RBP\nLEA RDI,[0x6a6c7]\nCALL 0x00007240\nCMP RAX,-0x1\nJZ 0x00009b64\nLEA RSI,[0x6a6c7]\nMOV RDI,R12\nCALL 0x00007240\nCMP RAX,-0x1\nJZ 0x00009b8e\nMOV R9,R12\nMOV R8,RBP\nLEA RCX,[0x6a6cd]\nLEA RDX,[0x6a750]\nMOV ESI,0x0\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x00007020\nJMP 0x00009afa\nMOV R8,RBP\nLEA RCX,[0x6a6cd]\nLEA RDX,[0x6a700]\nMOV ESI,0x0\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x00007020\nJMP 0x00009afa\nMOV R8,R12\nLEA RCX,[0x6a6cd]\nLEA RDX,[0x6a728]\nMOV ESI,0x0\nMOV EDI,0x1\nMOV EAX,0x0\nCALL 0x00007020\nJMP 0x00009afa\n"}, "449": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  if ([VAR1] != ([TYPE1] )0x0) {\n    (*(*[VAR1] ->s)->close)([VAR1] ->s);\n    [FUNC2] ([VAR1] ->hostname);\n    [FUNC2] ([VAR1] );\n    return;\n  }\n  return;\n}", "answer": {"VAR1": "pl", "FUNC2": "safefree", "FUNC1": "pfl_terminate", "TYPE1": "PortListener *"}, "assembly": "TEST RDI,RDI\nJZ 0x0000ffb0\nPUSH RBX\nMOV RBX,RDI\nMOV RDI,qword ptr [RDI + 0x10]\nMOV RAX,qword ptr [RDI]\nCALL qword ptr [RAX + 0x8]\nMOV RDI,qword ptr [RBX + 0x20]\nCALL 0x0000ea8f\nMOV RDI,RBX\nCALL 0x0000ea8f\nPOP RBX\nRET\nRET\n"}, "450": {"funcbody": "int [FUNC1] (TYPE18 [VAR1] ,TYPE22 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  _func_int_EC_GROUP_ptr_BIGNUM_ptr_BIGNUM_ptr_BN_CTX_ptr *p_Var1;\n  _func_int_EC_GROUP_ptr_BIGNUM_ptr_BN_CTX_ptr *p_Var2;\n  int iVar3;\n  int iVar4;\n  [TYPE7] [VAR7] ;\n  BN_CTX *[VAR9] ;\n  [TYPE8] [VAR8] ;\n  \n  [VAR9] = (BN_CTX *)0x0;\n  if (([VAR6] == ([TYPE6] )0x0) &&\n     ([VAR6] = [FUNC4] ([VAR1] ->libctx), [VAR9] = [VAR6] , [VAR6] == (BN_CTX *)0x0)) {\n    return 0;\n  }\n  if (((([VAR3] == ([TYPE3] )0x0) ||\n       ((iVar3 = [FUNC5] ((BIGNUM *)[VAR2] ->X,(BIGNUM *)[VAR3] ,(BIGNUM *)[VAR1] ->field,(BN_CTX *)[VAR6] ),\n        iVar3 != 0 &&\n        ((p_Var1 = [VAR1] ->meth->field_encode,\n         p_Var1 == (_func_int_EC_GROUP_ptr_BIGNUM_ptr_BIGNUM_ptr_BN_CTX_ptr *)0x0 ||\n         (iVar3 = (*p_Var1)([VAR1] ,[VAR2] ->X,[VAR2] ->X,[VAR6] ), iVar3 != 0)))))) &&\n      (([VAR4] == ([TYPE4] )0x0 ||\n       ((iVar3 = [FUNC5] ((BIGNUM *)[VAR2] ->Y,(BIGNUM *)[VAR4] ,(BIGNUM *)[VAR1] ->field,(BN_CTX *)[VAR6] ),\n        iVar3 != 0 &&\n        ((p_Var1 = [VAR1] ->meth->field_encode,\n         p_Var1 == (_func_int_EC_GROUP_ptr_BIGNUM_ptr_BIGNUM_ptr_BN_CTX_ptr *)0x0 ||\n         (iVar3 = (*p_Var1)([VAR1] ,[VAR2] ->Y,[VAR2] ->Y,[VAR6] ), iVar3 != 0)))))))) &&\n     ((iVar3 = 1, [VAR5] != ([TYPE5] )0x0 &&\n      (iVar3 = [FUNC5] ((BIGNUM *)[VAR2] ->Z,(BIGNUM *)[VAR5] ,(BIGNUM *)[VAR1] ->field,(BN_CTX *)[VAR6] ),\n      iVar3 != 0)))) {\n    iVar4 = [FUNC3] ([VAR2] ->Z);\n    p_Var1 = [VAR1] ->meth->field_encode;\n    if (p_Var1 != (_func_int_EC_GROUP_ptr_BIGNUM_ptr_BIGNUM_ptr_BN_CTX_ptr *)0x0) {\n      if ((iVar4 == 0) ||\n         (p_Var2 = [VAR1] ->meth->field_set_to_one,\n         p_Var2 == (_func_int_EC_GROUP_ptr_BIGNUM_ptr_BN_CTX_ptr *)0x0)) {\n        iVar3 = (*p_Var1)([VAR1] ,[VAR2] ->Z,[VAR2] ->Z,[VAR6] );\n      }\n      else {\n        iVar3 = (*p_Var2)([VAR1] ,[VAR2] ->Z,[VAR6] );\n      }\n      if (iVar3 == 0) goto err;\n    }\n    [VAR2] ->Z_is_one = iVar4;\n    iVar3 = 1;\n  }\nerr:\n  [FUNC2] ((BN_CTX *)[VAR9] );\n  return iVar3;\n}", "answer": {"VAR1": "group", "VAR2": "point", "VAR3": "x", "VAR4": "y", "VAR5": "z", "VAR6": "ctx", "FUNC2": "BN_CTX_free", "FUNC3": "BN_is_one", "FUNC1": "ossl_ec_GFp_simple_set_Jprojective_coordinates_GFp", "TYPE3": "BIGNUM *", "TYPE2": "EC_POINT *", "FUNC4": "BN_CTX_new_ex", "TYPE5": "BIGNUM *", "FUNC5": "BN_nnmod", "TYPE4": "BIGNUM *", "TYPE7": "int", "TYPE6": "BN_CTX *", "TYPE9": "undefined8", "TYPE8": "undefined8", "VAR7": "Z_is_one", "VAR8": "local_40", "VAR9": "local_48", "TYPE1": "EC_GROUP *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV R12,RDI\nMOV R13,RSI\nMOV R14,RDX\nMOV R15,RCX\nMOV qword ptr [RSP + 0x8],R8\nMOV RBP,R9\nMOV qword ptr [RSP],0x0\nTEST R9,R9\nJZ 0x000974e7\nTEST R14,R14\nJZ 0x00097463\nMOV RDX,qword ptr [R12 + 0x40]\nMOV RDI,qword ptr [R13 + 0x10]\nMOV RCX,RBP\nMOV RSI,R14\nCALL 0x0016288b\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x000974cd\nMOV RAX,qword ptr [R12]\nMOV RAX,qword ptr [RAX + 0x118]\nTEST RAX,RAX\nJZ 0x00097463\nMOV RSI,qword ptr [R13 + 0x10]\nMOV RCX,RBP\nMOV RDX,RSI\nMOV RDI,R12\nCALL RAX\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x000974cd\nTEST R15,R15\nJZ 0x000974a7\nMOV RDX,qword ptr [R12 + 0x40]\nMOV RDI,qword ptr [R13 + 0x18]\nMOV RCX,RBP\nMOV RSI,R15\nCALL 0x0016288b\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x000974cd\nMOV RAX,qword ptr [R12]\nMOV RAX,qword ptr [RAX + 0x118]\nTEST RAX,RAX\nJZ 0x000974a7\nMOV RSI,qword ptr [R13 + 0x18]\nMOV RCX,RBP\nMOV RDX,RSI\nMOV RDI,R12\nCALL RAX\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x000974cd\nMOV EBX,0x1\nMOV RSI,qword ptr [RSP + 0x8]\nTEST RSI,RSI\nJZ 0x000974cd\nMOV RDX,qword ptr [R12 + 0x40]\nMOV RDI,qword ptr [R13 + 0x20]\nMOV RCX,RBP\nCALL 0x0016288b\nMOV EBX,EAX\nTEST EAX,EAX\nJNZ 0x00097509\nMOV RDI,qword ptr [RSP]\nCALL 0x0015d990\nMOV EAX,EBX\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV RDI,qword ptr [RDI + 0xa8]\nCALL 0x0015d8a8\nMOV RBP,RAX\nMOV EBX,0x0\nTEST RAX,RAX\nJZ 0x000974d6\nMOV qword ptr [RSP],RAX\nJMP 0x0009741b\nMOV RDI,qword ptr [R13 + 0x20]\nCALL 0x00079ce9\nMOV R14D,EAX\nMOV RDX,qword ptr [R12]\nMOV RAX,qword ptr [RDX + 0x118]\nTEST RAX,RAX\nJZ 0x0009753f\nTEST R14D,R14D\nJNZ 0x0009754a\nMOV RSI,qword ptr [R13 + 0x20]\nMOV RCX,RBP\nMOV RDX,RSI\nMOV RDI,R12\nCALL RAX\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x000974cd\nMOV dword ptr [R13 + 0x28],R14D\nMOV EBX,0x1\nJMP 0x000974cd\nMOV RCX,qword ptr [RDX + 0x128]\nTEST RCX,RCX\nJZ 0x0009752a\nMOV RSI,qword ptr [R13 + 0x20]\nMOV RDX,RBP\nMOV RDI,R12\nCALL RCX\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x000974cd\nJMP 0x0009753f\n"}, "451": {"funcbody": "/* DWARF original prototype: void set_name(LoadObject * this, char * string) */\nvoid __thiscall LoadObject::[FUNC1] (TYPE15 [VAR1] ,[TYPE2] [VAR2] )\n{\n  char *pcVar1;\n  char *pcVar2;\n  \n  pcVar2 = (char *)0x0;\n  if ([VAR2] != ([TYPE2] )0x0) {\n    pcVar2 = [FUNC4] ([VAR2] );\n  }\n  [VAR1] ->pathname = pcVar2;\n  pcVar1 = [FUNC2] (pcVar2,0x2f);\n  if (pcVar1 != (char *)0x0) {\n    pcVar2 = pcVar1 + 1;\n  }\n  if (*pcVar2 == '<') {\n    pcVar1 = (char *)0x0;\n    if (pcVar2 != (char *)0x0) {\n      pcVar1 = [FUNC4] (pcVar2);\n    }\n    ([VAR1] ->super_HistableFile).super_Histable.name = pcVar1;\n  }\n  else {\n    pcVar2 = [FUNC3] (\"<%s>\",pcVar2);\n    ([VAR1] ->super_HistableFile).super_Histable.name = pcVar2;\n  }\n  return;\n}", "answer": {"VAR1": "this", "VAR2": "string", "FUNC2": "strrchr", "FUNC3": "dbe_sprintf", "FUNC1": "set_name", "TYPE2": "char *", "FUNC4": "strdup", "TYPE1": "LoadObject *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RDI\nMOV EBX,0x0\nTEST RSI,RSI\nJZ 0x000ebaf8\nMOV RDI,RSI\nCALL 0x00090280\nMOV RBX,RAX\nMOV qword ptr [RBP + 0x100],RBX\nMOV ESI,0x2f\nMOV RDI,RBX\nCALL 0x0008fca0\nLEA RDX,[RAX + 0x1]\nTEST RAX,RAX\nCMOVNZ RBX,RDX\nCMP byte ptr [RBX],0x3c\nJNZ 0x000ebb39\nMOV EAX,0x0\nTEST RBX,RBX\nJZ 0x000ebb2e\nMOV RDI,RBX\nCALL 0x00090280\nMOV qword ptr [RBP + 0x18],RAX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RSI,RBX\nLEA RDI,[0x248978]\nMOV EAX,0x0\nCALL 0x0012e0a5\nMOV qword ptr [RBP + 0x18],RAX\nJMP 0x000ebb32\n"}, "452": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  long lVar1;\n  [TYPE5] [VAR5] ;\n  int iVar2;\n  char *pcVar4;\n  long in_FS_OFFSET;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  int *piVar3;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC4] ([VAR1] ,(adns_query)0x0,cc_enter);\n  do {\n    while( true ) {\n      while( true ) {\n        iVar2 = [FUNC11] ([VAR1] ,[VAR2] ,[VAR3] ,[VAR4] );\n        if (iVar2 != 0xb) goto xit;\n        [VAR9] = 3;\n        [VAR8] = -1;\n        [FUNC10] ([VAR1] ,[VAR7] ,&[VAR9] ,&[VAR8] ,(timeval *)0x0);\n        iVar2 = [FUNC7] ([VAR7] ,[VAR9] ,[VAR8] );\n        if (iVar2 == -1) break;\n        if (iVar2 < 0) {\n          [FUNC8] (\"r >= 0\",\"../src/poll.c\",0x79,\"adns_wait_poll\");\n        }\n        [FUNC3] ([VAR1] ,[VAR7] ,[VAR9] ,(timeval *)0x0);\n      }\n      piVar3 = [FUNC12] ();\n      if (*piVar3 == 4) break;\n      pcVar4 = [FUNC6] (*piVar3);\n      [FUNC13] ([VAR1] ,-1,(adns_query)0x0,\"poll failed in wait: %s\",pcVar4);\n      [FUNC2] ([VAR1] );\n    }\n    iVar2 = 4;\n  } while ((*(byte *)&[VAR1] ->iflags & 0x20) == 0);\nxit:\n  [FUNC5] ([VAR1] ,(adns_query)0x0);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC9] ();\n}", "answer": {"FUNC12": "__errno_location", "FUNC11": "adns__internal_check", "VAR1": "ads", "FUNC13": "adns__diag", "VAR2": "query_io", "VAR3": "answer_r", "VAR4": "context_r", "FUNC10": "adns_beforepoll", "VAR5": "r", "VAR6": "local_40", "FUNC2": "adns_globalsystemfailure", "FUNC3": "adns_afterpoll", "FUNC1": "adns_wait_poll", "FUNC6": "strerror", "TYPE3": "adns_answer * *", "FUNC7": "Hpoll", "TYPE2": "adns_query *", "FUNC4": "adns__consistency", "TYPE5": "int", "FUNC5": "adns__returning", "TYPE4": "void * *", "TYPE7": "pollfd[3]", "TYPE6": "undefined8", "FUNC8": "__assert_fail", "TYPE9": "int", "FUNC9": "__stack_chk_fail", "TYPE8": "int", "VAR7": "fds", "TYPE11": "undefined8", "VAR8": "to", "VAR9": "nfds", "TYPE10": "undefined8", "VAR10": "local_70", "VAR11": "local_78", "TYPE1": "adns_state"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x48\nMOV RBX,RDI\nMOV R13,RSI\nMOV qword ptr [RSP],RDX\nMOV qword ptr [RSP + 0x8],RCX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x38],RAX\nXOR EAX,EAX\nMOV EDX,0x1\nMOV ESI,0x0\nCALL 0x00015808\nLEA R15,[RSP + 0x1c]\nLEA R14,[RSP + 0x18]\nLEA R12,[RSP + 0x20]\nJMP 0x0001552f\nCALL 0x00003ea0\nMOV EBP,dword ptr [RAX]\nCMP EBP,0x4\nJNZ 0x000154ff\nTEST byte ptr [RBX],0x20\nJZ 0x0001552f\nMOV ESI,0x0\nMOV RDI,RBX\nCALL 0x0000f1de\nMOV EAX,EBP\nMOV RCX,qword ptr [RSP + 0x38]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x000155c3\nADD RSP,0x48\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV EDI,EBP\nCALL 0x00004240\nMOV R8,RAX\nLEA RCX,[0x1b595]\nMOV EDX,0x0\nMOV ESI,0xffffffff\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x000118c8\nMOV RDI,RBX\nCALL 0x0000dba9\nMOV RCX,qword ptr [RSP + 0x8]\nMOV RDX,qword ptr [RSP]\nMOV RSI,R13\nMOV RDI,RBX\nCALL 0x0000e2e3\nMOV EBP,EAX\nCMP EAX,0xb\nJNZ 0x000154cd\nMOV dword ptr [RSP + 0x18],0x3\nMOV dword ptr [RSP + 0x1c],0xffffffff\nMOV R8D,0x0\nMOV RCX,R15\nMOV RDX,R14\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x00015165\nMOV EDX,dword ptr [RSP + 0x1c]\nMOV ESI,dword ptr [RSP + 0x18]\nMOV RDI,R12\nCALL 0x00006df6\nCMP EAX,-0x1\nJZ 0x000154bc\nTEST EAX,EAX\nJS 0x000155a4\nMOV ECX,0x0\nMOV EDX,dword ptr [RSP + 0x18]\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x0001539c\nJMP 0x0001552f\nLEA RCX,[0x1b5f0]\nMOV EDX,0x79\nLEA RSI,[0x1b574]\nLEA RDI,[0x1b5ad]\nCALL 0x00003f80\nCALL 0x00003f20\n"}, "453": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] )\n{\n  long lVar1;\n  uint uVar2;\n  \n  if (-1 < [VAR1] ) {\n    if ([VAR1] == 0) {\n      uVar2 = 0;\nLAB_0002f8dc:\n      return speeds[uVar2].given_speed;\n    }\n    lVar1 = 1;\n    do {\n      uVar2 = (uint)lVar1;\n      if (speeds[lVar1].actual_speed == [VAR1] ) goto LAB_0002f8dc;\n      lVar1 = lVar1 + 1;\n    } while (lVar1 != 0x1f);\n  }\n  return 1;\n}", "answer": {"VAR1": "BaudRate", "FUNC1": "_nc_ospeed", "TYPE1": "int"}, "assembly": "MOV EAX,0x1\nTEST EDI,EDI\nJS 0x0002f8d5\nTEST EDI,EDI\nJZ 0x0002f8d7\nMOV EAX,0x1\nLEA RCX,[0x3d324]\nMOV EDX,EAX\nCMP dword ptr [RCX + RAX*0x8],EDI\nJZ 0x0002f8dc\nADD RAX,0x1\nCMP RAX,0x1f\nJNZ 0x0002f8bf\nMOV EAX,0x1\nRET\nMOV EDX,0x0\nMOV EDX,EDX\nLEA RAX,[0x3d320]\nMOV EAX,dword ptr [RAX + RDX*0x8]\nRET\n"}, "454": {"funcbody": "bool [FUNC1] (undefined8 param_1,int param_2)\n{\n  long lVar1;\n  \n  lVar1 = [FUNC2] (param_1,1,param_2);\n  if (lVar1 != 0) {\n    *(long *)(lVar1 + 8) = (long)param_2;\n  }\n  return lVar1 != 0;\n}", "answer": {"FUNC2": "FUN_0025b7e8", "FUNC1": "FUN_0025deae"}, "assembly": "PUSH RBX\nMOV EBX,ESI\nMOV EDX,ESI\nMOV ESI,0x1\nCALL 0x0025b7e8\nMOV EDX,0x0\nTEST RAX,RAX\nJZ 0x0025ded3\nMOVSXD RBX,EBX\nMOV qword ptr [RAX + 0x8],RBX\nMOV EDX,0x1\nMOV EAX,EDX\nPOP RBX\nRET\n"}, "455": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,...)\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  [TYPE2] [VAR2] ;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  [TYPE18] [VAR18] ;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  undefined8 [VAR15] ;\n  undefined8 [VAR14] ;\n  undefined8 [VAR13] ;\n  undefined8 [VAR12] ;\n  undefined8 [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  if (in_AL != '\\0') {\n    [VAR10] ._0_4_ = in_XMM0_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR18] [0].gp_offset = 8;\n  [VAR18] [0].fp_offset = 0x30;\n  [VAR18] [0].overflow_arg_area = &stack0x00000008;\n  [VAR18] [0].reg_save_area = &[VAR16] ;\n  [VAR15] = in_RSI;\n  [VAR14] = in_RDX;\n  [VAR13] = in_RCX;\n  [VAR12] = in_R8;\n  [VAR11] = in_R9;\n  iVar2 = [FUNC2] (stdscr,[VAR1] ,[VAR18] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC3] ();\n}", "answer": {"TYPE17": "undefined8", "TYPE18": "va_list", "VAR1": "fmt", "VAR2": "code", "VAR3": "local_18", "VAR4": "local_28", "VAR5": "local_38", "VAR6": "local_48", "FUNC2": "vw_printw", "FUNC3": "__stack_chk_fail", "FUNC1": "printw", "TYPE3": "undefined1[16]", "VAR14": "local_a8", "TYPE2": "int", "VAR15": "local_b0", "TYPE5": "undefined1[16]", "VAR12": "local_98", "TYPE4": "undefined1[16]", "VAR13": "local_a0", "TYPE7": "undefined1[16]", "VAR18": "argp", "TYPE6": "undefined1[16]", "TYPE9": "undefined1[16]", "VAR16": "local_b8", "TYPE8": "undefined1[16]", "VAR17": "local_c0", "VAR7": "local_58", "TYPE11": "undefined8", "VAR8": "local_68", "TYPE12": "undefined8", "VAR9": "local_78", "TYPE10": "undefined1[16]", "VAR10": "local_88", "TYPE15": "undefined8", "VAR11": "local_90", "TYPE16": "undefined1", "TYPE1": "char *", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "SUB RSP,0xd8\nMOV qword ptr [RSP + 0x28],RSI\nMOV qword ptr [RSP + 0x30],RDX\nMOV qword ptr [RSP + 0x38],RCX\nMOV qword ptr [RSP + 0x40],R8\nMOV qword ptr [RSP + 0x48],R9\nTEST AL,AL\nJZ 0x00026ab8\nMOVAPS xmmword ptr [RSP + 0x50],XMM0\nMOVAPS xmmword ptr [RSP + 0x60],XMM1\nMOVAPS xmmword ptr [RSP + 0x70],XMM2\nMOVAPS xmmword ptr [RSP + 0x80],XMM3\nMOVAPS xmmword ptr [RSP + 0x90],XMM4\nMOVAPS xmmword ptr [RSP + 0xa0],XMM5\nMOVAPS xmmword ptr [RSP + 0xb0],XMM6\nMOVAPS xmmword ptr [RSP + 0xc0],XMM7\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0x8\nMOV dword ptr [RSP + 0x4],0x30\nLEA RAX,[RSP + 0xe0]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nMOV RDX,RSP\nMOV RSI,RDI\nMOV RDI,qword ptr [0x0025bfd0]\nCALL 0x00026a1c\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00026b18\nADD RSP,0xd8\nRET\nCALL 0x00008bc0\n"}, "456": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,TYPE47 [VAR4] ,\n         TYPE51 [VAR5] ,TYPE62 [VAR6] ,[TYPE7] [VAR7] )\n{\n  [TYPE10] [VAR10] ;\n  int iVar1;\n  EVP_PKEY *pk;\n  OSSL_LIB_CTX *libctx;\n  [TYPE9] [VAR9] ;\n  BIO *out;\n  TYPE82 [VAR8] ;\n  \n  if (([VAR3] & 1U) != 0) {\n    pk = (EVP_PKEY *)[FUNC5] ();\n    if (pk == (EVP_PKEY *)0x0) {\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = (*[VAR5] )(pk,[VAR2] );\n      if ((iVar1 != 0) &&\n         (([VAR6] == (TYPE62)0x0 ||\n          (iVar1 = [FUNC8] ((ossl_passphrase_data_st *)((long)[VAR1] + 0x10),[VAR6] ,[VAR7] ), iVar1 != 0)))) {\n        libctx = [FUNC6] (*[VAR1] );\n        out = [FUNC7] (*[VAR1] ,[VAR4] );\n        iVar1 = 0;\n        if (out != (BIO *)0x0) {\n          iVar1 = [FUNC9] (out,pk,*(int *)((long)[VAR1] + 8),[FUNC3] ,(void *)((long)[VAR1] + 0x10),libctx,\n                        (char *)0x0);\n          [FUNC4] ((BIO *)out);\n        }\n      }\n    }\n    [FUNC2] ((EVP_PKEY *)pk);\n    return iVar1;\n  }\n  return 0;\n}", "answer": {"VAR1": "vctx", "VAR2": "key", "VAR3": "selection", "VAR4": "cout", "VAR5": "set1_key", "VAR6": "pw_cb", "FUNC2": "EVP_PKEY_free", "FUNC3": "ossl_pw_pvk_password", "FUNC1": "key2pvk_encode", "FUNC6": "ossl_prov_ctx_get0_libctx", "TYPE3": "int", "FUNC7": "ossl_bio_new_from_core_bio", "TYPE2": "void *", "FUNC4": "BIO_free", "TYPE5": "evp_pkey_set1_fn *", "FUNC5": "EVP_PKEY_new", "TYPE4": "OSSL_CORE_BIO *", "TYPE7": "void *", "TYPE6": "OSSL_PASSPHRASE_CALLBACK *", "FUNC8": "ossl_pw_set_ossl_passphrase_cb", "TYPE9": "OSSL_LIB_CTX *", "FUNC9": "i2b_PVK_bio_ex", "TYPE8": "key2ms_ctx_st *", "VAR7": "pw_cbarg", "VAR8": "ctx", "VAR9": "libctx", "TYPE10": "int", "VAR10": "ret", "TYPE1": "void *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nAND EDX,0x1\nMOV EBX,EDX\nJNZ 0x0019abf2\nMOV EAX,EBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV R12,R9\nMOV RBX,R8\nMOV R13,RCX\nMOV R15,RSI\nMOV RBP,RDI\nCALL 0x0011ec29\nMOV R14,RAX\nTEST RAX,RAX\nJZ 0x0019ac9e\nMOV RSI,R15\nMOV RDI,RAX\nCALL RBX\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x0019ac91\nTEST R12,R12\nJZ 0x0019ac3c\nLEA RDI,[RBP + 0x10]\nMOV RDX,qword ptr [RSP + 0x40]\nMOV RSI,R12\nCALL 0x00132b8d\nMOV EBX,EAX\nTEST EAX,EAX\nJZ 0x0019ac91\nMOV RDI,qword ptr [RBP]\nCALL 0x001bc4af\nMOV R15,RAX\nMOV RSI,R13\nMOV RDI,qword ptr [RBP]\nCALL 0x0017a713\nMOV R12,RAX\nMOV EBX,0x0\nTEST RAX,RAX\nJZ 0x0019ac91\nMOV EDX,dword ptr [RBP + 0x8]\nSUB RSP,0x8\nPUSH 0x0\nMOV R9,R15\nLEA R8,[RBP + 0x10]\nLEA RCX,[0x13347c]\nMOV RSI,R14\nMOV RDI,RAX\nCALL 0x0026d8f5\nMOV EBX,EAX\nMOV RDI,R12\nCALL 0x000d36e1\nADD RSP,0x10\nMOV RDI,R14\nCALL 0x0011f52c\nJMP 0x0019abe1\nMOV EBX,0x0\nJMP 0x0019ac91\n"}, "457": {"funcbody": "coff_symbol_classification [FUNC1] (TYPE13 [VAR1] ,TYPE27 [VAR2] )\n{\n  byte bVar1;\n  long lVar2;\n  coff_symbol_classification cVar3;\n  char *pcVar4;\n  char *fmt;\n  long in_FS_OFFSET;\n  TYPE42 [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  lVar2 = *(long *)(in_FS_OFFSET + 0x28);\n  bVar1 = [VAR2] ->n_sclass;\n  if (bVar1 != 0x17) {\n    if (bVar1 < 0x18) {\n      if (bVar1 != 2) goto LAB_001f2837;\n    }\n    else if ((bVar1 != 0x69) && (bVar1 != 0x7f)) {\nLAB_001f2837:\n      if (bVar1 == 3) {\n        cVar3 = COFF_SYMBOL_LOCAL;\n      }\n      else if (bVar1 == 0x68) {\n        [VAR2] ->n_value = 0;\n        cVar3 = (-(uint)([VAR2] ->n_scnum == 0) & 0xfffffffe) + COFF_SYMBOL_PE_SECTION;\n      }\n      else {\n        cVar3 = COFF_SYMBOL_LOCAL;\n        if ([VAR2] ->n_scnum == 0) {\n          pcVar4 = [FUNC4] ([VAR1] ,[VAR2] ,[VAR4] );\n          fmt = (char *)[FUNC2] (&DAT_0026fd3f,\"warning: %pB: local symbol `%s\\' has no section\",5);\n          [FUNC3] (fmt,[VAR1] ,pcVar4);\n          cVar3 = COFF_SYMBOL_LOCAL;\n        }\n      }\n      goto LAB_001f2818;\n    }\n  }\n  cVar3 = COFF_SYMBOL_GLOBAL;\n  if ([VAR2] ->n_scnum == 0) {\n    cVar3 = ([VAR2] ->n_value == 0) + COFF_SYMBOL_COMMON;\n  }\nLAB_001f2818:\n  if (lVar2 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return cVar3;\n  }\n  [FUNC5] ();\n}", "answer": {"VAR1": "abfd", "VAR2": "syment", "VAR3": "local_20", "VAR4": "buf", "FUNC2": "dcgettext", "FUNC3": "_bfd_error_handler", "FUNC1": "coff_classify_symbol", "TYPE3": "undefined8", "TYPE2": "internal_syment *", "FUNC4": "_bfd_coff_internal_syment_name", "FUNC5": "__stack_chk_fail", "TYPE4": "char[9]", "TYPE1": "bfd *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x28\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOVZX EAX,byte ptr [RSI + 0x20]\nCMP AL,0x17\nJZ 0x001f27ff\nMOV RBX,RDI\nCMP AL,0x17\nJBE 0x001f2833\nCMP AL,0x69\nJZ 0x001f27ff\nCMP AL,0x7f\nJNZ 0x001f2837\nMOV EAX,0x0\nCMP dword ptr [RSI + 0x18],0x0\nJNZ 0x001f2818\nCMP qword ptr [RSI + 0x10],0x0\nSETZ AL\nMOVZX EAX,AL\nADD EAX,0x1\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x001f28af\nADD RSP,0x28\nPOP RBX\nPOP RBP\nRET\nCMP AL,0x2\nJZ 0x001f27ff\nCMP AL,0x3\nJZ 0x001f28a5\nCMP AL,0x68\nJZ 0x001f288c\nMOV EAX,0x3\nCMP dword ptr [RSI + 0x18],0x0\nJNZ 0x001f2818\nLEA RDX,[RSP + 0xf]\nMOV RDI,RBX\nCALL 0x001ef19e\nMOV RBP,RAX\nMOV EDX,0x5\nLEA RSI,[0x278d58]\nLEA RDI,[0x26fd3f]\nCALL 0x0008f940\nMOV RDX,RBP\nMOV RSI,RBX\nMOV RDI,RAX\nMOV EAX,0x0\nCALL 0x00178508\nMOV EAX,0x3\nJMP 0x001f2818\nMOV qword ptr [RSI + 0x10],0x0\nCMP dword ptr [RSI + 0x18],0x1\nSBB EAX,EAX\nAND EAX,0xfffffffe\nADD EAX,0x4\nJMP 0x001f2818\nMOV EAX,0x3\nJMP 0x001f2818\nCALL 0x0008fc50\n"}, "458": {"funcbody": "grub_err_t\n[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  long lVar1;\n  grub_err_t gVar2;\n  int iVar3;\n  grub_jfs_data *data;\n  grub_jfs_diropen *diro;\n  long in_FS_OFFSET;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC5] (my_mod);\n  data = [FUNC10] ([VAR1] ->disk);\n  diro = (grub_jfs_diropen *)0x0;\n  if (((data != (grub_jfs_data *)0x0) && (gVar2 = [FUNC6] (data,[VAR2] ,2), gVar2 == GRUB_ERR_NONE)) &&\n     (diro = [FUNC9] (data,&data->currinode), diro != (grub_jfs_diropen *)0x0)) {\n    do {\n      gVar2 = [FUNC3] (diro);\n      if (gVar2 == GRUB_ERR_OUT_OF_RANGE) {\n        if (grub_errno == GRUB_ERR_OUT_OF_RANGE) {\n          grub_errno = GRUB_ERR_NONE;\n        }\n        break;\n      }\n      [FUNC11] (&[VAR7] ,0,0x18);\n      gVar2 = [FUNC7] (data,diro->ino,&[VAR6] );\n      if (gVar2 != GRUB_ERR_NONE) break;\n      [VAR7] ._0_1_ = [VAR7] ._0_1_ & 0xfe | ([VAR6] .mode & 0xf000) == 0x4000 | 2;\n      [VAR7] .mtime = (grub_int64_t)(uint)[VAR6] .mtime.sec;\n      iVar3 = (*[VAR3] )(diro->name,&[VAR7] ,[VAR4] );\n    } while (iVar3 == 0);\n  }\n  [FUNC12] (diro);\n  [FUNC2] (data);\n  [FUNC8] (my_mod);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC4] ();\n  }\n  return grub_errno;\n}", "answer": {"FUNC12": "grub_jfs_closedir", "FUNC11": "grub_memset", "VAR1": "device", "VAR2": "path", "VAR3": "hook", "VAR4": "hook_data", "FUNC10": "grub_jfs_mount", "VAR5": "local_40", "VAR6": "inode", "FUNC2": "grub_free", "FUNC3": "FUNC1", "FUNC1": "grub_jfs_dir", "FUNC6": "FUNC1", "TYPE3": "grub_fs_dir_hook_t", "FUNC7": "grub_jfs_read_inode", "TYPE2": "char *", "FUNC4": "__stack_chk_fail", "TYPE5": "undefined8", "FUNC5": "grub_dl_ref", "TYPE4": "void *", "TYPE7": "grub_dirhook_info", "TYPE6": "grub_jfs_inode", "FUNC8": "grub_dl_unref", "FUNC9": "grub_jfs_opendir", "TYPE8": "undefined8", "VAR7": "info", "VAR8": "local_270", "TYPE1": "grub_device_t"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x248\nMOV RBX,RDI\nMOV R12,RSI\nMOV R13,RDX\nMOV R14,RCX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x238],RAX\nXOR EAX,EAX\nMOV RDI,qword ptr [0x002b8318]\nCALL 0x0005f841\nMOV RDI,qword ptr [RBX]\nCALL 0x0002447e\nMOV RBP,RAX\nMOV EBX,0x0\nTEST RAX,RAX\nJZ 0x00025436\nMOV EDX,0x2\nMOV RSI,R12\nMOV RDI,RAX\nCALL 0x00024ffa\nTEST EAX,EAX\nJZ 0x00025481\nMOV RDI,RBX\nCALL 0x00024460\nMOV RDI,RBP\nCALL 0x00061bad\nMOV RDI,qword ptr [0x002b8318]\nCALL 0x0005f847\nMOV EAX,dword ptr [0x002c63a0]\nMOV RCX,qword ptr [RSP + 0x238]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x00025541\nADD RSP,0x248\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nLEA RSI,[RBP + 0x2b0]\nMOV RDI,RBP\nCALL 0x00024744\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x00025436\nLEA R12,[RSP + 0x10]\nLEA R15,[RSP + 0x30]\nLEA RAX,[RAX + 0x38]\nMOV qword ptr [RSP + 0x8],RAX\nMOV RDI,RBX\nCALL 0x00024bdf\nCMP EAX,0xb\nJZ 0x00025525\nMOV EDX,0x18\nMOV ESI,0x0\nMOV RDI,R12\nCALL 0x00062db6\nMOV ESI,dword ptr [RBX + 0x439]\nMOV RDX,R15\nMOV RDI,RBP\nCALL 0x00024efa\nTEST EAX,EAX\nJNZ 0x00025436\nMOV EAX,dword ptr [RSP + 0x64]\nAND EAX,0xf000\nCMP EAX,0x4000\nSETZ DL\nMOVZX EAX,byte ptr [RSP + 0x10]\nAND EAX,0xfffffffe\nOR EAX,EDX\nOR EAX,0x2\nMOV byte ptr [RSP + 0x10],AL\nMOV EAX,dword ptr [RSP + 0x78]\nMOV qword ptr [RSP + 0x18],RAX\nMOV RDX,R14\nMOV RSI,R12\nMOV RDI,qword ptr [RSP + 0x8]\nCALL R13\nTEST EAX,EAX\nJZ 0x000254ab\nJMP 0x00025436\nCMP dword ptr [0x002c63a0],0xb\nJNZ 0x00025436\nMOV dword ptr [0x002c63a0],0x0\nJMP 0x00025436\nCALL 0x00006c80\n"}, "459": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  [TYPE2] [VAR2] ;\n  \n  if (*(FILE **)((long)[VAR1] + 0x48) != (FILE *)0x0) {\n    [FUNC3] (*(FILE **)((long)[VAR1] + 0x48));\n    *(undefined8 *)((long)[VAR1] + 0x48) = 0;\n  }\n  (*Curl_cfree)(*(void **)((long)[VAR1] + 0x20));\n  *(undefined8 *)((long)[VAR1] + 0x20) = 0;\n  return;\n}", "answer": {"VAR1": "ptr", "VAR2": "part", "FUNC2": "free", "FUNC3": "fclose", "FUNC1": "mime_file_free", "TYPE2": "curl_mimepart *", "TYPE1": "void *"}, "assembly": "PUSH RBX\nMOV RBX,RDI\nMOV RDI,qword ptr [RDI + 0x48]\nTEST RDI,RDI\nJZ 0x0002cadf\nCALL 0x000077a0\nMOV qword ptr [RBX + 0x48],0x0\nMOV RDI,qword ptr [RBX + 0x20]\nLEA RAX,[0x26d520]\nCALL qword ptr [RAX]\nMOV qword ptr [RBX + 0x20],0x0\nPOP RBX\nRET\n"}, "460": {"funcbody": "EVP_PKEY * [FUNC1] ([TYPE1] [VAR1] )\n{\n  EVP_PKEY *pEVar1;\n  long in_FS_OFFSET;\n  [TYPE3] [VAR3] ;\n  long [VAR2] ;\n  \n  [VAR2] = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR3] = 0;\n  pEVar1 = [FUNC2] ((BIO *)[VAR1] ,&[VAR3] );\n  if ([VAR2] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return (EVP_PKEY *)pEVar1;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "in", "VAR2": "local_10", "VAR3": "ispub", "FUNC2": "ossl_b2i_bio", "FUNC3": "__stack_chk_fail", "FUNC1": "b2i_PrivateKey_bio", "TYPE3": "int", "TYPE2": "undefined8", "TYPE1": "BIO *"}, "assembly": "SUB RSP,0x18\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP + 0x4],0x0\nLEA RSI,[RSP + 0x4]\nCALL 0x001d7220\nMOV RDX,qword ptr [RSP + 0x8]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x001d7585\nADD RSP,0x18\nRET\nCALL 0x000654a0\n"}, "461": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,TYPE21 [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,TYPE66 [VAR6] ,[TYPE7] [VAR7] )\n{\n  int iVar1;\n  \n  if ([VAR4] == ([TYPE4] )0x0) {\n    if (([VAR5] & 1U) == 0) {\n      [FUNC4] ();\n      [FUNC3] (\"providers/implementations/encode_decode/encode_key2any.c\",0x561,\n            \"dsa_to_PrivateKeyInfo_pem_encode\");\n      [FUNC8] (0x39,0x80106,(char *)0x0);\n      iVar1 = 0;\n    }\n    else {\n      iVar1 = [FUNC5] ((key2any_ctx_st *)[VAR1] ,[VAR2] ,[VAR3] ,0x74,\"DSA PRIVATE KEY\",(check_key_type_fn *)0x0\n                    ,[FUNC2] ,[VAR6] ,[VAR7] ,[FUNC7] ,[FUNC6] );\n    }\n  }\n  else {\n    [FUNC4] ();\n    [FUNC3] (\"providers/implementations/encode_decode/encode_key2any.c\",0x561,\n          \"dsa_to_PrivateKeyInfo_pem_encode\");\n    [FUNC8] (0x39,0x80106,(char *)0x0);\n    iVar1 = 0;\n  }\n  return iVar1;\n}", "answer": {"VAR1": "ctx", "VAR2": "cout", "VAR3": "key", "VAR4": "key_abstract", "VAR5": "selection", "VAR6": "cb", "FUNC2": "key_to_pki_pem_priv_bio", "FUNC3": "ERR_set_debug", "FUNC1": "dsa_to_PrivateKeyInfo_pem_encode", "FUNC6": "dsa_pki_priv_to_der", "TYPE3": "void *", "FUNC7": "prepare_dsa_params", "TYPE2": "OSSL_CORE_BIO *", "FUNC4": "ERR_new", "TYPE5": "int", "FUNC5": "key2any_encode", "TYPE4": "OSSL_PARAM *", "TYPE7": "void *", "TYPE6": "OSSL_PASSPHRASE_CALLBACK *", "FUNC8": "ERR_set_error", "VAR7": "cbarg", "TYPE1": "void *"}, "assembly": "PUSH RBX\nTEST RCX,RCX\nJNZ 0x000de5cf\nMOV EBX,R8D\nAND EBX,0x1\nJNZ 0x000de60e\nCALL 0x00080b6e\nLEA RDX,[0x274f60]\nMOV ESI,0x561\nLEA RDI,[0x274170]\nCALL 0x00080c7b\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00080f92\nJMP 0x000de60a\nCALL 0x00080b6e\nLEA RDX,[0x274f60]\nMOV ESI,0x561\nLEA RDI,[0x274170]\nCALL 0x00080c7b\nMOV EDX,0x0\nMOV ESI,0x80106\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x00080f92\nMOV EBX,0x0\nMOV EAX,EBX\nPOP RBX\nRET\nSUB RSP,0x8\nLEA RAX,[0xe3b5f]\nPUSH RAX\nLEA RAX,[0xe2f41]\nPUSH RAX\nPUSH qword ptr [RSP + 0x28]\nPUSH R9\nLEA RAX,[0xe40a3]\nPUSH RAX\nMOV R9D,0x0\nLEA R8,[0x274043]\nMOV ECX,0x74\nCALL 0x000dc34a\nMOV EBX,EAX\nADD RSP,0x30\nJMP 0x000de60a\n"}, "462": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  _func_int_EC_GROUP_ptr_BIGNUM_ptr_BIGNUM_ptr_BN_CTX_ptr *p_Var1;\n  uint uVar2;\n  int iVar3;\n  BIGNUM *a;\n  BN_CTX *[VAR5] ;\n  \n  p_Var1 = [VAR1] ->meth->field_inverse_mod_ord;\n  if (p_Var1 == (_func_int_EC_GROUP_ptr_BIGNUM_ptr_BIGNUM_ptr_BN_CTX_ptr *)0x0) {\n    uVar2 = 0;\n    if ([VAR1] ->mont_data != (BN_MONT_CTX *)0x0) {\n      [VAR5] = (BN_CTX *)0x0;\n      if (([VAR4] == ([TYPE4] )0x0) && ([VAR4] = [FUNC2] (), [VAR5] = [VAR4] , [VAR4] == (BN_CTX *)0x0)) {\n        uVar2 = 0;\n      }\n      else {\n        [FUNC3] ((BN_CTX *)[VAR4] );\n        a = [FUNC4] ((BN_CTX *)[VAR4] );\n        uVar2 = 0;\n        if (((a != (BIGNUM *)0x0) && (uVar2 = [FUNC6] (a,2), uVar2 != 0)) &&\n           (uVar2 = [FUNC9] (a,(BIGNUM *)[VAR1] ->order,a), uVar2 != 0)) {\n          iVar3 = [FUNC8] ([VAR2] ,[VAR3] ,(BIGNUM *)a,[VAR1] ->order,[VAR4] ,[VAR1] ->mont_data);\n          uVar2 = (uint)(iVar3 != 0);\n        }\n        [FUNC5] ((BN_CTX *)[VAR4] );\n        [FUNC7] ((BN_CTX *)[VAR5] );\n      }\n    }\n  }\n  else {\n    uVar2 = (*p_Var1)([VAR1] ,[VAR2] ,[VAR3] ,[VAR4] );\n  }\n  return uVar2;\n}", "answer": {"VAR1": "group", "VAR2": "res", "VAR3": "x", "VAR4": "ctx", "VAR5": "local_40", "FUNC2": "BN_CTX_secure_new", "FUNC3": "BN_CTX_start", "FUNC1": "ossl_ec_group_do_inverse_ord", "FUNC6": "BN_set_word", "TYPE3": "BIGNUM *", "FUNC7": "BN_CTX_free", "TYPE2": "BIGNUM *", "FUNC4": "BN_CTX_get", "TYPE5": "undefined8", "FUNC5": "BN_CTX_end", "TYPE4": "BN_CTX *", "FUNC8": "BN_mod_exp_mont", "FUNC9": "BN_sub", "TYPE1": "EC_GROUP *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBX,RDI\nMOV R13,RSI\nMOV R14,RDX\nMOV RBP,RCX\nMOV RAX,qword ptr [RDI]\nMOV RAX,qword ptr [RAX + 0x190]\nTEST RAX,RAX\nJZ 0x00088d16\nCALL RAX\nMOV R12D,EAX\nMOV EAX,R12D\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV R12D,0x0\nCMP qword ptr [RDI + 0x90],0x0\nJZ 0x00088d04\nMOV qword ptr [RSP + 0x8],0x0\nTEST RCX,RCX\nJZ 0x00088d7a\nMOV RDI,RBP\nCALL 0x0014d84a\nMOV RDI,RBP\nCALL 0x0014d9ed\nMOV R15,RAX\nMOV R12D,0x0\nTEST RAX,RAX\nJZ 0x00088d66\nMOV ESI,0x2\nMOV RDI,RAX\nCALL 0x000799bf\nMOV R12D,EAX\nTEST EAX,EAX\nJNZ 0x00088d99\nMOV RDI,RBP\nCALL 0x0014d97e\nMOV RDI,qword ptr [RSP + 0x8]\nCALL 0x0014d793\nJMP 0x00088d04\nCALL 0x0014d780\nMOV RBP,RAX\nTEST RAX,RAX\nJNZ 0x00088d92\nMOV R12D,0x0\nJMP 0x00088d04\nMOV qword ptr [RSP + 0x8],RAX\nJMP 0x00088d34\nMOV RSI,qword ptr [RBX + 0x10]\nMOV RDX,R15\nMOV RDI,R15\nCALL 0x0014ce93\nMOV R12D,EAX\nTEST EAX,EAX\nJZ 0x00088d66\nMOV RCX,qword ptr [RBX + 0x10]\nMOV R9,qword ptr [RBX + 0x90]\nMOV R8,RBP\nMOV RDX,R15\nMOV RSI,R14\nMOV RDI,R13\nCALL 0x0014f66f\nTEST EAX,EAX\nSETNZ R12B\nMOVZX R12D,R12B\nJMP 0x00088d66\n"}, "463": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  if ([VAR6] <= [VAR5] ) {\n    return 1;\n  }\n  [FUNC2] ((char *)0x0,[VAR1] ,[VAR2] ,\"char\",[VAR3] ,[VAR4] ,\">=\",\"[%c] compared to [%c]\",(ulong)(uint)(int)[VAR5] ,\n        (ulong)(uint)(int)[VAR6] );\n  return 0;\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "s1", "VAR4": "s2", "VAR5": "t1", "VAR6": "t2", "FUNC2": "test_fail_message", "FUNC1": "test_char_ge", "TYPE3": "char *", "TYPE2": "int", "TYPE5": "char", "TYPE4": "char *", "TYPE6": "char", "TYPE1": "char *"}, "assembly": "MOV EAX,0x1\nCMP R8B,R9B\nJL 0x00004e44\nRET\nSUB RSP,0x8\nMOV R10D,R9D\nMOV EAX,R8D\nMOV R9,RCX\nMOV R8,RDX\nMOV EDX,ESI\nMOVSX R10D,R10B\nPUSH R10\nMOVSX EAX,AL\nPUSH RAX\nLEA RAX,[0xa7fe]\nPUSH RAX\nLEA RAX,[0xa7d8]\nPUSH RAX\nLEA RCX,[0xa81d]\nMOV RSI,RDI\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x00004138\nMOV EAX,0x0\nADD RSP,0x28\nRET\n"}, "464": {"funcbody": "undefined8 [FUNC1] (undefined8 param_1)\n{\n  long lVar1;\n  long in_FS_OFFSET;\n  [TYPE2] [VAR2] ;\n  [TYPE1] [VAR1] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [FUNC4] ();\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n    [FUNC2] ();\n  }\n  return param_1;\n}", "answer": {"VAR1": "local_20", "VAR2": "local_24", "FUNC2": "__stack_chk_fail", "FUNC3": "decStatus", "FUNC1": "decNumberMaxMag", "TYPE2": "undefined4", "FUNC4": "decCompareOp", "TYPE1": "undefined8"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV RBX,RDI\nMOV RBP,RCX\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP + 0x4],0x0\nLEA R9,[RSP + 0x4]\nMOV R8D,0x7\nCALL 0x006ef106\nMOV ESI,dword ptr [RSP + 0x4]\nTEST ESI,ESI\nJNZ 0x006ef6f1\nMOV RAX,RBX\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x006ef6fe\nADD RSP,0x18\nPOP RBX\nPOP RBP\nRET\nMOV RDX,RBP\nMOV RDI,RBX\nCALL 0x006ed571\nJMP 0x006ef6d7\nCALL 0x000cff10\n"}, "465": {"funcbody": "int [FUNC1] (TYPE17 [VAR1] )\n{\n  OSSL_FUNC_keymgmt_query_operation_name_fn *pOVar1;\n  int iVar2;\n  OSSL_PROVIDER *prov;\n  [TYPE2] [VAR2] ;\n  OSSL_LIB_CTX *ctx;\n  [TYPE3] [VAR3] ;\n  EVP_SIGNATURE *signature;\n  [TYPE4] [VAR4] ;\n  \n  if ([VAR1] ->keymgmt == (EVP_KEYMGMT *)0x0) {\n    iVar2 = [FUNC2] ([VAR1] );\n    if (iVar2 == 0x198) {\n      iVar2 = [FUNC8] ((EC_KEY *)([VAR1] ->pkey).rsa);\n      return iVar2;\n    }\n    if (iVar2 < 0x199) {\n      if ((iVar2 == 6) || (iVar2 == 0x74)) {\n        return 1;\n      }\n    }\n    else if (iVar2 - 0x43fU < 2) {\n      return 1;\n    }\n    return 0;\n  }\n  prov = [FUNC7] ([VAR1] ->keymgmt);\n  ctx = [FUNC4] (prov);\n  pOVar1 = [VAR1] ->keymgmt->query_operation_name;\n  if (pOVar1 == (OSSL_FUNC_keymgmt_query_operation_name_fn *)0x0) {\n    [VAR4] = [FUNC6] ([VAR1] ->keymgmt);\n  }\n  else {\n    [VAR4] = (*pOVar1)(0xc);\n  }\n  signature = [FUNC3] (ctx,[VAR4] ,(char *)0x0);\n  if (signature != (EVP_SIGNATURE *)0x0) {\n    [FUNC5] (signature);\n    return 1;\n  }\n  return 0;\n}", "answer": {"VAR1": "pkey", "VAR2": "prov", "VAR3": "libctx", "VAR4": "supported_sig", "FUNC2": "EVP_PKEY_get_base_id", "FUNC3": "EVP_SIGNATURE_fetch", "FUNC1": "EVP_PKEY_can_sign", "FUNC6": "EVP_KEYMGMT_get0_name", "TYPE3": "OSSL_LIB_CTX *", "FUNC7": "EVP_KEYMGMT_get0_provider", "TYPE2": "OSSL_PROVIDER *", "FUNC4": "ossl_provider_libctx", "FUNC5": "EVP_SIGNATURE_free", "TYPE4": "char *", "FUNC8": "EC_KEY_can_sign", "TYPE1": "EVP_PKEY *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RDI,qword ptr [RDI + 0x60]\nTEST RDI,RDI\nJZ 0x0008d06b\nCALL 0x001ae947\nMOV RDI,RAX\nCALL 0x0009f052\nMOV RBP,RAX\nMOV RDI,qword ptr [RBX + 0x60]\nMOV RAX,qword ptr [RDI + 0x98]\nTEST RAX,RAX\nJZ 0x0008d0ae\nMOV EDI,0xc\nCALL RAX\nMOV RSI,RAX\nMOV EDX,0x0\nMOV RDI,RBP\nCALL 0x00094913\nMOV RDI,RAX\nMOV EAX,0x0\nTEST RDI,RDI\nJZ 0x0008d064\nCALL 0x000942f4\nMOV EAX,0x1\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RDI,RBX\nCALL 0x0008ceb9\nCMP EAX,0x198\nJZ 0x0008d0a3\nCMP EAX,0x198\nJG 0x0008d092\nCMP EAX,0x6\nJZ 0x0008d09c\nCMP EAX,0x74\nJZ 0x0008d09c\nMOV EAX,0x0\nJMP 0x0008d064\nSUB EAX,0x43f\nCMP EAX,0x1\nJA 0x0008d08b\nMOV EAX,0x1\nJMP 0x0008d064\nMOV RDI,qword ptr [RBX + 0x20]\nCALL 0x001777eb\nJMP 0x0008d064\nCALL 0x001ae955\nMOV RSI,RAX\nJMP 0x0008d040\n"}, "466": {"funcbody": "undefined8 [FUNC1] (undefined8 param_1)\n{\n  undefined uVar1;\n  int iVar2;\n  undefined uVar3;\n  undefined in_R8B;\n  undefined in_R9B;\n  \n  uVar3 = 0xe0;\n  iVar2 = [FUNC2] (param_1,1,0);\n  iVar2 = *(int *)(&DAT_0017a298 + (long)iVar2 * 4);\n  uVar1 = [FUNC4] (param_1,2,0);\n  [FUNC3] (iVar2,\"%s\",uVar1,uVar3,in_R8B,in_R9B);\n  return 0;\n}", "answer": {"FUNC2": "luaL_checkoption", "FUNC3": "log_write", "FUNC1": "FUN_000bfc36", "FUNC4": "luaL_checklstring"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nLEA RCX,[0x3d6ae0]\nMOV EDX,0x0\nMOV ESI,0x1\nCALL 0x0014b827\nCDQE\nLEA RDX,[0x17a298]\nMOV EBP,dword ptr [RDX + RAX*0x4]\nMOV EDX,0x0\nMOV ESI,0x2\nMOV RDI,RBX\nCALL 0x0014b785\nMOV RDX,RAX\nLEA RSI,[0x179da9]\nMOV EDI,EBP\nMOV EAX,0x0\nCALL 0x00086d1a\nMOV EAX,0x0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "467": {"funcbody": "/* DWARF original prototype: void add_entry(font * this, glyph * g, font_char_metric * metric) */\nvoid __thiscall font::[FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  font_char_metric *pfVar1;\n  int iVar2;\n  undefined3 uVar3;\n  int iVar4;\n  int iVar5;\n  \n  iVar2 = [VAR2] ->index;\n  if (iVar2 < 0) {\n    [FUNC2] (\"idx >= 0\",\"src/libs/libgroff/font.cpp\",0x2a9,\n          \"void font::add_entry(glyph*, const font_char_metric&)\");\n  }\n  if ([VAR1] ->nindices <= iVar2) {\n    [FUNC3] ([VAR1] ,iVar2);\n    if ([VAR1] ->nindices <= iVar2) {\n      [FUNC2] (\"idx < nindices\",\"src/libs/libgroff/font.cpp\",0x2ac,\n            \"void font::add_entry(glyph*, const font_char_metric&)\");\n    }\n  }\n  iVar5 = [VAR1] ->ch_used;\n  if ([VAR1] ->ch_size <= iVar5 + 1) {\n    [FUNC4] ([VAR1] );\n    iVar5 = [VAR1] ->ch_used;\n    if ([VAR1] ->ch_size <= iVar5 + 1) {\n      [FUNC2] (\"ch_used + 1 < ch_size\",\"src/libs/libgroff/font.cpp\",0x2af,\n            \"void font::add_entry(glyph*, const font_char_metric&)\");\n    }\n  }\n  [VAR1] ->ch_index[iVar2] = iVar5;\n  iVar2 = [VAR1] ->ch_used;\n  [VAR1] ->ch_used = iVar2 + 1;\n  pfVar1 = [VAR1] ->ch + iVar2;\n  uVar3 = *(undefined3 *)&[VAR3] ->field_0x1;\n  iVar2 = [VAR3] ->code;\n  iVar5 = [VAR3] ->width;\n  iVar4 = [VAR3] ->height;\n  pfVar1->type = [VAR3] ->type;\n  *(undefined3 *)&pfVar1->field_0x1 = uVar3;\n  pfVar1->code = iVar2;\n  pfVar1->width = iVar5;\n  pfVar1->height = iVar4;\n  iVar2 = [VAR3] ->pre_math_space;\n  iVar5 = [VAR3] ->italic_correction;\n  iVar4 = [VAR3] ->subscript_correction;\n  pfVar1->depth = [VAR3] ->depth;\n  pfVar1->pre_math_space = iVar2;\n  pfVar1->italic_correction = iVar5;\n  pfVar1->subscript_correction = iVar4;\n  pfVar1->special_device_coding = [VAR3] ->special_device_coding;\n  return;\n}", "answer": {"VAR1": "this", "VAR2": "g", "VAR3": "metric", "FUNC2": "__assert_fail", "FUNC3": "alloc_ch_index", "FUNC1": "add_entry", "TYPE3": "font_char_metric *", "TYPE2": "glyph *", "FUNC4": "extend_ch", "TYPE1": "font *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV EBP,dword ptr [RSI]\nTEST EBP,EBP\nJS 0x000108bf\nMOV RBX,RDI\nMOV R12,RDX\nCMP dword ptr [RDI + 0x48],EBP\nJLE 0x000108de\nMOV EAX,dword ptr [RBX + 0x58]\nLEA EDX,[RAX + 0x1]\nCMP EDX,dword ptr [RBX + 0x5c]\nJGE 0x0001090d\nMOVSXD RBP,EBP\nMOV RDX,qword ptr [RBX + 0x40]\nMOV dword ptr [RDX + RBP*0x4],EAX\nMOV RDX,qword ptr [RBX + 0x50]\nMOV EAX,dword ptr [RBX + 0x58]\nLEA ECX,[RAX + 0x1]\nMOV dword ptr [RBX + 0x58],ECX\nCDQE\nLEA RAX,[RAX + RAX*0x4]\nLEA RAX,[RDX + RAX*0x8]\nMOV RCX,qword ptr [R12]\nMOV RBX,qword ptr [R12 + 0x8]\nMOV qword ptr [RAX],RCX\nMOV qword ptr [RAX + 0x8],RBX\nMOV RCX,qword ptr [R12 + 0x10]\nMOV RBX,qword ptr [R12 + 0x18]\nMOV qword ptr [RAX + 0x10],RCX\nMOV qword ptr [RAX + 0x18],RBX\nMOV RDX,qword ptr [R12 + 0x20]\nMOV qword ptr [RAX + 0x20],RDX\nPOP RBX\nPOP RBP\nPOP R12\nRET\nLEA RCX,[0x1ad00]\nMOV EDX,0x2a9\nLEA RSI,[0x1a122]\nLEA RDI,[0x1a180]\nCALL 0x00006e30\nMOV ESI,EBP\nCALL 0x000105d8\nCMP dword ptr [RBX + 0x48],EBP\nJG 0x0001085f\nLEA RCX,[0x1ad00]\nMOV EDX,0x2ac\nLEA RSI,[0x1a122]\nLEA RDI,[0x1a195]\nCALL 0x00006e30\nMOV RDI,RBX\nCALL 0x000106b4\nMOV EAX,dword ptr [RBX + 0x58]\nLEA EDX,[RAX + 0x1]\nCMP EDX,dword ptr [RBX + 0x5c]\nJL 0x0001086e\nLEA RCX,[0x1ad00]\nMOV EDX,0x2af\nLEA RSI,[0x1a122]\nLEA RDI,[0x1a1a4]\nCALL 0x00006e30\n"}, "468": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         TYPE59 [VAR5] ,TYPE66 [VAR6] )\n{\n  uint uVar1;\n  [TYPE7] [VAR7] ;\n  \n  [FUNC4] ([VAR1] ->mutex);\n  uVar1 = [FUNC5] ([VAR1] ,[VAR2] ,(u8)[VAR3] ,[VAR4] ,[VAR5] ,[VAR6] );\n  if (([VAR1] ->mallocFailed == '\\0') && (uVar1 != 0xc0a)) {\n    uVar1 = uVar1 & [VAR1] ->errMask;\n  }\n  else {\n    uVar1 = [FUNC2] ([VAR1] );\n  }\n  [FUNC3] ([VAR1] ->mutex);\n  return uVar1;\n}", "answer": {"VAR1": "db", "VAR2": "zName", "VAR3": "enc", "VAR4": "pCtx", "VAR5": "xCompare", "VAR6": "xDel", "FUNC2": "apiOomError", "FUNC3": "sqlite3_mutex_leave", "FUNC1": "sqlite3_create_collation_v2", "TYPE3": "int", "TYPE2": "char *", "FUNC4": "sqlite3_mutex_enter", "TYPE5": "_func_int_void_ptr_int_void_ptr_int_void_ptr *", "FUNC5": "createCollation", "TYPE4": "void *", "TYPE7": "int", "TYPE6": "_func_void_void_ptr *", "VAR7": "rc", "TYPE1": "sqlite3 *"}, "assembly": "PUSH R15\nMOV R15,R9\nPUSH R14\nMOV R14,R8\nPUSH R13\nMOV R13,RCX\nPUSH R12\nMOV R12,RSI\nPUSH RBP\nMOV EBP,EDX\nPUSH RBX\nMOV RBX,RDI\nSUB RSP,0x8\nMOV RDI,qword ptr [RDI + 0x18]\nCALL 0x0000f4d0\nMOVZX EDX,BPL\nMOV R9,R15\nMOV R8,R14\nMOV RCX,R13\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x0004a310\nCMP byte ptr [RBX + 0x61],0x0\nJNZ 0x0004a5e0\nCMP EAX,0xc0a\nJZ 0x0004a5e0\nAND EAX,dword ptr [RBX + 0x54]\nMOV EBP,EAX\nMOV RDI,qword ptr [RBX + 0x18]\nCALL 0x0000f4f0\nADD RSP,0x8\nMOV EAX,EBP\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nMOV RDI,RBX\nCALL 0x0002c820\nMOV EBP,EAX\nJMP 0x0004a5c2\n"}, "469": {"funcbody": "/* DWARF original prototype: void CommonPacket(CommonPacket * this) */\nvoid __thiscall CommonPacket::[FUNC1] (TYPE18 [VAR1] )\n{\n  [VAR1] ->tags[0] = 0;\n  [VAR1] ->tags[1] = 0;\n  [VAR1] ->tags[2] = 0;\n  [VAR1] ->tstamp = 0;\n  [VAR1] ->jthread_TBR = (JThread *)0x0;\n  [VAR1] ->frinfo = 0;\n  [VAR1] ->leafpc = 0;\n  [VAR1] ->nat_stack = (void *)0x0;\n  [VAR1] ->user_stack = (void *)0x0;\n  return;\n}", "answer": {"VAR1": "this", "FUNC1": "CommonPacket", "TYPE1": "CommonPacket *"}, "assembly": "MOV dword ptr [RDI],0x0\nMOV dword ptr [RDI + 0x4],0x0\nMOV dword ptr [RDI + 0x8],0x0\nMOV qword ptr [RDI + 0x10],0x0\nMOV qword ptr [RDI + 0x18],0x0\nMOV qword ptr [RDI + 0x20],0x0\nMOV qword ptr [RDI + 0x28],0x0\nMOV qword ptr [RDI + 0x30],0x0\nMOV qword ptr [RDI + 0x38],0x0\nRET\n"}, "470": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  uint flags;\n  [TYPE4] [VAR4] ;\n  int iVar1;\n  TYPE37 [VAR3] ;\n  \n  flags = [FUNC3] ((EC_KEY *)[VAR1] );\n  [FUNC4] ((EC_KEY *)[VAR1] ,flags | 1);\n  iVar1 = [FUNC2] ((EC_KEY *)[VAR1] ,[VAR2] );\n  [FUNC4] ((EC_KEY *)[VAR1] ,flags);\n  return iVar1;\n}", "answer": {"VAR1": "veckey", "VAR2": "pder", "VAR3": "eckey", "VAR4": "old_flags", "FUNC2": "i2d_ECPrivateKey", "FUNC3": "EC_KEY_get_enc_flags", "FUNC1": "ec_pki_priv_to_der", "TYPE3": "EC_KEY *", "TYPE2": "uchar * *", "FUNC4": "EC_KEY_set_enc_flags", "TYPE4": "uint", "TYPE1": "void *"}, "assembly": "PUSH R12\nPUSH RBP\nPUSH RBX\nMOV RBX,RDI\nMOV R12,RSI\nCALL 0x000a03d2\nMOV EBP,EAX\nMOV ESI,EAX\nOR ESI,0x1\nMOV RDI,RBX\nCALL 0x000a03d6\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x0009dcbf\nMOV R12D,EAX\nMOV ESI,EBP\nMOV RDI,RBX\nCALL 0x000a03d6\nMOV EAX,R12D\nPOP RBX\nPOP RBP\nPOP R12\nRET\n"}, "471": {"funcbody": "int [FUNC1] (TYPE14 [VAR1] ,TYPE27 [VAR2] )\n{\n  undefined8 uVar1;\n  int iVar2;\n  \n  iVar2 = ([VAR2] ->mask_gen).algorithm_nid;\n  uVar1 = *(undefined8 *)&([VAR2] ->mask_gen).hash_algorithm_nid;\n  [VAR1] ->hash_algorithm_nid = [VAR2] ->hash_algorithm_nid;\n  ([VAR1] ->mask_gen).algorithm_nid = iVar2;\n  *(undefined8 *)&([VAR1] ->mask_gen).hash_algorithm_nid = uVar1;\n  [VAR1] ->trailer_field = [VAR2] ->trailer_field;\n  return 1;\n}", "answer": {"VAR1": "to", "VAR2": "from", "FUNC1": "ossl_rsa_pss_params_30_copy", "TYPE2": "RSA_PSS_PARAMS_30 *", "TYPE1": "RSA_PSS_PARAMS_30 *"}, "assembly": "MOV RAX,qword ptr [RSI]\nMOV RDX,qword ptr [RSI + 0x8]\nMOV qword ptr [RDI],RAX\nMOV qword ptr [RDI + 0x8],RDX\nMOV EAX,dword ptr [RSI + 0x10]\nMOV dword ptr [RDI + 0x10],EAX\nMOV EAX,0x1\nRET\n"}, "472": {"funcbody": "/* Local variable gctx:rsa_gen_ctx *[RDI:8] conflicts with parameter, skipped. */\nint [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  uint uVar2;\n  OSSL_PARAM *pOVar3;\n  [TYPE3] [VAR3] ;\n  \n  if ([VAR2] == ([TYPE2] )0x0) {\n    return 1;\n  }\n  pOVar3 = [FUNC4] ([VAR2] ,\"bits\");\n  if (pOVar3 != (OSSL_PARAM *)0x0) {\n    iVar1 = [FUNC2] (pOVar3,(size_t *)((long)[VAR1] + 0x18));\n    if (iVar1 == 0) {\n      return 0;\n    }\n    if (*(ulong *)((long)[VAR1] + 0x18) < 0x200) {\n      [FUNC3] ();\n      [FUNC6] (\"providers/implementations/keymgmt/rsa_kmgmt.c\",0x203,\"rsa_gen_set_params\");\n      [FUNC7] (0x39,0xab,(char *)0x0);\n      return 0;\n    }\n  }\n  pOVar3 = [FUNC4] ([VAR2] ,\"primes\");\n  if ((pOVar3 != (OSSL_PARAM *)0x0) &&\n     (iVar1 = [FUNC2] (pOVar3,(size_t *)((long)[VAR1] + 0x28)), iVar1 == 0)) {\n    return 0;\n  }\n  pOVar3 = [FUNC4] ([VAR2] ,\"e\");\n  if ((pOVar3 != (OSSL_PARAM *)0x0) &&\n     (iVar1 = [FUNC5] (pOVar3,(BIGNUM **)((long)[VAR1] + 0x20)), iVar1 == 0)) {\n    return 0;\n  }\n  uVar2 = 1;\n  if (*(int *)((long)[VAR1] + 0x10) == 0x1000) {\n    iVar1 = [FUNC8] ((RSA_PSS_PARAMS_30 *)((long)[VAR1] + 0x30),(int *)((long)[VAR1] + 0x44),[VAR2] ,*[VAR1] );\n    uVar2 = (uint)(iVar1 != 0);\n  }\n  return uVar2;\n}", "answer": {"VAR1": "genctx", "VAR2": "params", "VAR3": "p", "FUNC2": "OSSL_PARAM_get_size_t", "FUNC3": "ERR_new", "FUNC1": "rsa_gen_set_params", "FUNC6": "ERR_set_debug", "TYPE3": "OSSL_PARAM *", "FUNC7": "ERR_set_error", "TYPE2": "OSSL_PARAM *", "FUNC4": "OSSL_PARAM_locate_const", "FUNC5": "OSSL_PARAM_get_BN", "FUNC8": "ossl_rsa_pss_params_30_fromdata", "TYPE1": "void *"}, "assembly": "MOV EAX,0x1\nTEST RSI,RSI\nJZ 0x0011640b\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV RBX,RDI\nLEA RSI,[0x27be21]\nMOV RDI,RBP\nCALL 0x000b3fd9\nTEST RAX,RAX\nJZ 0x00116354\nLEA RSI,[RBX + 0x18]\nMOV RDI,RAX\nCALL 0x000b4cd2\nTEST EAX,EAX\nJZ 0x001163aa\nCMP qword ptr [RBX + 0x18],0x1ff\nJBE 0x001163b1\nLEA RSI,[0x27766b]\nMOV RDI,RBP\nCALL 0x000b3fd9\nTEST RAX,RAX\nJZ 0x00116378\nLEA RSI,[RBX + 0x28]\nMOV RDI,RAX\nCALL 0x000b4cd2\nTEST EAX,EAX\nJZ 0x001163aa\nLEA RSI,[0x26f717]\nMOV RDI,RBP\nCALL 0x000b3fd9\nTEST RAX,RAX\nJZ 0x0011639c\nLEA RSI,[RBX + 0x20]\nMOV RDI,RAX\nCALL 0x000b4d4e\nTEST EAX,EAX\nJZ 0x001163aa\nMOV EAX,0x1\nCMP dword ptr [RBX + 0x10],0x1000\nJZ 0x001163ee\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x0009809b\nLEA RDX,[0x27ff30]\nMOV ESI,0x203\nLEA RDI,[0x27ff00]\nCALL 0x000981a8\nMOV EDX,0x0\nMOV ESI,0xab\nMOV EDI,0x39\nMOV EAX,0x0\nCALL 0x000984bf\nMOV EAX,0x0\nJMP 0x001163aa\nLEA RSI,[RBX + 0x44]\nLEA RDI,[RBX + 0x30]\nMOV RCX,qword ptr [RBX]\nMOV RDX,RBP\nCALL 0x000c0833\nTEST EAX,EAX\nSETNZ AL\nMOVZX EAX,AL\nJMP 0x001163aa\nRET\n"}, "473": {"funcbody": "OSSL_PROPERTY_IDX [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  CRYPTO_RWLOCK **ppCVar1;\n  TYPE43 [VAR4] ;\n  CRYPTO_RWLOCK **pidx;\n  \n  ppCVar1 = (CRYPTO_RWLOCK **)[FUNC3] ([VAR1] ,3,&property_string_data_method);\n  [VAR4] ._0_4_ = 0;\n  if (ppCVar1 != (CRYPTO_RWLOCK **)0x0) {\n    pidx = ppCVar1 + 3;\n    if ([VAR3] == 0) {\n      pidx = (CRYPTO_RWLOCK **)0x0;\n    }\n    [VAR4] ._0_4_ = [FUNC2] (*ppCVar1,(PROP_TABLE *)ppCVar1[1],(OSSL_PROPERTY_IDX *)pidx,[VAR2] );\n  }\n  return (OSSL_PROPERTY_IDX)[VAR4] ;\n}", "answer": {"VAR1": "ctx", "VAR2": "s", "VAR3": "create", "VAR4": "propdata", "FUNC2": "ossl_property_string", "FUNC3": "ossl_lib_ctx_get_data", "FUNC1": "ossl_property_name", "TYPE3": "int", "TYPE2": "char *", "TYPE4": "PROPERTY_STRING_DATA *", "TYPE1": "OSSL_LIB_CTX *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV EBX,EDX\nLEA RDX,[0x525490]\nMOV ESI,0x3\nCALL 0x0009a6fb\nMOV RDI,RAX\nMOV EAX,0x0\nTEST RDI,RDI\nJZ 0x000ad55b\nLEA RDX,[RDI + 0x18]\nTEST EBX,EBX\nMOV EAX,0x0\nCMOVZ RDX,RAX\nMOV RSI,qword ptr [RDI + 0x8]\nMOV RCX,RBP\nMOV RDI,qword ptr [RDI]\nCALL 0x000ad108\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "474": {"funcbody": "_Bool [FUNC1] ([TYPE1] [VAR1] )\n{\n  asection *paVar1;\n  [TYPE2] [VAR2] ;\n  \n  paVar1 = [FUNC2] ([VAR1] ->output_bfd,\".eh_frame\");\n  [VAR2] = ([TYPE2] )0x0;\n  if (paVar1 != (asection *)0x0) {\n    [VAR2] = *([TYPE2] *)&paVar1->field_0xf8;\n    if ([VAR2] == ([TYPE2] )0x0) {\n      [VAR2] = ([TYPE2] )0x0;\n    }\n    else if (*(ulong *)&[VAR2] ->field_0x40 < 9) {\n      do {\n        [VAR2] = *([TYPE2] *)&[VAR2] ->field_0xf8;\n        if ([VAR2] == ([TYPE2] )0x0) goto LAB_00085e27;\n      } while (*(ulong *)&[VAR2] ->field_0x40 < 9);\n      [VAR2] = ([TYPE2] )Elf64_Ehdr_00000000.e_ident_magic_str;\n    }\n    else {\n      [VAR2] = ([TYPE2] )Elf64_Ehdr_00000000.e_ident_magic_str;\n    }\n  }\nLAB_00085e27:\n  return SUB81([VAR2] ,0);\n}", "answer": {"VAR1": "info", "VAR2": "eh", "FUNC2": "bfd_get_section_by_name", "FUNC1": "_bfd_elf_eh_frame_present", "TYPE2": "asection *", "TYPE1": "bfd_link_info *"}, "assembly": "SUB RSP,0x8\nMOV RDI,qword ptr [RDI + 0x50]\nLEA RSI,[0xedf62]\nCALL 0x0003f090\nMOV RDX,RAX\nMOV EAX,0x0\nTEST RDX,RDX\nJZ 0x00085e27\nMOV RAX,qword ptr [RDX + 0xf8]\nTEST RAX,RAX\nJZ 0x00085e2c\nCMP qword ptr [RAX + 0x40],0x8\nJA 0x00085e33\nMOV RAX,qword ptr [RAX + 0xf8]\nTEST RAX,RAX\nJZ 0x00085e27\nCMP qword ptr [RAX + 0x40],0x8\nJBE 0x00085e0f\nMOV EAX,0x1\nADD RSP,0x8\nRET\nMOV EAX,0x0\nJMP 0x00085e27\nMOV EAX,0x1\nJMP 0x00085e27\n"}, "475": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] )\n{\n  if (([VAR1] & 2U) == 0) {\n    wsnode_flagstr::retbuf[0] = (-(([VAR1] & 1U) == 0) & 0xbfU) + 0x6e;\n  }\n  else {\n    wsnode_flagstr::retbuf[0] = 'w';\n  }\n  wsnode_flagstr::retbuf[1] = (-(([VAR1] & 4U) == 0) & 0xbcU) + 0x71;\n  wsnode_flagstr::retbuf[2] = (-(([VAR1] & 8U) == 0) & 0xe8U) + 0x45;\n  wsnode_flagstr::retbuf[3] = (-(([VAR1] & 0x10U) == 0) & 0xc3U) + 0x6a;\n  wsnode_flagstr::retbuf[4] = (-(([VAR1] & 0x20U) == 0) & 0xbaU) + 0x73;\n  wsnode_flagstr::retbuf[5] = (-(([VAR1] & 0x40U) == 0) & 0xc9U) + 100;\n  wsnode_flagstr::retbuf[6] = '\\0';\n  return wsnode_flagstr::retbuf;\n}", "answer": {"VAR1": "flags", "FUNC1": "wsnode_flagstr", "TYPE1": "int"}, "assembly": "TEST DIL,0x2\nJZ 0x0000cdce\nMOV byte ptr [0x00219588],0x77\nMOV EAX,EDI\nAND EAX,0x4\nCMP EAX,0x1\nSBB EAX,EAX\nAND EAX,0xffffffbc\nADD EAX,0x71\nMOV byte ptr [0x00219589],AL\nMOV EAX,EDI\nAND EAX,0x8\nCMP EAX,0x1\nSBB EAX,EAX\nAND EAX,0xffffffe8\nADD EAX,0x45\nMOV byte ptr [0x0021958a],AL\nMOV EAX,EDI\nAND EAX,0x10\nCMP EAX,0x1\nSBB EAX,EAX\nAND EAX,0xffffffc3\nADD EAX,0x6a\nMOV byte ptr [0x0021958b],AL\nMOV EAX,EDI\nAND EAX,0x20\nCMP EAX,0x1\nSBB EAX,EAX\nAND EAX,0xffffffba\nADD EAX,0x73\nMOV byte ptr [0x0021958c],AL\nAND EDI,0x40\nCMP EDI,0x1\nSBB EAX,EAX\nAND EAX,0xffffffc9\nADD EAX,0x64\nMOV byte ptr [0x0021958d],AL\nMOV byte ptr [0x0021958e],0x0\nLEA RAX,[0x219588]\nRET\nMOV EAX,EDI\nAND EAX,0x1\nCMP EAX,0x1\nSBB EAX,EAX\nAND EAX,0xffffffbf\nADD EAX,0x6e\nMOV byte ptr [0x00219588],AL\nJMP 0x0000cd53\n"}, "476": {"funcbody": "DSO_FUNC_TYPE [FUNC1] (TYPE16 [VAR1] ,[TYPE2] [VAR2] )\n{\n  _func_3876 *p_Var1;\n  DSO_FUNC_TYPE pDVar2;\n  \n  if (([VAR1] == (TYPE16)0x0) || ([VAR2] == (TYPE20x0)) {\n    [FUNC3] ();\n    [FUNC4] (\"crypto/dso/dso_lib.c\",0xa8,\"DSO_bind_func\");\n    [FUNC2] (0x25,0xc0102,(char *)0x0);\n    pDVar2 = (DSO_FUNC_TYPE)0x0;\n  }\n  else {\n    p_Var1 = [VAR1] ->meth->dso_bind_var;\n    if (p_Var1 == (_func_3876 *)0x0) {\n      [FUNC3] ();\n      [FUNC4] (\"crypto/dso/dso_lib.c\",0xac,\"DSO_bind_func\");\n      [FUNC2] (0x25,0x6c,(char *)0x0);\n      pDVar2 = (DSO_FUNC_TYPE)0x0;\n    }\n    else {\n      pDVar2 = (DSO_FUNC_TYPE)(*p_Var1)([VAR1] ,[VAR2] );\n      if (pDVar2 == (DSO_FUNC_TYPE)0x0) {\n        [FUNC3] ();\n        [FUNC4] (\"crypto/dso/dso_lib.c\",0xb0,\"DSO_bind_func\");\n        [FUNC2] (0x25,0x6a,(char *)0x0);\n      }\n    }\n  }\n  return pDVar2;\n}", "answer": {"VAR1": "dso", "VAR2": "symname", "FUNC2": "ERR_set_error", "FUNC3": "ERR_new", "FUNC1": "DSO_bind_func", "TYPE2": "char *", "FUNC4": "ERR_set_debug", "TYPE1": "DSO *"}, "assembly": "PUSH RBX\nTEST RDI,RDI\nJZ 0x0014df02\nTEST RSI,RSI\nJZ 0x0014df02\nMOV RAX,qword ptr [RDI]\nMOV RAX,qword ptr [RAX + 0x18]\nTEST RAX,RAX\nJZ 0x0014df3f\nCALL RAX\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x0014df7c\nMOV RAX,RBX\nPOP RBX\nRET\nCALL 0x00080b6e\nLEA RDX,[0x27cc88]\nMOV ESI,0xa8\nLEA RDI,[0x27cbc4]\nCALL 0x00080c7b\nMOV EDX,0x0\nMOV ESI,0xc0102\nMOV EDI,0x25\nMOV EAX,0x0\nCALL 0x00080f92\nMOV EBX,0x0\nJMP 0x0014defd\nCALL 0x00080b6e\nLEA RDX,[0x27cc88]\nMOV ESI,0xac\nLEA RDI,[0x27cbc4]\nCALL 0x00080c7b\nMOV EDX,0x0\nMOV ESI,0x6c\nMOV EDI,0x25\nMOV EAX,0x0\nCALL 0x00080f92\nMOV EBX,0x0\nJMP 0x0014defd\nCALL 0x00080b6e\nLEA RDX,[0x27cc88]\nMOV ESI,0xb0\nLEA RDI,[0x27cbc4]\nCALL 0x00080c7b\nMOV EDX,0x0\nMOV ESI,0x6a\nMOV EDI,0x25\nMOV EAX,0x0\nCALL 0x00080f92\nJMP 0x0014defd\n"}, "477": {"funcbody": "_Bool [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  void *pvVar1;\n  byte bVar2;\n  char cVar3;\n  bool bVar4;\n  [TYPE3] [VAR3] ;\n  \n  bVar2 = [VAR2] ->st_info >> 4;\n  bVar4 = bVar2 != 1 && bVar2 < 10;\n  if (bVar4) {\n    bVar4 = false;\n  }\n  else {\n    pvVar1 = [VAR1] ->xvec->backend_data;\n    cVar3 = (**(code **)((long)pvVar1 + 0x300))([VAR2] ->st_info & 0xf);\n    if (((cVar3 == '\\0') && (bVar4 = false, [VAR2] ->st_shndx != 0)) &&\n       (cVar3 = (**(code **)((long)pvVar1 + 0x2d0))([VAR2] ), cVar3 == '\\0')) {\n      bVar4 = 0xf0 < [VAR2] ->st_shndx + 0x100;\n    }\n  }\n  return bVar4;\n}", "answer": {"VAR1": "abfd", "VAR2": "sym", "VAR3": "bed", "FUNC1": "is_global_data_symbol_definition", "TYPE3": "elf_backend_data *", "TYPE2": "Elf_Internal_Sym *", "TYPE1": "bfd *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOVZX EDX,byte ptr [RSI + 0x18]\nMOV EAX,EDX\nSHR AL,0x4\nCMP AL,0x1\nSETNZ CL\nCMP AL,0x9\nSETBE AL\nAND CL,AL\nJNZ 0x0006a7f4\nMOV EBX,ECX\nMOV RBP,RSI\nMOV RAX,qword ptr [RDI + 0x8]\nMOV R13,qword ptr [RAX + 0x378]\nMOV EDI,EDX\nAND EDI,0xf\nCALL qword ptr [R13 + 0x300]\nMOV R12D,EAX\nTEST AL,AL\nJNZ 0x0006a7e7\nCMP dword ptr [RBP + 0x1c],0x0\nJZ 0x0006a7fb\nMOV RDI,RBP\nCALL qword ptr [R13 + 0x2d0]\nMOV EBX,R12D\nTEST AL,AL\nJNZ 0x0006a7e7\nMOV EAX,dword ptr [RBP + 0x1c]\nADD EAX,0x100\nCMP EAX,0xf0\nSETA BL\nMOV EAX,EBX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV EBX,0x0\nJMP 0x0006a7e7\nMOV EBX,EAX\nJMP 0x0006a7e7\n"}, "478": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] )\n{\n  coff_tdata *pcVar1;\n  TYPE29 [VAR2] ;\n  \n  if ((([VAR1] ->xvec->flavour + ~bfd_target_aout_flavour & 0xfffffffd) == 0) &&\n     (([VAR1] ->field_0x48 & 7) == 1)) {\n    pcVar1 = ([VAR1] ->tdata).coff_obj_data;\n    if (pcVar1 != (coff_tdata *)0x0) {\n      if (pcVar1->section_by_index != (htab_t)0x0) {\n        [FUNC2] (pcVar1->section_by_index);\n      }\n      if (pcVar1->section_by_target_index != (htab_t)0x0) {\n        [FUNC2] (pcVar1->section_by_target_index);\n      }\n    }\n    return;\n  }\n  return;\n}", "answer": {"VAR1": "abfd", "VAR2": "td", "FUNC2": "htab_delete", "FUNC1": "coff_object_cleanup", "TYPE2": "coff_tdata *", "TYPE1": "bfd *"}, "assembly": "MOV RAX,qword ptr [RDI + 0x8]\nMOV EAX,dword ptr [RAX + 0x8]\nSUB EAX,0x2\nTEST EAX,0xfffffffd\nJNZ 0x000acb9f\nMOVZX EAX,byte ptr [RDI + 0x48]\nAND EAX,0x7\nCMP AL,0x1\nJZ 0x000acba1\nRET\nPUSH RBX\nMOV RBX,qword ptr [RDI + 0x110]\nTEST RBX,RBX\nJZ 0x000acbd0\nMOV RDI,qword ptr [RBX + 0xc8]\nTEST RDI,RDI\nJZ 0x000acbbf\nCALL 0x000e9a6b\nMOV RDI,qword ptr [RBX + 0xc0]\nTEST RDI,RDI\nJZ 0x000acbd0\nCALL 0x000e9a6b\nPOP RBX\nRET\n"}, "479": {"funcbody": "/* show_print_max_depth(ui_file*, int, cmd_list_element*, char const*) */\nvoid [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  char *pcVar1;\n  undefined uVar2;\n  undefined4 in_register_00000034;\n  undefined in_R8B;\n  undefined in_R9B;\n  \n  uVar2 = (char)[VAR4] ;\n  pcVar1 = (char *)[FUNC3] (\"Maximum print depth is %s.\\n\",CONCAT44(in_register_00000034,[VAR2] ));\n  [FUNC2] ([VAR1] ,pcVar1,(char)[VAR4] ,uVar2,in_R8B,in_R9B);\n  return;\n}", "answer": {"VAR1": "param_1", "VAR2": "param_2", "VAR3": "param_3", "VAR4": "param_4", "FUNC2": "gdb_printf", "FUNC3": "gettext", "FUNC1": "show_print_max_depth", "TYPE3": "cmd_list_element *", "TYPE2": "int", "TYPE4": "char *", "TYPE1": "ui_file *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RCX\nLEA RDI,[0x7e1c74]\nCALL 0x000d0680\nMOV RDX,RBP\nMOV RSI,RAX\nMOV RDI,RBX\nMOV EAX,0x0\nCALL 0x00596009\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "480": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] )\n{\n  char *pcVar1;\n  \n  if ([VAR1] == ([TYPE1] )0x0) {\n    pcVar1 = (char *)0x0;\n  }\n  else {\n    pcVar1 = [VAR1] ->bid_xname;\n    if (pcVar1 == (char *)0x0) {\n      return [VAR1] ->bid_name;\n    }\n  }\n  return pcVar1;\n}", "answer": {"VAR1": "dev", "FUNC1": "blkid_dev_devname", "TYPE1": "blkid_dev"}, "assembly": "TEST RDI,RDI\nJZ 0x0000b26b\nMOV RAX,qword ptr [RDI + 0x30]\nTEST RAX,RAX\nJZ 0x0000b266\nRET\nMOV RAX,qword ptr [RDI + 0x28]\nRET\nMOV EAX,0x0\nJMP 0x0000b264\n"}, "481": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  int iVar2;\n  \n  iVar1 = [FUNC3] ([VAR1] ,[VAR2] );\n  iVar2 = 1;\n  if (iVar1 == 0) {\n    iVar2 = [FUNC2] ([VAR1] ,[VAR2] );\n  }\n  return iVar2;\n}", "answer": {"VAR1": "s", "VAR2": "str", "FUNC2": "ASN1_GENERALIZEDTIME_set_string", "FUNC3": "ASN1_UTCTIME_set_string", "FUNC1": "ASN1_TIME_set_string", "TYPE2": "char *", "TYPE1": "ASN1_TIME *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBX,RDI\nMOV RBP,RSI\nCALL 0x0006bce5\nMOV EDX,0x1\nTEST EAX,EAX\nJZ 0x0006b519\nMOV EAX,EDX\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nMOV RSI,RBP\nMOV RDI,RBX\nCALL 0x0012508f\nMOV EDX,EAX\nJMP 0x0006b510\n"}, "482": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,...)\n{\n  long lVar1;\n  char in_AL;\n  int iVar2;\n  [TYPE2] [VAR2] ;\n  undefined8 in_RCX;\n  undefined8 in_RDX;\n  undefined8 in_RSI;\n  undefined8 in_R8;\n  undefined8 in_R9;\n  long in_FS_OFFSET;\n  undefined4 in_XMM0_Da;\n  [TYPE18] [VAR18] ;\n  [TYPE17] [VAR17] ;\n  [TYPE16] [VAR16] ;\n  undefined8 [VAR15] ;\n  undefined8 [VAR14] ;\n  undefined8 [VAR13] ;\n  undefined8 [VAR12] ;\n  undefined8 [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  [TYPE8] [VAR8] ;\n  [TYPE7] [VAR7] ;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  [TYPE3] [VAR3] ;\n  \n  if (in_AL != '\\0') {\n    [VAR10] ._0_4_ = in_XMM0_Da;\n  }\n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  [VAR18] [0].gp_offset = 8;\n  [VAR18] [0].fp_offset = 0x30;\n  [VAR18] [0].overflow_arg_area = &stack0x00000008;\n  [VAR18] [0].reg_save_area = &[VAR16] ;\n  [VAR15] = in_RSI;\n  [VAR14] = in_RDX;\n  [VAR13] = in_RCX;\n  [VAR12] = in_R8;\n  [VAR11] = in_R9;\n  iVar2 = [FUNC2] (stdscr,[VAR1] ,[VAR18] );\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return iVar2;\n  }\n  [FUNC3] ();\n}", "answer": {"TYPE17": "undefined8", "TYPE18": "va_list", "VAR1": "fmt", "VAR2": "code", "VAR3": "local_18", "VAR4": "local_28", "VAR5": "local_38", "VAR6": "local_48", "FUNC2": "vw_printw", "FUNC3": "__stack_chk_fail", "FUNC1": "printw", "TYPE3": "undefined1[16]", "VAR14": "local_a8", "TYPE2": "int", "VAR15": "local_b0", "TYPE5": "undefined1[16]", "VAR12": "local_98", "TYPE4": "undefined1[16]", "VAR13": "local_a0", "TYPE7": "undefined1[16]", "VAR18": "argp", "TYPE6": "undefined1[16]", "TYPE9": "undefined1[16]", "VAR16": "local_b8", "TYPE8": "undefined1[16]", "VAR17": "local_c0", "VAR7": "local_58", "TYPE11": "undefined8", "VAR8": "local_68", "TYPE12": "undefined8", "VAR9": "local_78", "TYPE10": "undefined1[16]", "VAR10": "local_88", "TYPE15": "undefined8", "VAR11": "local_90", "TYPE16": "undefined1", "TYPE1": "char *", "TYPE13": "undefined8", "TYPE14": "undefined8"}, "assembly": "SUB RSP,0xd8\nMOV qword ptr [RSP + 0x28],RSI\nMOV qword ptr [RSP + 0x30],RDX\nMOV qword ptr [RSP + 0x38],RCX\nMOV qword ptr [RSP + 0x40],R8\nMOV qword ptr [RSP + 0x48],R9\nTEST AL,AL\nJZ 0x0000d9de\nMOVAPS xmmword ptr [RSP + 0x50],XMM0\nMOVAPS xmmword ptr [RSP + 0x60],XMM1\nMOVAPS xmmword ptr [RSP + 0x70],XMM2\nMOVAPS xmmword ptr [RSP + 0x80],XMM3\nMOVAPS xmmword ptr [RSP + 0x90],XMM4\nMOVAPS xmmword ptr [RSP + 0xa0],XMM5\nMOVAPS xmmword ptr [RSP + 0xb0],XMM6\nMOVAPS xmmword ptr [RSP + 0xc0],XMM7\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nMOV dword ptr [RSP],0x8\nMOV dword ptr [RSP + 0x4],0x30\nLEA RAX,[RSP + 0xe0]\nMOV qword ptr [RSP + 0x8],RAX\nLEA RAX,[RSP + 0x20]\nMOV qword ptr [RSP + 0x10],RAX\nMOV RDX,RSP\nMOV RSI,RDI\nMOV RDI,qword ptr [0x0023b910]\nCALL 0x0000d942\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0000da3e\nADD RSP,0xd8\nRET\nCALL 0x00007710\n"}, "483": {"funcbody": "void [FUNC1] (TYPE11 [VAR1] )\n{\n  if ([VAR1] != (TYPE11)0x0) {\n    [FUNC2] ((ASN1_OBJECT *)[VAR1] ->valid_policy);\n    if ((*(byte *)&[VAR1] ->flags & 4) == 0) {\n      [FUNC4] ((OPENSSL_STACK *)[VAR1] ->qualifier_set,[FUNC3] );\n    }\n    [FUNC4] ((OPENSSL_STACK *)[VAR1] ->expected_policy_set,[FUNC2] );\n    [FUNC5] ([VAR1] );\n    return;\n  }\n  return;\n}", "answer": {"VAR1": "data", "FUNC2": "ASN1_OBJECT_free", "FUNC3": "POLICYQUALINFO_free", "FUNC1": "ossl_policy_data_free", "FUNC4": "OPENSSL_sk_pop_free", "FUNC5": "FUNC1", "TYPE1": "X509_POLICY_DATA *"}, "assembly": "TEST RDI,RDI\nJZ 0x00217a8b\nPUSH RBX\nMOV RBX,RDI\nMOV RDI,qword ptr [RDI + 0x8]\nCALL 0x0014bdc8\nTEST byte ptr [RBX],0x4\nJZ 0x00217a79\nMOV RDI,qword ptr [RBX + 0x18]\nLEA RSI,[0x14bdc8]\nCALL 0x000ce015\nMOV EDX,0x1b\nLEA RSI,[0x2b1631]\nMOV RDI,RBX\nCALL 0x000b3b8d\nPOP RBX\nRET\nMOV RDI,qword ptr [RBX + 0x10]\nLEA RSI,[0xd1f0b]\nCALL 0x000ce015\nJMP 0x00217a53\nRET\n"}, "484": {"funcbody": "void [FUNC1] (void)\n{\n  undefined4 uVar1;\n  int *piVar2;\n  [TYPE1] [VAR1] ;\n  [TYPE3] [VAR3] ;\n  int **ppiVar3;\n  [TYPE2] [VAR2] ;\n  [TYPE4] [VAR4] ;\n  int **ppiVar4;\n  long unaff_R14;\n  long unaff_R15;\n  \n  ppiVar4 = (int **)(*(int *)(unaff_R15 + 8) + unaff_R14);\n  ppiVar3 = (int **)(*(int *)(unaff_R15 + 0x10) + unaff_R14);\n  piVar2 = *ppiVar4;\n  uVar1 = *(undefined4 *)(ppiVar4 + 1);\n  *ppiVar3 = piVar2;\n  *(undefined4 *)(ppiVar3 + 1) = uVar1;\n  if ((char)((uint)uVar1 >> 8) != '\\0') {\n    *piVar2 = *piVar2 + 1;\n  }\n  return;\n}", "answer": {"VAR1": "result", "VAR2": "_gc", "VAR3": "_t", "VAR4": "_z2", "FUNC1": "ZEND_COPY_TMP_SPEC_TMPVAR_UNUSED_HANDLER", "TYPE3": "uint32_t", "TYPE2": "zend_refcounted *", "TYPE4": "zval *", "TYPE1": "zval *"}, "assembly": "MOVSXD RDX,dword ptr [R15 + 0x8]\nADD RDX,R14\nMOVSXD RAX,dword ptr [R15 + 0x10]\nADD RAX,R14\nMOV RCX,qword ptr [RDX]\nMOV EDX,dword ptr [RDX + 0x8]\nMOV qword ptr [RAX],RCX\nMOV dword ptr [RAX + 0x8],EDX\nTEST DH,0xff\nJZ 0x003d608d\nADD dword ptr [RCX],0x1\nADD R15,0x20\nRET\n"}, "485": {"funcbody": "/* Local variable forward:AvifInfoInternalForward *[RDI:8] conflicts with parameter, skipped. */\nuint8_t * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  uint8_t *puVar1;\n  [TYPE3] [VAR3] ;\n  \n  if ([VAR2] <= *(ulong *)((long)[VAR1] + 8)) {\n    puVar1 = *[VAR1] ;\n    *(uint8_t **)[VAR1] = puVar1 + [VAR2] ;\n    *(ulong *)((long)[VAR1] + 8) = *(ulong *)((long)[VAR1] + 8) - [VAR2] ;\n    return puVar1;\n  }\n  return (uint8_t *)0x0;\n}", "answer": {"VAR1": "stream", "VAR2": "num_bytes", "VAR3": "data", "FUNC1": "AvifInfoInternalForwardRead", "TYPE3": "uint8_t *", "TYPE2": "size_t", "TYPE1": "void *"}, "assembly": "MOV RDX,qword ptr [RDI + 0x8]\nCMP RDX,RSI\nJC 0x0032bc36\nMOV RAX,qword ptr [RDI]\nLEA RCX,[RAX + RSI*0x1]\nMOV qword ptr [RDI],RCX\nSUB RDX,RSI\nMOV qword ptr [RDI + 0x8],RDX\nRET\nMOV EAX,0x0\nRET\n"}, "486": {"funcbody": "int [FUNC1] (TYPE19 [VAR1] ,[TYPE2] [VAR2] )\n{\n  int iVar1;\n  ECPKPARAMETERS *a;\n  TYPE35 [VAR3] ;\n  \n  a = [FUNC6] ((EC_GROUP *)[VAR1] ,(ECPKPARAMETERS *)0x0);\n  if (a == (ECPKPARAMETERS *)0x0) {\n    [FUNC7] ();\n    [FUNC3] (\"crypto/ec/ec_asn1.c\",0x39b,\"i2d_ECPKParameters\");\n    [FUNC4] (0x10,0x78,(char *)0x0);\n    iVar1 = 0;\n  }\n  else {\n    iVar1 = [FUNC5] (a,[VAR2] );\n    if (iVar1 == 0) {\n      [FUNC7] ();\n      [FUNC3] (\"crypto/ec/ec_asn1.c\",0x39f,\"i2d_ECPKParameters\");\n      [FUNC4] (0x10,0x79,(char *)0x0);\n      [FUNC2] (a);\n    }\n    else {\n      [FUNC2] (a);\n    }\n  }\n  return iVar1;\n}", "answer": {"VAR1": "param_1", "VAR2": "out", "VAR3": "tmp", "FUNC2": "ECPKPARAMETERS_free", "FUNC3": "ERR_set_debug", "FUNC1": "i2d_ECPKParameters", "FUNC6": "EC_GROUP_get_ecpkparameters", "TYPE3": "ECPKPARAMETERS *", "FUNC7": "ERR_new", "TYPE2": "uchar * *", "FUNC4": "ERR_set_error", "FUNC5": "i2d_ECPKPARAMETERS", "TYPE1": "EC_GROUP *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV ESI,0x0\nCALL 0x0015bf83\nTEST RAX,RAX\nJZ 0x0015d366\nMOV RBX,RAX\nMOV RSI,RBP\nMOV RDI,RAX\nCALL 0x0015b2ed\nMOV EBP,EAX\nTEST EAX,EAX\nJZ 0x0015d3a3\nMOV RDI,RBX\nCALL 0x0015b329\nMOV EAX,EBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\nCALL 0x000810ae\nLEA RDX,[0x28a610]\nMOV ESI,0x39b\nLEA RDI,[0x28a440]\nCALL 0x000811bb\nMOV EDX,0x0\nMOV ESI,0x78\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x000814d2\nMOV EBP,0x0\nJMP 0x0015d35d\nCALL 0x000810ae\nLEA RDX,[0x28a610]\nMOV ESI,0x39f\nLEA RDI,[0x28a440]\nCALL 0x000811bb\nMOV EDX,0x0\nMOV ESI,0x79\nMOV EDI,0x10\nMOV EAX,0x0\nCALL 0x000814d2\nMOV RDI,RBX\nCALL 0x0015b329\nJMP 0x0015d35d\n"}, "487": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  ushort uVar1;\n  mp_limb_t *rp;\n  [TYPE5] [VAR5] ;\n  ulong rn;\n  long n;\n  [TYPE4] [VAR4] ;\n  \n  uVar1 = *(ushort *)(PTR__nettle_curve448_00245fa8 + 2);\n  n = (long)(int)((uint)uVar1 + (uint)uVar1 * 8);\n  rp = [FUNC2] (n);\n  rn = (ulong)uVar1;\n  [FUNC6] (rp,rn,[VAR3] ,0x38);\n  [FUNC4] ((ecc_modulo *)PTR__nettle_curve448_00245fa8,0x98a9,2,0x1be,rp,[VAR2] ,rp,rp + rn);\n  [FUNC5] ([VAR1] ,0x38,rp,rn);\n  [FUNC3] (rp,n);\n  return;\n}", "answer": {"VAR1": "q", "VAR2": "n", "VAR3": "p", "VAR4": "itch", "VAR5": "x", "FUNC2": "_nettle_gmp_alloc_limbs", "FUNC3": "_nettle_gmp_free_limbs", "FUNC1": "nettle_curve448_mul", "FUNC6": "_nettle_mpn_set_base256_le", "TYPE3": "uint8_t *", "TYPE2": "uint8_t *", "FUNC4": "_nettle_ecc_mul_m", "TYPE5": "mp_limb_t *", "FUNC5": "_nettle_mpn_get_base256_le", "TYPE4": "mp_size_t", "TYPE1": "uint8_t *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV R13,RDI\nMOV R14,RSI\nMOV R15,RDX\nMOV RAX,qword ptr [0x00245fa8]\nMOVZX EBP,word ptr [RAX + 0x2]\nMOVZX EAX,BP\nLEA R12D,[RAX + RAX*0x8]\nMOVSXD R12,R12D\nMOV RDI,R12\nCALL 0x00008c00\nMOV RBX,RAX\nMOVZX EBP,BP\nMOV ECX,0x38\nMOV RDX,R15\nMOV RSI,RBP\nMOV RDI,RAX\nCALL 0x00009090\nLEA RAX,[RBX + RBP*0x8]\nPUSH RAX\nPUSH RBX\nMOV R9,R14\nMOV R8,RBX\nMOV ECX,0x1be\nMOV EDX,0x2\nMOV ESI,0x98a9\nMOV RDI,qword ptr [0x00245fa8]\nCALL 0x00009030\nMOV RCX,RBP\nMOV RDX,RBX\nMOV ESI,0x38\nMOV RDI,R13\nCALL 0x00009220\nMOV RSI,R12\nMOV RDI,RBX\nCALL 0x00009270\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "488": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  int iVar1;\n  int32_t *val;\n  \n  if ([VAR1] ->type == 0x10) {\n    if (([VAR1] ->value).ptr == (char *)0x0) {\n      val = (int32_t *)0x0;\n    }\n    else {\n      val = (int32_t *)[FUNC6] ((ASN1_ITEM *)local_it_10096,(ASN1_TYPE *)[VAR1] );\n      if ((val != (int32_t *)0x0) &&\n         (iVar1 = [FUNC4] (*(ASN1_OCTET_STRING **)(val + 2),*val,[VAR2] ,[VAR3] ,[VAR4] ), iVar1 != -1))\n      goto LAB_0014cf62;\n    }\n  }\n  else {\n    val = (int32_t *)0x0;\n  }\n  [FUNC5] ();\n  [FUNC7] (\"crypto/asn1/evp_asn1.c\",0x80,\"ASN1_TYPE_get_int_octetstring\");\n  [FUNC3] (0xd,0x6d,(char *)0x0);\n  iVar1 = -1;\nLAB_0014cf62:\n  [FUNC2] ((ASN1_VALUE *)val,(ASN1_ITEM *)local_it_10096);\n  return iVar1;\n}", "answer": {"VAR1": "a", "VAR2": "num", "VAR3": "data", "VAR4": "max_len", "FUNC2": "ASN1_item_free", "FUNC3": "ERR_set_error", "FUNC1": "ASN1_TYPE_get_int_octetstring", "FUNC6": "ASN1_TYPE_unpack_sequence", "TYPE3": "uchar *", "FUNC7": "ERR_set_debug", "TYPE2": "long *", "FUNC4": "asn1_type_get_int_oct", "FUNC5": "ERR_new", "TYPE4": "int", "TYPE1": "ASN1_TYPE *"}, "assembly": "PUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nCMP dword ptr [RDI],0x10\nJNZ 0x0014cf22\nMOV RBP,RSI\nMOV R12,RDX\nMOV R13D,ECX\nCMP qword ptr [RDI + 0x8],0x0\nJZ 0x0014cf7e\nMOV RSI,RDI\nLEA RDI,[0x540140]\nCALL 0x00149fd3\nMOV RBX,RAX\nTEST RAX,RAX\nJZ 0x0014cf27\nMOV RDI,qword ptr [RAX + 0x8]\nMOV R8D,R13D\nMOV RCX,R12\nMOV RDX,RBP\nMOV ESI,dword ptr [RAX]\nCALL 0x0014ccf7\nMOV EBP,EAX\nCMP EAX,-0x1\nJNZ 0x0014cf62\nJMP 0x0014cf27\nMOV EBX,0x0\nCALL 0x0009edef\nLEA RDX,[0x289470]\nMOV ESI,0x80\nLEA RDI,[0x2893fb]\nCALL 0x0009eefc\nMOV EDX,0x0\nMOV ESI,0x6d\nMOV EDI,0xd\nMOV EAX,0x0\nCALL 0x0009f213\nMOV EBP,0xffffffff\nLEA RSI,[0x540140]\nMOV RDI,RBX\nCALL 0x000738e6\nMOV EAX,EBP\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nRET\nMOV EBX,0x0\nJMP 0x0014cf27\n"}, "489": {"funcbody": "void [FUNC1] (void)\n{\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  undefined8 uVar4;\n  \n  lVar2 = [FUNC2] (token[1],(char **)0x0,10);\n  myrating = (int)lVar2;\n  uVar3 = [FUNC2] (token[2],(char **)0x0,10);\n  iVar1 = myrating;\n  opprating = (int)uVar3;\n  uVar4 = [FUNC3] (\"my rating = %d, opponent rating = %d\\n\");\n  [FUNC4] (ofp,1,uVar4,iVar1,uVar3 & 0xffffffff);\n  bookfirstlast = 2;\n  return;\n}", "answer": {"FUNC2": "strtol", "FUNC3": "gettext", "FUNC1": "cmd_rating", "FUNC4": "__fprintf_chk"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV EDX,0xa\nMOV ESI,0x0\nMOV RDI,qword ptr [0x00304998]\nCALL 0x00004f60\nMOV dword ptr [0x0024b118],EAX\nMOV EDX,0xa\nMOV ESI,0x0\nMOV RDI,qword ptr [0x003049a0]\nCALL 0x00004f60\nMOV RBX,RAX\nMOV dword ptr [0x0024b114],EAX\nMOV EBP,dword ptr [0x0024b118]\nLEA RDI,[0x331f8]\nCALL 0x00004dc0\nMOV R8D,EBX\nMOV ECX,EBP\nMOV RDX,RAX\nMOV ESI,0x1\nMOV RDI,qword ptr [0x0024b120]\nMOV EAX,0x0\nCALL 0x00005150\nMOV word ptr [0x0024b13a],0x2\nADD RSP,0x8\nPOP RBX\nPOP RBP\nRET\n"}, "490": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  if ([VAR5] <= [VAR6] ) {\n    return 1;\n  }\n  [FUNC2] ((char *)0x0,[VAR1] ,[VAR2] ,\"unsigned int\",[VAR3] ,[VAR4] ,\"<=\",\"[%u] compared to [%u]\",(ulong)[VAR5] ,\n        (ulong)[VAR6] );\n  return 0;\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "s1", "VAR4": "s2", "VAR5": "t1", "VAR6": "t2", "FUNC2": "test_fail_message", "FUNC1": "test_uint_le", "TYPE3": "char *", "TYPE2": "int", "TYPE5": "uint", "TYPE4": "char *", "TYPE6": "uint", "TYPE1": "char *"}, "assembly": "MOV EAX,0x1\nCMP R8D,R9D\nJA 0x000680e4\nRET\nSUB RSP,0x8\nMOV R10D,R9D\nMOV EAX,R8D\nMOV R9,RCX\nMOV R8,RDX\nMOV EDX,ESI\nPUSH R10\nPUSH RAX\nLEA RAX,[0x260fe6]\nPUSH RAX\nLEA RAX,[0x260fd3]\nPUSH RAX\nLEA RCX,[0x260fd9]\nMOV RSI,RDI\nMOV EDI,0x0\nMOV EAX,0x0\nCALL 0x0006769b\nMOV EAX,0x0\nADD RSP,0x28\nRET\n"}, "491": {"funcbody": "void [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] )\n{\n  uint uVar1;\n  int iVar2;\n  int iVar3;\n  [TYPE5] [VAR5] ;\n  int iVar4;\n  [TYPE4] [VAR4] ;\n  int iVar5;\n  \n  uVar1 = [VAR3] ->flags;\n  if ([VAR3] ->section == (bfd_section *)0x0) {\n    [FUNC3] ([VAR1] ,[VAR2] ,[VAR3] ->value);\n  }\n  else {\n    [FUNC3] ([VAR1] ,[VAR2] ,[VAR3] ->section->vma + [VAR3] ->value);\n  }\n  iVar5 = 0x46;\n  if (((uVar1 & 8) == 0) && (iVar5 = 0x66, (uVar1 & 0x4000) == 0)) {\n    iVar5 = (-(uint)((uVar1 & 0x10000) == 0) & 0xffffffd1) + 0x4f;\n  }\n  iVar4 = 100;\n  if ((uVar1 & 4) == 0) {\n    iVar4 = (-(uint)((uVar1 & 0x8000) == 0) & 0xffffffdc) + 0x44;\n  }\n  iVar3 = 0x49;\n  if ((uVar1 & 0x2000) == 0) {\n    iVar3 = (-(uint)((uVar1 & 0x400000) == 0) & 0xffffffb7) + 0x69;\n  }\n  if ((uVar1 & 1) == 0) {\n    iVar2 = 0x67;\n    if ((uVar1 & 2) == 0) {\n      iVar2 = (-(uint)((uVar1 & 0x800000) == 0) & 0xffffffab) + 0x75;\n    }\n  }\n  else {\n    iVar2 = (-(uint)((uVar1 & 2) == 0) & 0x4b) + 0x21;\n  }\n  [FUNC2] ([VAR2] ,1,\" %c%c%c%c%c%c%c\",iVar2,(-(uint)((uVar1 & 0x80) == 0) & 0xffffffa9) + 0x77,\n        (-(uint)((uVar1 & 0x800) == 0) & 0xffffffdd) + 0x43,\n        (-(uint)((uVar1 & 0x1000) == 0) & 0xffffffc9) + 0x57,iVar3,iVar4,iVar5);\n  return;\n}", "answer": {"VAR1": "abfd", "VAR2": "arg", "VAR3": "symbol", "VAR4": "file", "VAR5": "type", "FUNC2": "__fprintf_chk", "FUNC3": "bfd_fprintf_vma", "FUNC1": "bfd_print_symbol_vandf", "TYPE3": "asymbol *", "TYPE2": "void *", "TYPE5": "flagword", "TYPE4": "FILE *", "TYPE1": "bfd *"}, "assembly": "PUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,RSI\nMOV EBX,dword ptr [RDX + 0x18]\nMOV RAX,qword ptr [RDX + 0x20]\nTEST RAX,RAX\nJZ 0x000c6752\nMOV RAX,qword ptr [RAX + 0x30]\nADD RAX,qword ptr [RDX + 0x10]\nMOV RDX,RAX\nCALL 0x00030370\nMOV EDI,0x46\nTEST BL,0x8\nJNZ 0x000c66a5\nMOV EDI,0x66\nTEST BH,0x40\nJNZ 0x000c66a5\nMOV EAX,EBX\nAND EAX,0x10000\nCMP EAX,0x1\nSBB EDI,EDI\nAND EDI,0xffffffd1\nADD EDI,0x4f\nMOV ESI,0x64\nTEST BL,0x4\nJNZ 0x000c66c1\nMOV EAX,EBX\nAND EAX,0x8000\nCMP EAX,0x1\nSBB ESI,ESI\nAND ESI,0xffffffdc\nADD ESI,0x44\nMOV EDX,0x49\nTEST BH,0x20\nJNZ 0x000c66dd\nMOV EAX,EBX\nAND EAX,0x400000\nCMP EAX,0x1\nSBB EDX,EDX\nAND EDX,0xffffffb7\nADD EDX,0x69\nMOV EAX,EBX\nAND EAX,0x1000\nCMP EAX,0x1\nSBB EAX,EAX\nAND EAX,0xffffffc9\nADD EAX,0x57\nMOV ECX,EBX\nAND ECX,0x800\nCMP ECX,0x1\nSBB R9D,R9D\nAND R9D,0xffffffdd\nADD R9D,0x43\nMOV ECX,EBX\nAND ECX,0x80\nCMP ECX,0x1\nSBB R8D,R8D\nAND R8D,0xffffffa9\nADD R8D,0x77\nTEST BL,0x1\nJZ 0x000c6760\nAND EBX,0x2\nCMP EBX,0x1\nSBB ECX,ECX\nAND ECX,0x4b\nADD ECX,0x21\nPUSH RDI\nPUSH RSI\nPUSH RDX\nPUSH RAX\nLEA RDX,[0x10136c]\nMOV ESI,0x1\nMOV RDI,RBP\nMOV EAX,0x0\nCALL 0x0002c4a0\nADD RSP,0x28\nPOP RBX\nPOP RBP\nRET\nMOV RDX,qword ptr [RDX + 0x10]\nCALL 0x00030370\nJMP 0x000c667f\nMOV ECX,0x67\nTEST BL,0x2\nJNZ 0x000c672e\nAND EBX,0x800000\nCMP EBX,0x1\nSBB ECX,ECX\nAND ECX,0xffffffab\nADD ECX,0x75\nJMP 0x000c672e\n"}, "492": {"funcbody": "_Bool [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] )\n{\n  char cVar1;\n  _Bool _Var2;\n  char *__ptr;\n  [TYPE6] [VAR6] ;\n  char *pcVar3;\n  [TYPE7] [VAR7] ;\n  long lVar4;\n  ulong uVar5;\n  [TYPE5] [VAR5] ;\n  [TYPE2] pcVar6;\n  undefined uVar7;\n  byte bVar8;\n  int [VAR9] ;\n  [TYPE8] [VAR8] ;\n  \n  bVar8 = 0;\n  __ptr = [FUNC7] ((stab_write_handle *)[VAR1] );\n  if ([VAR3] == DEBUG_PARM_REG) {\n    uVar7 = 0x50;\n    [VAR9] = 0x40;\n  }\n  else if ([VAR3] < DEBUG_PARM_REFERENCE) {\n    if ([VAR3] != DEBUG_PARM_STACK) {\nLAB_0004469a:\n      [FUNC5] ();\n    }\n    uVar7 = 0x70;\n    [VAR9] = 0xa0;\n  }\n  else if ([VAR3] == DEBUG_PARM_REFERENCE) {\n    uVar7 = 0x76;\n    [VAR9] = 0xa0;\n  }\n  else {\n    if ([VAR3] != DEBUG_PARM_REF_REG) goto LAB_0004469a;\n    uVar7 = 0x61;\n    [VAR9] = 0x40;\n  }\n  lVar4 = -1;\n  pcVar6 = [VAR2] ;\n  do {\n    if (lVar4 == 0) break;\n    lVar4 = lVar4 + -1;\n    cVar1 = *pcVar6;\n    pcVar6 = pcVar6 + (ulong)bVar8 * -2 + 1;\n  } while (cVar1 != '\\0');\n  uVar5 = 0xffffffffffffffff;\n  pcVar3 = __ptr;\n  do {\n    if (uVar5 == 0) break;\n    uVar5 = uVar5 - 1;\n    cVar1 = *pcVar3;\n    pcVar3 = pcVar3 + (ulong)bVar8 * -2 + 1;\n  } while (cVar1 != '\\0');\n  pcVar3 = (char *)[FUNC3] (~uVar5 - lVar4);\n  [FUNC4] (pcVar3,1,0xffffffffffffffff,&DAT_001024d2,[VAR2] ,uVar7,__ptr);\n  [FUNC6] (__ptr);\n  _Var2 = [FUNC2] ((stab_write_handle *)[VAR1] ,[VAR9] ,0,[VAR4] ,pcVar3);\n  if (_Var2) {\n    [FUNC6] (pcVar3);\n  }\n  return _Var2;\n}", "answer": {"VAR1": "p", "VAR2": "name", "VAR3": "kind", "VAR4": "val", "VAR5": "info", "VAR6": "s", "FUNC2": "stab_write_symbol", "FUNC3": "xmalloc", "FUNC1": "stab_function_parameter", "FUNC6": "free", "TYPE3": "debug_parm_kind", "FUNC7": "stab_pop_type", "TYPE2": "char *", "FUNC4": "__sprintf_chk", "TYPE5": "stab_write_handle *", "FUNC5": "abort", "TYPE4": "bfd_vma", "TYPE7": "char *", "TYPE6": "char *", "TYPE9": "undefined4", "TYPE8": "undefined8", "VAR7": "buf", "VAR8": "local_40", "VAR9": "local_44", "TYPE1": "void *"}, "assembly": "PUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x18\nMOV R13,RDI\nMOV R14,RSI\nMOV EBP,EDX\nMOV qword ptr [RSP + 0x8],RCX\nCALL 0x000421f0\nMOV RBX,RAX\nCMP EBP,0x2\nJZ 0x000445f5\nCMP EBP,0x2\nJBE 0x000445dc\nCMP EBP,0x3\nJZ 0x0004469f\nCMP EBP,0x4\nJNZ 0x0004469a\nMOV R15D,0x61\nMOV dword ptr [RSP + 0x4],0x40\nJMP 0x00044603\nCMP EBP,0x1\nJNZ 0x0004469a\nMOV R15D,0x70\nMOV dword ptr [RSP + 0x4],0xa0\nJMP 0x00044603\nMOV R15D,0x50\nMOV dword ptr [RSP + 0x4],0x40\nMOV RBP,-0x1\nMOV EAX,0x0\nMOV RCX,RBP\nMOV RDI,R14\nSCASB.REPNE RDI\nMOV RDX,RCX\nMOV RCX,RBP\nMOV RDI,RBX\nSCASB.REPNE RDI\nMOV RAX,RCX\nNOT RAX\nSUB RAX,RDX\nMOV RDI,RAX\nCALL 0x000fbdc7\nMOV R12,RAX\nSUB RSP,0x8\nPUSH RBX\nMOVSX R9D,R15B\nMOV R8,R14\nLEA RCX,[0x1024d2]\nMOV RDX,RBP\nMOV ESI,0x1\nMOV RDI,RAX\nMOV EAX,0x0\nCALL 0x0002d790\nMOV RDI,RBX\nCALL 0x0002d7a0\nMOV R8,R12\nMOV RCX,qword ptr [RSP + 0x18]\nMOV EDX,0x0\nMOV ESI,dword ptr [RSP + 0x14]\nMOV RDI,R13\nCALL 0x000441f3\nMOV EBX,EAX\nADD RSP,0x10\nTEST AL,AL\nJNZ 0x000446b2\nMOV EAX,EBX\nADD RSP,0x18\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\nCALL 0x0002d160\nMOV R15D,0x76\nMOV dword ptr [RSP + 0x4],0xa0\nJMP 0x00044603\nMOV RDI,R12\nCALL 0x0002d7a0\nJMP 0x00044689\n"}, "493": {"funcbody": "int [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n         [TYPE5] [VAR5] ,[TYPE6] [VAR6] )\n{\n  char cVar1;\n  int iVar2;\n  ulong uVar3;\n  size_t l1;\n  size_t l2;\n  [TYPE6] pcVar4;\n  [TYPE5] pcVar5;\n  byte bVar6;\n  \n  bVar6 = 0;\n  if (([VAR5] == (TYPE50x0) && ([VAR6] == (TYPE60x0)) {\n    return 1;\n  }\n  if ((([VAR5] != (TYPE50x0) && ([VAR6] != (TYPE60x0)) &&\n     (iVar2 = [FUNC3] ([VAR5] ,[VAR6] ), iVar2 == 0)) {\n    return 1;\n  }\n  l2 = 0;\n  if ([VAR6] != (TYPE60x0) {\n    uVar3 = 0xffffffffffffffff;\n    pcVar4 = [VAR6] ;\n    do {\n      if (uVar3 == 0) break;\n      uVar3 = uVar3 - 1;\n      cVar1 = *pcVar4;\n      pcVar4 = pcVar4 + (ulong)bVar6 * -2 + 1;\n    } while (cVar1 != '\\0');\n    l2 = ~uVar3 - 1;\n  }\n  l1 = 0;\n  if ([VAR5] != (TYPE50x0) {\n    uVar3 = 0xffffffffffffffff;\n    pcVar5 = [VAR5] ;\n    do {\n      if (uVar3 == 0) break;\n      uVar3 = uVar3 - 1;\n      cVar1 = *pcVar5;\n      pcVar5 = pcVar5 + (ulong)bVar6 * -2 + 1;\n    } while (cVar1 != '\\0');\n    l1 = ~uVar3 - 1;\n  }\n  [FUNC2] ((char *)0x0,[VAR1] ,[VAR2] ,\"string\",[VAR3] ,[VAR4] ,\"==\",[VAR5] ,l1,[VAR6] ,l2);\n  return 0;\n}", "answer": {"VAR1": "file", "VAR2": "line", "VAR3": "st1", "VAR4": "st2", "VAR5": "s1", "VAR6": "s2", "FUNC2": "test_fail_string_message", "FUNC3": "strcmp", "FUNC1": "test_str_eq", "TYPE3": "char *", "TYPE2": "int", "TYPE5": "char *", "TYPE4": "char *", "TYPE6": "char *", "TYPE1": "char *"}, "assembly": "TEST R8,R8\nSETZ R10B\nTEST R9,R9\nSETZ R11B\nTEST R10B,R10B\nJZ 0x0006887c\nMOV EAX,0x1\nTEST R11B,R11B\nJZ 0x0006887c\nRET\nPUSH R15\nPUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x8\nMOV RBP,R9\nMOV RBX,R8\nMOV R15,RCX\nMOV R14,RDX\nMOV R13D,ESI\nMOV R12,RDI\nTEST R10B,R10B\nJNZ 0x000688c0\nTEST R11B,R11B\nJNZ 0x000688c0\nMOV RSI,R9\nMOV RDI,R8\nCALL 0x00063480\nMOV EDX,EAX\nMOV EAX,0x1\nTEST EDX,EDX\nJZ 0x00068943\nMOV EDX,0x0\nTEST RBP,RBP\nJZ 0x000688e5\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,RBP\nSCASB.REPNE RDI\nMOV RSI,RCX\nNOT RSI\nLEA RDX,[RSI + -0x1]\nMOV ECX,0x0\nTEST RBX,RBX\nJZ 0x0006890d\nMOV RCX,-0x1\nMOV EAX,0x0\nMOV RDI,RBX\nSCASB.REPNE RDI\nMOV RSI,RCX\nNOT RSI\nMOV RCX,RSI\nSUB RCX,0x1\nSUB RSP,0x8\nPUSH RDX\nPUSH RBP\nPUSH RCX\nPUSH RBX\nLEA RAX,[0x260614]\nPUSH RAX\nMOV R9,R15\nMOV R8,R14\nLEA RCX,[0x2a0cb4]\nMOV EDX,R13D\nMOV RSI,R12\nMOV EDI,0x0\nCALL 0x0006cc40\nADD RSP,0x30\nMOV EAX,0x0\nADD RSP,0x8\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nPOP R15\nRET\n"}, "494": {"funcbody": "int [FUNC1] (void)\n{\n  char *pcVar1;\n  \n  pcVar1 = [FUNC2] (0x68000ab);\n  if (pcVar1 == (char *)0x0) {\n    [FUNC3] (ASN1_str_reasons);\n  }\n  return 1;\n}", "answer": {"FUNC2": "ERR_reason_error_string", "FUNC3": "ERR_load_strings_const", "FUNC1": "ossl_err_load_ASN1_strings"}, "assembly": "SUB RSP,0x8\nMOV EDI,0x68000ab\nCALL 0x0009ecea\nTEST RAX,RAX\nJZ 0x0023b7d2\nMOV EAX,0x1\nADD RSP,0x8\nRET\nLEA RDI,[0x550040]\nCALL 0x0009ebbd\nJMP 0x0023b7c8\n"}, "495": {"funcbody": "size_t [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] ,[TYPE3] [VAR3] ,[TYPE4] [VAR4] ,\n            [TYPE5] [VAR5] ,TYPE64 [VAR6] )\n{\n  long lVar1;\n  int iVar2;\n  [TYPE8] [VAR8] ;\n  ulong uVar3;\n  ulong uVar4;\n  [TYPE7] [VAR7] ;\n  size_t sVar5;\n  long in_FS_OFFSET;\n  [TYPE11] [VAR11] ;\n  [TYPE10] [VAR10] ;\n  [TYPE9] [VAR9] ;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar3 = (ulong)((uint)[VAR5] & 7);\n  if (([VAR5] & 7) == 0) {\n    uVar4 = uVar3;\n    if ([VAR5] - 0x10 < 0x7ffffff0) {\n      if ([VAR5] == 0x10) {\n        (*[VAR6] )([VAR4] ,[VAR10] ,[VAR1] );\n        [VAR11] [0] = [VAR10] [0];\n        [VAR11] [1] = [VAR10] [1];\n        [VAR11] [2] = [VAR10] [2];\n        [VAR11] [3] = [VAR10] [3];\n        [VAR11] [4] = [VAR10] [4];\n        [VAR11] [5] = [VAR10] [5];\n        [VAR11] [6] = [VAR10] [6];\n        [VAR11] [7] = [VAR10] [7];\n        *(undefined8 *)[VAR3] = [VAR10] ._8_8_;\n        [FUNC2] ([VAR10] ,0x10);\n        sVar5 = 8;\n      }\n      else {\n        sVar5 = [FUNC4] ([VAR1] ,[VAR11] ,[VAR3] ,[VAR4] ,[VAR5] ,[VAR6] );\n        if ([VAR5] - 8 != sVar5) {\n          [FUNC2] ([VAR3] ,[VAR5] );\n          goto LAB_001b64bc;\n        }\n      }\n      if ([VAR2] == ([TYPE2] )0x0) {\n        iVar2 = [FUNC5] ([VAR11] ,default_aiv,4);\n      }\n      else {\n        iVar2 = [FUNC5] ([VAR11] ,[VAR2] ,4);\n      }\n      if (iVar2 == 0) {\n        uVar4 = (ulong)((uint)[VAR11] [4] << 0x18 | (uint)[VAR11] [5] << 0x10 | (uint)[VAR11] [7] |\n                       (uint)[VAR11] [6] << 8);\n        if ((([VAR5] & 0xfffffffffffffff8) - 0x10 < uVar4) &&\n           (uVar4 <= ([VAR5] & 0xfffffffffffffff8) - 8)) {\n          iVar2 = [FUNC5] ([VAR3] + uVar4,CRYPTO_128_unwrap_pad::zeros,sVar5 - uVar4);\n          if (iVar2 != 0) {\n            [FUNC2] ([VAR3] ,[VAR5] );\n            uVar4 = uVar3;\n          }\n        }\n        else {\n          [FUNC2] ([VAR3] ,[VAR5] );\n          uVar4 = uVar3;\n        }\n      }\n      else {\n        [FUNC2] ([VAR3] ,[VAR5] );\n      }\n    }\n  }\n  else {\n    uVar4 = 0;\n  }\nLAB_001b64bc:\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n  [FUNC3] ();\n}", "answer": {"VAR1": "key", "VAR2": "icv", "VAR3": "out", "VAR4": "in", "VAR5": "inlen", "VAR6": "block", "FUNC2": "OPENSSL_cleanse", "FUNC3": "__stack_chk_fail", "FUNC1": "CRYPTO_128_unwrap_pad", "TYPE3": "uchar *", "TYPE2": "uchar *", "FUNC4": "crypto_128_unwrap_raw", "TYPE5": "size_t", "FUNC5": "CRYPTO_memcmp", "TYPE4": "uchar *", "TYPE7": "size_t", "TYPE6": "block128_f", "TYPE9": "undefined8", "TYPE8": "size_t", "VAR7": "ptext_len", "TYPE11": "uchar[8]", "VAR8": "ret", "VAR9": "local_30", "TYPE10": "uchar[16]", "VAR10": "buff", "VAR11": "aiv", "TYPE1": "void *"}, "assembly": "PUSH R14\nPUSH R13\nPUSH R12\nPUSH RBP\nPUSH RBX\nSUB RSP,0x30\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x28],RAX\nXOR EAX,EAX\nMOV RBP,R8\nAND EBP,0x7\nJNZ 0x001b64b7\nMOV R12,RSI\nMOV R13,RDX\nMOV RBX,R8\nLEA RAX,[R8 + -0x10]\nCMP RAX,0x7fffffef\nJA 0x001b64bc\nCMP R8,0x10\nJNZ 0x001b6438\nLEA R14,[RSP + 0x10]\nMOV RDX,RDI\nMOV RSI,R14\nMOV RDI,RCX\nCALL R9\nMOV RAX,qword ptr [RSP + 0x10]\nMOV qword ptr [RSP + 0x8],RAX\nMOV RAX,qword ptr [RSP + 0x18]\nMOV qword ptr [R13],RAX\nMOV ESI,0x10\nMOV RDI,R14\nCALL 0x000a9ed0\nMOV R14D,0x8\nTEST R12,R12\nJZ 0x001b645f\nLEA RDI,[RSP + 0x8]\nMOV EDX,0x4\nMOV RSI,R12\nCALL 0x000a9f40\nTEST EAX,EAX\nJNZ 0x001b647d\nMOVZX R12D,byte ptr [RSP + 0xc]\nSHL R12D,0x18\nMOVZX EAX,byte ptr [RSP + 0xd]\nSHL EAX,0x10\nOR R12D,EAX\nMOVZX EAX,byte ptr [RSP + 0xf]\nOR R12D,EAX\nMOVZX EAX,byte ptr [RSP + 0xe]\nSHL EAX,0x8\nOR R12D,EAX\nMOV RAX,RBX\nSHR RAX,0x3\nLEA RAX,[-0x8 + RAX*0x8]\nLEA RDX,[RAX + -0x8]\nCMP RDX,R12\nJNC 0x001b6428\nCMP RAX,R12\nJNC 0x001b648a\nMOV RSI,RBX\nMOV RDI,R13\nCALL 0x000a9ed0\nJMP 0x001b64bc\nLEA RSI,[RSP + 0x8]\nCALL 0x001b5eb5\nMOV R14,RAX\nLEA RAX,[RBX + -0x8]\nCMP RAX,R14\nJZ 0x001b63c0\nMOV RSI,RBX\nMOV RDI,R13\nCALL 0x000a9ed0\nJMP 0x001b64bc\nLEA RDI,[RSP + 0x8]\nMOV EDX,0x4\nLEA RSI,[0x299210]\nCALL 0x000a9f40\nTEST EAX,EAX\nJZ 0x001b63e3\nMOV RSI,RBX\nMOV RDI,R13\nCALL 0x000a9ed0\nJMP 0x001b64bc\nMOV RDX,R14\nSUB RDX,R12\nLEA RDI,[R13 + R12*0x1]\nLEA RSI,[0x57a708]\nCALL 0x000a9f40\nTEST EAX,EAX\nJNZ 0x001b64aa\nMOV RBP,R12\nJMP 0x001b64bc\nMOV RSI,RBX\nMOV RDI,R13\nCALL 0x000a9ed0\nJMP 0x001b64bc\nMOV EBP,0x0\nMOV RAX,RBP\nMOV RDX,qword ptr [RSP + 0x28]\nXOR RDX,qword ptr FS:[0x28]\nJNZ 0x001b64dc\nADD RSP,0x30\nPOP RBX\nPOP RBP\nPOP R12\nPOP R13\nPOP R14\nRET\nCALL 0x00062640\n"}, "496": {"funcbody": "char * [FUNC1] ([TYPE1] [VAR1] )\n{\n  if ([VAR1] == (TYPE10x0) {\n    return (char *)0x0;\n  }\n  if ([VAR1] ->magic == 0xaecd1846) {\n    [VAR1] ->errnum = 0;\n    return [VAR1] ->debug_prefix;\n  }\n  return (char *)0x0;\n}", "answer": {"VAR1": "ctx", "FUNC1": "ipmi_sel_ctx_get_debug_prefix", "TYPE1": "ipmi_sel_ctx_t"}, "assembly": "TEST RDI,RDI\nJZ 0x001c8f50\nCMP dword ptr [RDI],0xaecd1846\nJNZ 0x001c8f56\nMOV dword ptr [RDI + 0x4],0x0\nMOV RAX,qword ptr [RDI + 0x18]\nRET\nMOV EAX,0x0\nRET\nMOV EAX,0x0\nRET\n"}, "497": {"funcbody": "Bignum [FUNC1] ([TYPE1] [VAR1] )\n{\n  int iVar1;\n  [TYPE2] [VAR2] ;\n  long in_FS_OFFSET;\n  [TYPE4] [VAR4] ;\n  long [VAR3] ;\n  \n  [VAR3] = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = [FUNC3] ([VAR1] ->body + [VAR1] ->savedpos,*(int *)&[VAR1] ->length - (int)[VAR1] ->savedpos,\n                (Bignum *)&[VAR4] );\n  if (iVar1 < 0) {\n    [VAR4] = (Bignum)0x0;\n  }\n  else {\n    [VAR1] ->savedpos = [VAR1] ->savedpos + (long)iVar1;\n  }\n  if ([VAR3] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return [VAR4] ;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "pkt", "VAR2": "j", "VAR3": "local_10", "VAR4": "b", "FUNC2": "__stack_chk_fail", "FUNC3": "ssh1_read_bignum", "FUNC1": "ssh1_pkt_getmp", "TYPE3": "undefined8", "TYPE2": "int", "TYPE4": "Bignum", "TYPE1": "Packet *"}, "assembly": "PUSH RBX\nSUB RSP,0x10\nMOV RBX,RDI\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x8],RAX\nXOR EAX,EAX\nMOV RDI,qword ptr [RDI + 0x30]\nMOV RDX,RSP\nMOV ESI,dword ptr [RBX]\nSUB ESI,EDI\nADD RDI,qword ptr [RBX + 0x28]\nCALL 0x0003783f\nTEST EAX,EAX\nJS 0x00020895\nCDQE\nADD qword ptr [RBX + 0x30],RAX\nMOV RAX,qword ptr [RSP]\nMOV RCX,qword ptr [RSP + 0x8]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x0002089c\nADD RSP,0x10\nPOP RBX\nRET\nMOV EAX,0x0\nJMP 0x0002087f\nCALL 0x00008280\n"}, "498": {"funcbody": "OSSL_PARAM * [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  OSSL_PARAM *in_RDI;\n  \n  in_RDI->key = [VAR1] ;\n  in_RDI->data_type = 2;\n  in_RDI->data = [VAR2] ;\n  in_RDI->data_size = 8;\n  in_RDI->return_size = 0xffffffffffffffff;\n  return in_RDI;\n}", "answer": {"VAR1": "key", "VAR2": "buf", "FUNC1": "OSSL_PARAM_construct_size_t", "TYPE2": "size_t *", "TYPE1": "char *"}, "assembly": "MOV RAX,RDI\nMOV qword ptr [RDI],RSI\nMOV dword ptr [RDI + 0x8],0x2\nMOV qword ptr [RDI + 0x10],RDX\nMOV qword ptr [RDI + 0x18],0x8\nMOV qword ptr [RDI + 0x20],-0x1\nRET\n"}, "499": {"funcbody": "_Bool [FUNC1] ([TYPE1] [VAR1] ,[TYPE2] [VAR2] )\n{\n  _Bool _Var1;\n  long in_FS_OFFSET;\n  _Bool _Var2;\n  [TYPE6] [VAR6] ;\n  [TYPE5] [VAR5] ;\n  [TYPE4] [VAR4] ;\n  long [VAR3] ;\n  \n  [VAR3] = *(long *)(in_FS_OFFSET + 0x28);\n  _Var1 = [FUNC3] ([VAR1] ,[VAR2] ,&[VAR6] ,&[VAR4] ,&[VAR5] );\n  _Var2 = false;\n  if ((_Var1) && (-1 < [VAR6] )) {\n    _Var2 = [VAR4] != 0;\n  }\n  if ([VAR3] == *(long *)(in_FS_OFFSET + 0x28)) {\n    return _Var2;\n  }\n  [FUNC2] ();\n}", "answer": {"VAR1": "abfd", "VAR2": "sec", "VAR3": "local_10", "VAR4": "uncompressed_size", "VAR5": "uncompressed_align_power", "VAR6": "compression_header_size", "FUNC2": "__stack_chk_fail", "FUNC3": "bfd_is_section_compressed_with_header", "FUNC1": "bfd_is_section_compressed", "TYPE3": "undefined8", "TYPE2": "sec_ptr", "TYPE5": "uint", "TYPE4": "bfd_size_type", "TYPE6": "int", "TYPE1": "bfd *"}, "assembly": "SUB RSP,0x28\nMOV RAX,qword ptr FS:[0x28]\nMOV qword ptr [RSP + 0x18],RAX\nXOR EAX,EAX\nLEA RCX,[RSP + 0x10]\nLEA RDX,[RSP + 0x8]\nLEA R8,[RSP + 0xc]\nCALL 0x000ca8cc\nMOV EDX,0x0\nTEST AL,AL\nJZ 0x000cad7d\nCMP dword ptr [RSP + 0x8],0x0\nJS 0x000cad7d\nCMP qword ptr [RSP + 0x10],0x0\nSETNZ DL\nMOVZX EDX,DL\nMOV EAX,EDX\nAND EAX,0x1\nMOV RCX,qword ptr [RSP + 0x18]\nXOR RCX,qword ptr FS:[0x28]\nJNZ 0x000cad97\nADD RSP,0x28\nRET\nCALL 0x0002c520\n"}}